[
    {
        "content": "<p>I don't understand how to use<code>bv_decide</code>.</p>\n<p>I hear <code>bv_decide</code> calls fast SAT solver internally, so I can solve SAT problem by using <code>by_decide</code>?<br>\nBut I cannot  use <code>by_decide</code> to solve a SAT problem.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> None of the hypotheses are in the supported BitVec fragment after applying preprocessing. -/</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n</code></pre></div>",
        "id": 546904603,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761314351
    },
    {
        "content": "<p>the docstring of <code>grind</code> says:</p>\n<blockquote>\n<p><code>grind</code> is <em>not</em> designed for goals whose search space explodes combinatorially, think large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards, or a 200‑variable Sudoku encoded as Boolean constraints. Such encodings require thousands (or millions) of case‑splits that overwhelm <code>grind</code>’s branching search.</p>\n<p>For <strong>bit‑level or combinatorial problems</strong>, consider using <strong><code>bv_decide</code></strong>. <code>bv_decide</code> calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a <em>compact, machine‑checkable certificate</em>.</p>\n</blockquote>",
        "id": 546905157,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761314491
    },
    {
        "content": "<p>so using <code>bv_decide</code>, can I solve Sudoku or N-queens problem?</p>",
        "id": 546905281,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761314526
    },
    {
        "content": "<p>you need to phrase it in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a> I think</p>",
        "id": 546905777,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761314650
    },
    {
        "content": "<p>oh you want an exists goal</p>",
        "id": 546905889,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761314681
    },
    {
        "content": "<p>bv_decide handles forall goals</p>",
        "id": 546905923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761314689
    },
    {
        "content": "<blockquote>\n<p>so using <code>bv_decide</code>, can I solve Sudoku or N-queens problem?</p>\n</blockquote>\n<p>how about this?</p>",
        "id": 546906685,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761314874
    },
    {
        "content": "<p><code>bv_decide</code> reasons in the logic of quantifier free bitvector theory. What this means is you can use it to prove sentences of the form <code>forall x1 x2 x3, bitvec_expr_containing x1 x2 x3</code>. In particular if a sentence is wrong it will provide you with a counter example. So if you want to use it to solve problems for you what you can do is ask it to prove <code>forall x1 x2 x3, ~problem x1 x2 x3</code> and if there is an assignment of <code>x1</code>, <code>x2</code>, <code>x3</code> that satisfies the <code>problem</code> it will tell you about it. Applied to your case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">(</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x5</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x3</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">x4</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n</code></pre></div>\n<p>yields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">x1</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"n\">x5</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"n\">x4</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"n\">x3</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<p>note that <code>x2</code> is not included in this model because it doesn't occur in your formula. In principle the translation from existential to universally quantified problem could be made automatic but proving existentials is not the primary use case so I didn't do that.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/about.20.60bv_decide.60/near/546905777\">said</a>:</p>\n<blockquote>\n<p>you need to phrase it in terms of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=BitVec#doc\">docs#BitVec</a> I think</p>\n</blockquote>\n<p>No, <code>bv_decide</code> handles <code>BitVec</code>, <code>Bool</code>, enumeration types, <code>UIntX</code> and <code>IntX</code> as well as structures of finite types with invariants.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"626349\">Asei Inoue</span> <a href=\"#narrow/channel/113489-new-members/topic/about.20.60bv_decide.60/near/546906685\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>so using <code>bv_decide</code>, can I solve Sudoku or N-queens problem?</p>\n</blockquote>\n<p>how about this?</p>\n</blockquote>\n<p>If you formulate the problem in the same way I described above you can totally do that yes. But again this is not the primary use case, the primary use case is proving. If you don't know how that works: If you want to prove a property <code>P</code> using a SAT solver you instead ask it to search for an assignment of <code>~P</code>, if it cannot find this assignment it will return <code>UNSAT</code>. Luckily for us a modern SAT solver is going to accompany this <code>UNSAT</code> with a description of how it arrived at this conclusion. <code>bv_decide</code> is capable of turning this description into a Lean proof, thus demonstrating that <code>~~P</code> which is equivalent to <code>P</code>.</p>",
        "id": 546907306,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1761315049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>  Thank you!</p>",
        "id": 546907955,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761315230
    }
]