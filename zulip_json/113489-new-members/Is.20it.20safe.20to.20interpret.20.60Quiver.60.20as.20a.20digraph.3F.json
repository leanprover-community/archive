[
    {
        "content": "<p>Of course, quiver is clearly another way of calling a directed graph, but I'm wondering if there were some thoughts about distinguishing them when defining <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quiver#doc\">docs#Quiver</a> . (For instance, <code>quiver</code> is defined as a typeclass, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> is defined as a structure.)</p>",
        "id": 515204421,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745987469
    },
    {
        "content": "<p>One thing to note about Quiver is that it lets you have an arbitrary type as your set of edges between any two vertices, so it's more like a multidigraph. According to the documentation of Quiver, you can use <code>Quiver.{0} V</code> if you want to prevent repeated edges.</p>\n<p>One important thing to note about quivers is that they form the backbone of the category theory library in mathlib, so you'll see a lot of category theory specific notation and terminology (less so when you aren't using it as a typeclass though)</p>",
        "id": 515204893,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745987776
    },
    {
        "content": "<p>If you wanted to use a digraph, I would either use the <code>Digraph</code> type directly or just a <code>V -&gt; V -&gt; Prop</code> (in classical math, a digraph is a set + a relation on that set, but in Lean types are usually decoupled from the structures on them, so in Lean a digraph is just a relation)</p>",
        "id": 515205123,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745987941
    },
    {
        "content": "<p>If you'd like, you can think of making an instance of <code>Quiver</code> as basically a way to overload the the a ⟶ b notation, which intuitively represents the set of morphisms between two objects (not to be confused with the A → B notation which is the type of functions from A to B)</p>",
        "id": 515205569,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745988273
    },
    {
        "content": "<p>Then why is <code>Digraph</code> not designed to accept multiple edges? I don't think people are only interested in digraphs without multiple edges.</p>",
        "id": 515206284,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745988751
    },
    {
        "content": "<p>But some people are interested in graphs without multiple edges, so there needs to be a type for those that doesn't require passing around \"there is at most one edge between any pair of vertices\" as a hypothesis to several theorems</p>",
        "id": 515206912,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745989113
    },
    {
        "content": "<p>That being said, <code>Digraph</code> doesn't need to be the only digraph type, it's possible that in the future we might add a <code>Multidigraph</code> type</p>",
        "id": 515206997,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745989178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515206997\">말함</a>:</p>\n<blockquote>\n<p>That being said, <code>Digraph</code> doesn't need to be the only digraph type, it's possible that in the future we might add a <code>Multidigraph</code> type</p>\n</blockquote>\n<p>And maybe <code>MultiGraph</code>, too. Would you also be happy if there is a definition for both?</p>",
        "id": 515207230,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745989251
    },
    {
        "content": "<p>I think this is the point we start running into issues. There's really no such thing as a \"graph\" in math, since there are dozens of different types of graphs. If we wanted a type for every sort of graph, we would need</p>\n<ul>\n<li>Simple Graphs</li>\n<li>Digraphs</li>\n<li>Digraphs without loops</li>\n<li>Multidigraphs</li>\n<li>Multigraphs</li>\n<li>Undirected graphs (i.e. Simple Graphs but they can include loops)</li>\n<li>Weighted graphs</li>\n<li>Mixed graphs</li>\n<li>Hypergraphs</li>\n<li>Digraphs where the edges have their own identity</li>\n</ul>",
        "id": 515207574,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745989387
    },
    {
        "content": "<p>If we did this naively, this would be bad, because we would need to keep reproving the same facts for different types of graphs. So, we clearly need an a priori approach to adding different types of graphs</p>",
        "id": 515207724,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745989472
    },
    {
        "content": "<p>unfortunately, there doesn't seem to be one yet, although this is something multiple people have spent some time thinking about. For example, a while back <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> had worked on <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>, which should hopefully be a step in the right direction</p>",
        "id": 515207911,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745989570
    },
    {
        "content": "<p>There's the also the issue of what you actually mean by a multigraph. If you look at <a href=\"https://en.wikipedia.org/wiki/Multigraph\">https://en.wikipedia.org/wiki/Multigraph</a>, then you'll notice there are two different definitions of undirected multigraphs. Let's assume you want the latter.</p>\n<p>In classical math, a simple (non-multi) graph is a set of vertices along with a subset of the pairs of vertices. Technically, in classical math, you are not allowed to talk about the set of all graphs, because from there you could get the set of all sets, which leads to Russell's paradox. However, given a set of vertices, you can talk about the set of simple (non-multi) graphs on those set of vertices. That is, instead of talking about graphs in general, we talk about graphs on V, where V is a fixed set of vertices. This is what Lean does, so there's no issue.</p>\n<p>If you instead choose to define a multigraph as a set V along with for every pair of vertices, a set of edges between them, then you can't even talk about the set of multigraphs on V, because you hit Russell's paradox right away. In Lean, this problem manifests itself by the fact that <code>Quiver</code> requires you to increase the universe level by 1, which can make some things ugly.</p>",
        "id": 515208807,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745990139
    },
    {
        "content": "<p>All of this is to say that the reason we don't have <code>MultiGraph</code> yet is that we haven't yet figured out a good way to add it.</p>",
        "id": 515208966,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745990227
    },
    {
        "content": "<p>Thanks for the brief overview!<br>\nIt seems like we might need a new definition of multiset with infinite cardinality in consideration, and <code>HasAdj</code> in <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a> to be extended to accept more or less than two vertices (by multiset described earlier).<br>\nAlso to consider weights, we may also define <code>HasWeightedAdj</code> typeclass extended from <code>HasAdj</code>.</p>\n<p>Something like <code>def MultiSet (\\a : Type*) : \\a \\to Sort _</code> and <code>class HasAdj (Γ : Type _) (V : outParam (Γ → Type _)) where Adj (G : Γ) : MultiSet (V G) → Prop</code> may work for example, but we probably need more discussion for these.</p>",
        "id": 515210453,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745991054
    },
    {
        "content": "<p>The <code>Multiset</code> in mathlib is more of a data structure than a practically usable type; that is why it only allows finite cardinality. For infinite Multisets, the definition you'd want would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">InfMultiset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>although at that point I'm not even sure its worth having this as its own type.</p>",
        "id": 515214344,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745993064
    },
    {
        "content": "<p>Out of curiosity, do you have a specific thing you plan to do with digraphs or multigraphs? If you're interested in them just because, then that's totally fine, but if you're trying to accomplish something there might be an easier way that doesn't require resolving the hard problem of getting good graph theory definitions</p>",
        "id": 515214693,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745993224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515214344\">말함</a>:</p>\n<blockquote>\n<p>The <code>Multiset</code> in mathlib is more of a data structure than a practically usable type; that is why it only allows finite cardinality. For infinite Multisets, the definition you'd want would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">InfMultiset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>although at that point I'm not even sure its worth having this as its own type.</p>\n</blockquote>\n<p>I'm aware of <code>Multiset</code>. The definition you suggested might not work for types with more diverse cardinality.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515214693\">말함</a>:</p>\n<blockquote>\n<p>Out of curiosity, do you have a specific thing you plan to do with digraphs or multigraphs? If you're interested in them just because, then that's totally fine, but if you're trying to accomplish something there might be an easier way that doesn't require resolving the hard problem of getting good graph theory definitions</p>\n</blockquote>\n<p>Actually, no, <code>Digraph</code> is enough for my case. Since <code>Quiver</code> has more APIs to use than <code>Digraph</code>,  I was just wondering why <code>Quiver</code> is defined (again, aside from <code>Digraph</code>) in Mathlib, and has more theorems than <code>Digraph</code>s.</p>",
        "id": 515215776,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745993727
    },
    {
        "content": "<p>Oh right, I completely forgot that infinite multisets might allow infinite cardinality. In that case, maybe <code>A -&gt; Cardinal</code> might work, although there might be a more elegant way to define it. Plus this requires a universe bump, so it's not like it's any better than Quiver.</p>\n<p>The documentation at the top of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Digraph/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Combinatorics/Digraph/Basic.html</a> describes why we aren't just using <code>Quiver.{0}</code>. To be fair, I'm not completely sure myself why we couldn't have used <code>Quiver.{0}</code> despite the fact that it is a class, but the <code>Digraph</code> here is definitely clearer.</p>",
        "id": 515216862,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745994231
    },
    {
        "content": "<p>Eventually, we might want <code>Digraph</code> to as much API as Quiver, although that might be blocked behind <a href=\"https://github.com/leanprover-community/mathlib4/pull/4127\">#4127</a>, which is in turn blocked behind <a href=\"https://github.com/leanprover/lean4/pull/6489\">lean4#6489</a></p>",
        "id": 515217968,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745994696
    },
    {
        "content": "<p>What sort of API is present in Quiver that you need that's missing from Digraph?</p>",
        "id": 515218079,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745994736
    },
    {
        "content": "<p>Well, that's what I have to figure out, but I searched for connected components and that's definitely not implemented for digraphs.<br>\nAside from APIs from quiver, I probably need orientation of a graph, which is not implemented yet. I'll fill in the TODOs when I need them.</p>",
        "id": 515219257,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745995220
    },
    {
        "content": "<p>Maybe you can ask in \"Is there code for X?\" I'm not super familiar with every part of mathlib, so there might be people there who can tell you whether or not such a thing exists, or if there's something similar for relations that can easily be translated to graphs (e.g. a clever way to combine existing things like transitive closures and antisymmetrizations to get a setoid).</p>\n<p>Also, if you're looking for ways to contribute to mathlib, these might be valuable things to add! You'd probably need to discuss how graph theory development should be handled right now with someone more knowledgeable than I am</p>",
        "id": 515222913,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745996482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515207574\">said</a>:</p>\n<blockquote>\n<p>I think this is the point we start running into issues. There's really no such thing as a \"graph\" in math, since there are dozens of different types of graphs. If we wanted a type for every sort of graph, we would need</p>\n<ul>\n<li>Simple Graphs</li>\n<li>Digraphs</li>\n<li>Digraphs without loops</li>\n<li>Multidigraphs</li>\n<li>Multigraphs</li>\n<li>Undirected graphs (i.e. Simple Graphs but they can include loops)</li>\n<li>Weighted graphs</li>\n<li>Mixed graphs</li>\n<li>Hypergraphs</li>\n<li>Digraphs where the edges have their own identity</li>\n</ul>\n</blockquote>\n<p>That's very true, unfortunately - and it's only the tip of the iceberg. Once you've picked your graphs, you have to agree on what constitutes a path, or a cycle.</p>\n<p>I'm very interested in seeing how the graph part of the library evolves, including what tricks can be used to accomodate variants of the notions without duplicating lots of code. My naive view would be that the \"right\" way would be to have maximal generality (something like, multidigraphs with labelled edges and vertices) and make it as simple as possible to specialize, but it's very possible that there are good design reasons not to pick that as a solution.</p>",
        "id": 515223445,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1745996670
    },
    {
        "content": "<p>The \"multidigraphs with labeled edges and vertices\" approach you mentioned is basically <code>Quiver</code>, but it requires a universe bump so maybe we shouldn't use it everywhere. Plus, this isn't actually full generality: it doesn't accommodate weighted graphs, mixed graphs, hypergraphs, etc. (arguably hypergraphs barely count as graphs, and maybe shouldn't need to fit into the standard graph hierarchy).</p>\n<p>Additionally, it's not clear it can easily be specialized. Suppose you want multigraphs where the edges have no identity and there must be a finite number of them between two vertices. You can't actually express this as a subtype of Quiver. Quiver lets you pick any type between two given vertices to act as your set of edges, and it's very hard to force it to be finite or to remove the identity between edges.</p>",
        "id": 515226049,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745997530
    },
    {
        "content": "<p>It seems what we would need is an extra layer of abstraction on top of Quiver to specify the acceptable type of Homs. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">GeneralizedQuiver</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span>\n</code></pre></div>\n<p>and then <code>Quiver.{v,u}</code> becomes <code>GeneralizedQuiver (Sort v)</code>, and a weighted graph becomes <code>GeneralizedQuiver Real</code>, and a multidigraph with finite edge counts and no identity becomes <code>GeneralizedQuiver Nat</code>. <code>Digraph</code> is either <code>Quvier.{0}</code> or <code>GeneralizedQuiver Prop</code>, and <code>SimpleGraph</code> would be a subtype of <code>Digraph</code>. I'm not sure how to do mixed graphs (maybe like <code>GeneralizedQuiver (Fin 3)</code> + some symmetry property?), and hypergraphs seem hopeless.</p>\n<p>Now that I think about it, effectively, all <code>GeneralizedQuiver</code> is is operator overloading for the Hom operator.</p>\n<p>Maybe this doesn't actually make any sense (it's really late for me, so I'm not thinking straight) but I can't think of any other way to do it. I also have no idea where typeclasses should be involved.</p>",
        "id": 515226907,
        "sender_full_name": "Niels Voss",
        "timestamp": 1745997823
    },
    {
        "content": "<blockquote>\n<p>Maybe you can ask in \"Is there code for X?\"</p>\n</blockquote>\n<p>I was about to ask there, but I accidently posted the question here.</p>",
        "id": 515231793,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1745999435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515226049\">said</a>:</p>\n<blockquote>\n<p>The \"multidigraphs with labeled edges and vertices\" approach you mentioned is basically <code>Quiver</code>, but it requires a universe bump so maybe we shouldn't use it everywhere. Plus, this isn't actually full generality: it doesn't accommodate weighted graphs, mixed graphs, hypergraphs, etc. (arguably hypergraphs barely count as graphs, and maybe shouldn't need to fit into the standard graph hierarchy).</p>\n</blockquote>\n<p>In my mind, once you have identities on vertices and edges you can add weights as a mapping from vertices/edges to wherever your weights should live in. It would probably feel better to have them in the graph structure itself, but it's something that would become partly transparent with implicit arguments.</p>\n<p>One other thing that would make graph theorists (at least, those that I know) very confused would be if it was difficult to state that their graphs are finite. This is very often an unstated (because it's so obvious) assumption in some areas, but in others it would make the notion next to to useless. </p>\n<p>As an example, recently some colleagues (working with Coq instead of Lean, but the problems are similar) wanted to use graphs and paths to formalize results about transition systems, but since the graph part of the mathematical library in Coq assumes finiteness, they'd have to rewrite it almost from scratch.</p>",
        "id": 515235225,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1746000386
    },
    {
        "content": "<p>Oh I kind of see how you could do that with Quiver now. If we are talking about weighted (non-multi) digraphs, then we basically have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">WeightedGraph</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"c1\">-- would probably come from extending Quiver.{0}</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n</code></pre></div>\n<p>This is effectively just a partial function from <code>V x V -&gt;. Real</code></p>\n<p>I'm not sure how to define a multigraph without identity using this. I first thought that maybe we could just do the same thing but with <code>Nat</code> instead of <code>Real</code>, but then that distinguishes between an empty edge set and a 0-edge set.</p>",
        "id": 515238155,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746001203
    },
    {
        "content": "<p>Actually, now that I thinl about it, making the edge weight decoupled from the existence of an edge is not as weird as it sounds, and might be the right way to go</p>",
        "id": 515239206,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746001493
    },
    {
        "content": "<p>Niels Voss <a href=\"#narrow/channel/113489-new-members/topic/Is.20it.20safe.20to.20interpret.20.60Quiver.60.20as.20a.20digraph.3F/near/515239206\">said</a>:</p>\n<blockquote>\n<p>Actually, now that I thinl about it, making the edge weight decoupled from the existence of an edge is not as weird as it sounds, and might be the right way to go</p>\n</blockquote>\n<p>It actually sounds better to have a separate function-like definition for weight of a graph, than a separate definition (possibly extended) of weighted graph. If we make a separate structure, then all those functions which apply to unweighted graph will also apply to weighted graph, which may result in a duplication of similar theorems.</p>",
        "id": 515242560,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1746002403
    }
]