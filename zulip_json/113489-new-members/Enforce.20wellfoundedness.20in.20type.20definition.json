[
    {
        "content": "<p>I have the following inductive type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I would like it to be wellfounded with respect to the following relation: (<code>Tree.list</code> returns the <code>List (Tree a)</code> used in the <code>node</code> constructor )</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">list</span>\n</code></pre></div>\n<p>I know neither <code>Tree</code> nor <code>isImmediateSubtree</code> as defined above are wellfounded, so I would like to define another type</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">wfTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">tree</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">?</span>\n</code></pre></div>\n<p>that would enforce wellfoundedness of that relation wrt. <code>wfTree</code>s. Would anyone have suggestions of how I could go about this?</p>",
        "id": 474413762,
        "sender_full_name": "nrs",
        "timestamp": 1727908679
    },
    {
        "content": "<p>It is already well founded wrt that relation</p>",
        "id": 474413900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474413900\">said</a>:</p>\n<blockquote>\n<p>It is already well founded wrt that relation</p>\n</blockquote>\n<p>oh, so I would only need to write <code>wf : WellFounded isImmediateSubtree</code>?</p>",
        "id": 474413961,
        "sender_full_name": "nrs",
        "timestamp": 1727908787
    },
    {
        "content": "<p>no, I mean you can prove it, you don't need to enforce anything</p>",
        "id": 474414031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474414031\">said</a>:</p>\n<blockquote>\n<p>no, I mean you can prove it, you don't need to enforce anything</p>\n</blockquote>\n<p>in the constructor <code>node</code>, don't we have that nothing prevents <code>List (Tree a)</code> as defined above from growing indefinitely?</p>",
        "id": 474414136,
        "sender_full_name": "nrs",
        "timestamp": 1727908879
    },
    {
        "content": "<p><code>List</code>s are finite by definition</p>",
        "id": 474414180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908906
    },
    {
        "content": "<p>and nested inductive types are built inductively, meaning that they only contain smaller things</p>",
        "id": 474414251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908926
    },
    {
        "content": "<p>this is basically well founded by the definition of what an inductive type is</p>",
        "id": 474414275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908945
    },
    {
        "content": "<p>in fact well foundedness itself is defined using inductive types, which are the primitive concept in lean's type theory</p>",
        "id": 474414307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727908970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474414307\">said</a>:</p>\n<blockquote>\n<p>in fact well foundedness itself is defined using inductive types, which are the primitive concept in lean's type theory</p>\n</blockquote>\n<p>oh, so any attempt to define a non-wellfounded <code>Tree</code> value  will fail by virtue of needing to provide a termination proof for defining the value right?</p>",
        "id": 474414517,
        "sender_full_name": "nrs",
        "timestamp": 1727909085
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">acc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 474414970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727909318
    },
    {
        "content": "<p>No there are no termination proofs needed to define a value of the type, but you can only build values by applying the constructor to values you built previously, so you will never get infinitely large things that way</p>",
        "id": 474415041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727909357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474415041\">said</a>:</p>\n<blockquote>\n<p>No there are no termination proofs needed to define a value of the type, but you can only build values by applying the constructor to values you built previously, so you will never get infinitely large things that way</p>\n</blockquote>\n<p>ah I see! thank you very much for taking the time, things are way clearer to me now, ty!</p>",
        "id": 474415088,
        "sender_full_name": "nrs",
        "timestamp": 1727909391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474414180\">said</a>:</p>\n<blockquote>\n<p><code>List</code>s are finite by definition</p>\n</blockquote>\n<p>right, but a subsequent <code>Tree</code> </p>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474414970\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">acc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I have been studying this theorem for a while, I have a question for you if you have time (no worries otherwise, already very much appreciate the answer!): what exactly is being passed to <code>acc</code> here? I'm a bit confused by the fact that defining the function <code>acc</code> with pattern matching typechecks while using <code>:=</code> doesn't</p>",
        "id": 474443733,
        "sender_full_name": "nrs",
        "timestamp": 1727921916
    },
    {
        "content": "<p>for anyone else who might be interested, the following makes it a bit clearer. Mario Carneiro is having Lean infer the correct thing to place there</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span>\n<span class=\"w\">    </span><span class=\"n\">rename_i</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">accList</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">d</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> would still very much be interested in understanding how you managed to reason your way into that representation, it is very elegant!</p>",
        "id": 474450405,
        "sender_full_name": "nrs",
        "timestamp": 1727923747
    },
    {
        "content": "<p>here it is with the implicit arguments filled in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">acc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tree</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"n\">isImmediateSubtree</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">accList</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 474539961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727948615
    },
    {
        "content": "<p>because the types are so constraining here, lean can figure all these out by itself</p>",
        "id": 474540124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727948655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"749978\">nrs</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474443733\">said</a>:</p>\n<blockquote>\n<p>what exactly is being passed to <code>acc</code> here?</p>\n</blockquote>\n<p>There are two calls to <code>acc</code> in this proof. In the first one (on the first line), it's not being applied at all, the whole function applying it to every argument is passed to produce a proof of well-foundedness. In the second one, it is applied to <code>a</code>, which is the subtree which we selected using the <code>a \\in l</code> hypothesis.</p>\n<p>Stepping back a bit and giving an explanation for the proof in words: we need to show that every element is \"accessible\" by the <code>isImmediateSubtree</code> relation, where <code>Acc isImmediateSubtree t</code> holds if <code>Acc isImmediateSubtree a</code> holds for every <code>a \\in t.list</code>. We prove this by induction on <code>t</code>, mutually with another theorem that talks about a <code>l : List (Tree a)</code> and says that every element of <code>l</code> is <code>Acc isImmediateSubtree</code>. (We should expect this proof to proceed by mutual induction because a nested inductive type is basically a mutual inductive where the types being defined are all the types appearing in the constructors involving the type being defined, here <code>Tree α</code> and <code>List (Tree α)</code>.)</p>\n<p>In the tree case, we can apply the definition of <code>Acc</code> to reduce to showing that <code>∀ a ∈ l, Acc isImmediateSubtree a</code>, which is the other (list) inductive hypothesis.</p>\n<p>In the list case, we can match on the list, which is nonempty because we've assumed it has a member <code>a</code>, and the element <code>a</code> is either at the head in which case we apply the node IH, or it's in the tail which is the list IH.</p>",
        "id": 474542996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1727949326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474542996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"749978\">nrs</span> <a href=\"#narrow/stream/113489-new-members/topic/Enforce.20wellfoundedness.20in.20type.20definition/near/474443733\">said</a>:</p>\n<blockquote>\n<p>what exactly is being passed to <code>acc</code> here?</p>\n</blockquote>\n<p>There are two calls to <code>acc</code> in this proof. In the first one (on the first line), it's not being applied at all, the whole function applying it to every argument is passed to produce a proof of well-foundedness. In the second one, it is applied to <code>a</code>, which is the subtree which we selected using the <code>a \\in l</code> hypothesis.</p>\n<p>Stepping back a bit and giving an explanation for the proof in words: we need to show that every element is \"accessible\" by the <code>isImmediateSubtree</code> relation, where <code>Acc isImmediateSubtree t</code> holds if <code>Acc isImmediateSubtree a</code> holds for every <code>a \\in t.list</code>. We prove this by induction on <code>t</code>, mutually with another theorem that talks about a <code>l : List (Tree a)</code> and says that every element of <code>l</code> is <code>Acc isImmediateSubtree</code>. (We should expect this proof to proceed by mutual induction because a nested inductive type is basically a mutual inductive where the types being defined are all the types appearing in the constructors involving the type being defined, here <code>Tree α</code> and <code>List (Tree α)</code>.)</p>\n<p>In the tree case, we can apply the definition of <code>Acc</code> to reduce to showing that <code>∀ a ∈ l, Acc isImmediateSubtree a</code>, which is the other (list) inductive hypothesis.</p>\n<p>In the list case, we can match on the list, which is nonempty because we've assumed it has a member <code>a</code>, and the element <code>a</code> is either at the head in which case we apply the node IH, or it's in the tail which is the list IH.</p>\n</blockquote>\n<p>Thank you very much for the answer, it is very clear to me now!! Highly appreciate the time you've taken to answer this!!</p>",
        "id": 474643297,
        "sender_full_name": "nrs",
        "timestamp": 1727975554
    }
]