[
    {
        "content": "<p>What is this sorcery? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.instRepr#doc\">docs#Finset.instRepr</a></p>",
        "id": 469856793,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726205954
    },
    {
        "content": "<p>Surely it should be impossible to consistently print a <code>Finset</code> without having some extra structure like a linear order? And why is this <code>unsafe</code>?</p>",
        "id": 469856854,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206000
    },
    {
        "content": "<p>Is it somehow looking inside the quotient?</p>",
        "id": 469856920,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206016
    },
    {
        "content": "<p>Oh apparently the magic is happening at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.instRepr#doc\">docs#Multiset.instRepr</a></p>",
        "id": 469857217,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206170
    },
    {
        "content": "<p>Oh here it is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.unquot#doc\">docs#Quot.unquot</a></p>",
        "id": 469857265,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206212
    },
    {
        "content": "<p>I guess my new question is, why does Lean allow this? Surely you can easily prove <code>False</code> by using this</p>",
        "id": 469857422,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206291
    },
    {
        "content": "<p>Does it count as using new axioms?</p>",
        "id": 469857436,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1726206298
    },
    {
        "content": "<p>You can't prove things about unsafe</p>",
        "id": 469859967,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1726207448
    },
    {
        "content": "<p>It works exactly how Quot.unquot describes. The quotient, computationally, still holds the unquotiented value in the VM. So we can repr the finset by printing the list that is wrapped.</p>",
        "id": 469860239,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1726207571
    },
    {
        "content": "<p>A related question is, well, if quotient values are really the underlying base types underneath, wouldn't it be possible to sniff out if two quotients' representatives are _really_ equal by a timing attack, if evaluating the relation is faster in the equality case?</p>",
        "id": 469860674,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1726207693
    },
    {
        "content": "<p>It seems like it should definitely be possible, yes. Isn't that the expected behaviour?</p>",
        "id": 469963838,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726233569
    },
    {
        "content": "<p>In general, even if <code>x = y</code>, the running times for <code>#eval x</code> and <code>#eval y</code> can be very different.</p>",
        "id": 470032291,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1726253661
    }
]