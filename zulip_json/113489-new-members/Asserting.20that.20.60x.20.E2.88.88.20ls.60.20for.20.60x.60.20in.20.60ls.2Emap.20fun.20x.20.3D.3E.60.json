[
    {
        "content": "<p>I've found myself in the need to prove that, inside a function passed to <code>List.map</code>, the elements passed to the function belong to the list. This could be achieved using the auxiliary lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/List/Lemmas.html#List.exists_of_mem_map\"><code>List.exists_of_mem_map: ∀ {α : Type u_1} {α_1 : Type u_2} {f : α → α_1} {l : List α} {b : α_1}, b ∈ List.map f l → ∃ a ∈ l, f a = b</code></a>, except that I need this fact to be true and accessible from whithin the function itself.</p>\n<p>For a simplified example, consider the implementation of the following function.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Batteries</span>\n\n<span class=\"kn\">variable</span><span class=\"o\">{</span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">collectEven</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">size</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">size</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- map_function</span>\n<span class=\"w\">  </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">data</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Ignoring the sorry at the end, Lean4 refused to accept the current execution since it's unable to ascertain that the elements in <code>indices</code>are in fact less than <code>size</code>. We can obtain <code>∀ i, i ∈ List.range size -&gt; i &lt; size</code> from <code>List.mem_range</code>, but I'm unsure of how to obtain that <code>i ∈ indices</code> from within the function marked as <code>map_function</code> in the code.</p>\n<p>Am I approaching this the wrong way? Is there an easier way to solve this problem?</p>",
        "id": 468472074,
        "sender_full_name": "Ayhon",
        "timestamp": 1725741965
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a> is useful here</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">collectEven</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">size</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">size</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">indices</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">data</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">data</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 468472582,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725742484
    },
    {
        "content": "<p>This is it! Thanks a lot!</p>",
        "id": 468472635,
        "sender_full_name": "Ayhon",
        "timestamp": 1725742548
    },
    {
        "content": "<p>Out of curiosity, how could I have found this method on my own? I tried using Loogle or simply looking at the <code>List</code> implementation, but couldn't find anything relevant. Is this simply due to inexperience?</p>",
        "id": 468472709,
        "sender_full_name": "Ayhon",
        "timestamp": 1725742613
    },
    {
        "content": "<p>I learned about <code>.attach</code> at some point by seeing it used, maybe here on Zulip.</p>",
        "id": 468472956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725742834
    },
    {
        "content": "<p>I first saw <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.attach#doc\">docs#Finset.attach</a> and figured <code>List</code> would have it too.</p>",
        "id": 468472982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725742867
    },
    {
        "content": "<p>Was having <code>x ∈ ls</code> available as an argument to <code>ls.map</code> ever considered? If so, it might make sense for the docstring of <code>List.map</code> to explain why that turned out to be a bad idea, and to point to <code>List.attach</code> and <code>List.map_congr</code>.</p>",
        "id": 468473620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725743503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Asserting.20that.20.60x.20.E2.88.88.20ls.60.20for.20.60x.60.20in.20.60ls.2Emap.20fun.20x.20.3D.3E.60/near/468473620\">said</a>:</p>\n<blockquote>\n<p>Was having <code>x ∈ ls</code> available as an argument to <code>ls.map</code> ever considered? If so, it might make sense for the docstring of <code>List.map</code> to explain why that turned out to be a bad idea, and to point to <code>List.attach</code> and <code>List.map_congr</code>.</p>\n</blockquote>\n<p>I think that's a good idea. I know I would have appreciated it. Should I open an issue / PR in GitHub?</p>",
        "id": 468473708,
        "sender_full_name": "Ayhon",
        "timestamp": 1725743598
    },
    {
        "content": "<p>That makes <code>map</code> much more dependent, and you can't rewrite <code>ls</code>. The zen of <code>attach</code> is that <code>ls.attach.map</code> is how you get this dependent version — you can opt-in to the additional difficulty.</p>\n<p>It would be great if <code>List.map</code> mentioned <code>List.map_congr</code> and <code>List.attach</code></p>",
        "id": 468473816,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725743669
    },
    {
        "content": "<p>You can rewrite <code>ls</code> in the non-dependent case, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_cons_self</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">mem_cons_of_mem</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">l₁</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l₂</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">l₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 468475457,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725745216
    },
    {
        "content": "<p>That is, it's not clear that making <code>map</code> dependent incurs any costs for non-dependent uses, besides downstream churn and an extra underscore.</p>",
        "id": 468475555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725745305
    },
    {
        "content": "<p>It's possible that the zen of<code>l.attach.map fun a =&gt; f a.val a.prop</code> instead of <code>l.map' fun a ha =&gt; f a ha</code> is a historical artifact caused by the fact that <code>map</code> lived in core and was effectively immutable, while <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.attach\">docs3#list.attach</a> lived in mathlib</p>",
        "id": 468476612,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725746160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Asserting.20that.20.60x.20.E2.88.88.20ls.60.20for.20.60x.60.20in.20.60ls.2Emap.20fun.20x.20.3D.3E.60/near/468473620\">said</a>:</p>\n<blockquote>\n<p>Was having <code>x ∈ ls</code> available as an argument to <code>ls.map</code> ever considered? If so, it might make sense for the docstring of <code>List.map</code> to explain why that turned out to be a bad idea, and to point to <code>List.attach</code> and <code>List.map_congr</code>.</p>\n</blockquote>\n<p>Isn't that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.pmap#doc\">docs#List.pmap</a> ?</p>",
        "id": 468492645,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725758004
    }
]