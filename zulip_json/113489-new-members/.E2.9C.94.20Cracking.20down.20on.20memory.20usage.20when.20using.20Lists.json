[
    {
        "content": "<p>Hi all,</p>\n<p>Apologies in advance for the girthy question. I'm not entirely sure how to pose it without giving some background info first. I've been developing a little program to find decision trees for sorting lists of numbers. To quickly sketch the problem: a sorting tree for length <code>len</code> is a binary tree whose leaves are permutations of <code>List.range len</code> and whose nodes store a comparison, i.e. a tuple of <code>Fin len</code>'s representing two items being compared to each other. See <a href=\"https://imgur.com/a/sorting-tree-aDNpdRf\">here</a> for an example for length 3. To sort a random list (of <code>len</code> elements) given such a sorting tree, we start at the root node and look at its comparison, say <code>(n, m)</code>. We then compare the <code>n</code>th and <code>m</code>th elements of the input list; if <code>n &lt; m</code> we continue down the left branch and vice versa. If we encounter a leaf, say <code>[2, 0, 1]</code>we reorder the input list according to these indices (so we would get the third element, followed by the first, followed by the second). This list should then be sorted.</p>\n<p>I calculate these trees recursively by seeing which comparisons I haven't yet used, choosing one, then filtering the remaining possible permutations on if they'd still work if the comparison was true or false (i.e. whether the first element was smaller or not). If more than one permutation still remains, I call the deepening function again; if there's exactly one remaining, I construct a leaf. If there aren't any possible permutations anymore I know there's been an incompatible choice of comparison results, and I can stop searching there.</p>\n<p>I've uploaded my code to <a href=\"https://github.com/WalrusGumboot/sorting-trees\">GitHub</a>, if you want to take a look.</p>\n<p>The program does work, but consumes an ungodly amount of memory. Calculating a tree for length 3 (i.e. finding  a tree which sorts all list of three elements correctly) is pretty much instant, calculating one for length 4 takes half a minute and allocates 11 gigabytes (!). I haven't been able to calculate one for 5 yet, since my laptop only has 16GB of memory. I frankly don't know enough about how Lean works behind the scenes to have a clue about how to optimize this. Does anyone have any useful pointers on decreasing this absurd memory usage? My usual go-to tools for profiling and optimizing software (Valgrind, Flamegraph) don't give me much intuition.</p>\n<p>Any help would be much appreciated!</p>",
        "id": 506536795,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742318190
    },
    {
        "content": "<p>Every time you recurse, you are copying the list of remaining permutations, which starts out at a size of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>⋅</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\cdot n!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!)</span></span></span></span>, and you are copying it <del>up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n^2)!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)!)</span></span></span></span> times in total</del> up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>⋅</mo><mtext>log </mtext><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n \\cdot \\text{log}\\ n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord text\"><span class=\"mord\">log</span></span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> times in total, so unless I misunderstood your code this explains the ungodly space usage.</p>",
        "id": 506537871,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742318487
    },
    {
        "content": "<p>This already seems a bit suspicious:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">workingTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">testTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">allTrees</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">head?</span>\n</code></pre></div>\n<p>you appear to be constructing a sorting tree by first constructing every possible tree, filtering the list to throw away all trees that are not valid, and then throwing away all of those validated trees except for the first</p>",
        "id": 506544468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742320353
    },
    {
        "content": "<p>Assuming that there isn't a way to do correct by construction tree generation, you could instead avoid making a list to begin with and just enumerate trees and return the first success</p>",
        "id": 506544673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742320419
    },
    {
        "content": "<p>Lean does not evaluate your expressions lazily, it is actually generating all trees here.</p>",
        "id": 506544785,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742320447
    },
    {
        "content": "<p><code>testTree</code> is also a very expensive function, you check it against every permutation. It seems like something that should be true by construction about the result of <code>allTrees</code></p>",
        "id": 506545802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742320738
    },
    {
        "content": "<p>If you want to get something which is actually algorithmically efficient here, I think you have to ditch the permutations entirely and work with partial orders instead. The only permutations that should come up are the ones in the sorting tree in the output</p>",
        "id": 506546939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742320956
    },
    {
        "content": "<p>Here's an algorithm I would suggest for this problem:</p>\n<ul>\n<li><code>mkTree</code>: takes as input a partial order <code>P</code> on <code>[0...n]</code> and returns a sorting tree for all permutations consistent with <code>P</code><ul>\n<li>Find a pair <code>a,b</code> which are incomparable in <code>P</code>. If there is none, then this is a leaf, output the results in the provided order.</li>\n<li>If there is one, then return a tree with root node <code>a:b</code>, left side is <code>mkTree(P ∪ {a &lt; b})</code> and the right side is <code>mkTree(P ∪ {a &gt; b})</code>.</li>\n</ul>\n</li>\n</ul>\n<p>This in turn requires a persistent data structure for the partial order <code>P</code>, which supports three operations:</p>\n<ul>\n<li>add an inequality <code>a &lt; b</code> to <code>P</code></li>\n<li>find an incomparable pair <code>a, b</code> in <code>P</code></li>\n<li>Return the elements of <code>P</code> in order if it is a total orderz</li>\n</ul>\n<p>It's possible to implement these operations in linear time with just a list of pairs, but you can probably do better than that by using binary search trees.</p>",
        "id": 506548389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742321418
    },
    {
        "content": "<p>A completely different way to construct a sorting tree, probably even better than what I just suggested (which does not control how incomparable pairs are selected and so can have depth <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> if the selection is done poorly) is to just use an arbitrary off the shelf sorting algorithm, but whenever that algorithm does a <code>a &lt; b</code> test you just run both sides of the conditional and concatenate them with a <code>a:b</code> node. This should give you the optimal running time <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{O(n\\log n)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mop mtight\"><span class=\"mtight\">l</span><span class=\"mtight\">o</span><span class=\"mtight\" style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace mtight\" style=\"margin-right:0.1952em;\"></span><span class=\"mord mathnormal mtight\">n</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> which is the minimum size of the output.</p>",
        "id": 506549241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742321708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Cracking.20down.20on.20memory.20usage.20when.20using.20Lists/near/506544785\">said</a>:</p>\n<blockquote>\n<p>Lean does not evaluate your expressions lazily, it is actually generating all trees here.</p>\n</blockquote>\n<p>Okay, that's already a very good pointer. Coming from Haskell I guess I assumed \"ah this is one of those fancy functional languages I've heard about, i'll be grand\" haha</p>",
        "id": 506549648,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742321850
    },
    {
        "content": "<p>In any case, thanks everyone for the great advice. To be fair, the <code>workingTree</code> function isn't actually used anymore, I believe that <code>allTrees</code> should indeed give correct-by-construction trees, but I'm not 100% sure</p>",
        "id": 506549918,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742321927
    },
    {
        "content": "<p><code>allTrees</code> has an even worse lower bound though because by its spec it has to generate not one but all sorting trees which puts it at something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n!)!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!)!)</span></span></span></span> complexity</p>",
        "id": 506550149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742322009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/Cracking.20down.20on.20memory.20usage.20when.20using.20Lists/near/506544673\">said</a>:</p>\n<blockquote>\n<p>Assuming that there isn't a way to do correct by construction tree generation, you could instead avoid making a list to begin with and just enumerate trees and return the first success</p>\n</blockquote>\n<p>What would be a good way of going about this? do I have to do some monadic business to iterate over all trees and return upon the first success?</p>",
        "id": 506550162,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742322015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/Cracking.20down.20on.20memory.20usage.20when.20using.20Lists/near/506550149\">said</a>:</p>\n<blockquote>\n<p><code>allTrees</code> has an even worse lower bound though because by its spec it has to generate not one but all sorting trees which puts it at something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">!</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O((n!)!)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">!)!)</span></span></span></span> complexity</p>\n</blockquote>\n<p>okay yeah, that's embarrassing... <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 506550261,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742322050
    },
    {
        "content": "<p>it depends on how you do the enumeration. In your case you have a recursive function which builds up the tree in pieces, so you could have those functions return <code>Option SortingTree</code> to return the first good result, if it's a fallible operation</p>",
        "id": 506550505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742322124
    },
    {
        "content": "<p>so kind of like what you are doing with <code>List</code> but you just eagerly throw away all results but the first</p>",
        "id": 506550574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742322148
    },
    {
        "content": "<p>But the methods I described above don't have any fallibility built in, they just directly construct a valid tree</p>",
        "id": 506550750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742322223
    },
    {
        "content": "<p>if you run any correct sorting algorithm, it <em>will</em> construct a valid sorting tree with no backtracking needed</p>",
        "id": 506550840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1742322252
    },
    {
        "content": "<p>Yeah, that makes sense. I suppose now's a good time to crack open Sedgewick's Algorithms for the first time in a while <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 506551045,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742322343
    },
    {
        "content": "<p>Thanks so much! I've received nothing but quick and valuable help from this community so far, it's been a great experience.</p>",
        "id": 506551171,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1742322386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819173\">Simeon Duwel</span> has marked this topic as resolved.</p>",
        "id": 506596123,
        "sender_full_name": "Notification Bot",
        "timestamp": 1742338633
    }
]