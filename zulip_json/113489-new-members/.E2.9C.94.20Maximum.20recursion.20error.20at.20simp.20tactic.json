[
    {
        "content": "<p>Why would <code>by simpa using e</code> give me maximum recursion error? I thought simp lemmas always have a 'direction' so that the term cannot blow up by applying them? (I would understand the situation if I supplied custom rules like <code>simpa [rules, ⋯] using e</code> but that's not the case.)</p>\n<p>EDIT: In some variation of this code, <code>by simp</code> will also give me maximum recursion error, so it's not bound to <code>by simpa</code>.</p>\n<p>Here is some <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span><span class=\"bp\">.</span><span class=\"n\">Shapes</span><span class=\"bp\">.</span><span class=\"n\">Pullback</span><span class=\"bp\">.</span><span class=\"n\">CommSq</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Limits</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- If `E` is an equalizer of `f g : X ⟶ Y`, then `E` is also the pullback of the diagonal map</span>\n<span class=\"sd\">`Y ⟶ Y × Y` along `⟨f, g⟩ : X ⟶ Y × Y`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isPullback_equalizer_prod''</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasBinaryProduct</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fork</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsLimit</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPullback</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">diag</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">toFork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PullbackCone</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">diag</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Fork</span><span class=\"bp\">.</span><span class=\"n\">ofι</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">lift_eq_diag_of_comp_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"o\">]</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">PullbackCone</span><span class=\"bp\">.</span><span class=\"n\">IsLimit</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_⟩⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toFork</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Fork</span><span class=\"bp\">.</span><span class=\"n\">IsLimit</span><span class=\"bp\">.</span><span class=\"n\">lift_ι</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fork</span><span class=\"bp\">.</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toFork</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Fork</span><span class=\"bp\">.</span><span class=\"n\">IsLimit</span><span class=\"bp\">.</span><span class=\"n\">hom_ext</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fork</span><span class=\"bp\">.</span><span class=\"n\">IsLimit</span><span class=\"bp\">.</span><span class=\"n\">lift_ι</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 529222173,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1752738883
    },
    {
        "content": "<p>I assume simp lemmas only heuristically converge but there might be edge cases where they don't?</p>",
        "id": 529226264,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1752740318
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245772\">@Klaus Gy</span> your code doesn't compile. also, the recursion error gives you the steps to debug the problem yourself</p>",
        "id": 529240828,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752745449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I was more curious about the general case. Should we assume that simp lemmas always terminate, does non-termination hint to a poorly designed simp lemma?  Or is non-termination just something unavoidable in the simp construction?</p>",
        "id": 529242599,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1752746098
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245772\">@Klaus Gy</span> I am telling you that generally you should look at the error and see what happened, and if you see a poorly designed simp lemma you can discuss it on zulip</p>",
        "id": 529244080,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752746580
    },
    {
        "content": "<p>yes, you should assume that simp lemmas always terminate</p>",
        "id": 529244124,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752746593
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245772\">Klaus Gy</span> has marked this topic as resolved.</p>",
        "id": 529244495,
        "sender_full_name": "Notification Bot",
        "timestamp": 1752746731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> but just to get some perspective, how often do you stumble across non-terminating simp lemmas in the mathlib? I just want to wager if I should investigate further, from a first glance, I didn't see anything suspicious in the logs.</p>",
        "id": 529275499,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1752757648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245772\">@Klaus Gy</span> which lemmas were repeated in the logs?</p>",
        "id": 529275890,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752757764
    },
    {
        "content": "<p>you should investigate</p>",
        "id": 529275911,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752757773
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p><a href=\"/user_uploads/3121/asXAdtV6SgupRt0q13OxWHZj/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/asXAdtV6SgupRt0q13OxWHZj/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"224x130\" src=\"/user_uploads/thumbnail/3121/asXAdtV6SgupRt0q13OxWHZj/image.png/840x560.webp\"></a></div>",
        "id": 529276129,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752757831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245772\">@Klaus Gy</span> try to understand this example and then do the same to yours and then tell me the result here</p>",
        "id": 529276185,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1752757848
    },
    {
        "content": "<p>In my case it only used theorem <code>PullbackCone.π_app_left</code> 474 times but also a lot of unfolded declarations. Will investigate!</p>",
        "id": 529276588,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1752757983
    },
    {
        "content": "<p>hmm on a second thought, maybe this simp lemma is problematic?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The first projection of a pullback cone. -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PullbackCone</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">WalkingCospan</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"bp\">...</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">π_app_left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PullbackCone</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">π</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"n\">WalkingCospan</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>it seems to me like the simp tactic gets stuck because it applies simp and then unfolds the abbreviation and then is again in a position to reapply the same simp lemma?</p>",
        "id": 530502013,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753345427
    },
    {
        "content": "<p>that's exactly what's happening</p>",
        "id": 530502943,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753345701
    },
    {
        "content": "<p><code>abbrev</code>s should be used with caution</p>",
        "id": 530503048,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753345735
    },
    {
        "content": "<p>thats not my abbrev, thats from mathlib</p>",
        "id": 530503089,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753345748
    },
    {
        "content": "<p>in that case, please PR :)</p>",
        "id": 530503169,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753345770
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/27421\">https://github.com/leanprover-community/mathlib4/pull/27421</a></p>",
        "id": 530505253,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753346383
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/Uc57o0PcqcEO1nnPChzqsR7e/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Uc57o0PcqcEO1nnPChzqsR7e/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"645x63\" src=\"/user_uploads/thumbnail/3121/Uc57o0PcqcEO1nnPChzqsR7e/image.png/840x560.webp\"></a></div>",
        "id": 530505339,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753346407
    },
    {
        "content": "<p>oh, i used pi in the branch name, is that bad?</p>",
        "id": 530505571,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753346487
    },
    {
        "content": "<p>not sure, it's the first time i saw that message</p>",
        "id": 530505729,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753346535
    }
]