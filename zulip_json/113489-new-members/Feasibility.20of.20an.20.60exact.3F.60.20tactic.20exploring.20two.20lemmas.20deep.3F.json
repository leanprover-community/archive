[
    {
        "content": "<p>The <code>exact?</code> tactic is useful when there is a single lemma that can immediately solve the current goal. Is there a comparable mechanism for situations where exactly two lemmas, used together, suffice to close the goal?</p>\n<p>I suspect a naïve approach—exploring all possible pairs of lemmas, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> combinations—would be prohibitively slow. In absolute terms, roughly how slow would this be? Are there any clever heuristics or pruning strategies that would reduce the search space enough to handle simpler “two-lemma” scenarios in a reasonable time?</p>\n<p>Two simple examples:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact_2?</span><span class=\"w\"> </span><span class=\"c1\">-- would suggest `exact Nat.prime_iff.mp (fact_iff.mp h)`</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact_2?</span><span class=\"w\"> </span><span class=\"c1\">-- would suggest `exact fact_iff.mpr h.nat_prime`</span>\n</code></pre></div>\n<p>The question is twofold: does a mechanism of this kind already exist, and if not, could one be built without incurring prohibitive performance costs?</p>",
        "id": 506173581,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1742222767
    },
    {
        "content": "<p>Does <code>apply?</code> followed by <code>exact?</code> work here?</p>",
        "id": 506177267,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1742223563
    },
    {
        "content": "<p>That would only search the first result of <code>apply?</code></p>",
        "id": 506189770,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1742226094
    },
    {
        "content": "<p>I meant once <code>apply?</code> found something you can use <code>exact?</code> to close the goal (of course this requires that you picked the right suggestion from <code>apply?</code> in the first place)</p>",
        "id": 506208264,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1742230033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> Using the mechanical strategy \"try all <code>apply?</code> suggestions two lemmas deep\" does succeed in one of the two example cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- \"apply?\" gives two suggestions. One of them is \"fact_iff.mpr\".</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">fact_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">  </span><span class=\"c1\">-- \"apply?\" now gives one suggestion: \"Prime.nat_prime\".</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">nat_prime</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n</code></pre></div>\n<p>However, for the second test case -- <code>example (p : ℕ) (h : Prime p) : Fact p.Prime := by sorry</code> which can be solved by <code>exact fact_iff.mpr h.nat_prime</code>-- this mechanical approach does not seem to work.</p>",
        "id": 506247568,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1742241195
    },
    {
        "content": "<p>I guess you mean for the 1st test case. I think that's because the search made by <code>apply?</code> does not take hypotheses into accounts, it only uses the hypotheses when it found a candidate lemma. So when looking for a lemma to prove <code>Prime _</code> <code>apply</code> will only look at lemmas whose conclusion has the form <code>Prime _</code>, which is not the case of <code>fact_iff.mp</code>.</p>",
        "id": 506251044,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1742242340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> Yes, I mixed them up! Could we come up with a search heuristic that would find the other case too?</p>",
        "id": 506526322,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1742315249
    },
    {
        "content": "<p>Also, does anyone want to weigh in on this more generally?</p>\n<blockquote>\n<p>I suspect a naïve approach—exploring all possible pairs of lemmas, i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">n^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span> combinations—would be prohibitively slow. In absolute terms, roughly how slow would this be? Are there any clever heuristics or pruning strategies that would reduce the search space enough to handle simpler “two-lemma” scenarios in a reasonable time?</p>\n</blockquote>",
        "id": 506526976,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1742315408
    }
]