[
    {
        "content": "<p>Hi, I am trying to understand the behavior and limits of the termination checker when we have a nested recursive type, like a rose tree:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I can define a size function exactly as I would expect:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rose_size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">rose_size</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But if I try to write an equality function (purely as an example), Lean cannot prove termination:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">γ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>\n<p>In this context, I don't understand why Lean treats the use of <code>List.map</code> and <code>map2</code> differently when it comes to termination. Is there a way to define <code>map2</code> so that the above typechecks? If so, what is the general rule? I know I can use a nested recursive function, but I am trying to do without to see how Lean's termination checking works.</p>",
        "id": 537889909,
        "sender_full_name": "Josh Cohen",
        "timestamp": 1757084347
    },
    {
        "content": "<p>the termination checker doesn't know that <code>map2</code> calls its testing function with elements of the list</p>",
        "id": 537895529,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757086063
    },
    {
        "content": "<p>it also doesn't know that <code>List.map</code> calls its function elements from the list, but <code>List.map</code> has a theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.map_wfParam#doc\">docs#List.map_wfParam</a> which is used in preprocessing to \"attach\" this information to the list</p>",
        "id": 537895705,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757086131
    },
    {
        "content": "<p><code>map2</code> does not have such a theorem since you didn't write one</p>",
        "id": 537895772,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757086149
    },
    {
        "content": "<p>you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a> to attach the information to your list</p>",
        "id": 537896600,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757086447
    },
    {
        "content": "<p>you can also use structural recursion by writing out the map manually and making it mutually recursive with your defintion</p>",
        "id": 537896739,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757086498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Understanding.20the.20termination.20checker.20for.20nested.20recursion/near/537895772\">said</a>:</p>\n<blockquote>\n<p><code>map2</code> does not have such a theorem since you didn't write one</p>\n</blockquote>\n<p>Thanks for the pointers, that is helpful. I tried to write a similar theorem for <code>map2</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">wf_preprocess</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">map2_wfParam</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ys</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">wfParam</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"bp\">.</span><span class=\"n\">unattach</span><span class=\"bp\">.</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">wfParam</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>But that still doesn't seem the satisfy the termination checker. Is that theorem the one I want?</p>",
        "id": 537897798,
        "sender_full_name": "Josh Cohen",
        "timestamp": 1757086813
    },
    {
        "content": "<p>You need the theorem defined below as well, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.map_unattach#doc\">docs#List.map_unattach</a></p>",
        "id": 537898476,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757087053
    },
    {
        "content": "<p>Thank you, that worked! So just to clarify, for each such function I want to use in a nested way, I would need the <code>_wfParam</code> lemma (or at least to inline the <code>attach.unattach</code> pattern in the recursive call) and then the <code>_unattach</code> theorem?</p>",
        "id": 537899568,
        "sender_full_name": "Josh Cohen",
        "timestamp": 1757087398
    },
    {
        "content": "<p>you could also just call it with the attached lists</p>",
        "id": 537899672,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757087421
    },
    {
        "content": "<p>like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 537899735,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757087439
    },
    {
        "content": "<p>This gives me an error because <code>rose_eq</code> expects a <code>List a</code> rather than a <code>List</code> of sigma types. Am I missing a coercion somewhere?</p>",
        "id": 537900530,
        "sender_full_name": "Josh Cohen",
        "timestamp": 1757087689
    },
    {
        "content": "<p>probably I forgot to put a coercion somewhere</p>",
        "id": 537900697,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757087733
    },
    {
        "content": "<p>try</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rose</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">leaf</span><span class=\"w\"> </span><span class=\"n\">x2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"n\">x2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">all</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rose_eq</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"bp\">.</span><span class=\"n\">attach</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">id</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n</code></pre></div>",
        "id": 537900791,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757087763
    },
    {
        "content": "<p>This version seems to end up back at the original error message. I suppose I would need to add a manual proof obligation that <code>x : { x // x ∈ l1 }</code> implies <code>sizeOf x.val &lt; 1 + sizeOf l1</code>, which shouldn't be too hard (though now that I think about it, I'm not sure how the <code>sizeOf</code> operator is defined).</p>",
        "id": 537902000,
        "sender_full_name": "Josh Cohen",
        "timestamp": 1757088060
    },
    {
        "content": "<p>Almost, you need <code>(fun ⟨x, _⟩ ⟨y, _⟩ =&gt; rose_eq eq x y)</code></p>",
        "id": 537903061,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757088395
    }
]