[
    {
        "content": "<p>I want to encode the following chain - you can probably ignore everything up til the final definition <code>computes</code> whose structure is quite clear. Basically, I say state A \"computes to\" state B if either A = B, or there is C such that A ~ C and C computes to B (for some fixed known notion of <code>~</code>).</p>\n<p>How can I specify this type? Lean lacks the usual phrasing of recursive functions that I would normally reach for in a programming language, so the following doesn't compile. Am I going to have to parameterise my type on the length of the chain and then define it by induction?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">pfun</span>\n<span class=\"kn\">import</span> <span class=\"n\">computability</span><span class=\"bp\">.</span><span class=\"n\">turing_machine</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">zmod</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">modular_machine</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">mBig</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">steps</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"n\">turing</span><span class=\"bp\">.</span><span class=\"n\">dir</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">reduces</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">modular_machine</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">fromState</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- α , β , u m + a, v m + b</span>\n  <span class=\"o\">(</span><span class=\"n\">toState</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"c1\">-- α1 , β1 ,</span>\n  <span class=\"o\">:=</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- α1 = u m^2 + c , β1 = v</span>\n  <span class=\"c1\">-- α1 = u , β1 = v m^2 + c</span>\n  <span class=\"o\">(</span><span class=\"n\">toState</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">fromState</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">/</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">toState</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span> <span class=\"n\">fromState</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">/</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span><span class=\"o\">)</span>\n  <span class=\"bp\">∨</span>\n  <span class=\"o\">(</span><span class=\"n\">toState</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">fromState</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">/</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span> <span class=\"bp\">∧</span> <span class=\"n\">toState</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">fromState</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">/</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">M</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">computes</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">modular_machine</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">fromState</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">toState</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span>\n  <span class=\"n\">fromState</span> <span class=\"bp\">=</span> <span class=\"n\">toState</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">reduces</span> <span class=\"n\">m</span> <span class=\"n\">fromState</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">computes</span> <span class=\"n\">m</span> <span class=\"n\">c</span> <span class=\"n\">toState</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 196806708,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1588873792
    },
    {
        "content": "<p>(by the way, this is in aid of supplying an alternative Turing-complete form of computation which is fundamental to the proof I know of the unsolvability of the word problem in groups, see <a href=\"https://www.patrickstevens.co.uk/misc/ModularMachines/EmbedMMIntoTuringMachine.pdf\" title=\"https://www.patrickstevens.co.uk/misc/ModularMachines/EmbedMMIntoTuringMachine.pdf\">https://www.patrickstevens.co.uk/misc/ModularMachines/EmbedMMIntoTuringMachine.pdf</a> if interested)</p>",
        "id": 196807121,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1588874000
    },
    {
        "content": "<p>The usual way to construct this is as an inductive proposition. In fact it already exists as <a href=\"https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.refl_trans_gen\" title=\"https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.refl_trans_gen\">https://leanprover-community.github.io/mathlib_docs/logic/relation.html#relation.refl_trans_gen</a></p>",
        "id": 196807791,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588874297
    },
    {
        "content": "<p>(and I see that <code>computability.turing_machine</code> uses it, for example)</p>",
        "id": 196807850,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588874321
    },
    {
        "content": "<p>Your \"definition\" is not really a definition at all as it stands--if we treat it as an equation, then the constant \"true\" relation also satisfies it. You need to say that <code>computes</code> is the smallest relation with this property, and that's what an inductive proposition is.</p>",
        "id": 196808141,
        "sender_full_name": "Reid Barton",
        "timestamp": 1588874418
    }
]