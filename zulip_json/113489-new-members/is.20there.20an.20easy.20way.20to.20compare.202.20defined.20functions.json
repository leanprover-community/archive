[
    {
        "content": "<p>This might be a very stupid question, but I want to make sure that I'm not missing anything. Say I have two functions f and g, one of which is defined using <code>def</code> constructions, the other is either from Mathlib or also using <code>def</code> but is not written in the same way as a first one. Is there an easy way (a tactic that attempts that, maybe) to check whether they are equivalent? <br>\nFor example, a proper divisor of natural n is a natural divisor that does not equal n. There is a <code>def Nat.properDivisors</code> in Mathlib and this could also be written like <code>def properDivisors (n : Nat) : Set Nat := {x | x |n ∧ x ≠ n}</code> (although in this example there might be a problem with Set/Finset kind of thing). Even if I use <code>def ProperDivisors ...</code> and write the same definition as in Mathlib, I still can't use a lemma like 'm.properDivisors = ...' to get 'properDivisors m = ...'. Constructs that are obviously equivalent for a human can be written using many different forms and I want to understand with what one can get away with in this regard</p>",
        "id": 531814057,
        "sender_full_name": "V S",
        "timestamp": 1753873831
    },
    {
        "content": "<p>That's a classical undecidable problem in computer science - in general, telling whether two given programs compute the same result for all possible inputs is undecidable.</p>\n<p>Of course in specific cases you may be able to prove that <em>this</em> function and <em>that</em> other function are equivalent, that's not a problem. Like, you can write addition on the natural numbers by recursion on the first or second arguments, and prove that the two are equivalent even though the general problem is undecidable.</p>\n<p>In Lean, you can of course write the statement that the two functions are equivalent as <code>\\forall x, f x = g x</code>; you can even (I believe) use it in code to write a function whose result depends on that, but your function will then be \"non computable\" - you won't be able to evaluate it.</p>",
        "id": 531815645,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1753874327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/is.20there.20an.20easy.20way.20to.20compare.202.20defined.20functions/near/531815645\">said</a>:</p>\n<blockquote>\n<p>That's a classical undecidable problem in computer science - in general, telling whether two given programs compute the same result for all possible inputs is undecidable.</p>\n<p>Of course in specific cases you may be able to prove that <em>this</em> function and <em>that</em> other function are equivalent, that's not a problem. Like, you can write addition on the natural numbers by recursion on the first or second arguments, and prove that the two are equivalent even though the general problem is undecidable.</p>\n<p>In Lean, you can of course write the statement that the two functions are equivalent as <code>\\forall x, f x = g x</code>; you can even (I believe) use it in code to write a function whose result depends on that, but your function will then be \"non computable\" - you won't be able to evaluate it.</p>\n</blockquote>\n<p>I see, thank you for clarifications! I thought that there might be something useful for these specific cases, but it's probably up to the person writing in Lean to pick the better function out of all possibilities</p>",
        "id": 531830347,
        "sender_full_name": "V S",
        "timestamp": 1753878572
    },
    {
        "content": "<p>For some reason I am unable to close the topic, but it should be considered closed I guess</p>",
        "id": 531830623,
        "sender_full_name": "V S",
        "timestamp": 1753878635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"874708\">V S</span> <a href=\"#narrow/channel/113489-new-members/topic/is.20there.20an.20easy.20way.20to.20compare.202.20defined.20functions/near/531814057\">said</a>:</p>\n<blockquote>\n<p>Constructs that are obviously equivalent for a human</p>\n</blockquote>\n<p>You need to understand that Lean is not a human, and it needs everything to be specified exactly. So you can't just have a rule that checks \"by vibes\" that two definitions are the same and allow you to automatically replace one with the other.</p>\n<p>However once you proved that your two definitions are equivalent (still not the same, because one returns Set and one returns Finset), then you can freely <code>rewrite</code> one to the other.</p>",
        "id": 531950067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753918160
    }
]