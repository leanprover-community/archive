[
    {
        "content": "<p>Hi all, why is the computational structure for dependent function types preserved in Lean but the one for pairs isn't? If I have a proof <code>h : ∀ x : α, P x</code> I can apply it to data x to produce a proof of the proposition <code>P x</code>but if I instead have a proof <code>h : ∃ x : α, P x</code>I need a noncomputable <code>h.choose</code> to extract the witness. Axiom of choice and classical reasoning aside, I assume the problem boils down to not allowing eliminating from the Prop universe into a Type universe which would differentiate the second from the first case? Because if one has already made the effort to construct the witness <code>x</code> and thus construct an existential proof <code>h</code> then why won't they be able to reuse their own constriction from within the proof term?</p>",
        "id": 563704561,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1765736383
    },
    {
        "content": "<p>Because of definitional proof irrelevance, you can't be allowed to project data from proofs</p>",
        "id": 563704614,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765736474
    },
    {
        "content": "<p>Because it's unsound if you can use the witness. Any two proofs of a proposition are equal in lean so in particular different witnesses give the same proof</p>",
        "id": 563704624,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765736488
    },
    {
        "content": "<p>if the exists statement is the existence of a proof, then you can project it out, so if <code>P</code> is a proposition and <code>h : ∃ x : P, Q x</code> then <code>h.1 : P</code> and <code>h.2 : Q h.1</code></p>",
        "id": 563704783,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765736680
    },
    {
        "content": "<p>Please see <a href=\"https://leanprover-community.github.io/extras/pitfalls.html#trying-to-extract-data-from-proofs-of-propositions\">https://leanprover-community.github.io/extras/pitfalls.html#trying-to-extract-data-from-proofs-of-propositions</a>. I think what you might be confused about is why you can seemingly extract data from <code>hf : ∀ x : α, P x</code>, but not from <code>he : ∃ x : α, P x</code>, despite them both being proofs of propositions. The reason for this is that when you apply x to <code>hf</code>, you don't get data, you get a proof, which is perfectly fine. Likewise, you are actually allowed to extract an <code>x</code> from <code>he</code> without choice using <code>Exists.elim</code> provided that this <code>x</code> is only used to produce a proof of a proposition. The only thing that requires using choice is extracting an <code>x</code> from <code>he</code> and then using it to construct an element of some type in <code>Type</code> or above.</p>",
        "id": 563964508,
        "sender_full_name": "Niels Voss",
        "timestamp": 1765860093
    },
    {
        "content": "<p>First of all, thanks all for replying and the clarifications you added!</p>\n<blockquote>\n<p>I think what you might be confused about is why you can seemingly extract data from <code>hf : ∀ x : α, P x</code>, but not from <code>he : ∃ x : α, P x</code>, despite them both being proofs of propositions.</p>\n</blockquote>\n<p>Exactly, it seemed strange they are treated differently at first.</p>\n<blockquote>\n<p>Likewise, you are actually allowed to extract an <code>x</code> from <code>he</code> without choice using <code>Exists.elim</code> provided that this <code>x</code> is only used to produce a proof of a proposition.</p>\n</blockquote>\n<p>Good clarification, it must explain why we can eliminate in proofs but not outside of them.</p>\n<blockquote>\n<p>The only thing that requires using choice is extracting an <code>x</code> from <code>he</code> and then using it to construct an element of some type in <code>Type</code> or above.</p>\n</blockquote>\n<p>This matches with my suggested assumption above: \"I assume the problem boils down to not allowing eliminating from the Prop universe into a Type universe which would differentiate the second from the first case.\"</p>\n<blockquote>\n<p>Because it's unsound if you can use the witness. Any two proofs of a proposition are equal in lean so in particular different witnesses give the same proof.</p>\n</blockquote>\n<p>I see, so in one sentence because of the design choice of proof irrelevance so that we cannot project two witnesses that might compute differently from the same proof. Or in a validated example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">he1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">he2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">proof_irrelevance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">irrelevant_proofs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">he1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">he2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proof_irrelevance</span><span class=\"w\"> </span><span class=\"n\">he1</span><span class=\"w\"> </span><span class=\"n\">he2</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">he1</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">he2</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">Invalid projection: Cannot project a value of non-propositional type</span>\n<span class=\"cm\">  Nat</span>\n<span class=\"cm\">from the expression</span>\n<span class=\"cm\">  he1</span>\n<span class=\"cm\">which has propositional type</span>\n<span class=\"cm\">  ∃ x, x = 0</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<blockquote>\n<p>if the exists statement is the existence of a proof, then you can project it out, so if <code>P</code> is a proposition and <code>h : ∃ x : P, Q x</code> then <code>h.1 : P</code> and <code>h.2 : Q h.1</code></p>\n</blockquote>\n<p>Which makes the behavior consistent in allowing exploiting the computational structure of the two proofs <em>as long</em> as the result of this is a proof, i.e. remains in the Prop universe. Just to add a validated example for everyone else that might end up reading this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"c1\">-- : P</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"c1\">-- : Q h.1</span>\n</code></pre></div>\n<p>Thanks all!</p>",
        "id": 564050281,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1765894046
    }
]