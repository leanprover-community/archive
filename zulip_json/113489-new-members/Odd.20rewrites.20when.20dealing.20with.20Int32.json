[
    {
        "content": "<p>Hi,</p>\n<p>I'm a complete Lean beginner with a bit of Isabelle background.<br>\nHere is a minimal example of my situation : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int32</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">other</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Plus</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">opt</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I'm trying to prove a very basic arithmetic simplification.<br>\nWhenever my numbers (from Expr.Num) are of type Nat, the rw [opt] in my proof works exactly as I expect it to do and it solves the goal. However, when the type is Int32, it creates 3 subgoals which I do not understand.</p>\n<p>Subgoal 1 : (opt (Num 0)).Plus (opt e) = opt e<br>\nFor me, it makes no sense as it seems to apply the 3rd rule \"opt (Plus e1 e2) = Plus (opt e1) (opt e2)\" when it should apply the first rule \"opt (Plus (Num 0) e) = opt e\"</p>\n<p>Subgoal 2 : Num 0 = Num { toUInt32 := { toBitVec := <a href=\"https://github.com/leanprover-community/0/pull/32\">0#32</a> } } → False<br>\nSubgoal 3 : e = Num { toUInt32 := { toBitVec := <a href=\"https://github.com/leanprover-community/0/pull/32\">0#32</a> } } → False</p>\n<p>I understand nothing about the last two subgoals. I know that Int32 is defined way differently from Nat, but I don't know how and I assume I shouldn't have to know (?). <br>\nWhat I am wondering is why can't I do this single rewrite when \"it looks obvious\". I would have expected to finish my goal with this single rw [opt].</p>\n<p>Thank you very much for reading this.</p>",
        "id": 520041338,
        "sender_full_name": "ZDHKLV",
        "timestamp": 1748002980
    },
    {
        "content": "<p>Thank you for reporting this. This is indeed very unfortunate. As you guessed, <code>rw</code> decides that it should apply the third rule and asks you to prove that the first two rules are not applicable, but of course this is impossible since the first rule is in fact applicable. In this specific case, you can use <code>erw</code> instead of <code>rw</code>, which is basically a version of <code>rw</code> that will try harder to apply the first rule for <code>opt</code> and it succeeds on your goal. It is completely reasonable to expect normal <code>rw</code> to succeed here. I will create a Lean issue for this problem.</p>",
        "id": 520044586,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1748003912
    },
    {
        "content": "<p>Thank you very much for your response. While erw works for this minimal version, unfortunately I hit a timeout in my real one (where the opt function contains many more cases). If this is indeed the case that the issue isn't from a bad comprehension from me then I am perfectly fine with it and I'll try to work with the Int type instead (which works at intended just like Nat). Thank you again.</p>",
        "id": 520046885,
        "sender_full_name": "ZDHKLV",
        "timestamp": 1748004618
    }
]