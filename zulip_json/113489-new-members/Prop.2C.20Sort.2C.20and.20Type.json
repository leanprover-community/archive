[
    {
        "content": "<p>Is there a good resource/can someone explain what the relations between Prop, Sort m, and Type n are? I have found <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html\">https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html</a> but I am still confused about why Prop = Sort 0 and why the Sort and Type hierarchies have to exist. Second, my brain can comprehend, say, how \"float\" in C++ consists of \"floating point numbers\", but what lives in Sort 42?</p>",
        "id": 524033336,
        "sender_full_name": "Sam",
        "timestamp": 1749865309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928928\">@Sam</span> the simple explanation is, everything has a type, <code>term : type</code> means <code>term</code> has type <code>type</code>. For example, <code>37 : Nat</code> means \"37 is a natural number\", and <code>rfl : 3 = 3</code> means that \"<code>rfl</code> is a proof of the proposition <code>3 = 3</code>\". (i.e. the \"type\" thing has two different translations depending on whether the RHS is mathematically a set or a proposition)</p>\n<p>Now, what mathematicians think of sets (e.g. <code>Nat</code>) correspond to types. in colon notation, this says <code>Nat : Type</code>.</p>\n<p>But then <code>Type</code>, which is the \"type of all types\", needs to have a type as well. That is <code>Type 1</code>, which mathematically corresponds to a \"larger universe\", so <code>Type : Type 1</code></p>\n<p>this goes on, since <code>Type 1</code> also needs a type, so <code>Type 1 : Type 2</code>, and <code>Type 2 : Type 3</code>, and so on. (and <code>3 = 3 : Prop</code>)</p>",
        "id": 524033599,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749865625
    },
    {
        "content": "<p>So now we have <code>Prop</code> for the type of propositions, then <code>Type</code> for the mathematical sets, but then on top of that we also have a hierarchy <code>Type 1</code>, <code>Type 2</code>, <code>Type 3</code>, ...</p>\n<p><code>Sort</code> is just a way to unify these two things, so <code>Sort 0 = Prop</code>, <code>Sort 1 = Type</code>, <code>Sort 2 = Type 1</code>, <code>Sort 3 = Type 2</code>, etc.</p>",
        "id": 524033692,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749865768
    },
    {
        "content": "<p>Thanks for the explanation. More silly questions coming:</p>\n<ul>\n<li>Is the main idea just that \"Type\" and \"Prop\" are two orthogonal (for lack of a better word) concepts that have both been lumped together as lowercase-t types? </li>\n<li>How does Prop differ from a true/false type in any other programming language? Hovering over Prop tells me \"Every proposition is propositionally equal to either True or False.\" In my head I picture some boolean type with two \"members\": \"true\" and \"false\". Is that what the Prop type consists of? Or does it contain the statements \"3 = 3\" themselves?</li>\n</ul>",
        "id": 524035481,
        "sender_full_name": "Sam",
        "timestamp": 1749868626
    },
    {
        "content": "<p>In backwards order:</p>\n<blockquote>\n<p>How does Prop differ from a true/false type in any other programming language? Hovering over Prop tells me \"Every proposition is propositionally equal to either True or False.\" In my head I picture some boolean type with two \"members\": \"true\" and \"false\".</p>\n</blockquote>\n<p>A first approximation is \"Prop is for math and bool is for programming, but otherwise they're representing the same thing\". <a href=\"https://lean-lang.org/doc/reference/latest/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans\">https://lean-lang.org/doc/reference/latest/Basic-Types/Booleans/#The-Lean-Language-Reference--Basic-Types--Booleans</a> has a slightly longer explanation.</p>\n<blockquote>\n<p>Or does it contain the statements \"3 = 3\" themselves?</p>\n</blockquote>\n<p><code>3 = 3 : Prop</code> (is a term of type Prop). Note that <code>3 = 7 : Prop</code> -- i.e. is also a term of type Prop. The former you will be able to find proofs of, the latter you (hopefully) will not. (Finding a proof of <code>3 = 3</code> is equivalently constructing a term of type <code>3 = 3</code>. ) Here perhaps is where bool and Prop start to feel different, as <code>3 = 7</code> would \"Evaluate\" to false, but the point in Lean is generally you want to be able to state things <em>without</em> necessarily evaluating them, as the point is to prove (or disprove) them and there isn't some general algorithm which \"solves\" any proposition, whereas when we're programming we want to know \"do we go this way in the if statement or not?\".</p>\n<blockquote>\n<p>Is the main idea just that \"Type\" and \"Prop\" are two orthogonal (for lack of a better word) concepts that have both been lumped together as lowercase-t types?</p>\n</blockquote>\n<p>A key concept in type theory/interactive theorem provers/Lean is that these are in fact <em>not</em> orthogonal -- specifically, or perhaps mindbendingly -- checking \"does X prove Y\" is in a real sense precisely the same as \"is X of type Y\" -- where the latter is certainly a familiar operation for programmers and the former is a familiar operation for mathematicians, and this nice correspondence is what makes theorem provers possible .</p>\n<p>You might also find <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a> hepful to read.</p>",
        "id": 524035882,
        "sender_full_name": "Julian Berman",
        "timestamp": 1749869308
    },
    {
        "content": "<p>Type n exists for the foundational reason that everything <em>has</em> to have a type in type theory, so Type needs to have a type and whatever that type is needs to have a type etc, and you can't have loops because this gives contradictions. When I'm teaching lean I don't teach the existence of these universes, they're basically only there because the type theory foundations demand it. I agree that Type 42 contains nothing interesting to 99.9% of people. I just teach that types are sets and their terms are elements, and that props are theorem statements and their terms are proofs. The fact that Prop has type Type is something that I've always found misleading and I don't think it has any mathematical meaning (it does allow our definition of subset to work but I regard this as an implementation detail). My understanding is that this is not true in Isabelle, which is a perfectly good system for doing a lot of mathematics.</p>",
        "id": 524046644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749885605
    },
    {
        "content": "<p>Also, as for the difference between <code>Prop</code> and <code>Bool</code>, Lean is by default based on <em>intuitionistic</em> type theory, so <code>Prop</code>isn't necessarily like <code>Bool</code> (note that this doesn't mean that there are propositions that are neither true nor false, but rather that you might not be able to tell which one it is, which is not the same). The moment you add classical axioms, <code>Prop</code> indeed collapses to being perfectly equivalent to <code>Bool</code>, but as <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>  said it makes sense to keep them separate conceptually (so that for example when compiling programs you know you can forget about anything in <code>Prop</code>, as it's only going to contain specifications and proofs about your functions, but not actual data).</p>\n<p>And as Kevin said there's a lot of arbitrariness built into the details. You want to avoid the usual paradoxes (Russel, etc), and there's various approaches one can take. Lean doesn't always take the most conceptually elegant, though it often does take the simplest and most practical (after all doing type theory itself is not the main goal)</p>",
        "id": 524048871,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1749888610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928928\">@Sam</span> for one outcome of \"lumping together\" Prop and Type, consider the two operations below:</p>\n<ol>\n<li>If <code>p</code> and <code>q</code> are propositions, then <code>f : p -&gt; q</code> is a mysterious blackbox that says, \"if you feed to me a proof of <code>p</code> (i.e. a term of type <code>p</code>, i.e. <code>h : p</code>), then I will output to you a proof of <code>q</code> (i.e. <code>f h : q</code>)</li>\n<li>If <code>A</code> and <code>B</code> are sets (i.e. <code>A, B : Type</code>), then <code>f : A -&gt; B</code> is a mysterious blackbox that says, \"if you give me an element of <code>A</code> (<code>x : A</code>), then I will give you an element of <code>B</code> (<code>f x : B</code>).</li>\n</ol>\n<p>In type theory, these two operations are the same thing, i.e. when you lump Prop with Type, you also get that implications are the same as functions.</p>",
        "id": 524053175,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749893910
    },
    {
        "content": "<p>as for the difference between Prop and Bool, it's actually two additional axioms (this is only a technical detail, most mathematicians don't really care about this) that you need in order to <em>prove</em> that every proposition is either equal to true or equal to false.</p>\n<ol>\n<li>The first axiom is <code>propext {a b : Prop} : (a ↔ b) → a = b</code>, in words, if two propositions are logically equivalent, then they are equal. Without this, you cannot actually prove that the proposition <code>0 = 0</code> is <strong>equal</strong> to the proposition <code>1 = 1</code>.</li>\n<li>The second axiom is <code>Classical.em (p : Prop) : p ∨ ¬p</code> (technically, this is not the axiom itself, but for our purposes here let's pretend that it is); in words, this means that a proposition is either true or false. With this extra axiom, then you can prove that a proposition <code>p</code> is either <code>= True</code> or <code>= False</code>.</li>\n</ol>",
        "id": 524053607,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749894431
    },
    {
        "content": "<p>In my mind the biggest difference between Prop and Bool is that Bool is a type (so contains terms) and Prop is a universe (so contains types). They're at different levels of the hierarchy.</p>",
        "id": 524054039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749894985
    },
    {
        "content": "<p>This discussion just led me to understand that I had so far misunderstood the meaning of propositional extentiality, confusing it with proof irrelevance.</p>\n<p>Propositional extentiality seems to say that any two equivalent propositions are actually equal, while proof irrelevance (and I don't know it Lean sees this as an axiom, or if it's somehow built into the definition of what <code>Prop</code> is) says that any two proofs of the same proposition are the same - so one is at the level of expressions of type <code>Prop</code>, while the other is at the level below of terms of some type which has type <code>Prop</code>.</p>\n<p>Now, shouldn't this in turn imply that any two proofs of any two propositions are actually the same? if <code>p</code> is a term of type <code>P</code> and <code>Q</code> is another proposition provably equivalent to <code>P</code> (but from proofs of both <code>P</code> and <code>Q</code> is is easy to prove <code>P ↔ Q</code>), then shouldn't one be able to prove <code>p : Q</code> ? (I tried it and Lean doesn't let me state the equality <code>p=q</code> from hypotheses <code>(P Q : Prop)</code>, <code>p : P</code> and <code>q :  Q</code>, complaining that <code>q</code> doesn't have the right type - something I was comfortable with until I just re-read what \"propositional extentionality\" is about.</p>\n<p>So, I'm even more confused than I already was.</p>",
        "id": 524059582,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749901580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524059582\">said</a>:</p>\n<blockquote>\n<p>(I tried it and Lean doesn't let me state the equality <code>p=q</code> from hypotheses <code>(P Q : Prop)</code>, <code>p : P</code> and <code>q :  Q</code>, complaining that <code>q</code> doesn't have the right type - something I was comfortable with until I just re-read what \"propositional extentionality\" is about.</p>\n</blockquote>\n<p>You do get <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=proof_irrel_heq#doc\">docs#proof_irrel_heq</a>, which does need a different kind of equality to make it type correct.</p>",
        "id": 524061377,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749903328
    },
    {
        "content": "<p>Yeah if you believe that there are only two propositions, the true one and the false one, then you believe that there is only one proof, namely the trivial proof. So where did all the work go? The work went into deciding whether your favourite proposition was the true one or the false one. That's where all the mathematical content moves to in this logical interpretation of mathematics.</p>",
        "id": 524064308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906659
    },
    {
        "content": "<p>Lean's model of mathematics forgets a proof once it's checked it, so it's no different to a tick in a box once it's been processed, ie no different to the trivial proof of the true statement. This is only a model of mathematics and it's very different to the one I was brought up with but it's basically still all the same stuff, just with different labels.</p>",
        "id": 524064381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906744
    },
    {
        "content": "<p>indeed, the effort is in convincing lean that <code>trivial : FLT</code> typechecks <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 524064423,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749906796
    },
    {
        "content": "<p>Right, that only type checks <em>after</em> you've found the hard maths proof, which then enables you to deduce <code>FLT = True</code>, which enables you to do the rewrite to make the trivial proof typecheck.</p>",
        "id": 524064508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749906898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524059582\">said</a>:</p>\n<blockquote>\n<p>Now, shouldn't this in turn imply that any two proofs of any two propositions are actually the same? if <code>p</code> is a term of type <code>P</code> and <code>Q</code> is another proposition provably equivalent to <code>P</code> (but from proofs of both <code>P</code> and <code>Q</code> is is easy to prove <code>P ↔ Q</code>), then shouldn't one be able to prove <code>p : Q</code> ? (I tried it and Lean doesn't let me state the equality <code>p=q</code> from hypotheses <code>(P Q : Prop)</code>, <code>p : P</code> and <code>q :  Q</code>, complaining that <code>q</code> doesn't have the right type - something I was comfortable with until I just re-read what \"propositional extentionality\" is about.</p>\n<p>So, I'm even more confused than I already was.</p>\n</blockquote>\n<p>One way of thinking about this is to stop thinking that <code>A = B</code> means \"<code>A</code> and <code>B</code> are absolutely the same thing, everywhere <code>A</code> works we can put <code>B</code>\". Equality is just a \"normal\" relation, defined in Lean, without no fundamental properties (of course it happens to have strong property, but for the system it is nothing special). Instead of saying <code>A=B</code> say <code>A</code> and <code>B</code> are <em>similar</em>, and everything becomes more clear. In particular, if <code>at: A</code> and <code>B</code> is another  type that is similar to <code>A</code> it is not enough to conclude that <code>t : B</code>. The relation that allows this (being \"absolutely the same thing\") is what is called <em>definitional equality</em>, and it's not really a mathematical notion: think about it as \"<code>A</code> and <code>B</code> are defined pressing the same keys on the keyboard\" (the situation is more complicated, but it is similar).</p>",
        "id": 524066404,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749908842
    },
    {
        "content": "<p>I'm not sure I understand much better, but at least I think I have a better mental picture. Thanks!</p>\n<p>(Still, coming from bijective combinatorics, I have a hard time accepting the idea that, once you have a proof of a theorem, it litterally becomes trivial and there is no point in looking for a second proof.)</p>",
        "id": 524069687,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749912575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"726077\">@Philippe Duchon</span> it’s probably irrelevant, but for stating equality of terms of different types, you use heq instead of eq.</p>\n<p>and no, in that context you cannot even state p : Q, it will just not typecheck</p>",
        "id": 524069704,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749912607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/stream/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524069687\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand much better, but at least I think I have a better mental picture. Thanks!</p>\n<p>(Still, coming from bijective combinatorics, I have a hard time accepting the idea that, once you have a proof of a theorem, it litterally becomes trivial and there is no point in looking for a second proof.)</p>\n</blockquote>\n<p>It's not pointless, it is of course interesting and a human may find the new proof much better. Lean on the other hand only cares about whether a theorem is provable, and this clearly does not depend on the proof. Note that I love formalization, but mathematics is more than using a proof assistant.</p>",
        "id": 524071615,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749914652
    },
    {
        "content": "<p>Indeed my mention of <code>trivial : FLT</code> type checking was mostly tongue in cheek. you can do something like it, it gives a bit of intuition of how types behave, but it would look <em>not quite</em> the same</p>",
        "id": 524072675,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1749915948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524069687\">said</a>:</p>\n<blockquote>\n<p>(Still, coming from bijective combinatorics, I have a hard time accepting the idea that, once you have a proof of a theorem, it litterally becomes trivial and there is no point in looking for a second proof.)</p>\n</blockquote>\n<p>You shouldn't equate <strong>pragmatical/practical</strong> formalization decisions with \"how\" mathematics \"should\" be done</p>",
        "id": 524075619,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749919581
    },
    {
        "content": "<p>Thanks everyone for such detailed answers; this is all very helpful and enlightening! I've been playing around with some of the things mentioned above such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- this type checks!</span>\n</code></pre></div>\n<p>and I think I have a clearer grasp of what <code>Prop</code> is now.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524064423\">said</a>:</p>\n<blockquote>\n<p>indeed, the effort is in convincing lean that <code>trivial : FLT</code> typechecks <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>How would one pull the \"as long as some proof exists it typechecks\" off in Lean? Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"c1\">-- a 'simpler' version of FLT :)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">flt_proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- my proof is too long for zulip chat :(</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"sd\">/--</span>\n<span class=\"sd\">type mismatch</span>\n<span class=\"sd\">  trivial</span>\n<span class=\"sd\">has type</span>\n<span class=\"sd\">  True : Prop</span>\n<span class=\"sd\">but is expected to have type</span>\n<span class=\"sd\">  FLT : Prop</span>\n<span class=\"sd\">-/</span>\n</code></pre></div>",
        "id": 524076323,
        "sender_full_name": "Sam",
        "timestamp": 1749920600
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"c1\">-- a 'simpler' version of FLT :)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">flt_proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- my proof is too long for zulip chat :(</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eq_true</span><span class=\"w\"> </span><span class=\"n\">flt_proof</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 524076383,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749920665
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"c1\">-- a 'simpler' version of FLT :)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">flt_proof</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- my proof is too long for zulip chat :(</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">propext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">trivial</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">flt_proof</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">flt_eq_true</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I've made the connection to <code>propext</code> more explicit</p>",
        "id": 524076668,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749920997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928928\">@Sam</span> for another analogy, it is known that Lean is consistent with the addition of the following axiom:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">iForgotTheName</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>i.e. two types are equal if they have the same cardinality. Under this axiom, it would make <code>Nat = Int</code> provable. So as of now, without this axiom, the proposition <code>Nat = Int</code> is actually undecidable.</p>",
        "id": 524076726,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749921086
    },
    {
        "content": "<p>I think that's some version of univalence without the computation since all equalities are equal</p>",
        "id": 524076746,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749921106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524076726\">said</a>:</p>\n<blockquote>\n<p>Under this axiom, it would make <code>Nat = Int</code> provable. So as of now, without this axiom, the proposition <code>Nat = Int</code> is actually undecidable.</p>\n</blockquote>\n<p>But mathematically the two <em>sets</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> aren't equal - so why would this be desirable (or even \"correct\")?; Am I missing some fine distinction between what <code>=</code> means in lean and what <code>=</code> means in math?</p>",
        "id": 524078581,
        "sender_full_name": "Sam",
        "timestamp": 1749923308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928928\">Sam</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524078581\">said</a>:</p>\n<blockquote>\n<p>Am I missing some fine distinction between what <code>=</code> means in lean and what <code>=</code> means in math?</p>\n</blockquote>\n<p>Yes, this is the point <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> and I are trying to make. It's better to think of <code>=</code> in Lean to mean \"similar\".</p>\n<p>The mathematical analogy breaks down here because in maths, \"sets\" are always subset of a larger \"universe\", but in Lean, each type is its <strong>own universe</strong>. There's nothing outside Nat, because Nat is everything that there is, from the perspective of terms of Nat.</p>",
        "id": 524078702,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923468
    },
    {
        "content": "<p>What <code>=</code> means in Lean is more a syntactical thing. <code>=</code> is there for you to rewrite things with.</p>",
        "id": 524078729,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923501
    },
    {
        "content": "<p>the identity <code>x + y = y + x</code> mean that in any expression containing <code>x + y</code>, you can rewrite it using <code>y + x</code>.</p>",
        "id": 524078741,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923521
    },
    {
        "content": "<p>After you proved that <code>x + y = y + x</code>, they're still only \"weakly equal\", in that the proof is <em>still</em> not rfl!</p>",
        "id": 524078754,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923545
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails of course</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails!!</span>\n</code></pre></div>",
        "id": 524078819,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923598
    },
    {
        "content": "<p>Try to fit this example into your mental model of equality.</p>",
        "id": 524078827,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923604
    },
    {
        "content": "<p>This is maybe a little too much. When doing maths equality has the usual meaning, and you can substitute everywhere. But \"having type A\" is not a mathematical property (is not a Prop), so you cannot substitute equal things</p>",
        "id": 524078845,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749923622
    },
    {
        "content": "<p>propositions are also not mathematical objects (in the usual formulation)</p>",
        "id": 524078873,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923651
    },
    {
        "content": "<p>so you can't even say that two propositions are equal</p>",
        "id": 524078878,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923660
    },
    {
        "content": "<p>There are quirks (called dependent type hell), but you ignore those at the beginning.</p>",
        "id": 524078888,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749923668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524078878\">said</a>:</p>\n<blockquote>\n<p>so you can't even say that two propositions are equal</p>\n</blockquote>\n<p>Yes, exactly. When you start doing stuff like that you stopped doing maths and type theory becomes much more relevant (same for equality of proofs)</p>",
        "id": 524078956,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749923718
    },
    {
        "content": "<p>Another good example for building your mental model is provable subsingletons vs. actual subsingletons (sorry I'll elaborate on this later)</p>",
        "id": 524079071,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749923843
    },
    {
        "content": "<p>My suggestion of thinking equality as being similar was only in the case you want to understand the details. If your goal is doing math in the usual sense just ignore all this stuff.</p>",
        "id": 524079072,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749923844
    },
    {
        "content": "<blockquote>\n<p>When I'm teaching lean I don't teach the existence of these universes, they're basically only there because the type theory foundations demand it.</p>\n</blockquote>\n<p>It's not special to type theory though. You have a distinction between sets and proper classes in set theory too, and you can have more levels as well.</p>",
        "id": 524079764,
        "sender_full_name": "suhr",
        "timestamp": 1749924572
    },
    {
        "content": "<p>This is pretty interesting (and yes, I was also joking when I wrote that looking for a new proof of something was pointless).</p>\n<p>If I may ask - what's the reason for having <code>propext</code> as an axiom? I get the point for proof irrelevance (since proofs of the same proposition are equal, they cannot carry information and you cannot \"hide\" something in the proof), but I don't see how this one can be useful. I suppose it's a type-theoretic reason that I won't be able to understand though.</p>",
        "id": 524082839,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749928242
    },
    {
        "content": "<p>You get <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quotient.exact#doc\">docs#Quotient.exact</a> as a consequence</p>",
        "id": 524082871,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749928297
    },
    {
        "content": "<p>OK, that's convincing enough.</p>",
        "id": 524082926,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749928378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524046644\">said</a>:</p>\n<blockquote>\n<p>The fact that Prop has type Type is something that I've always found misleading and I don't think it has any mathematical meaning (it does allow our definition of subset to work but I regard this as an implementation detail).</p>\n</blockquote>\n<p>What exactly would constitute 'mathematical meaning' in this context in your mind? Classically, the fact that <code>Prop</code> has type <code>Type</code> is essentially the easy but I would argue still important fact that $2$ is smaller than the first inaccessible cardinal.</p>",
        "id": 524083889,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749929625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928928\">Sam</span> <a href=\"#narrow/stream/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524078581\">said</a>:</p>\n<blockquote>\n<p>But mathematically the two <em>sets</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> aren't equal - so why would this be desirable (or even \"correct\")?; Am I missing some fine distinction between what <code>=</code> means in lean and what <code>=</code> means in math?</p>\n</blockquote>\n<p>Are you absolutely sure about this? What is the definition of the set of naturals? And what is the definition of the set of integers? Obviously it is not mathematically meaningful to ask if those two sets happen to be equal. But from a foundational set-theoretic viewpoint it is meaningful. Did you really ever check that it's not true that they're equal? Can you see that this is not a mathematical question, it is an irrelevant question about the underlying wiring? Why then are you not happy to accept the idea that whether FLT is <em>equal</em> to 2+2=4 is also a mathematically irrelevant question and that its answer just depends on the wiring of the foundations? </p>\n<p>To a mathematician, equality of terms is meaningful but equality of types and props and proofs is not mathematics, this is all about how mathematics is encoded in your foundational system. I would encourage you to examine your confident claim that the naturals and the integers were definitely not equal in set theory.</p>",
        "id": 524083916,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749929656
    },
    {
        "content": "<p>I would say that equality of terms has the same meaning in lean as it does in regular mathematics but equality of Props is not a mathematically meaningful question and that Lean's opinion on the matter should not be taken too seriously. If you asked a mathematician whether two props were equal they would probably complain that the question is meaningless. The only reason that lean attaches a meaning to it is that this is the very nature of a foundational system -- it enables you to ask weird questions and then the answers will not shed any light into mathematics.</p>",
        "id": 524084078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749929843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"928928\">@Sam</span> (in the same vein), here's a fun \"mathematical\" fact: the ordered pair (0, 1) is actually equal to the set {1, 2} in ZFC set theory!</p>",
        "id": 524084478,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749930456
    },
    {
        "content": "<p>Do the sets of naturals and integers even each have a single, agreed-upon definition in set theory? I mean, any number of different \"definitions\" could be used (including some where the two sets are defined the same way, provided one doesn't expect \"the 12 of naturals\" to be the same element as \"the 12 of integers - for arbitrary values of 12, of course). So the question is meaningful from a set-theoretic point of view, but the answer depends on the definitions used.</p>\n<p>(I mean, I vaguely recall from my courses some years ago, some \"definition\" of the naturals from the ZFC axioms, and then the integers could be defined as equivalence classes of pairs of naturals; but surely there are other possibilities)</p>",
        "id": 524084632,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1749930703
    },
    {
        "content": "<p>That's the whole point - whether <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">(0, 1) = \\{1, 2\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">}</span></span></span></span> depends on your specific encoding of natural numbers and ordered pairs, and so isn't a meaningful question because you can just as well choose a different encoding and everything works out the same.</p>",
        "id": 524084755,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1749930879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524084632\">said</a>:</p>\n<blockquote>\n<p>Do the sets of naturals and integers even each have a single, agreed-upon definition in set theory?</p>\n</blockquote>\n<p>I think this is more-or-less Kevin's point, that the encoding can vary and the exact encoding doesn't have mathematical meaning.</p>\n<p>For example, one could construct the integers by starting from the naturals and using the even naturals for the non-negative integers and the odd naturals for the negative integers. (This is inconvenient though if you want the natural function Nat -&gt; Int to correspond to subset-of, but that's convenience rather than necessity.)</p>",
        "id": 524084760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749930887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524083916\">said</a>:</p>\n<blockquote>\n<p>Did you really ever check that it's not true that they're equal?</p>\n</blockquote>\n<p>For the record this is actually pretty easy to see using any of the standard quotient constructions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> in two different ways: (1) A quotient is always a set of disjoint sets. (2) Every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> is finite but a typical quotient construction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> will involve infinite equivalence classes.</p>",
        "id": 524084959,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749931147
    },
    {
        "content": "<p>For things like whether Nat = Int there's a weak counterpoint though, one could interpret equality in structural way, like HoTT does. Aka \"meaning as use\".</p>\n<p>But it's not a very useful interpretation, since sets/types <em>by themself</em> have very little structure. They are only meaningful together with operations on them, which make them different.</p>",
        "id": 524085284,
        "sender_full_name": "suhr",
        "timestamp": 1749931537
    },
    {
        "content": "<p>for more \"wiring\", consider the following purely set theoretical question: given an injection f : A -&gt; B, construct a set X containing A, and a bijection g : X -&gt; B that restricts to f on A.</p>\n<p>it's \"trivial\" that such a set X exists, but actually constructing it in terms of set theory will take some thought.</p>",
        "id": 524087772,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749935044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524084959\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524083916\">said</a>:</p>\n<blockquote>\n<p>Did you really ever check that it's not true that they're equal?</p>\n</blockquote>\n<p>For the record this is actually pretty easy to see using any of the standard quotient constructions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> in two different ways: (1) A quotient is always a set of disjoint sets. (2) Every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> is finite but a typical quotient construction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> will involve infinite equivalence classes.</p>\n</blockquote>\n<p>I totally agree modulo I would argue that according to Wikipedia there are no fewer than three \"standard\" constructions of ordered pairs in set theory. However my point is that once you actually <em>do</em> this calculation you also realise that what you are doing is not mathematics, but wiring.</p>",
        "id": 524087845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749935136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524087845\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524084959\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524083916\">said</a>:</p>\n<blockquote>\n<p>Did you really ever check that it's not true that they're equal?</p>\n</blockquote>\n<p>For the record this is actually pretty easy to see using any of the standard quotient constructions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> in two different ways: (1) A quotient is always a set of disjoint sets. (2) Every element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> is finite but a typical quotient construction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> will involve infinite equivalence classes.</p>\n</blockquote>\n<p>I totally agree modulo I would argue that according to Wikipedia there are no fewer than three \"standard\" constructions of ordered pairs in set theory. However my point is that once you actually <em>do</em> this calculation you also realise that what you are doing is not mathematics, but wiring.</p>\n</blockquote>\n<p>Firstly, neither of the arguments I gave depend on the choice of coding of ordered pairs, so I don't really see why you're bringing up the fact that Wikipedia contains an encyclopedic account of various set-theoretic definitions of ordered pairs that have been proposed. (Personally, if I were trying to judge what the modern 'standard' version of a construction was, I'd look in a textbook, not on Wikipedia.) My hedging had more to do with the rare cases where you do actually literally code the integers as natural numbers (such as when working in  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"sans-serif\">P</mi><mi mathvariant=\"sans-serif\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathsf{PA}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">PA</span></span></span></span></span>).</p>\n<p>Secondly, Professor Buzzard, with all due respect, I find the way you talk about this stuff toxic. You're sliding between a reasonable point (i.e., foundational implementation details don't matter for end-user mathematicians as long as they work) and a really ugly attitude (i.e., foundational implementation details are not mathematics). The only conclusion I can really draw from comments like this is that on some level you actually do think that people like me <em>are not mathematicians</em>.</p>",
        "id": 524088280,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749935805
    },
    {
        "content": "<p>James I'm sorry I'm upsetting you again; I am simply saying that the question \"does the naturals equal the integers\" in set theory depends on specific wiring and is not self-evident as the original poster seemed to be claiming. You have given a rigorous proof that they are not equal in the standard encoding and someone else has pointed out a nonstandard encoding where they are equal. I think that we're all clear that the point is now made.</p>",
        "id": 524088933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749936908
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Why did you bring up the definitions of ordered pairs listed on Wikipedia? What rhetorical purpose did it serve in this conversation? You said</p>\n<blockquote>\n<p>I totally agree modulo I would argue that according to Wikipedia there are no fewer than three \"standard\" constructions of ordered pairs in set theory. </p>\n</blockquote>\n<p>but how does that addendum actually modify my point? I said 'any of the standard quotient constructions' not '<em>the</em> standard quotient construction.'</p>",
        "id": 524089065,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749937084
    },
    {
        "content": "<p>You're apologetic now, but my objection isn't to how you talk when you're being apologetic; it's to how you talk when you're being dismissive.</p>",
        "id": 524089087,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749937128
    },
    {
        "content": "<p>The observation demonstrates the point that there is not even a \"canonical\" set representing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> because there is not a \"canonical\" way to implement ordered pairs within set theory. I think that this conversation demonstrates really well that the question \"does <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}=\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>?\" is really a much stranger question than one might naively imagine in set theory, which I think is at least some evidence as to why it might also be a strange question in type theory.</p>",
        "id": 524089219,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749937357
    },
    {
        "content": "<p>And in fact in Lean's type theory, <code>ℕ = ℤ</code> is independent of the axioms.</p>",
        "id": 524089253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749937413
    },
    {
        "content": "<p>But when a mathematician comes here and says \"how can this be a weird question in type theory, it's clearly false in set theory\" we're seeing above that the actual answer is \"well actually it can be proved to be false under some of the usual assumptions in set theory but actually the proof is pretty weird and not at all what we would expect\", we expect a proof of the form \"-1 is an integer but not a natural\" but your proof is nothing of the sort.</p>",
        "id": 524089300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1749937519
    },
    {
        "content": "<p>It's actually quite funny that you would bring up definitions of ordered pairs given the fact that just a few days ago I wrote <a href=\"https://mathoverflow.net/a/496074/83901\">a MathOverflow answer</a> in which I argued that things like set-theoretic codings of ordered pairs have more mathematical content than people seem to think.</p>",
        "id": 524089425,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749937765
    },
    {
        "content": "<p>I think that the main point here is that <code>ℕ = ℤ</code> is more subtle than what most people think, and probably 90% of mathematician don't care about the real meaning. But let me stress that this is <em>not</em> because it is bad mathematics, just because it is very specific: I am sure that 90% of mathematicians don't care about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic modular forms either, but Lean makes it very simple to play with <code>ℕ = ℤ</code> and (unfortunately...) very difficult to play with modular forms. So the point is: if you never cared before you probably should not care now that you use Lean.</p>\n<p>Having said that, I think that there has been a confusion because someone else mentioned pairs and <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> explained why <code>ℕ ≠ ℤ</code> in usual constructions in set theory more or less at the same moment (online communication is always a mess...).</p>",
        "id": 524089710,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1749938258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524089425\">said</a>:</p>\n<blockquote>\n<p>It's actually quite funny that you would bring up definitions of ordered pairs given the fact that just a few days ago I wrote <a href=\"https://mathoverflow.net/a/496074/83901\">a MathOverflow answer</a> in which I argued that things like set-theoretic codings of ordered pairs have more mathematical content than people seem to think.</p>\n</blockquote>\n<p>that's an interesting read. actually just yesterday I was privately talking about the other way in the context of algebraic geometry: if K is an algebraically closed field, then the <strong>unordered pair</strong> {x, y} can be encoded as the <strong>ordred pair</strong> (x+y,  xy)!</p>",
        "id": 524089855,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749938459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524089855\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524089425\">said</a>:</p>\n<blockquote>\n<p>It's actually quite funny that you would bring up definitions of ordered pairs given the fact that just a few days ago I wrote <a href=\"https://mathoverflow.net/a/496074/83901\">a MathOverflow answer</a> in which I argued that things like set-theoretic codings of ordered pairs have more mathematical content than people seem to think.</p>\n</blockquote>\n<p>that's an interesting read. actually just yesterday I was privately talking about the other way in the context of algebraic geometry: if K is an algebraically closed field, then the <strong>unordered pair</strong> {x, y} can be encoded as the <strong>ordred pair</strong> (x+y,  xy)!</p>\n</blockquote>\n<p>Thank you. Issues like this show up in model theory a fair amount, actually. They have to do with 'elimination of imaginaries,' which is basically about when you have definable injections from quotient sorts into non-quotient sorts.</p>",
        "id": 524090193,
        "sender_full_name": "James E Hanson",
        "timestamp": 1749938998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Prop.2C.20Sort.2C.20and.20Type/near/524089300\">said</a>:</p>\n<blockquote>\n<p>we expect a proof of the form \"-1 is an integer but not a natural\" but your proof is nothing of the sort.</p>\n</blockquote>\n<p>Right, when I wrote my statement above I was mainly thinking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn><mo mathvariant=\"normal\">∉</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">-1 \\notin \\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">∈</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>⊊</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\N \\subsetneq \\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8249em;vertical-align:-0.136em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel amsrm\">⊊</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>. Thanks for the above proofs and additional context!</p>",
        "id": 524345126,
        "sender_full_name": "Sam",
        "timestamp": 1750114828
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn><mo mathvariant=\"normal\">∉</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">-1 \\notin \\N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord\"><span class=\"mrel\">∈</span></span><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"llap\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mord\">/</span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> is really a proof that they are not isomorphic <em>as semi-rings</em>, which you can formalize in lean virtually identically as on paper</p>",
        "id": 524402009,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1750150240
    }
]