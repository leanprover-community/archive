[
    {
        "content": "<p>Where do I find a good explanation for termination checking?<br>\nI also tried to search for code on github that I could shamelessly adapt/copy but was not successful.</p>\n<p>So far I know a bit of functional programming, played the Natural Numbers game, and a long time ago proved some things in Isabelle (so what I want to say is: I have no experience).</p>\n<p>What I generally would like to do is prove the termination of my function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],[])</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,[])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n  <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>What I tried so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span> <span class=\"bp\">+</span> <span class=\"n\">y.length</span>\n</code></pre></div>\n<p>but it complains about the <code>x==y</code> case.<br>\nI guess the next step is to add <code>decreasing_by</code> but I haven't figured out the syntax or found a good tutorial for what I need to do next.</p>\n<p>PS: Is there a better way for the case matching instead of constructing the pair x,y ?</p>",
        "id": 382229875,
        "sender_full_name": "Philipp",
        "timestamp": 1691272273
    },
    {
        "content": "<p>You can directly <code>match x', y' with</code>.</p>",
        "id": 382237018,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277342
    },
    {
        "content": "<p>You might like to look at the PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/6117\">#6117</a>, which starts the development of Levenshtein distances. (You could review it! :-)</p>",
        "id": 382237162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277458
    },
    {
        "content": "<p><code>termination_by levenshtein x y _ =&gt; x.length + y.length</code> is the right thing to do.</p>",
        "id": 382237320,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277580
    },
    {
        "content": "<p>The error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">termination</span><span class=\"o\">,</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">:</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"k\">have</span><span class=\"bp\">`-</span><span class=\"n\">expressions</span> <span class=\"n\">to</span> <span class=\"n\">prove</span> <span class=\"n\">the</span> <span class=\"n\">remaining</span> <span class=\"n\">goals</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">termination_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">a</span> <span class=\"n\">different</span> <span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">relation</span>\n  <span class=\"bp\">-</span> <span class=\"n\">Use</span> <span class=\"bp\">`</span><span class=\"n\">decreasing_by</span><span class=\"bp\">`</span> <span class=\"n\">to</span> <span class=\"n\">specify</span> <span class=\"n\">your</span> <span class=\"n\">own</span> <span class=\"n\">tactic</span> <span class=\"n\">for</span> <span class=\"n\">discharging</span> <span class=\"n\">this</span> <span class=\"n\">kind</span> <span class=\"n\">of</span> <span class=\"n\">goal</span>\n<span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">x'y'</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"n\">BEq</span> <span class=\"n\">α</span>\n<span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span>\n<span class=\"n\">ys</span><span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span>\n<span class=\"n\">h</span><span class=\"bp\">✝</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">List.length</span> <span class=\"n\">xs</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">ys</span> <span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"n\">x'</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">y'</span>\n</code></pre></div>\n<p>tells you what is missing.</p>",
        "id": 382237333,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277596
    },
    {
        "content": "<p>You need to use <code>have</code> to show Lean the proof of decreasing-ness.</p>",
        "id": 382237401,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277624
    },
    {
        "content": "<p>Notice however that the way you have structured the proof there is no connection in the context between <code>xs</code> and <code>x'</code> anymore (similarly for <code>ys</code>), and so this goal is not provable. You will need to restructure the proof to allow this.</p>",
        "id": 382237464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277676
    },
    {
        "content": "<p>Hopefully that is helpful --- and please ask again if you'd like further hints on that restructuring!</p>",
        "id": 382237472,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691277692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638732\">Philipp</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382229875\">said</a>:</p>\n<blockquote>\n<p>Where do I find a good explanation for termination checking?<br>\nI also tried to search for code on github that I could shamelessly adapt/copy but was not successful.</p>\n<p>So far I know a bit of functional programming, played the Natural Numbers game, and a long time ago proved some things in Isabelle (so what I want to say is: I have no experience).</p>\n<p>What I generally would like to do is prove the termination of my function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],[])</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,[])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n  <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>What I tried so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span> <span class=\"bp\">+</span> <span class=\"n\">y.length</span>\n</code></pre></div>\n<p>but it complains about the <code>x==y</code> case.<br>\nI guess the next step is to add <code>decreasing_by</code> but I haven't figured out the syntax or found a good tutorial for what I need to do next.</p>\n<p>PS: Is there a better way for the case matching instead of constructing the pair x,y ?</p>\n</blockquote>\n<p>Your termination hint makes sense, the only issue is the way you matched on your lists: By writing <code>match (x',y'</code>) with ...`, you match on the tuple constructed by the two lists, before deconstructing it by pattern-matching, this gives lean trouble as to how to prove termination. What you should do instead is match on them separately, all you need to do for that is to remove the parenthesis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span><span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span>\n      <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.length</span><span class=\"bp\">+</span> <span class=\"n\">ys.length</span>\n</code></pre></div>\n<p>This code should work</p>",
        "id": 382293724,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691308995
    },
    {
        "content": "<p>You could also keep the match on tuples, but then you'd need to</p>\n<ol>\n<li>add the equality hypothesis to your match by writing <code>match h : (x',y') with ...</code></li>\n<li>prove all proofs of well-foundedness that the termination-checker wouldn't manage to prove by itself<br>\nHere is a version of your code that matches on tuples and proves termination:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],[])</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,[])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"n\">xs</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">ys</span> <span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"n\">x'</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.add_lt_add</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_succ_self</span> <span class=\"n\">_</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"n\">xs</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"n\">x'</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.add_lt_add_right</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_succ_self</span> <span class=\"n\">_</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">List.length</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">ys</span> <span class=\"bp\">&lt;</span> <span class=\"n\">List.length</span> <span class=\"n\">x'</span> <span class=\"bp\">+</span> <span class=\"n\">List.length</span> <span class=\"n\">y'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Nat.add_lt_add_left</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Nat.lt_succ_self</span> <span class=\"n\">_</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span>\n      <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.length</span><span class=\"bp\">+</span> <span class=\"n\">ys.length</span>\n</code></pre></div>",
        "id": 382295400,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691309538
    },
    {
        "content": "<p>This also works, and is cleaner IMO:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],[])</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">([],</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,[])</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span>\n      <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.length</span><span class=\"bp\">+</span> <span class=\"n\">ys.length</span>\n<span class=\"n\">decreasing_by</span> <span class=\"o\">{</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">decreasing_trivial</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 382295636,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691309626
    },
    {
        "content": "<p>Ah thanks! I didn't know how to match on multiple variables without a tuple - or rather that <code>(x, y)</code> is different from <code>x, y</code>.</p>\n<p>Could we go over another example? This one is a bit bigger unfortunately...</p>\n<p>I used levenshtein to have a distance metric for strings:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">metric</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">distance</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">levenshtein_metric</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">metric</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">distance</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">levenshtein</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>and defined BkTrees:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">BkTree</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Lean.AssocList</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)))</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n</code></pre></div>\n<p>For the size function I \"cheated\" a bit by writing my own <code>foldl</code> function - then the termination checker was fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BkTree.size</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">_</span> <span class=\"n\">ts</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"mi\">1</span> <span class=\"n\">ts</span>\n<span class=\"n\">where</span> <span class=\"n\">foldl</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Lean.AssocList</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n      <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Lean.AssocList.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n      <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">Lean.AssocList.cons</span> <span class=\"n\">_</span> <span class=\"n\">v</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">foldl</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">v.size</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>Now I'd like to prove termination for <code>contains</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BkTree.contains</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">val</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d.distance</span> <span class=\"n\">v</span> <span class=\"n\">val</span><span class=\"bp\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dist</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">cs.find</span><span class=\"bp\">?</span> <span class=\"n\">dist</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">c.contains</span> <span class=\"n\">v</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">BkTree.contains</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">t.size</span>\n<span class=\"n\">decreasing_by</span> <span class=\"o\">{</span>\n  <span class=\"n\">simp_wf</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Thanks to your tips, I have inserted <code>h</code> and <code>h2</code>, to keep the association between <code>t</code> and <code>ts</code>.<br>\nBut I don't know if the rewrite makes sense because the goal is now to show <code>size c &lt; size t</code>.</p>\n<p>Do I need a lemma that the size of BkTrees is decreasing on recursion? And how do I even show that c is a sub-tree of t?</p>",
        "id": 382399395,
        "sender_full_name": "Philipp",
        "timestamp": 1691338692
    },
    {
        "content": "<p>Now what you're asking for here is a bigger task <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <br>\nYou shouldn't need to define <code>size</code> yourself, for every inductive type <code>T</code> you define, Lean defines a function <code>sizeOf : T -&gt; Nat</code> which helps you prove wellfounded recursion, so feel free to use <code>sizeOf t</code> instead of <code>t.size</code>as your termination clue.<br>\nHowever, this doesn't solve your problem, you still need to prove something equivalent. AssocList is used in core to do some things, but it's not necessarily meant to be used by users. As such, it doesn't have many lemmas surrounding it. You'd have to prove yourself that the size of an element found in the AssocList is strictly smaller to the size of the list here.</p>",
        "id": 382412002,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691342847
    },
    {
        "content": "<p>Ok so if I show that <code>sizeOf t</code> where <code>t := BkTree _ cs</code> is the sum of sizes of the bktrees in <code>cs</code> that would suffice?</p>",
        "id": 382439392,
        "sender_full_name": "Philipp",
        "timestamp": 1691355099
    },
    {
        "content": "<p>ofc I could also just use a custom list of tuples if that's easier - I just thought that AssocList is doing what I want (except that performance wise I should probably take RBMap)</p>",
        "id": 382439565,
        "sender_full_name": "Philipp",
        "timestamp": 1691355226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638732\">@Philipp</span>, I should try to tempt to you prove the triangle inequality for Levenshtein distance, on top of the definition that is making its way towards mathlib in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6117\">#6117</a>. :-)</p>",
        "id": 382472648,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1691373425
    },
    {
        "content": "<p>Here's something that works. I am not used to proving much in lean, so I'm sure someone somewhere will have a much proper proof of all this, but at least it type-checks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"o\">(</span><span class=\"n\">AssocList</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">x'</span><span class=\"o\">,</span> <span class=\"n\">y'</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],[]</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span><span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">y.length</span>\n  <span class=\"bp\">|</span> <span class=\"n\">x</span><span class=\"o\">,[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.length</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">),(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">y</span> <span class=\"k\">then</span>\n      <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">ys</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"n\">where</span>\n  <span class=\"n\">min3</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">levenshtein</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">xs.length</span><span class=\"bp\">+</span> <span class=\"n\">ys.length</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">metric</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">distance</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">levenshtein_metric</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">metric</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">distance</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">levenshtein</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">BkTree</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">leaf</span>\n<span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">children</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">AssocList</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)))</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">BkTree.contains</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">val</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d.distance</span> <span class=\"n\">v</span> <span class=\"n\">val</span><span class=\"bp\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dist</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">cs.find</span><span class=\"bp\">?</span> <span class=\"n\">dist</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span>\n        <span class=\"n\">induction</span> <span class=\"n\">cs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">&lt;;&gt;</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AssocList.find</span><span class=\"bp\">?</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n        <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n        <span class=\"bp\">·</span> <span class=\"n\">rename_i</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span>\n          <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n          <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">tail</span> <span class=\"o\">:=</span> <span class=\"n\">tail_ih</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n      <span class=\"n\">c.contains</span> <span class=\"n\">v</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">BkTree.contains</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 382592152,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691407809
    },
    {
        "content": "<p>I think the preferred style for that would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BkTree.contains</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">val</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d.distance</span> <span class=\"n\">v</span> <span class=\"n\">val</span><span class=\"bp\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dist</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">cs.find</span><span class=\"bp\">?</span> <span class=\"n\">dist</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span>\n        <span class=\"n\">induction</span> <span class=\"n\">cs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AssocList.find</span><span class=\"bp\">?</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n        <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n        <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n          <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">tail</span> <span class=\"o\">:=</span> <span class=\"n\">tail_ih</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n      <span class=\"n\">c.contains</span> <span class=\"n\">v</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>since it's not clear what the <code>decreasing_by</code> is supposed to prove</p>",
        "id": 382593376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691408071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638732\">Philipp</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382439565\">said</a>:</p>\n<blockquote>\n<p>ofc I could also just use a custom list of tuples if that's easier - I just thought that AssocList is doing what I want (except that performance wise I should probably take RBMap)</p>\n</blockquote>\n<p>There are indeed some more efficient structures for what you're doing such as RBMap. However, these are not considered to be strictly positive functors, can't be used in a recursive manner in inductive types. As such, your inductive definition of <code>BkTree</code> would sadly not be accepted by lean if you used RBMap instead</p>",
        "id": 382593596,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691408121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382593376\">said</a>:</p>\n<blockquote>\n<p>I think the preferred style for that would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">BkTree.contains</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">val</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d.distance</span> <span class=\"n\">v</span> <span class=\"n\">val</span><span class=\"bp\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dist</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">cs.find</span><span class=\"bp\">?</span> <span class=\"n\">dist</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases</span> <span class=\"n\">h</span>\n        <span class=\"n\">induction</span> <span class=\"n\">cs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AssocList.find</span><span class=\"bp\">?</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n        <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n        <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h2</span>\n          <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n          <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">tail</span> <span class=\"o\">:=</span> <span class=\"n\">tail_ih</span> <span class=\"n\">h2</span>\n            <span class=\"n\">linarith</span>\n      <span class=\"n\">c.contains</span> <span class=\"n\">v</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>since it's not clear what the <code>decreasing_by</code> is supposed to prove</p>\n</blockquote>\n<p>woops, fixed, thanks</p>",
        "id": 382594258,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691408246
    },
    {
        "content": "<p>it would be better to prove a lemma about <code>AssocList.find?</code> first though rather than inlining the whole thing in a termination proof</p>",
        "id": 382594401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691408275
    },
    {
        "content": "<p>While you can't use <code>RBMap</code> in a nested inductive, you can use <code>RBNode</code>, the inductive it is defined from</p>",
        "id": 382594760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691408333
    },
    {
        "content": "<p>I believe <code>Json</code> makes use of this trick for objects</p>",
        "id": 382594888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1691408364
    },
    {
        "content": "<p>Here is a version with an inlined theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">AssocList</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">AssocList.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"n\">cs</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">induction</span> <span class=\"n\">cs</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">AssocList.find</span><span class=\"bp\">?</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rename_i</span> <span class=\"n\">key</span> <span class=\"n\">value</span> <span class=\"n\">tail</span> <span class=\"n\">tail_ih</span>\n    <span class=\"n\">split</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">linarith</span>\n    <span class=\"bp\">·</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">tail</span> <span class=\"o\">:=</span> <span class=\"n\">tail_ih</span> <span class=\"n\">h</span>\n      <span class=\"n\">linarith</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">BkTree.contains</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">BkTree</span> <span class=\"n\">β</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">leaf</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n  <span class=\"bp\">|</span> <span class=\"n\">node</span> <span class=\"n\">val</span> <span class=\"n\">cs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d.distance</span> <span class=\"n\">v</span> <span class=\"n\">val</span><span class=\"bp\">;</span>\n    <span class=\"k\">if</span> <span class=\"n\">dist</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">true</span>\n    <span class=\"k\">else</span> <span class=\"k\">match</span> <span class=\"n\">h2</span><span class=\"o\">:</span> <span class=\"n\">cs.find</span><span class=\"bp\">?</span> <span class=\"n\">dist</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">h2</span>\n      <span class=\"n\">c.contains</span> <span class=\"n\">v</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">BkTree.contains</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sizeOf</span> <span class=\"n\">t</span>\n</code></pre></div>",
        "id": 382595616,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691408520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382593596\">schrieb</a>:</p>\n<blockquote>\n<p>As such, your inductive definition of <code>BkTree</code> would sadly not be accepted by lean if you used RBMap instead</p>\n</blockquote>\n<p>Oh wow that's sad :(</p>",
        "id": 382718661,
        "sender_full_name": "Philipp",
        "timestamp": 1691430943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382595616\">schrieb</a>:</p>\n<blockquote>\n<p>Here is a version with an inlined theorem:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">AssocList</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">AssocList.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"n\">cs</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Should such a theorem be added to the AssocList then? Or does that not make sense because AssocList should not be used outside of the Lean core?</p>",
        "id": 382719155,
        "sender_full_name": "Philipp",
        "timestamp": 1691431071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638732\">Philipp</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382719155\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"432410\">Arthur Adjedj</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382595616\">schrieb</a>:</p>\n<blockquote>\n<p>Here is a version with an inlined theorem:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">BEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">SizeOf</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">cs</span> <span class=\"o\">:</span> <span class=\"n\">AssocList</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">}</span> <span class=\"o\">:</span>  <span class=\"n\">AssocList.find</span><span class=\"bp\">?</span> <span class=\"n\">d</span> <span class=\"n\">cs</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">sizeOf</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">sizeOf</span> <span class=\"n\">cs</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n<span class=\"bp\">...</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Should such a theorem be added to the AssocList then? Or does that not make sense because AssocList should not be used outside of the Lean core?</p>\n</blockquote>\n<p>I don't know what the policy is in regards to such PRs, sorry.</p>",
        "id": 382739713,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1691436286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/113489-new-members/topic/Termination.20checking.20for.20dummies/near/382472648\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"638732\">Philipp</span>, I should try to tempt to you prove the triangle inequality for Levenshtein distance, on top of the definition that is making its way towards mathlib in <a href=\"https://github.com/leanprover-community/mathlib4/pull/6117\">#6117</a>. :-)</p>\n</blockquote>\n<p>I can try that. Unfortunately however, I can't use mathlib due to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">toolchain</span> <span class=\"bp\">'</span><span class=\"n\">leanprover</span><span class=\"bp\">/</span><span class=\"n\">lean4</span><span class=\"o\">:</span><span class=\"n\">nightly</span><span class=\"bp\">-</span><span class=\"mi\">2023</span><span class=\"bp\">-</span><span class=\"mi\">08</span><span class=\"bp\">-</span><span class=\"mi\">05</span><span class=\"bp\">'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">the</span> <span class=\"n\">binary</span> <span class=\"bp\">`</span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"bp\">\\</span><span class=\"n\">Users</span><span class=\"bp\">\\</span><span class=\"n\">Philipp</span><span class=\"bp\">\\.</span><span class=\"n\">elan</span><span class=\"bp\">\\</span><span class=\"n\">toolchains</span><span class=\"bp\">\\</span><span class=\"n\">leanprover</span><span class=\"c1\">--lean4---nightly-2023-08-05\\bin\\lean.exe`</span>\n</code></pre></div>",
        "id": 382743927,
        "sender_full_name": "Philipp",
        "timestamp": 1691437608
    }
]