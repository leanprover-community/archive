[
    {
        "content": "<p>Hi, Im new here so apologies if I make any faux pas.</p>\n<p>I'm currently working on my masters project in Lean 3 and really enjoying it but struggling to make arguments regarding infinite sets and intersections? I think? and was wondering if you guys could help any?<br>\nFor background I'm encoding logic on language semantics, I have states</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">state</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">string</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>and expressions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">expression</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">state</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℕ</span>\n</code></pre></div>\n<p>I want to encode the idea of the free variables of the expression (ie. the strings that if they change then the expression changes.<br>\nI came up with this encoding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">expression.Free</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">):</span> <span class=\"n\">set</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"n\">σ</span> <span class=\"bp\">≠</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">v</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>ie. the set of strings such that the outcome of the expression with some state will be changed by the value of that string changing. (<code>state{var ↦ val} </code>) simply maps that variable to the value and every other variable to the states value for that variable.</p>\n<p>I want to prove the main characteristic I want free variables to have which is that if they are all the same for 2 states, then the expression evaluated at those states will be the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">for_all_free_expression</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">σ'</span><span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">e.Free</span><span class=\"o\">,</span> <span class=\"n\">σ</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">σ'</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"n\">e</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"n\">σ'</span>\n</code></pre></div>\n<p>Which I believe is a  true result, and sort of is the fundamental property I'd like <code>Free</code> to have!</p>\n<p>I have so far been unable to make any progress on this as all the arguments I can come up with require reasoning over the set of strings and I don't know how to do that sort of argument in Lean.</p>\n<p>For example, one argument I tried is to instead encode the free variables as the intersection of all the sets with the property that if the variables are all the same, then the expressions are the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">expression.FreeProp</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">):</span> <span class=\"n\">set</span> <span class=\"n\">string</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"n\">σ'</span><span class=\"o\">:</span> <span class=\"n\">state</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">σ</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">σ'</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">e</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">e</span> <span class=\"n\">σ'</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">expression.Free</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">):</span> <span class=\"n\">set</span> <span class=\"n\">string</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">string</span><span class=\"o\">,</span> <span class=\"n\">expression.FreeProp</span> <span class=\"n\">e</span> <span class=\"n\">F</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span>\n</code></pre></div>\n<p>I was able to show these two encodings are equivalent and then the problem reduces to showing that the <code>expression.Free</code> has <code>FreeProp</code>! On paper I can make this argument by showing that the intersection of any two sets that satisfy the <code>FreeProp</code> for some <code>e</code> will satisfy <code>FreeProp</code> itself.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">expression.FreeProp.intersection</span> <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">string</span><span class=\"o\">}</span>  <span class=\"o\">:</span>\n  <span class=\"n\">e.FreeProp</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">e.FreeProp</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">e.FreeProp</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Then expanding this for the set of all infinite sets? (Which I am aware is a bit of a shaky argument)<br>\nHowever, for this argument I wanted to construct some intermediate state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₃</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">σ₂</span><span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"k\">then</span> <span class=\"n\">σ₁</span> <span class=\"n\">s</span> <span class=\"k\">else</span> <span class=\"n\">σ₃</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Which runs into a problem with decidability? I can't seem to find much helpful online.<br>\nI keep running into similar problems whichever way I try argue this where decidability and infinite sets.<br>\nIf anyone could point me in the right direction for this sort of thing? Or let me know if I am barking up the wrong tree.<br>\nThanks</p>",
        "id": 340166476,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678209573
    },
    {
        "content": "<p>Welcome to the Zulip chat, congratulations on nicely formatting your first post :)</p>\n<p>To start with your last question, you can use the tactic <code>classical</code> before the definition of <code>σ₂</code> to allow you to arbitrary case distinctions in <code>if</code>.</p>",
        "id": 340167494,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678209838
    },
    {
        "content": "<p>I would also suggest using <code>let</code> instead of <code>have</code>, since <code>have</code> forgets the body of the definition. So the following (untested) should get you going again:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">σ₁</span> <span class=\"n\">σ₃</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">σ₂</span><span class=\"o\">:</span> <span class=\"n\">state</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"k\">then</span> <span class=\"n\">σ₁</span> <span class=\"n\">s</span> <span class=\"k\">else</span> <span class=\"n\">σ₃</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 340167785,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678209910
    },
    {
        "content": "<p>Thank you for the welcome! Thats awesome, thank you that's has definitely got me unstuck at least for now!</p>",
        "id": 340169649,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678210361
    },
    {
        "content": "<p>I've now reached a problem with formulating an argument about infinite intersections. <br>\nI have successfully argued for binary intersections:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">expression.FreeProp.intersection</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">expression</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">string</span><span class=\"o\">}:</span>\n  <span class=\"n\">e.FreeProp</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">e.FreeProp</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">e.FreeProp</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">∩</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>And now want to argue that the infinite intersection of all sets that satisfy this.<br>\nAny idea how I could make such an argument? Is there any topology code that I can look at as that that may cover similar arguments?</p>",
        "id": 340332620,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678274641
    },
    {
        "content": "<p><code>src/topology/</code> contains boatloads of topology <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 340332932,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1678274740
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 340333255,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678274817
    },
    {
        "content": "<p>Is that in the lean3 GitHub repo?</p>",
        "id": 340333301,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678274833
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"597231\">Alfie Richards</span> <a href=\"#narrow/stream/113489-new-members/topic/Arguments.20with.20infinite.20sets.20and.20decidability/near/340333301\">said</a>:</p>\n<blockquote>\n<p>Is that in the lean3 GitHub repo?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/tree/master/src/topology\">https://github.com/leanprover-community/mathlib/tree/master/src/topology</a></p>",
        "id": 340333511,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1678274892
    },
    {
        "content": "<p>For finite sets you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.cons_induction\">docs#finset.cons_induction</a></p>",
        "id": 340395140,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678289742
    },
    {
        "content": "<p>Is there an equivalent of <code>set.sInter</code> for <code>finset (finset X)</code> or a way to easily get from a <code>finset (finset X))</code> to <code>set (set X))</code>?</p>",
        "id": 341106344,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678535639
    },
    {
        "content": "<p>Something like <code>↑(s.map ⟨coe, finset.coe_injective⟩)</code> should work</p>",
        "id": 341107311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678535926
    },
    {
        "content": "<p>Or <code>coe '' coe s</code></p>",
        "id": 341107441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678535962
    },
    {
        "content": "<p>That worked perfectly thank you, unfortunately I had so many headaches going back and forth between <code>finset</code> and <code>set</code>  I decided to use <code>set</code> everywhere and keep around the <code>set.finite</code> hypotheses instead. Im pretty much there except I need to show <code>B.finite → 𝒫B.finite</code>, any ideas?</p>",
        "id": 341343023,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678660723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"597231\">Alfie Richards</span> <a href=\"#narrow/stream/113489-new-members/topic/Arguments.20with.20infinite.20sets.20and.20decidability/near/341106344\">said</a>:</p>\n<blockquote>\n<p>Is there an equivalent of <code>set.sInter</code> for <code>finset (finset X)</code></p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.inf\">docs#finset.inf</a> should work</p>",
        "id": 341343100,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678660787
    },
    {
        "content": "<p>Did <code>library_search</code> find anything?</p>",
        "id": 341343186,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678660829
    },
    {
        "content": "<p>No, and Ive had a look through the mathlib documentation and soundly find anything along those lines. though its possible I missed it because I find them a bit hard to read</p>",
        "id": 341343237,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678660876
    },
    {
        "content": "<p>It likely just missing, though should follow trivially from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.coe_powerset\">docs#finset.coe_powerset</a></p>",
        "id": 341343250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678660905
    },
    {
        "content": "<p>Ah okay, I'll try make it as a separate lemma, thank you for your help!</p>",
        "id": 341343357,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678660971
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.of_finset\">docs#set.finite.of_finset</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.exists_finset_coe\">docs#set.finite.exists_finset_coe</a> should do the rest of the work</p>",
        "id": 341343568,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678661147
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.powerset\">docs#set.finite.powerset</a></p>",
        "id": 341349783,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678666725
    },
    {
        "content": "<p>Oh well, I have it in a PR somewhere and it mustn't have been merged yet.</p>",
        "id": 341349813,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678666757
    },
    {
        "content": "<p>I have wrestled with this a bit but am still having issues with the types.<br>\nThis is what I have currently</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite_powerset</span> <span class=\"o\">(</span><span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">string</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B.finite</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">hA</span> <span class=\"o\">:=</span> <span class=\"n\">set.finite.exists_finset_coe</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">hB</span> <span class=\"o\">:=</span> <span class=\"n\">finset.coe_powerset</span> <span class=\"o\">(</span><span class=\"n\">hA_w</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hA_h</span> <span class=\"n\">at</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n\n  <span class=\"n\">exact</span> <span class=\"n\">set.finite.of_finset</span> <span class=\"o\">(</span><span class=\"n\">hA_w.powerset</span><span class=\"o\">)</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>However, I'm having issues with it wanting to have a <code>finset (set string)</code> rather than <code>finset (finset string)</code>.<br>\nI did try the map you suggested earlier but it spawned a bunch of other goals that I couldn't solve.<br>\nIs there anywhere I can read about <code>coe</code> or what's going on here?</p>",
        "id": 341415721,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678701795
    },
    {
        "content": "<p>Ooh, could I see the PR? Is it public?</p>",
        "id": 341415845,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678701826
    },
    {
        "content": "<p>Yeah, I just need to find it back <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 341417158,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678702190
    },
    {
        "content": "<p>Thank you so much for your help</p>",
        "id": 341417258,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678702211
    },
    {
        "content": "<p><code>git log -S 'lemma powerset' --all ^master --author=Yael</code> only has three results</p>",
        "id": 341417420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702268
    },
    {
        "content": "<p>Can you search through PR-less branches as well?</p>",
        "id": 341417491,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678702294
    },
    {
        "content": "<p>That's what the above does</p>",
        "id": 341417624,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702328
    },
    {
        "content": "<p>Maybe it's in a branch you never pushed?</p>",
        "id": 341417647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702336
    },
    {
        "content": "<p>In which case you need to run that on your machine</p>",
        "id": 341417676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702342
    },
    {
        "content": "<p>It's possible it's on another repo. At any rate, it's not too hard to reprove. Give me 5 minutes.</p>",
        "id": 341417767,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678702372
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">set.finite.powerset</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">s'</span><span class=\"o\">,</span> <span class=\"n\">hs'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.finite.exists_finset_coe</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">set.finite.of_finset</span> <span class=\"o\">(</span><span class=\"n\">s'.powerset.map</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_injective</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_map</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_powerset</span><span class=\"o\">,</span>\n    <span class=\"n\">function.embedding.coe_fn_mk</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hs'</span><span class=\"o\">,</span> <span class=\"n\">set.image_preimage_eq_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_powerset_iff</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">s'.filter</span> <span class=\"o\">(</span><span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_filter</span><span class=\"o\">,</span> <span class=\"n\">set.sep_mem_eq</span><span class=\"o\">,</span> <span class=\"n\">set.inter_eq_right_iff_subset</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 341419712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702918
    },
    {
        "content": "<p>I bet <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> can come up with a shorter one</p>",
        "id": 341419770,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678702926
    },
    {
        "content": "<p>The final proof is shorter, but that's because I split off a lemma (analogous to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.coe_powerset\">docs#finset.coe_powerset</a>).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.powerset</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_coe_coe_powerset</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">coe</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">s.powerset</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">powerset</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_powerset</span><span class=\"o\">,</span> <span class=\"n\">set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_powerset_iff</span><span class=\"o\">,</span> <span class=\"n\">coe_subset</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">hts</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">coe_subset.2</span> <span class=\"n\">hts</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">lift</span> <span class=\"n\">t</span> <span class=\"n\">to</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"n\">using</span> <span class=\"n\">s.finite_to_set.subset</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">coe_subset.1</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">finite.powerset</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s.powerset.finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">lift</span> <span class=\"n\">s</span> <span class=\"n\">to</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"n\">using</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finset.image_coe_coe_powerset</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">s.powerset.finite_to_set.image</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set</span>\n</code></pre></div>",
        "id": 341423350,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678703855
    },
    {
        "content": "<p>Thank you both thats great</p>",
        "id": 341424092,
        "sender_full_name": "Alfie Richards",
        "timestamp": 1678704042
    }
]