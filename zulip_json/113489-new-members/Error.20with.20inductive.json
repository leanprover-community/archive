[
    {
        "content": "<p>I'm trying to translate the following haskell code</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">MSF</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">MSF</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">unMSF</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">MSF</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>to lean. My attempt below causes an error.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">MSF</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">×</span> <span class=\"n\">MSF</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">MSF</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"o\">)</span> <span class=\"n\">arg</span> <span class=\"bp\">#</span><span class=\"mi\">5</span> <span class=\"n\">of</span> <span class=\"bp\">'</span><span class=\"n\">MSF.mk'</span> <span class=\"n\">contains</span> <span class=\"n\">a</span> <span class=\"n\">non</span> <span class=\"n\">valid</span> <span class=\"n\">occurrence</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">datatypes</span> <span class=\"n\">being</span> <span class=\"n\">declared</span>\n</code></pre></div>\n<p>Can anyone help with this error ? If I remove m from mk  it works...</p>",
        "id": 350024786,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1681498114
    },
    {
        "content": "<p>The <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/stream/270676-lean4/topic/Free.20monad\">#lean4 &gt; Free monad</a> thread sounds quite similar</p>",
        "id": 350038968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681503421
    },
    {
        "content": "<p>The quick fix is to add <code>unsafe</code>, the right fix is probably more involved. What does MSF stand for here?</p>",
        "id": 350039000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1681503436
    },
    {
        "content": "<p>MSF is not allowed because if there were such a type you could create an element of <code>Empty</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unsafe</span> <span class=\"kd\">inductive</span> <span class=\"n\">MSF</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">×</span> <span class=\"n\">MSF</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">MSF</span> <span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">mkEmptyOf</span> <span class=\"o\">:</span> <span class=\"n\">MSF</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">→</span> <span class=\"n\">Empty</span><span class=\"o\">)</span> <span class=\"n\">Unit</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">Empty</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"o\">()</span> <span class=\"o\">((),</span> <span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"n\">unsafe</span> <span class=\"kd\">def</span> <span class=\"n\">mkEmpty</span> <span class=\"o\">:</span> <span class=\"n\">Empty</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkEmptyOf</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">MSF.mk</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">()</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"o\">((),</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkEmptyOf</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I think this is basically using the omega/y-combinator trick to get an infinite loop even without an obvious recursion.</p>",
        "id": 350050064,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681507957
    },
    {
        "content": "<p>Thanks Eric and Kyle. Ok, so it seems MSF cannot safely be defined in lean4. My ideia here was to practice doing proofs, so unsafe doesn't help.</p>\n<p>MSF stands for Monadic Signal Function, and it is a recent approach to Functional Reactive Programming. The <a href=\"https://dl.acm.org/doi/10.1145/2976002.2976010\">paper</a> that introduces it is <a href=\"http://Functional%20Reactive%20Programming,%20Refactored\">here in pdf</a>. It is implemented in the dunai Haskell library, and the definition of MSF is <a href=\"https://github.com/ivanperez-keera/dunai/blob/develop/dunai/src/Data/MonadicStreamFunction/Core.hs\">here</a>.</p>\n<p>MSF is an update on Arrowised FRP, of which the prime example is Yampa, which, optimizations aside,  has as core data element <code>type SF ′ a b = DTime → a → (b, SF ′ a b)</code> which appears to work ok in lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">SF</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">×</span> <span class=\"n\">SF</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">SF</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>So the main problem appears to be the presence of the monad m.</p>\n<p>The fact that when evaluating the MSF or SF you get to generate a new MSF or SF means that you can hide state in the signal function, and it also means the behaviour of the signal function can change radically when some particular event appears. </p>\n<p>I'll keep exploring the Free Monad thread, and if nothing works, I'll just play with SF.</p>",
        "id": 350119581,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1681551105
    },
    {
        "content": "<p>I get an interesting error defining the identity SF:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">SF.id</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">SF</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">SF.id</span><span class=\"o\">))</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fail</span> <span class=\"n\">to</span> <span class=\"k\">show</span> <span class=\"n\">termination</span> <span class=\"n\">for</span>\n  <span class=\"n\">SF.id</span>\n<span class=\"k\">with</span> <span class=\"n\">errors</span>\n<span class=\"n\">structural</span> <span class=\"n\">recursion</span> <span class=\"n\">cannot</span> <span class=\"n\">be</span> <span class=\"n\">used</span>\n\n<span class=\"n\">well</span><span class=\"bp\">-</span><span class=\"n\">founded</span> <span class=\"n\">recursion</span> <span class=\"n\">cannot</span> <span class=\"n\">be</span> <span class=\"n\">used</span><span class=\"o\">,</span> <span class=\"bp\">'</span><span class=\"n\">SF.id'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">take</span> <span class=\"n\">any</span> <span class=\"o\">(</span><span class=\"n\">non</span><span class=\"bp\">-</span><span class=\"n\">fixed</span><span class=\"o\">)</span> <span class=\"n\">arguments</span>\n</code></pre></div>\n<p>But I'm not actually calling <a href=\"http://SF.id\">SF.id</a> again in the definition of the function, I'm just providing itself in the result, to be called at some later point. Since the function is not called, shouldn't this not have any issues with termination ?</p>",
        "id": 350187585,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1681575179
    },
    {
        "content": "<p>I guess this type is empty, so that's a strong reason why you can't define anything. I simplified the type a little by specializing to <code>Unit</code> since there was a termination-by I wasn't sure how to do in <code>SF'.elim</code> when you have <code>b × SF a b</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- setting a = b = Unit and simplifying</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">SF'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Float</span> <span class=\"bp\">→</span> <span class=\"n\">SF'</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">SF'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SF'.elim</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">SF'</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">SF'.equiv</span> <span class=\"o\">:</span> <span class=\"n\">SF'</span> <span class=\"bp\">≃</span> <span class=\"n\">Empty</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"n\">SF'.elim</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"n\">Empty.elim</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">x.elim</span> <span class=\"o\">:</span> <span class=\"n\">Empty</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">x.elim</span>\n</code></pre></div>",
        "id": 350197967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681580359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"583642\">@Miguel Negrão</span> I'm not very familiar with them, but maybe <code>SF</code> is better modeled as a coinductive type rather than an inductive type (it seems like an infinite stream vs a finite tree). Lean doesn't natively have these, but I believe I've heard that there are ways to simulate them regardless. I haven't read it too carefully, but <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20Efficient.20coinduction/near/298282159\">here's</a> what appears to be a previous discussion for a very similar type.</p>",
        "id": 350473052,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1681728003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> thanks for pointing me to that discussion. Indeed in that discussion they are trying to implement something similar to Yampa, which is what I was also trying to do, so I will have a look at that. Thanks !</p>",
        "id": 350567615,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1681749670
    },
    {
        "content": "<p><a href=\"http://adam.chlipala.net/cpdt/html/Coinductive.html\">this</a> page about the same issue in coq is very illuminating, regarding why it's so easy to define infinite data structures in Haskell, but one has to be very careful with that in theorem provers.</p>",
        "id": 350995293,
        "sender_full_name": "Miguel Negrão",
        "timestamp": 1681898033
    }
]