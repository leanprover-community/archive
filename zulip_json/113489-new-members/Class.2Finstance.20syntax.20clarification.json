[
    {
        "content": "<p>Could someone please clarify the differences between the following?  (I'm trying to generalize the example code in FPiL in section 5.2).</p>\n<p>I can sort of fix it but I'm not able to find a precise definition outside of seeing some examples in e.g. Prelude, and not able to find a description in the \"Type Classes\" section of TPiL:</p>\n<p>1) </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>That seems to type check but then e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>is stuck due to metavariables.</p>\n<p>2) </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>This now works</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>but I have to specify e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">applyPrim</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Arith</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"c1\">-- note the \"duplicate\" specification of Monad</span>\n</code></pre></div>\n<p>3) I think the \"correct\" way to specify this (based on e.g. Monad) is to use inheritance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>But I don't quite get the difference between this and 2) above (e.g. why the constraints on the class don't get automatically \"propagated\"). </p>\n<p>Thank you.</p>",
        "id": 471979296,
        "sender_full_name": "Tom",
        "timestamp": 1726956651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/471979296\">said</a>:</p>\n<blockquote>\n<p>1)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>That seems to type check but then e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>is stuck due to metavariables.</p>\n</blockquote>\n<p>This does not really make sense because you introduce a hypothesis on <code>m</code> before introducing <code>m</code> itself. In fact what happens (you can see it by hovering over the class to see its type) is that when Lean encounters <code>[Monad m]</code> it does not know what <code>m</code> is and therefore will automatically create a variable <code>m</code> which makes sense, because of the option <code>autoImplicit</code> (which is disabled by default in Mathlib btw). So in the end your class takes two different <code>Type → Type</code> parameters which I think was not intended.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/471979296\">said</a>:</p>\n<blockquote>\n<p>2)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>This now works</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>but I have to specify e.g.</p>\n<p><code>def applyPrim [Monad f] [Fail f] : Arith → Int → Int → f Int -- note the \"duplicate\" specification of Monad</code></p>\n</blockquote>\n<p>The meaning of this definition is that given <code>m</code> which already has a <code>Monad</code> instance you can define a <code>Fail</code> instance. In particular writing <code>[Fail f]</code> makes no sense if you don't already know <code>[Monad f]</code>. It's like writing <code>[Module R M]</code> when you don't know that <code>R</code> is a semiring for instance.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/471979296\">said</a>:</p>\n<blockquote>\n<p>3) I think the \"correct\" way to specify this (based on e.g. Monad) is to use inheritance</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>But I don't quite get the difference between this and 2) above (e.g. why the constraints on the class don't get automatically \"propagated\").</p>\n</blockquote>\n<p>Here the definition states that a <code>Fail</code> instance is given by a <code>Monad</code> instance plus the field <code>fail</code>. You could interpret it as saying that this is \"equivalent\" (it is not really but that's the idea) to writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/--</span>\n<span class=\"sd\">    Fields of the `Monad` class</span>\n<span class=\"sd\">  -/</span>\n<span class=\"w\">  </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>So when you write <code>[Fail f]</code> as an assumption you in particular assume <code>[Monad f]</code>. This is not really equivalent because when you write <code>extends Monad m</code> you explicitly states that <code>m</code> is a <code>Monad</code> which allows to use related theorems so extension is indeed the way to go.</p>",
        "id": 472021100,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1726988825
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> </p>\n<blockquote>\n<p>This does not really make sense because you introduce a hypothesis on <code>m</code> before introducing <code>m</code> itself.</p>\n</blockquote>\n<p>It made sense to me <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> .  No seriously - I assumed since the syntax allows it, it had a meaning.  I appreciate the pointer about <code>autoImplicits</code>, that seems like a good default to keep in mind!</p>\n<p>In all fairness though, putting the type class first is the \"same syntax\" as when defining an instance, e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Something</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Note that here, the hypothesis also gets introduced before introducing a, and so it's not unreasonable to assume that it would work similarly for <code>class</code>.</p>\n<p>As for 2), I see with point, but still don't fully understand one thing, so let's go with your \"math example\".  Suppose I give the definition of a Vector space over a Field F.  When discussing a vector space, I don't have have to keep saying \"and F is a field\".  I think I would try encode e.g. like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It would seem redundant to me to keep having to say e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>What's the advantage of re-specifying that each time?  The \"hypothesis\" already seems like a part of the type.  Is there a reason why Lean can't \"just\" introduce it automatically?</p>\n<p>Note that I'm only asking this about <code>class</code>es; for instances it makes perfect sense.</p>\n<p>Thanks for taking the time to help me understand!</p>",
        "id": 472072481,
        "sender_full_name": "Tom",
        "timestamp": 1727029725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472072481\">said</a>:</p>\n<blockquote>\n<p>What's the advantage of re-specifying that each time? The \"hypothesis\" already seems like a part of the type. Is there a reason why Lean can't \"just\" introduce it automatically?</p>\n</blockquote>\n<p>the first example i can think of where this is a non-trivial problem is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- how many `A T` parameters?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- should this have just [D T] or also [A T] as parameter?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test2</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 472073341,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727030414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472072481\">said</a>:</p>\n<blockquote>\n<p>In all fairness though, putting the type class first is the \"same syntax\" as when defining an instance, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">Something</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>Note that here, the hypothesis also gets introduced before introducing a, and so it's not unreasonable to assume that it would work similarly for <code>class</code>.</p>\n</blockquote>\n<p>I'm not sure what you mean here, <code>a</code> is not introduced at all. Or rather it is with <code>autoImplicit</code>, but in your first example you explicitly introduced <code>m</code> after a hypothesis, so that the hypothesis in fact does not refer to this <code>m</code> but to another one which was implicitly introduced.</p>\n<p>When it comes to vector spaces, first a vector space is a structure with two different types: a field <code>K</code> and a group <code>E</code>. So it's rather <code>VectorSpace K E</code>. I guess you might expect something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">VectorSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span>\n</code></pre></div>\n<p>But this is not supported. However I'm unfortunately not able to tell you why it is as it is.</p>",
        "id": 472074019,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1727030884
    },
    {
        "content": "<p>I think it's worth pointing out that the parameters list isn't a set, where you can add parameters in any order, but instead the exact order matters. In Lean, parameters can only ever refer to what's been defined in a <em>previous</em> parameter — this is due to the way it's using dependent type theory. (One could imagine a version of Lean where it tries to do a topological sort of the parameters in some way to get all the dependencies to be in order, but Lean doesn't do that.)</p>\n<blockquote>\n<p>What's the advantage of re-specifying that each time? The \"hypothesis\" already seems like a part of the type. Is there a reason why Lean can't \"just\" introduce it automatically?</p>\n</blockquote>\n<p>With <code>autoImplicit</code> it indeed \"just\" introduces an <em>implicit</em> parameter automatically.  If you want an explicit parameter you have to introduce it yourself.</p>",
        "id": 472075096,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727031424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> </p>\n<p>Thank you for constructing an example!  I am trying to understand it, could you please clarify the following line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- how many `Foo T` parameters?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Baz</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I assume it's a typo but just want to check.</p>\n<p><span class=\"user-mention\" data-user-id=\"703970\">@Etienne Marion</span> <br>\nThanks!  I am starting to appreciate more and more why you said you don't use <code>autoImplicit</code> in your code.  Regarding the vector space, yes, I was being sloppy for the sake of the brevity/example, thanks for the correction.</p>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <br>\nThanks for the clarification.  I didn't really think of the parameters as a set but I'm realizing that I wasn't quite cognizant of all the places where the auto implicits were being used, sort of thinking of something closer the the topo-sort idea you mention.  I think the fact Etienne mentioned that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Fail</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>actually introduces <em>two</em> variables despite the fact that they are both called <code>m</code> really threw me for a loop.</p>\n<p>I appreciate you all helping with my silly/novice questions.</p>",
        "id": 472078227,
        "sender_full_name": "Tom",
        "timestamp": 1727034156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472078227\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> </p>\n<p>Thank you for constructing an example!  I am trying to understand it, could you please clarify the following line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- how many `Foo T` parameters?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test1</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Baz</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I assume it's a typo but just want to check</p>\n</blockquote>\n<p>Fixed it</p>",
        "id": 472078540,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727034421
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> </p>\n<p>I thought about your counterexample and have to admit I am still not sure why it would pose a problem.  From my meager understanding of Lean's type classes, I see the type class specification, in part, as a \"predicate\" which needs to be satisfied in order the definition to apply.  While having the \"predicate\" multiple times is redundant, it's also idempotent.</p>\n<p>Indeed, the following works for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>It also seems that if I name the instance, e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">test</span>\n</code></pre></div>\n<p>Lean already de-duplicates the instances!!, because the output is <code>fun v [inst : Add ?m.1452] [inst : Add ?m.1452] =&gt; inst.1 v v</code></p>\n<p>It would also appear that this is not an uncommon thing.  Looking, for example, at the definition of <code>Module</code> in Mathlib, it seems it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span>\n</code></pre></div>\n<p>In order to avoid repeating this incantation everywhere, a <code>variable</code> is used right after the definition.  This is similar to my observation in another thread about trying to specify a \"numeric\" type, where I had to keep re-specifying a long string of type classes.</p>",
        "id": 472558571,
        "sender_full_name": "Tom",
        "timestamp": 1727205420
    },
    {
        "content": "<p>Typeclasses are not simple constraints, and they're not idempotent. There are lots of things that can go wrong when you have duplicate instances, for example <code>[Field a] [Add a]</code> gives an incredible amount of trouble (it's a frequent source of confusion as evidenced by Zulip questions).</p>\n<p>If you want, each instance argument is like a vtable. There's no reason the different vtables passed to the two <code>Add</code> instances in your example have the same pointers.</p>",
        "id": 472560171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206101
    },
    {
        "content": "<p>Adding in missing instances without overlap can be slow. It depends on trying to synthesize instances and seeing whether they fail or not.</p>\n<p>I implemented this in the mathlib <code>variable?</code> command, which you might be interested in looking at.</p>",
        "id": 472560269,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206156
    },
    {
        "content": "<p>Thanks!  That vtable analogy is good one, it's sort of how I understand things atm.  As I mentioned, in the simple example using two <code>[Add a]</code> instances to my eyes it looked they actually go de-duplicated!</p>",
        "id": 472560560,
        "sender_full_name": "Tom",
        "timestamp": 1727206283
    },
    {
        "content": "<p>Here's <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span>'s example using <code>variable?</code>. It deduplicates the <code>A</code> instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 472560676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206330
    },
    {
        "content": "<blockquote>\n<p>As I mentioned, in the simple example using two <code>[Add a]</code> instances to my eyes it looked they actually go de-duplicated!</p>\n</blockquote>\n<p>There's no mechanism in Lean that deduplicates instances in binders though.</p>",
        "id": 472560794,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206391
    },
    {
        "content": "<p>Is the slowness partially because of the trial-and-error of a (prolog-like/backtracking) recursive instance search?  Could perhaps a solution be something Datalog-ish like which more deterministic?</p>",
        "id": 472560795,
        "sender_full_name": "Tom",
        "timestamp": 1727206393
    },
    {
        "content": "<p>All you're seeing is that the last local instance is the one that \"wins\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">def test : {a : Type} → a → [inst : Add a] → [inst : Add a] → a :=</span>\n<span class=\"cm\">fun {a} v [inst : Add a] [inst : Add a] ↦ @HAdd.hAdd a a a (@instHAdd a inst) v v</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>(The first <code>inst</code> argument is unused.)</p>\n<p>This means in the <code>[Field a] [Add a]</code> example, the second one \"wins\" for interpreting <code>+</code>, which could be completely different from the one that would have been supplied by <code>Field</code>.</p>",
        "id": 472561057,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206497
    },
    {
        "content": "<p>Thanks for the explanations.  </p>\n<p>I guess there is a mechanism for not having to repeat myself too much when writing the code by using the <code>variable</code> commands in the current file, even though that doesn't apply/is brittle to the potential users of my code.</p>",
        "id": 472561127,
        "sender_full_name": "Tom",
        "timestamp": 1727206529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472560795\">said</a>:</p>\n<blockquote>\n<p>Is the slowness partially because of [...]</p>\n</blockquote>\n<p>My understanding is that it's slow to refute the existence of an instance, because you have to consider all the many <code>instance</code>s that will try to derive an instance. You can investigate this with <code>set_option trace.Meta.synthInstance true</code> on a failing instance problem to see — there might be some interesting ones in the <code>variable?</code> test file.</p>",
        "id": 472561487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472561057\">said</a>:</p>\n<blockquote>\n<p>(The first <code>inst</code> argument is unused.)</p>\n<p>This means in the <code>[Field a] [Add a]</code> example, the second one \"wins\" for interpreting <code>+</code>, which could be completely different from the one that would have been supplied by <code>Field</code>.</p>\n</blockquote>\n<p>Ok, I see.  <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>  I guess I don't like it much because it seems brittle from a programming perspective but at least I feel I understand it now.  Thanks for taking the time to explain!</p>",
        "id": 472561632,
        "sender_full_name": "Tom",
        "timestamp": 1727206753
    },
    {
        "content": "<p>At least it's flexible and fits in the theory.</p>\n<p>What did you have in mind with the Datalog suggestion by the way? Doing bottom-up calculation of all instances? The actual full set of instances is infinite. The Lean instance synthesis algorithm does do caching, so it's sort of like a top-down Datalog query already.</p>",
        "id": 472561941,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206879
    },
    {
        "content": "<p>There are probably gains to be had if instance synthesis could \"pre-compile\" query plans, where it would try synthesizing certain instances to see if it can throw out entire subtrees.</p>",
        "id": 472562173,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727206976
    },
    {
        "content": "<p>You may be thinking \"What's the deal? Don't classes <code>extend</code> other classes? Can't we deduplicate instance implicit binders with reference to this hierarchy?\" I think there are a number of issues that make this impossible at the moment (for example, in the algebraic hierarchy, there are instances that are morally from extension but there's no <code>extends</code> recording that fact), but it would be nice if it could work one day, maybe using additional annotations users can supply to record what structure implies what structure.</p>\n<p>Sometimes people have suggested a <code>[[Cls x y z]]</code> notation to insert all the missing instance arguments. This <code>variable?</code> command is at least something in that direction.</p>",
        "id": 472562935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727207314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472561941\">said</a>:</p>\n<blockquote>\n<p>At least it's flexible and fits in the theory.</p>\n<p>What did you have in mind with the Datalog suggestion by the way? Doing bottom-up calculation of all instances? The actual full set of instances is infinite. The Lean instance synthesis algorithm does do caching, so it's sort of like a top-down Datalog query already.</p>\n</blockquote>\n<p>Sort of.  When you say \"infinite\", do you mean infinite because of type variables?  Initially,  I thought the instance dependency graph may be \"infinite\" (in the sense of e.g. having loops) but ultimately, is there not just a finite list of actual types defined in the program?  So a type class <code>Add a</code> could correspond to a \"datalog rule\" <code>Add(x) :-</code> and specific instances would be e.g. <code>Add(Int)</code>.  <br>\nI realize there additional issues here with e.g. something like <code>Foo(x, y) :- Add(x), Bar(y)</code> in the case where I want to specialize <code>Foo(Int, x)</code>, and also e.g. with <code>Monad</code> because datalog cannot natively represent higher-order predicates but it still sounds plausible.</p>\n<p>I have some other thoughts but this is probably already too speculative and taking us too far off course.</p>",
        "id": 472563882,
        "sender_full_name": "Tom",
        "timestamp": 1727207734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472562935\">said</a>:</p>\n<blockquote>\n<p>You may be thinking \"What's the deal? Don't classes <code>extend</code> other classes? Can't we deduplicate instance implicit binders with reference to this hierarchy?\" I think there are a number of issues that make this impossible at the moment (for example, in the algebraic hierarchy, there are instances that are morally from extension but there's no <code>extends</code> recording that fact), but it would be nice if it could work one day, maybe using additional annotations users can supply to record what structure implies what structure.</p>\n<p>Sometimes people have suggested a <code>[[Cls x y z]]</code> notation to insert all the missing instance arguments. This <code>variable?</code> command is at least something in that direction.</p>\n</blockquote>\n<p>Awesome, thanks!  That makes sense now.</p>\n<p>Maybe at some point I can take a crack at something like that - that sounds like exactly the sort of project which would be fun.</p>",
        "id": 472564318,
        "sender_full_name": "Tom",
        "timestamp": 1727207906
    },
    {
        "content": "<blockquote>\n<p>When you say \"infinite\", do you mean infinite because of type variables</p>\n</blockquote>\n<p>Rules like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instFintypeProd#doc\">docs#instFintypeProd</a> make the set of instances infinite.</p>",
        "id": 472564963,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727208147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.2Finstance.20syntax.20clarification/near/472075096\">said</a>:</p>\n<blockquote>\n<p>In Lean, parameters can only ever refer to what's been defined in a <em>previous</em> parameter — this is due to the way it's using dependent type theory. (One could imagine a version of Lean where it tries to do a topological sort of the parameters in some way to get all the dependencies to be in order, but Lean doesn't do that.)</p>\n</blockquote>\n<p>Thanks, I was about to ask the question you answered here. It is good to know there is no deeper theoretic reason for this since for a newcomer it does feel like a paper cut.</p>\n<p>Could we say the same about ordering of commands in a module assuming there are no dependency cycles?</p>",
        "id": 472890734,
        "sender_full_name": "Yuri",
        "timestamp": 1727355564
    }
]