[
    {
        "content": "<p>I have code which deals with several different kinds of indices, so having them all be <code>Fin n</code> or <code>Nat</code> is somewhat error-prone. An approach I would typically use is defining a \"newtype\" (a 1x1-ary inductive data structure). Trying to do that in Lean now, here's an illustration of my woes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Vector</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">VId</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">VId</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\">  </span><span class=\"c1\">--fails</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\">   </span><span class=\"c1\">--fails</span>\n\n<span class=\"c1\">-- deriving instance LinearOrder for VId n -- fails!</span>\n<span class=\"c1\">-- Surely there's some way to automate this?</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">VId</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">VId</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n<span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">VId</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">VId</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span>\n\n<span class=\"c1\">-- Conversions are awkward as well; Coe doesn't help.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">[(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"c1\">--fails!!</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">[</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"c1\">-- succeeds but why oh why</span>\n</code></pre></div>\n<p>So the question is: what is the least painful method of supporting this pattern? I know I can do <code>deriving Ord</code> on a structure, but <code>deriving LT</code> fails nonetheless, much less <code>deriving LinearOrder</code>. (What does <code>Ord</code> do anyway? It doesn't provide <code>LT</code>, how can it provide <code>Decidable LT</code>).</p>",
        "id": 479274958,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730121917
    },
    {
        "content": "<p><code>#check i &lt; j</code> fails because typeclass inference doesn't unfold semireducible definitions so can't see through <code>VId</code> to get <code>Fin</code>. You can make it an <code>abbrev</code> or leave it as a def but add a new instance by unfolding it and then using typeclass inference.</p>",
        "id": 479281365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1730123587
    },
    {
        "content": "<p>Yeah I understand. In fact, <code>def</code>s are auto coercible,  so it seems that structures are my only hope. Is there a way to painlessly derive type classes given a term bijection, or do I have to go method by method?</p>",
        "id": 479306124,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730130481
    }
]