[
    {
        "content": "<p>I'm having an issue with the following, and the error message (<code>ill-formed match/equations expression</code>) is very short:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">tensor_product</span>\n\n<span class=\"n\">mutual</span> <span class=\"n\">def</span> <span class=\"n\">tensor_power</span><span class=\"o\">,</span> <span class=\"n\">tensor_power</span><span class=\"bp\">.</span><span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"k\">with</span> <span class=\"n\">tensor_power</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">R</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n        <span class=\"bp\">@</span><span class=\"n\">tensor_product</span> <span class=\"n\">R</span> <span class=\"bp\">_</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">tensor_power</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">tensor_power</span><span class=\"bp\">.</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">sorry</span>\n        <span class=\"c1\">-- haveI : semimodule R (tensor_power n) := tensor_power.semi_module n i,</span>\n        <span class=\"c1\">-- exact tensor_product R V (tensor_power n)</span>\n<span class=\"k\">with</span> <span class=\"n\">tensor_power</span><span class=\"bp\">.</span><span class=\"n\">add_comm_monoid</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">tensor_power</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Is there a way to get a better diagnosis of what is going on?</p>",
        "id": 204460884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595271247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Did you already have something like this? You have multilinear maps, but maybe not tensor powers, right?</p>",
        "id": 204461340,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> It might be a lot easier to define this via the monoidal structure on the category of modules over <code>R</code>.</p>",
        "id": 204461487,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271504
    },
    {
        "content": "<p>But that's just an intuition. I've never tested it.</p>",
        "id": 204461504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Do we have repeated tensor powers in the categorical framework already?</p>",
        "id": 204461533,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/mutual.20types.3A.20ill-formed.20match.2Fequation.20expression/near/204461487\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> It might be a lot easier to define this via the monoidal structure on the category of modules over <code>R</code>.</p>\n</blockquote>\n<p>The reason being that all the typeclasses will be bundled, so you don't need the complicated mutual def construction.</p>",
        "id": 204461599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271568
    },
    {
        "content": "<p>(Aside: is there a reason you give the <code>n = 1</code> case explicitly? It looks nice to have it defeq to <code>V</code> instead of <code>V \\tensor R</code>, but it means that for proofs you will need to do an extra case, all the time (I guess).)</p>",
        "id": 204461790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595271653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/mutual.20types.3A.20ill-formed.20match.2Fequation.20expression/near/204461340\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> Did you already have something like this? You have multilinear maps, but maybe not tensor powers, right?</p>\n</blockquote>\n<p>I had something like that in a previous version of multilinear maps that was defined inductively (now, the current version is defined directly as multilinear maps from <code>fin n</code> to some space, so no induction needed). But it was simpler, as I could first define the type inductively, then the norm on it inductively. Here, it's more complicated as both things need to be defined together.</p>\n<p>If mutual def doesn't work well, you can define a structure containing both the type and the add_comm_monoid structure on it, and define with normal induction this structure at rank <code>n+1</code> when you have it at rank <code>n</code>.</p>",
        "id": 204466329,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1595273876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/mutual.20types.3A.20ill-formed.20match.2Fequation.20expression/near/204461533\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> Do we have repeated tensor powers in the categorical framework already?</p>\n</blockquote>\n<p>Unfortunately no. Monoidal categories are purely in terms of the binary tensor product.</p>",
        "id": 204504677,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595295446
    },
    {
        "content": "<p>But it should be zero problem to write a tensor power def, no <code>mutual</code> required!</p>",
        "id": 204504687,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595295467
    },
    {
        "content": "<p>This is all good advice, but it would be great if someone could tell me what my error message means!</p>",
        "id": 204512748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595307999
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I've never seen it before, but I see two things:</p>\n<ol>\n<li>If you have a match on <code>0</code>, and <code>1</code>, then the remaining case is <code>(n+2)</code>, not <code>(n+1)</code>.</li>\n<li>Does it help if you break</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">with</span> <span class=\"n\">tensor_power</span><span class=\"bp\">.</span><span class=\"n\">add_comm_monoid</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">tensor_power</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>into 3 branches <code>0</code>, <code>1</code>, <code>(n+2)</code> as well, instead of only <code>k</code>?</p>",
        "id": 204514433,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595310857
    },
    {
        "content": "<p>Making either or both of those changes does not help</p>",
        "id": 204514821,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595311519
    },
    {
        "content": "<p>It looks like the issue is that <code>tensor_power</code> appears in the type of <code>add_comm_monoid</code>, not just the definition.</p>",
        "id": 204514901,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595311633
    },
    {
        "content": "<p>Hmm... I'm sorry that I can't really help you.</p>",
        "id": 204515407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595312345
    },
    {
        "content": "<p>I don't have experience with mutual defs</p>",
        "id": 204515412,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595312360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/mutual.20defs.3A.20ill-formed.20match.2Fequation.20expression/near/204514901\">said</a>:</p>\n<blockquote>\n<p>It looks like the issue is that <code>tensor_power</code> appears in the type of <code>add_comm_monoid</code>, not just the definition.</p>\n</blockquote>\n<p>Yes, I think this means the desugaring would produce a definition which appears in its own type, which is not possible</p>",
        "id": 204541612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595335107
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">monoidal</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">CommRing</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoidal_category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">tensor_power</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span><span class=\"bp\">_</span> <span class=\"n\">C</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"err\">⊗</span> <span class=\"n\">tensor_power</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">tensor_power</span> <span class=\"n\">M</span> <span class=\"mi\">17</span>\n\n<span class=\"c1\">-- And if you want to do this with unbundled objects:</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">tensor_power</span> <span class=\"o\">(</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"mi\">17</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">delta</span> <span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 204543114,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595336031
    },
    {
        "content": "<p>I'm a bit confused by that example. For one, I don't see any import of tensor_product.</p>\n<p>My bigger concern is it seems like everything is defined twice, once in <code>category</code> and once not. How should I pick between them? Is there a plan to unify at some later point?</p>",
        "id": 204545572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595337277
    },
    {
        "content": "<p><code>import algebra.category.Module.monoidal</code> transitively imports <code>linear_algebra.tensor_product</code>. This is defeq to what you want.</p>",
        "id": 204548555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595338998
    },
    {
        "content": "<p>You're right that there is becoming worrying amounts of duplication, but in fact this isn't part of it.</p>",
        "id": 204548591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595339023
    },
    {
        "content": "<p>The other worrying part is that I don't know any category theory...</p>",
        "id": 204549174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1595339310
    },
    {
        "content": "<p>But this is a concrete category so you can just think of it as some sort of overlay on top of the stuff you know</p>",
        "id": 204555613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595342486
    },
    {
        "content": "<p>I only know basic category theory (that is, covering about half of the concepts in <a href=\"https://www.youtube.com/watch?v=1NUc-ZNC_2s\">https://www.youtube.com/watch?v=1NUc-ZNC_2s</a> ) but if we only scratch the surface (like using it to define <code>tensor_power</code> ) we'll manage. Plus, category_theory in lean seems to have good automation.</p>\n<p>B.T.W. Clifford Algebra can be defined categorically too, see 1.2 in <a href=\"https://empg.maths.ed.ac.uk/Activities/Spin/Lecture1.pdf\">PG course on Spin Geometry - Lecture 1: Clifford algebras: basic notions</a>.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"1NUc-ZNC_2s\" href=\"https://www.youtube.com/watch?v=1NUc-ZNC_2s\"><img src=\"https://i.ytimg.com/vi/1NUc-ZNC_2s/default.jpg\"></a></div>",
        "id": 204561887,
        "sender_full_name": "Utensil Song",
        "timestamp": 1595345073
    }
]