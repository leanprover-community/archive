[
    {
        "content": "<p>Where can I read about what the <code>gcongr</code> tactic does <strong>and</strong> doesn't do?</p>\n<p>I'm looking for an explanatory article / video suitable f or beginners.</p>\n<p>All I can seem to find online are things like this which are more like source code annotation than explanatory articles:<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/GCongr/Core.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/GCongr/Core.html</a></p>",
        "id": 453032359,
        "sender_full_name": "rzeta0",
        "timestamp": 1721591357
    },
    {
        "content": "<p><a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md#gcongr\">https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md#gcongr</a></p>",
        "id": 453042181,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1721597902
    },
    {
        "content": "<p>Oh, apparently this is the same as the docs</p>",
        "id": 453042222,
        "sender_full_name": "Rida Hamadani",
        "timestamp": 1721597969
    },
    {
        "content": "<p><code>gcongr</code> takes a goal of the form <code>LHS REL RHS</code>, where <code>REL</code> is a relation like <code>≤</code> or <code>⊆</code>. Then it determines common structure of LHS and RHS. E.g., if the goal is <code>a + b * c ≤ a + x * y</code>, then it will determine <code>_ + ?_ * ?_</code>. Here <code>_</code> means that the corresponding term is the same on the left and on the right, while <code>?_</code> means that the corresponding terms are different. Then it applies lemmas annotated with <code>@[gcongr]</code> attribute (+ some built-in rules) to reduce the goal to something like <code>b ≤ x</code> and <code>c ≤ y</code>, possibly generating side goals like <code>0 ≤ b</code>. Finally, it tries to discharge the side goals and the new goals using another set of rules (at least <code>positivity</code> for side goals and <code>assumption</code> for main rules, not sure about details).</p>",
        "id": 453042336,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721598081
    },
    {
        "content": "<p>With the current set of rules, it can reduce, e.g., <code>Finset.card (s ∪ t) ≤ Finset.card (s ∪ u)</code> to <code>t ⊆ u</code>.</p>",
        "id": 453042406,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721598148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  - thanks for explaining. </p>\n<p>From what you said, I understood that <code>gcongr</code> would reduce <code>a + b * c ≤ a + x * y</code> down to <code>b * c ≤ x * y</code>, and then decompose into smaller, more manageable, goals, specifically <code>b ≤ x</code> and <code>c ≤ y</code>. </p>\n<p>My <strong>question</strong> is: why not also <code>c ≤ x</code> and <code>b ≤ y</code>?</p>\n<p>Is it  the case that <code>gcongr</code> tries all combinations? Almost like Prolog tries all combinations to find those that work to meet the overall goal?</p>",
        "id": 453424369,
        "sender_full_name": "rzeta0",
        "timestamp": 1721743611
    },
    {
        "content": "<p>No, it just matches the order</p>",
        "id": 453425294,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1721743872
    },
    {
        "content": "<p>Have a look at the remaining goals here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">gcongr</span>\n</code></pre></div>",
        "id": 453425724,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1721744024
    },
    {
        "content": "<p>If you want to prove <code>a * b ≤ c * d</code> in <code>x + a * b ≤ y + c * d</code> using a different lemma than <code>gcongr</code> chooses automatically, then you can use <code>gcongr ?_ + ?_</code>, then make one <code>apply</code> in the goal <code>a * b ≤ c * d</code> and possibly call <code>gcongr</code> again (if <code>a</code> etc are complicated formulae).</p>",
        "id": 453592086,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721795611
    },
    {
        "content": "<p>If you want to make <code>gcongr</code> more clever, then you need to</p>\n<ul>\n<li>come up with a new algorithm;</li>\n<li>discuss it here on Zulip (probably, in the <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4\">#mathlib4</a> channel);</li>\n<li>(find someone to) implement it.</li>\n</ul>",
        "id": 453592224,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721795716
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  - I'm actually trying to simplify and reduce the code complexity - preparing educational examples for beginners like myself. </p>\n<p>The ideal situation would be if lean4 included a <code>by extra</code> which Heather Macbeth developed for her course \"Mechanics of Proof\". The readability of the proof is then greatly improved, as is the cognitive load writing such positivity proofs reduced.</p>",
        "id": 453632503,
        "sender_full_name": "rzeta0",
        "timestamp": 1721810444
    },
    {
        "content": "<p>You can depend on a Heather's repository (or create a repository with her <code>extra</code> tactic, if she didn't publish it as a github repo).</p>",
        "id": 453718445,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1721833231
    }
]