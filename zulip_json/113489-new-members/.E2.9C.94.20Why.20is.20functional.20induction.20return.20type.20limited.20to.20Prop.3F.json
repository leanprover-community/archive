[
    {
        "content": "<p>I wanted to prove Decidable for my recursive function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">name'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">name'</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"n\">typl</span><span class=\"w\"> </span><span class=\"n\">typr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"n\">typl'</span><span class=\"w\"> </span><span class=\"n\">typr'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"n\">typl</span><span class=\"w\"> </span><span class=\"n\">typl'</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"n\">typr</span><span class=\"w\"> </span><span class=\"n\">typr'</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">False</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">dec_types_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">types_eq</span><span class=\"bp\">.</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"k\">with</span>\n</code></pre></div>\n<p>But this doesn't work, because the motive for <code>types_eq.induct</code> can only return <code>Prop</code>. I'm thinking of reporting feature request to extend it to any <code>Sort u</code>, but I thought I'll ask here first.</p>\n<p>Btw, it seems like completions for <code>types_eq.&lt;cursor&gt;</code> doesn't work. Is it only for me?</p>",
        "id": 501109313,
        "sender_full_name": "MrQubo",
        "timestamp": 1740145760
    },
    {
        "content": "<p>After investigating the source code, it seems like it would be not too hard to rewrite FinInd to use <code>.brecOn</code> instead of <code>.binductionOn</code>. The problem is that it would be noncomputable. And it looks like code generation for <code>if</code> requires Decidable instance to be computable (although I'm not sure why?).</p>",
        "id": 501175673,
        "sender_full_name": "MrQubo",
        "timestamp": 1740167151
    },
    {
        "content": "<p>I mean I would say you should just</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">dec_types_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types_eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>I mean generally I wouldn't oppose having functional induction to <code>Sort u</code> but I think this is just mostly because the main intention of functional induction is to do reasoning on existing functions instead of writing definitions.</p>",
        "id": 501176697,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740167592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20functional.20induction.20return.20type.20limited.20to.20Prop.3F/near/501175673\">schrieb</a>:</p>\n<blockquote>\n<p>And it looks like code generation for <code>if</code> requires Decidable instance to be computable (although I'm not sure why?).</p>\n</blockquote>\n<p>Well if it's not computable then it can't generate code lol. You can avoid the problem by using tactic mode <code>if</code> or <code>by_cases</code> or by using <code>open Classical</code>.</p>",
        "id": 501176967,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740167714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20is.20functional.20induction.20return.20type.20limited.20to.20Prop.3F/near/501109313\">schrieb</a>:</p>\n<blockquote>\n<p>Btw, it seems like completions for <code>types_eq.&lt;cursor&gt;</code> doesn't work. Is it only for me?</p>\n</blockquote>\n<p>Things like functional induction principles are generated lazily, i.e. only once you've tried to access it once. If you do <code>types_eq.&lt;cursor&gt;</code> directly after defining the function, then it won't have generated anything, you can e.g. then <code>#print types_eq.eq_1</code> or <code>#print types_eq.induct</code> and they will show up if you write <code>#check types_eq.&lt;cursor&gt;</code></p>",
        "id": 501177321,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740167862
    },
    {
        "content": "<p>I think I now understand why Decidable instance needs to be computable. <code>types_eq</code> function is noncomputable, because it returns Prop. The Decidable instance is what actually makes it possible to derive computable version of <code>if</code>.</p>",
        "id": 501177995,
        "sender_full_name": "MrQubo",
        "timestamp": 1740168127
    },
    {
        "content": "<p>The honest answer is that it was easier to think about Prop only at first, but I expected that eventually someone will ask for type. Feel free to create an RFC, although I don't expect immediate action, as it's non-trivial. In particular</p>\n<ul>\n<li>It would also need equations to be proven about to be fully useful</li>\n<li>As mentioned, it would still be noncomputable with the current design</li>\n</ul>",
        "id": 501238569,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1740209791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> has marked this topic as resolved.</p>",
        "id": 501510728,
        "sender_full_name": "Notification Bot",
        "timestamp": 1740394924
    }
]