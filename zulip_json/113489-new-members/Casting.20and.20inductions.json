[
    {
        "content": "<p>Hi. Just a disclaimer, I know I probably shouldn't worry about tactics in lean 3 too much, but I was just curious + I need to prove the results for my use case.<br>\nI am trying to read the proof of <code>∀ m n, ((m * n : ℤ) : α) = m * n :=</code> at <a href=\"https://github.com/leanprover-community/mathlib/blob/bed4f0529aa52e2b169d5c2359eef2849e306028/src/data/int/cast/lemmas.lean#L47\">https://github.com/leanprover-community/mathlib/blob/bed4f0529aa52e2b169d5c2359eef2849e306028/src/data/int/cast/lemmas.lean#L47</a>, but I don't understand their syntax. In particular, how can I turn the proof into interactive mode while still using <code>int.induction_on'</code>?</p>",
        "id": 325674861,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1675442186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"579936\">@Gareth Ma</span> Here's a tactic proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.int.cast.lemmas</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_mul</span> <span class=\"o\">[</span><span class=\"n\">non_assoc_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">m</span> <span class=\"n\">using</span> <span class=\"n\">int.induction_on'</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">k</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"mi\">0</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sub_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 325675834,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675442442
    },
    {
        "content": "<p>Thank you!! Really helps a lot <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 325676053,
        "sender_full_name": "Gareth Ma",
        "timestamp": 1675442495
    },
    {
        "content": "<p>You'll probably more likely see something like this, using <code>refine</code> rather than <code>induction</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_mul</span> <span class=\"o\">[</span><span class=\"n\">non_assoc_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">int.induction_on'</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sub_mul</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 325676470,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675442598
    },
    {
        "content": "<p>I guess there's a one-lie tactic proof, where you apply <code>simp</code> to every goal with the <code>contextual</code> option (which allows it to use left sides of implications to simplify right sides).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">theorem</span> <span class=\"n\">cast_mul</span> <span class=\"o\">[</span><span class=\"n\">non_assoc_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">int.induction_on'</span> <span class=\"n\">m</span> <span class=\"mi\">0</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 325676856,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1675442701
    }
]