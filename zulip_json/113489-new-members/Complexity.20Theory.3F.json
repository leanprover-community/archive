[
    {
        "content": "<p>I’m interested in looking at any/all formalizations in the domain of complexity theory. I saw that mathlib has a computability section with definitions for computable functions and Turing machines. Is there anything for e.g. polynomial time algorithms, Karp reductions, etc.?</p>\n<p>Thanks in advance!!</p>",
        "id": 451745733,
        "sender_full_name": "Ian Sweet",
        "timestamp": 1721132155
    },
    {
        "content": "<p>No, it's all missing. However, there seems to be a lot of people interested in formalising complexity theory recently, so I encourage you to type \"complexity theory\" in the Zulip search bar and see what comes up. I would do it for you but I'm on my phone!</p>",
        "id": 451747158,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721132705
    },
    {
        "content": "<p>Thanks! I took your advice to search Zulip but didn’t find anything else. I’m new to Zulip so I could be missing things unintentionally.</p>\n<p>I’m interested in complexity theory as a foundation for asymptotic security in cryptography. I’ll keep looking around and see if I can find anything :)</p>\n<p>Thanks again!!</p>",
        "id": 451753329,
        "sender_full_name": "Ian Sweet",
        "timestamp": 1721134878
    },
    {
        "content": "<p>Hmm, hopefully <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> can point you to the relevant threads, or I arrive home and access my computer</p>",
        "id": 451754114,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721135060
    },
    {
        "content": "<p>See <a href=\"#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory</a></p>",
        "id": 451754609,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721135178
    },
    {
        "content": "<p>there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Turing.TM2ComputableInPolyTime#doc\">docs#Turing.TM2ComputableInPolyTime</a></p>",
        "id": 451754757,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721135234
    },
    {
        "content": "<p>Thanks so much <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> , apologies for not finding it on my own.</p>\n<p>This looks like a great place to start digging in.</p>",
        "id": 451755213,
        "sender_full_name": "Ian Sweet",
        "timestamp": 1721135397
    },
    {
        "content": "<p>I've wanted to work on complexity theory in Lean, but haven't found the time for that yet</p>",
        "id": 451755317,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721135431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/Complexity.20Theory.3F/near/451754757\">said</a>:</p>\n<blockquote>\n<p>there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Turing.TM2ComputableInPolyTime#doc\">docs#Turing.TM2ComputableInPolyTime</a></p>\n</blockquote>\n<p>I believe this should suffice for defining a lot of cryptography, but writing code for reductions seems like it would be extremely challenging in the current state - I believe you'd have to manually create a Turing machine and all of its transitions</p>",
        "id": 451756376,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721135720
    },
    {
        "content": "<p>About complexity theory in mathlib:</p>\n<ol>\n<li>There is a computability part of mathlib which deals with Turing machines and partial recursive functions. There is also a notion of polytime computability, but there is no definition of the class NP. There was a <a class=\"stream\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths\">#maths</a> thread on defining complexity classes recently where someone suggested adding the certificate definition of NP.</li>\n<li>In principle, someone who can devote sufficient time can formalise a number of results around Turing machines like time and space hierarchy theorems and such. In practice, TMs are a pain to work with, even with pen and paper proofs, where, after a point, textbooks get away with abstract descriptions of machines: Roughly you have something like <code>M</code> that compute some function <code>f</code> which takes inputs <code>x : X</code> on which a <code>size : X -&gt; Nat</code> is defined, in time <code>T (size x)</code> many steps. You could try to encode this approach with some typeclasses. Then you could define Karp reductions using some notion of composition. By doing that properly, you might manage to narrow down the scope of your formalisation. Even then, to reiterate, the few TMs you define could be a pain to handle, because you need to take care of every little corner case. I suggest sticking to the binary alphabet if you take this approach, because you have a lot of good source material for nice binary encodings.</li>\n</ol>",
        "id": 451758158,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136283
    },
    {
        "content": "<p>All that being said, complexity is a vast topic, with many other areas.</p>",
        "id": 451758254,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136311
    },
    {
        "content": "<p>In particular circuit complexity is, despite its limitations, much neater to formalise upto a point. You need a notion of circuits which are DAGs. You could define them as trees with binders which point to a circuit in some context</p>",
        "id": 451758483,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136390
    },
    {
        "content": "<p>You can also define uniform circuit classes upto a point by parametrically generating a circuit from a computable lean function carrying a size parameter <code>n</code>. EDIT : I say \"up to a point\" because there does come a point where one needs to be explicit about the complexity of the function constructing the circuit: for e.g.: DLOGTIME uniform AC0.</p>",
        "id": 451758608,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136440
    },
    {
        "content": "<p>Stasys Jukna's book is a good place to start on this : <a href=\"https://web.vu.lt/mif/s.jukna/boolean/index.html\">https://web.vu.lt/mif/s.jukna/boolean/index.html</a></p>",
        "id": 451759092,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136579
    },
    {
        "content": "<p>The reason I recommend this over other areas is that once you have set up the relatively simple framework I described above for circuits, this area is mostly combinatorics. You can get a lot of help w.r.t combinatorics from mathlib and this zulipchat</p>",
        "id": 451759275,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136618
    },
    {
        "content": "<p>Hastad's switching lemma could be a good target to move towards</p>",
        "id": 451759551,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136684
    },
    {
        "content": "<p>If you are okay with doing more esoteric things that the practicing complexity theorist might probably not use, but is exciting nevertheless: there is this paper you could build on : <a href=\"https://drops.dagstuhl.de/storage/00lipics/lipics-vol193-itp2021/LIPIcs.ITP.2021.20/LIPIcs.ITP.2021.20.pdf\">https://drops.dagstuhl.de/storage/00lipics/lipics-vol193-itp2021/LIPIcs.ITP.2021.20/LIPIcs.ITP.2021.20.pdf</a></p>",
        "id": 451760491,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721136945
    },
    {
        "content": "<p>One basic problem with moving too far into non conventional models is that you have to put in a lot of legwork to recover theorems which complexity theorists who work with TMs would prove using tricks like padding the input.</p>",
        "id": 451761387,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721137211
    },
    {
        "content": "<p>another nice corner that is not strictly complexity theory, but still relevant, is boolean fourier transforms. It's a rather powerful technique that can recover several nice theorems from the CS theory literature : <a href=\"https://arxiv.org/abs/2105.10386\">https://arxiv.org/abs/2105.10386</a></p>",
        "id": 451763097,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721137661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/113489-new-members/topic/Complexity.20Theory.3F/near/451763097\">said</a>:</p>\n<blockquote>\n<p>another nice corner that is not strictly complexity theory, but still relevant, is boolean fourier transforms. It's a rather powerful technique that can recover several nice theorems from the CS theory literature : <a href=\"https://arxiv.org/abs/2105.10386\">https://arxiv.org/abs/2105.10386</a></p>\n</blockquote>\n<p>If you're interesting in that I did some of it in <a href=\"https://command-master.github.io/lean-bourgain/\">https://command-master.github.io/lean-bourgain/</a></p>",
        "id": 451763346,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721137738
    },
    {
        "content": "<p>ooh that's cool. For others, what's nice about this framework is that you can get theorems like the correctness of BLR test, arrow's impossibility  result, and goldreich levin very easily</p>",
        "id": 451764907,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721138253
    },
    {
        "content": "<p>I'd say circuit complexity is at a sweet spot for formalisation because even though I used scary words like binders, I believe it is relatively simpler than the lambda calculus stuff, and once you have a working definition, it is mostly combinatorics. I don't know much about arithmetic circuits, but I assume that's similar stuff since you are essentially working with polynomials</p>",
        "id": 451765693,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721138459
    }
]