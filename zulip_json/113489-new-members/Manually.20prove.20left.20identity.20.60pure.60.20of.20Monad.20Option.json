[
    {
        "content": "<p>Hi! I'm new to functional programming and just do some practice. Given the Monad contract that <code>pure</code> should always be left/right identity of <code>bind</code> and the associativity. I try to manually prove them with instances of <code>Monad Id'</code> <code>Monad Option</code> and <code>Monad Result</code>. And I dont know how to unfold the polymorphic function<code>pure</code>/<code>bind</code> as I wish (or maybe I use the wrong tactic). E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">opt</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">left_identity_pure_for_option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">pure_def</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">bind</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ Monad.toBind.1 (some x) f = f x</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I hope the goal after <code>unfold</code> step to be <code>-- ⊢ f x = f x</code> (just use the <code>bind</code> under Monad Option).</p>",
        "id": 484467060,
        "sender_full_name": "Edward Zhang",
        "timestamp": 1732613148
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 484467654,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732613332
    },
    {
        "content": "<p>This is true by <code>rfl</code></p>",
        "id": 484467875,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732613394
    },
    {
        "content": "<p>If you're using Mathlib you can also use <code>unfold_projs</code> to unfold it</p>",
        "id": 484468933,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1732613712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/113489-new-members/topic/Manually.20prove.20left.20identity.20.60pure.60.20of.20Monad.20Option/near/484467875\">said</a>:</p>\n<blockquote>\n<p>This is true by <code>rfl</code></p>\n</blockquote>\n<p>Yep. I know it’s true to solve the goal directly by rfl. Just want to move step by step like manually proof on paper. So I wonder can I use other tactics ( not strong enough  to solve immediately)</p>",
        "id": 484470906,
        "sender_full_name": "Edward Zhang",
        "timestamp": 1732614309
    }
]