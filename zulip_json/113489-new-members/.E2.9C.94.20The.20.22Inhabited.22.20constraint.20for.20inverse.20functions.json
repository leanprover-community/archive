[
    {
        "content": "<p>I'm reading through MIL and have gotten to this point:</p>\n<blockquote>\n<p>To define the inverse of a function <code>f : α → β</code>, we will use two new ingredients. First, we need to deal with the fact that an arbitrary type in Lean may be empty. To define the inverse to <code>f</code> at <code>y</code> when there is no <code>x</code> satisfying <code>f x = y</code>, we want to assign a default value in <code>α</code>. Adding the annotation <code>[Inhabited α]</code> as a variable is tantamount to assuming that <code>α</code> has a preferred element, which is denoted <code>default</code>. Second, in the case where there is more than one <code>x</code> such that <code>f x = y</code>, the inverse function needs to <em>choose</em> one of them. This requires an appeal to the <em>axiom of choice</em>. Lean allows various ways of accessing it; one convenient method is to use the classical <code>choose</code> operator, illustrated below.</p>\n</blockquote>\n<p>The part about <code>Inhabited</code> and <code>default</code> being necessary confuses me — I previously learned Set-theoretical definition of a function, and I don't see a direct mapping for this concept in the Set-theoretical understanding of a function.</p>\n<p>Does this special <code>default</code> value show up only on the type level or can I actually reach it? What are some examples of <code>default</code> values for different types?</p>\n<p>I'm also still struggling with why type theory demands that the <code>α</code> has that default value in order to build an inverse function. I kind of understand that <code>β → α</code> demands that any <code>β</code> gives <em>some</em> <code>α</code>. But if an inverse function is only possible when the original is bijective, doesn't this already guarantee that each <code>β</code> will map to <em>some</em> <code>α</code>? Is this guarantee somehow missed by the type system?</p>\n<p>Maybe another way to ask this is: is it impossible to encode that if the functions are inverse to each other, <code>α</code> being an empty type would mean <code>β</code> has to be an empty type too (due to bijection)? And then somehow not have the <code>default</code> case even show up?</p>\n<p>It just \"feels wrong\" that we have to designate a value as a default when no computation ever actually leads to it (if I understand correctly).</p>\n<p>Sorry for the rambling question, hope this makes sense.</p>",
        "id": 499951223,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739654234
    },
    {
        "content": "<p>If your input function is known to be bijective, then you don't need the inhabited assumption</p>",
        "id": 499951342,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654370
    },
    {
        "content": "<p>However <code>invFun</code> does something slightly different: it takes an <em>arbitrary</em> function <code>f : A -&gt; B</code> and returns <code>invFun f : B -&gt; A</code> with the property that if <code>f</code> is injective then <code>invFun f</code> is surjective, if <code>f</code> is surjective then <code>invFun f</code> is injective, and so if <code>f</code> is bijective then <code>invFun f</code> is bijective and they are inverses</p>",
        "id": 499951469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654484
    },
    {
        "content": "<p>it does so using the following definition: given <code>y : B</code>, if there exists some <code>x</code> such that <code>f x = y</code>, then pick one using <code>Classical.choice</code> and set <code>invFun f y = x</code>; otherwise, set <code>invFun f y = default</code></p>",
        "id": 499951566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654583
    },
    {
        "content": "<p>This <code>default</code> element is in fact reachable, you just need to plug in a value for which that clause is exercised. So for example if I take <code>f n = 2 * n</code> to be the doubling function on the natural numbers, then <code>invFun f 1</code> will be <code>default</code>, which for Nat means <code>0</code></p>",
        "id": 499951680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654665
    },
    {
        "content": "<p>note that the doubling function is not a bijection; if the function you give is a bijection (or even just a surjection), then that clause will never be reached, and you can construct a modified version of the function which takes this as a presupposition and never needs to assume the existence of a <code>default</code> element</p>",
        "id": 499951734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654744
    },
    {
        "content": "<p>Ah, fantastic.</p>\n<p>I can see that I'm able to modify the example and remove <code>[Inhabited α]</code> if I also edit</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">default</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">inverse</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which would ofc be a slightly different definition but would match the inverse definition I learned in the past (which was only defined for bijective functions).</p>",
        "id": 499951742,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739654751
    },
    {
        "content": "<p>right</p>",
        "id": 499951810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739654803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 499951822,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739654818
    },
    {
        "content": "<p>If I have a <code>Bijective</code> constraint, is it possible to avoid choice? For some reason I can't seem to \"destructure\" <code>h.2 y</code> although I thought I was able to do this in the past...</p>",
        "id": 499952490,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739655429
    },
    {
        "content": "<p>You can't extract data out of Exists without choice on lean</p>",
        "id": 499952583,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739655521
    },
    {
        "content": "<p>Hmm, why does <code>rcases</code> work on <code>Exists</code> in some other scenarios? For example in one of the previous MIL exercises:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"bp\">⋂</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"bp\">⋂</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"c1\">-- h : ∃ x, (∀ (i : I), x ∈ A i) ∧ f x = b</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ai</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"c1\">-- a : α</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ai : ∀ (i : I), a ∈ A i</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_iInter</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ai</span><span class=\"w\"> </span><span class=\"n\">i</span>\n</code></pre></div>",
        "id": 499952742,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739655706
    },
    {
        "content": "<p>As Ruben said you can’t extract data. When you prove a theorem, the result has type Prop, so it’s not data, so you can use rcases. But inside a definition, the output is not of type Prop so it is data so you can’t use rcases, you need choice.</p>",
        "id": 499953240,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1739656200
    },
    {
        "content": "<p>Hmm I see.</p>\n<p>If I was proving the <em>existence</em> of an inverse function for a bijective function (as a theorem), would I be able to avoid choice here? Not that I specifically want to avoid it — just trying to understand the constraints of the system.</p>\n<p>Also, if the example above is data, does this mean that <code>inverse</code> is runnable in a non-theorem context? If that's so, what's the runtime implementation of choice?</p>",
        "id": 499954100,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739656979
    },
    {
        "content": "<p>I guess I also assumed that with the <code>inverse</code> definition being nested inside <code>noncomputable section</code> (as in MIL), I'd still be able to do the same things as I do in <code>theorem</code>.</p>",
        "id": 499954396,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739657232
    },
    {
        "content": "<blockquote>\n<p>If I was proving the <em>existence</em> of an inverse function for a bijective function (as a theorem), would I be able to avoid choice here? Not that I specifically want to avoid it — just trying to understand the constraints of the system.</p>\n</blockquote>\n<p><del>Yep, you can avoid it since an existential statement is a <code>Prop</code>.</del> (Not true, see below)</p>\n<blockquote>\n<p>what's the runtime implementation of choice?</p>\n</blockquote>\n<p>There is no runtime implementation of choice, which is why any function that relies on it must be marked <code>noncomputable</code>.</p>",
        "id": 499959813,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739662649
    },
    {
        "content": "<blockquote>\n<p>Yep, you can avoid it since an existential statement is a <code>Prop</code>.</p>\n</blockquote>\n<p>I'm not sure about that, since inside the proof you'll need to make an inverse function, and in the context of that local definition you need to construct values.</p>",
        "id": 499960284,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663060
    },
    {
        "content": "<p>hmm... you can't just prove that it must exist?</p>",
        "id": 499960459,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739663234
    },
    {
        "content": "<p>that's interesting, I hadn't really considered that you would have to use Choice at some point</p>",
        "id": 499960556,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739663318
    },
    {
        "content": "<p>I figured you could do a proof by contradiction using a cardinality argument or something</p>",
        "id": 499960717,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739663511
    },
    {
        "content": "<p>I'd guess the internals of the cardinality theorems themselves would need to construct a function though</p>",
        "id": 499960841,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663643
    },
    {
        "content": "<p>yeah, that's a good point</p>",
        "id": 499960911,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739663717
    },
    {
        "content": "<p>What you are describing (constructing a function under an existential) is exactly what the usual axiom of choice does, a quantifier commutation <code>(∀ x : A, ∃ y : B, P x y) → ∃ f : A → B, ∀ x, P x (f x)</code>. Lean's version of the axiom of choice is stronger than this and is known in the literature as \"global choice\" since it's not guarded by an exists. (This theorem is available as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.axiom_of_choice#doc\">docs#Classical.axiom_of_choice</a> .)</p>",
        "id": 499963885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739666406
    },
    {
        "content": "<p>I'm curious if there's a general principle that tells us which non-constructive existence proofs must use Choice</p>",
        "id": 499973146,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1739675670
    },
    {
        "content": "<p>in general I think that's hard, there are a ton of choice equivalents and intermediate choice principles. I think there is a book just listing all the choice equivalent theorems (by Jech?)</p>",
        "id": 499981948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739684643
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 499983556,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739686362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20The.20.22Inhabited.22.20constraint.20for.20inverse.20functions/near/499954100\">said</a>:</p>\n<blockquote>\n<p>Hmm I see.</p>\n<p>If I was proving the <em>existence</em> of an inverse function for a bijective function (as a theorem), would I be able to avoid choice here? Not that I specifically want to avoid it — just trying to understand the constraints of the system.</p>\n</blockquote>\n<p>You can avoid it by requiring <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a>, which gives you a concrete list of all the values, and then the inverse is constructed by iterating through that list. Indeed this is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.bijInv#doc\">docs#Fintype.bijInv</a>.</p>",
        "id": 499983939,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739686813
    },
    {
        "content": "<p>My understanding is that the \"possibly choice-avoiding\" version of <code>Bijective</code> is <code>Equiv</code> (which is data, since it is a structure): it contains both the bijection and its inverse (together with the proofs that they are two-sided inverses of each other).</p>\n<p>It is only \"possibly\" choice-avoiding, because of course one can construct an instance of <code>Equiv</code> using choice; but if you build instances from other choice-free instances and other explicit constructions, this should avoid \"contamination by choice\".</p>",
        "id": 500010921,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1739712473
    }
]