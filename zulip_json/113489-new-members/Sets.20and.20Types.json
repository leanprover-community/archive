[
    {
        "content": "<p>Hi all!<br>\nI have <code>A : Finset V</code> and <code>S : Finset { x // x ∈ A }</code>, and I would like to obtain an <code>S' : Finset V</code> such that <code>S' ⊆ A</code>, and for <code>x ∈ S'</code> I have <code>x ∈ S</code> and vice versa. I'm having trouble even writing that down as a type, because of course the things in <code>S'</code> and <code>S</code> have different types:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hmm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Because it does not actually make sense to say <code>x ∈ S</code>, lean tells me <code>failed to synthesize  Membership V (Finset { x // x ∈ A })</code>. So <code>x ∈ S</code> not quite what I want, but I'm not sure what is. A <code>Bijection</code> between <code>S</code> and <code>S'</code>? Will I need to write it myself or does it exist somewhere already and I'm just not seeing it?</p>\n<p>So far, i have managed to prove a statement about a <code>S' : Set V</code> (not <code>Finset</code>) and the coercion of <code>x</code>, but that's not sufficient for my needs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hmm</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">exists</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_and_right</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_eq_right</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">xins</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">xins</span><span class=\"bp\">.</span><span class=\"n\">out</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>Any hints? Am I even making sense?</p>",
        "id": 485789313,
        "sender_full_name": "ooovi",
        "timestamp": 1733215846
    },
    {
        "content": "<p>What you're trying to do is in the queue <a href=\"https://github.com/leanprover-community/mathlib4/pull/19514\">#19514</a> . If you're in a hurry, please check the implementation of it.</p>",
        "id": 485790384,
        "sender_full_name": "Jihoon Hyun",
        "timestamp": 1733216198
    },
    {
        "content": "<p>How did you end up with <code>S</code> in the first place? Usually my advice to students who get into this kind of situation is to look at which point they changed a term into a type (which for you is <code>{ x // x ∈ A }</code>) and to see if there is a way of avoiding this (e.g. by not making <code>S</code> at all and instead directly making <code>S'</code> at the point where they made <code>S</code>). But sometimes it's unavoidable.</p>",
        "id": 485790890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733216363
    },
    {
        "content": "<p>It's the vertex set of a subgraph induced by <code>A</code>.</p>",
        "id": 485800289,
        "sender_full_name": "ooovi",
        "timestamp": 1733218672
    }
]