[
    {
        "content": "<p>Is there a preferred/idiomatic way to prove denumerability for a simple inductive type, like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Form</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span>   <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n</code></pre></div>\n<p>for example?</p>\n<p>What I'm considering is proving countability and infinity, then using <code>Encodable.ofCountable</code> and <code>Denumerable.ofEncodableOfInfinite</code>. This feels sort of indirect, and ends up requiring a not of <code>noncomputable</code> annotations. But the only alternative that's leaping out at me right now (to build  <code>decode : Nat-&gt;Form</code>) is to futz around with <code>Nat.mkpair</code>  and <code>Nat.evenOddRec</code> or something, which seems likely to be a mess.</p>",
        "id": 339901961,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1678117229
    },
    {
        "content": "<p>It would be cool if <code>@[derive Denumerable]</code> could be made to work. I guess you could build an explicit injection <code>i</code> into <code>Nat</code> by sending <code>atom n</code> to <code>2^(n+1)</code>, <code>neg f</code> to <code>3^(1 + i f)</code>, <code>and f g</code> to <code>5^(1 + b (i f) (i g))</code> where <code>b</code> is some fixed bijection Nat^2-&gt;Nat etc; injectivity should hopefully be a simple induction (modulo the necessary arithmetic lemmas)</p>",
        "id": 339931848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678124942
    },
    {
        "content": "<p>You could also use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.div_mod_equiv\">docs#nat.div_mod_equiv</a> to split the type into the 5 constructors, and then use mkpair on the binary constructors</p>",
        "id": 339932942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678125247
    },
    {
        "content": "<p>Do we have an n-ary version of mkpair?</p>",
        "id": 339933020,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678125265
    },
    {
        "content": "<p>I guess you can just iterate it</p>",
        "id": 339933071,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678125282
    },
    {
        "content": "<p>It seems like you could get a lot done if you have that the following type is <code>Encodable</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ConsExp</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span>  <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n</code></pre></div>\n<p>It's easy to create an injective map to this from <code>Form</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Form</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span>   <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Form.toConsExp</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">f.toConsExp</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"n\">f.toConsExp</span><span class=\"o\">,</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">3</span> <span class=\"o\">[</span><span class=\"n\">f.toConsExp</span><span class=\"o\">,</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">4</span> <span class=\"o\">[</span><span class=\"n\">f.toConsExp</span><span class=\"o\">,</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Form.toConsExp_injective</span> <span class=\"o\">:</span> <span class=\"n\">Function.Injective</span> <span class=\"n\">Form.toConsExp</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f1</span> <span class=\"n\">f2</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f1</span> <span class=\"n\">generalizing</span> <span class=\"n\">f2</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">cases</span> <span class=\"n\">f2</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">aesop</span>\n</code></pre></div>",
        "id": 339937671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678126626
    },
    {
        "content": "<p>It's also easy to construct a left inverse:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Interpret a `ConsExp` as a `Form`, returning `atom 0` if the input is malformed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConsExp.toForm</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">0</span> <span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">1</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">neg</span> <span class=\"n\">f.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">2</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">3</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"mi\">4</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">impl</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toForm_toConsExp_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Form</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toConsExp.toForm</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">unfold</span> <span class=\"n\">ConsExp.toForm</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 339938973,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678127003
    },
    {
        "content": "<p>Thanks all! I went the countability/infinity route this morning. The injection goes first into a sum of products of Nat, using the Encodable instance for that to recur:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">abbrev</span> <span class=\"n\">tupleEquiv</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span><span class=\"bp\">⊕</span> <span class=\"n\">Nat</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">×</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Form.toSumEncoding</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"bp\">⊕</span> <span class=\"n\">Nat</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">×</span> <span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"bp\">⊕</span> <span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">×</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">#</span><span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inl</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">~</span><span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inl</span> <span class=\"o\">(</span><span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"bp\">&amp;</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inl</span> <span class=\"o\">⟨</span><span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">g</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"bp\">¦</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inl</span> <span class=\"o\">⟨</span><span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">g</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Form.impl</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"bp\">$</span> <span class=\"n\">Sum.inr</span> <span class=\"o\">⟨</span><span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">Encodable.encode</span> <span class=\"bp\">$</span> <span class=\"n\">toSumEncoding</span> <span class=\"n\">g</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Derivable denumberance instances <em>would</em> be cool. But short of that, the <code>ConsExp</code> idea or something similar seems pretty elegant. When I clean this up, I'll see if I can work something like that out.</p>",
        "id": 339943786,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1678128374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"577178\">@Graham Leach-Krouse</span> As an exercise for myself, I created an <code>Encodable</code> instance for a variant of <code>ConsExpr</code> and used it to create one for <code>Form</code>:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Logic.Denumerable</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">ConsExp</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ConsExp.encode</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">Nat.mkpair</span> <span class=\"n\">f.encode</span> <span class=\"n\">g.encode</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ConsExp.decode</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">Nat.boddDiv2</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">nat</span> <span class=\"n\">m</span>\n  <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">Nat.unpair</span> <span class=\"n\">m</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- Some proofs to show termination:</span>\n      <span class=\"k\">have</span> <span class=\"n\">hn'</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">cases</span> <span class=\"n\">n</span>\n        <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hn</span>\n        <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">hn</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n        <span class=\"n\">cases</span> <span class=\"n\">this</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.binaryRec_decreasing</span>\n        <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">Nat.one_le_iff_ne_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hn'</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"n\">_</span> <span class=\"n\">this</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">hm</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n        <span class=\"n\">cases</span> <span class=\"n\">this</span>\n        <span class=\"n\">cases</span> <span class=\"n\">m</span>\n        <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n        <span class=\"n\">next</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Nat.unpair_lt</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">hm</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n        <span class=\"n\">cases</span> <span class=\"n\">this</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.unpair_right_le</span> <span class=\"n\">m</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Nat.lt_of_le_of_lt</span> <span class=\"n\">this</span>\n        <span class=\"n\">assumption</span>\n      <span class=\"c1\">-- With those out of the way:</span>\n      <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">decode</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">decode</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">ConsExp.decode_encode</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp.decode</span> <span class=\"n\">c.encode</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">c</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">encode</span><span class=\"o\">,</span> <span class=\"n\">decode</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span>\n    <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.div2_val</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">next</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">encode</span><span class=\"o\">,</span> <span class=\"n\">decode</span><span class=\"o\">]</span>\n    <span class=\"n\">split</span>\n    <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">next</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.div2_val</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n      <span class=\"n\">cases</span> <span class=\"n\">h</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Encodable</span> <span class=\"n\">ConsExp</span> <span class=\"n\">where</span>\n  <span class=\"n\">encode</span> <span class=\"o\">:=</span> <span class=\"n\">ConsExp.encode</span>\n  <span class=\"n\">decode</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">ConsExp.decode</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"n\">encodek</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ConsExp.decode_encode</span><span class=\"o\">]</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Form</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span>  <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span>   <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Form.toConsExp</span> <span class=\"o\">:</span> <span class=\"n\">Form</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">atom</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">neg</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f.toConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">and</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f.toConsExp</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">or</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f.toConsExp</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">impl</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f.toConsExp</span> <span class=\"n\">g.toConsExp</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Interpret a `ConsExp` as a `Form`, returning `atom 0` if the input is malformed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">ConsExp.toForm</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">n</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">neg</span> <span class=\"n\">f.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">impl</span> <span class=\"n\">f.toForm</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toForm_toConsExp_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Form</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toConsExp.toForm</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Encodable</span> <span class=\"n\">Form</span> <span class=\"n\">where</span>\n  <span class=\"n\">encode</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Encodable.encode</span> <span class=\"n\">f.toConsExp</span>\n  <span class=\"n\">decode</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Encodable.decode</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">ConsExp.toForm</span>\n  <span class=\"n\">encodek</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">toForm_toConsExp_eq</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 339948096,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678129751
    },
    {
        "content": "<p>The intermediate type is the simpler</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">ConsExp</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">ConsExp</span>\n</code></pre></div>",
        "id": 339948167,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1678129775
    },
    {
        "content": "<p>I think the <code>fintype</code> derive handler alread builds this type of equivalence for you</p>",
        "id": 339948840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678130007
    },
    {
        "content": "<p>So we should be able to extend it to <code>encodable</code> quite easily</p>",
        "id": 339948878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1678130022
    },
    {
        "content": "<p>Is it possible to <code>@derive</code> this?</p>",
        "id": 339949448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678130197
    },
    {
        "content": "<p>Trivial tweak: here's a revision using <code>Option.none</code> rather than <code>.atom 0</code> for the junk case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ConsExp.toForm</span> <span class=\"o\">:</span> <span class=\"n\">ConsExp</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">Form</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">atom</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">neg</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f.toForm</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f.toForm</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">nat</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">impl</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f.toForm</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">g.toForm</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">.</span><span class=\"n\">none</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">toForm_toConsExp_eq</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Form</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.toConsExp.toForm</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Encodable</span> <span class=\"n\">Form</span> <span class=\"n\">where</span>\n  <span class=\"n\">encode</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">Encodable.encode</span> <span class=\"n\">f.toConsExp</span>\n  <span class=\"n\">decode</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">Option.bind</span> <span class=\"o\">(</span><span class=\"n\">Encodable.decode</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ConsExp.toForm</span>\n  <span class=\"n\">encodek</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">toForm_toConsExp_eq</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 339952369,
        "sender_full_name": "Graham Leach-Krouse",
        "timestamp": 1678131146
    }
]