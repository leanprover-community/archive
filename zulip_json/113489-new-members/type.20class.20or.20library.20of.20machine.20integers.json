[
    {
        "content": "<p>I am trying to reason about machine integers in a generic fashion... (UInt8, ..., USize)</p>\n<p>all of these types have exactly the same operators (ofNatCore, size, val, etc.) but I don't seem to be able to find a type class that would allow me to write generic operations</p>\n<p>this is what I came up with (sketch):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">MachineInteger</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">size</span><span class=\"o\">:</span> <span class=\"n\">Nat</span>\n  <span class=\"n\">val</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span>\n  <span class=\"n\">ofNatCore</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">LT.lt</span> <span class=\"n\">n</span> <span class=\"n\">size</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">t</span>\n\n<span class=\"c1\">-- @**Chris Bailey** showed me this style</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">hygiene</span> <span class=\"n\">false</span> <span class=\"k\">in</span>\n<span class=\"kd\">run_cmd</span>\n  <span class=\"n\">for</span> <span class=\"n\">typeName</span> <span class=\"k\">in</span> <span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"n\">UInt8</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">UInt16</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">UInt32</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">UInt64</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">USize</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">Lean.mkIdent</span> <span class=\"k\">do</span>\n  <span class=\"n\">Lean.Elab.Command.elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">‚Üê</span> <span class=\"bp\">`</span><span class=\"o\">(</span>\n    <span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">typeName</span>\n    <span class=\"kd\">instance</span><span class=\"o\">:</span> <span class=\"n\">MachineInteger</span> <span class=\"bp\">$</span><span class=\"n\">typeName</span> <span class=\"n\">where</span>\n      <span class=\"n\">size</span> <span class=\"o\">:=</span> <span class=\"n\">size</span>\n      <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">val</span>\n      <span class=\"n\">ofNatCore</span> <span class=\"o\">:=</span> <span class=\"n\">ofNatCore</span>\n    <span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">typeName</span>\n  <span class=\"o\">))</span>\n\n<span class=\"c1\">-- Sample generic operation</span>\n<span class=\"kd\">def</span> <span class=\"n\">scalar_cast</span> <span class=\"o\">{</span> <span class=\"n\">src</span> <span class=\"n\">dst</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span> <span class=\"o\">[</span> <span class=\"n\">MachineInteger</span> <span class=\"n\">src</span> <span class=\"o\">]</span> <span class=\"o\">[</span> <span class=\"n\">MachineInteger</span> <span class=\"n\">dst</span> <span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">src</span><span class=\"o\">):</span> <span class=\"n\">Option</span> <span class=\"n\">dst</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">MachineInteger.val</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">MachineInteger.size</span> <span class=\"n\">dst</span> <span class=\"k\">then</span>\n    <span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">MachineInteger.ofNatCore</span> <span class=\"o\">(</span><span class=\"n\">MachineInteger.val</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">.</span><span class=\"n\">none</span>\n</code></pre></div>\n<ul>\n<li>are there already facilities for doing this more efficiently? right now I'm taking inspiration from <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UInt.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UInt.lean</a></li>\n<li>if not, any comments on the style I'm using and whether it can be improved?</li>\n</ul>\n<p>I'm particularly curious to hear <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span>'s thoughts on the matter, since I assume you must have done something comparable for electrolysis</p>",
        "id": 325038676,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675207368
    },
    {
        "content": "<p>Would it be a bad idea to use something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">UInt</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">size</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">UInt8</span> <span class=\"o\">:=</span> <span class=\"n\">UInt</span> <span class=\"n\">UInt8.size</span>\n<span class=\"kd\">def</span> <span class=\"n\">UInt8.mk</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">UInt8</span> <span class=\"o\">:=</span> <span class=\"n\">UInt.mk</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>instead of the current</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">UInt8</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">Fin</span> <span class=\"n\">UInt8.size</span>\n</code></pre></div>\n<p>That might make this kind of generalization easier</p>",
        "id": 325040908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1675208390
    },
    {
        "content": "<p>yes, that would be a bad idea</p>",
        "id": 325040981,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675208408
    },
    {
        "content": "<p>these types exist mainly to facilitate ABI issues (in C type signatures and the like), and the compiler has a much harder time recognizing these types when a simple <code>whnf</code> doesn't yield a constant symbol</p>",
        "id": 325041095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675208468
    },
    {
        "content": "<p>the other thing is, we would want such a typeclass to have a really big interface, not a minimal one, including at least all the operations that have compiler builtins</p>",
        "id": 325041330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675208586
    },
    {
        "content": "<p>or we can just keep using that macro to stamp out lots of copies of the theorems and not bother with a typeclass</p>",
        "id": 325041400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675208633
    },
    {
        "content": "<p>makes sense... I guess I'm not bound to those types (which seem indeed to be compiler internals), so I could just redefine my own library of machine integers in the style that Eric proposes, which would indeed make things easier (and would remove one layer of perhaps unnecessary abstraction), but then I would lose the benefit of the operations on those builtin types, which are defined e.g. here <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UInt.lean\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Data/UInt.lean</a></p>",
        "id": 325043002,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675209459
    },
    {
        "content": "<p>If you define your own machine integers, then they won't be machine integers anymore, which usually defeats the purpose for using machine integer types in the first place</p>",
        "id": 325048507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675212256
    },
    {
        "content": "<p>a typeclass is a better way to abstract over the types without actually redefining them</p>",
        "id": 325048592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675212305
    },
    {
        "content": "<p>(just to be clear, my \"that would be a bad idea\" was directed at <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> 's suggestion to change the definition of the <code>UInt*</code> types, not your suggestion of having a <code>MachineInteger</code> typeclass)</p>",
        "id": 325048756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675212375
    },
    {
        "content": "<p>ok, sounds like I'm on the right track then... how inefficient are <code>Nat</code>s? right now for the Lean backend of Aeneas, I need to mimic Rust's semantics of error-on-overflow, which I do by running the operation on <code>Nat</code>s, checking that it fits, then casting back to the right size, e.g. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">USize.checked_mul</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span> <span class=\"n\">USize</span><span class=\"o\">):</span> <span class=\"n\">result</span> <span class=\"n\">USize</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">n.val</span> <span class=\"bp\">*</span> <span class=\"n\">m.val</span> <span class=\"bp\">&lt;</span> <span class=\"n\">USize.size</span> <span class=\"k\">then</span>\n    <span class=\"bp\">.</span><span class=\"n\">ret</span> <span class=\"o\">‚ü®</span> <span class=\"n\">n.val</span> <span class=\"bp\">*</span> <span class=\"n\">m.val</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">‚ü©</span>\n  <span class=\"k\">else</span>\n    <span class=\"bp\">.</span><span class=\"n\">fail</span> <span class=\"n\">integerOverflow</span>\n</code></pre></div>\n<p>are <code>Nat</code>s really running as <code>succ (succ ...)</code> like in Coq, or is there an efficient bignum implementation under the hood? if it's the former, I probably have a problem, but if it's the latter, it's probably fine for now</p>",
        "id": 325068095,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675226989
    },
    {
        "content": "<p>They have efficient bignum representations internally.</p>",
        "id": 325074099,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1675231641
    },
    {
        "content": "<p>A <code>Nat</code> is represented as a tagged pointer (i.e. the type says <code>lean_object*</code> but it's actually a <code>usize</code> with low bit 1) if it is less than <code>2^31</code> or <code>2^63</code> depending on architecture. For larger natural numbers, it falls back to a GMP bignum (or a homebrew bignum if you disable GMP) representation. In any case, lean 4 will never use unary representation for numerals (even though the inductive declaration suggests that it would), since the kernel is also clued in on this bignum stuff.</p>",
        "id": 325074933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675232141
    },
    {
        "content": "<p>It's still a bit less efficient than if you use actual fixed-width integer types since these don't need the tagging scheme</p>",
        "id": 325075066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675232220
    },
    {
        "content": "<p>That implementation of <code>checked_mul</code> sounds about as efficient as you are likely to get. The only thing I could see which might improve it would be to do the operation on the double-width fixed width integer type, when one exists, since a multiplication can't overflow that. For added fun, that gives you a nontrivial proof condition to show that it is as good as doing the multiplication over <code>Nat</code></p>",
        "id": 325075702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1675232617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"342995\">Jonathan Protzenko</span> <a href=\"#narrow/stream/113489-new-members/topic/type.20class.20or.20library.20of.20machine.20integers/near/325038676\">said</a>:</p>\n<blockquote>\n<p>I'm particularly curious to hear <span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span>'s thoughts on the matter, since I assume you must have done something comparable for electrolysis</p>\n</blockquote>\n<p>Hah, those were quite different times <a href=\"https://github.com/Kha/electrolysis/blob/master/thys/core/pre.lean#L74-L78\">https://github.com/Kha/electrolysis/blob/master/thys/core/pre.lean#L74-L78</a>. No built-in bounded nats to be found.</p>",
        "id": 325093153,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1675240299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/type.20class.20or.20library.20of.20machine.20integers/near/325075702\">said</a>:</p>\n<blockquote>\n<p>That implementation of <code>checked_mul</code> sounds about as efficient as you are likely to get. The only thing I could see which might improve it would be to do the operation on the double-width fixed width integer type, when one exists, since a multiplication can't overflow that. For added fun, that gives you a nontrivial proof condition to show that it is as good as doing the multiplication over <code>Nat</code></p>\n</blockquote>\n<p>yes that's how I would implement it in C, with the caveat that for the max type (e.g. uint64) you need a couple intrinsics to do that efficiently... (since there's no uint128 by default)</p>\n<p>since this is bignums under the hood, I'm not worried about performance just now -- we don't intend to execute the Lean code, just verify it, and as long as the simplifier's performance isn't shot, I think we're good!</p>",
        "id": 325203884,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675268911
    },
    {
        "content": "<blockquote>\n<p>No built-in bounded nats to be found.</p>\n</blockquote>\n<p>different times indeed!</p>",
        "id": 325203957,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1675268933
    }
]