[
    {
        "content": "<p>I've been going through a real analysis book and trying to port it to Lean as an exercise, and I've began to define the rationals on top of integers using <code>Quotient</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">myratSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">myrat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rel_rat</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">is_equivalence_rat</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyRat</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">myratSetoid</span>\n</code></pre></div>\n<p>And I was able to define multiplication and addition normally, using Quot.liftOn₂, but I'm having problems trying to figure out how to do it with the reciprocal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">inv_fn</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">myrat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a_neq</span> <span class=\"o\">:</span> <span class=\"n\">a.n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyRat</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a.d</span> <span class=\"bp\">//</span> <span class=\"n\">a.n</span><span class=\"o\">)</span> <span class=\"n\">a_neq</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">inv_respects</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"o\">:</span> <span class=\"n\">myrat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"o\">:</span> <span class=\"n\">a.n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha'</span><span class=\"o\">:</span> <span class=\"n\">a'.n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">haa'</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">~</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inv_fn</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"bp\">=</span> <span class=\"n\">inv_fn</span> <span class=\"n\">a'</span> <span class=\"n\">ha'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">rel_rat</span> <span class=\"n\">at</span> <span class=\"n\">haa'</span>\n  <span class=\"n\">apply</span> <span class=\"n\">rel_int_rat</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">haa'.symm</span><span class=\"o\">]</span>\n  <span class=\"n\">ring</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- I already have this: theorem numerator_neq_zero (x: MyRat) (ha: x ≠ 0) : ∀(n m : MyInt) (hm: m ≠ 0), (n // m) hm = x → n ≠ 0</span>\n<span class=\"c1\">-- def inv (a: MyRat) (a_neq : a ≠ 0) : MyRat := ???</span>\n</code></pre></div>\n<p>But the issue I've been having is actually passing the inequality onto <code>Quot.liftOn</code>, the closes thing I've got  is to make another <code>structure</code> called <code>temp_rat</code> that actually has this equivalence, then I can use <code>Quot.liftOn</code> on it, allowing me to define inv_temp:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">temp_rat</span> <span class=\"n\">where</span>\n  <span class=\"n\">mk</span> <span class=\"o\">::</span>\n  <span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">myrat</span>\n  <span class=\"n\">n_neq</span><span class=\"o\">:</span> <span class=\"n\">r.n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rel_temp_rat</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">temp_rat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">temp_rat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">a.r</span> <span class=\"bp\">~</span> <span class=\"n\">b.r</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">is_equivalence_temp</span> <span class=\"o\">:</span> <span class=\"n\">Equivalence</span> <span class=\"n\">rel_temp_rat</span> <span class=\"n\">where</span>\n  <span class=\"n\">refl</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rel_rat_refl</span> <span class=\"n\">x.r</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rel_rat_symm</span> <span class=\"n\">a</span>\n  <span class=\"n\">trans</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">a1</span> <span class=\"n\">a2</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rel_rat_trans</span> <span class=\"n\">a1</span> <span class=\"n\">a2</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">tempSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"o\">(</span><span class=\"n\">temp_rat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rel_temp_rat</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"n\">is_equivalence_temp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">TempRat</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient</span> <span class=\"n\">tempSetoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">inv_temp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">TempRat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyRat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quot.liftOn</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">inv_fn</span> <span class=\"n\">x.r</span> <span class=\"n\">x.n_neq</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">haa'</span>\n    <span class=\"n\">exact</span> <span class=\"n\">inv_respects</span> <span class=\"n\">a.r</span> <span class=\"n\">a'.r</span> <span class=\"n\">a.n_neq</span> <span class=\"n\">a'.n_neq</span> <span class=\"n\">haa'</span>\n  <span class=\"o\">})</span>\n</code></pre></div>\n<p>But I don't see a way to define <code>def inv (a: MyRat) (a_neq : a ≠ 0) : MyRat</code> from this in any sane way. I know that mathlib forgoes the zero divisor problem by defining it in the operation, but I'd like to define it like this anyway, this is just an exercise and doing it like this follows closer to the procedure of the book. Can anyone guide me towards a way to do this? I've been stuck in this for a while.</p>",
        "id": 401536299,
        "sender_full_name": "Kauê Campos",
        "timestamp": 1699729548
    }
]