[
    {
        "content": "<p>Evaluating the method <em>String.contains</em> is done in near zero time:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"s2\">\"Hello!\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span>\n</code></pre></div>\n<p>I expect it would be just as fast to produce the evidence of exactly the same expression given as a proposition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hello!\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>However, this takes exponential time, and even a very short string is prohibitively expensive to check in the context of proving a proposition. What can I do to make this fast?</p>",
        "id": 387945299,
        "sender_full_name": "Fredrik",
        "timestamp": 1693335696
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hegjdfgdfjgfgfdgfdkgfsdgfsllo!\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 387945951,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1693335929
    },
    {
        "content": "<p>What I don't understand, however, is why the following proof times out.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hegjdfgdfjgfgfdgfdkgfsdgfsllo!\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 387946205,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1693336046
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <br>\nInteresting that <em>rfl</em> is fast. The reason I didn't try <em>rfl</em> is that I first tried to prove the opposite:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"s2\">\"Hello\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm not sure how I can transform this goal to make it work with <em>rfl</em>.</p>",
        "id": 387947143,
        "sender_full_name": "Fredrik",
        "timestamp": 1693336462
    },
    {
        "content": "<p>I am not surprised by <code>rfl</code> being fast -- it uses only definitional equalities.<br>\nI am surprised by the other two being so slow.</p>",
        "id": 387947931,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1693336776
    },
    {
        "content": "<p>I found a theorem that can be applied to also let the negative proposition by proven by <em>rfl</em>. It would however still be good to know why the other tactics are so terribly slow.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"s2\">\"Hello long string without exclamation mark\"</span><span class=\"bp\">.</span><span class=\"n\">contains</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ne_true_of_eq_false</span>\n  <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 387949842,
        "sender_full_name": "Fredrik",
        "timestamp": 1693337421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638770\">Fredrik</span> has marked this topic as resolved.</p>",
        "id": 387949871,
        "sender_full_name": "Notification Bot",
        "timestamp": 1693337429
    },
    {
        "content": "<p><em>rfl</em> given as a function argument also turns out to be exponentially slow. <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span> I was hoping to make an easy to use function that takes a string that must not contain NUL characters.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"bp\">!</span><span class=\"n\">a.contains</span> <span class=\"sc\">'\\x00'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">function</span> <span class=\"s2\">\"Aaaaaa\"</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 387955834,
        "sender_full_name": "Fredrik",
        "timestamp": 1693339289
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638770\">@Fredrik</span> , speed considerations aside, <code>simp</code> is not applying any <code>simp</code> lemmas here (as evidenced by <code>by simp?</code>).</p>",
        "id": 387972792,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693344951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> something is seriously broken here though. This times out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">String.contains</span> <span class=\"s2\">\"aaaaaab\"</span> <span class=\"sc\">'b'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- times out</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">String.contains</span> <span class=\"s2\">\"aaaaaab\"</span> <span class=\"sc\">'b'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works fine</span>\n</code></pre></div>\n<p>and with fewer <code>a</code>s it is noticably faster. I think the exponentially slow description provided above is accurate in the literal sense.</p>",
        "id": 387973070,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693345070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <code>simp?</code> reports that no lemmas are used: <code>Try this: simp only</code>. <code>simp only</code> is just as slow as regular <code>simp</code>. I also observed that <code>:= rfl</code> is slow while <code>:= by rfl</code> is fast.</p>",
        "id": 387973806,
        "sender_full_name": "Fredrik",
        "timestamp": 1693345395
    },
    {
        "content": "<p>Right, what I'm saying is that <code>simp</code> is sort of a red herring. You're trying to use it where it doesn't really apply (even though it happens to work because it does slightly more than <em>just</em> applying <code>simp</code> lemmas). I think the slowness of <code>simp</code> is just due to the issue I'm mentioning above, although it's interesting that <code>by rfl</code> works fine.</p>",
        "id": 387975046,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693345922
    },
    {
        "content": "<p>Mario, I'll note that if you artificially increase the starting position then you can witness the increase in speed too. That is, this is fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">String.anyAux</span> <span class=\"s2\">\"aaaaaaaab\"</span> <span class=\"s2\">\"aaaaaaaab\"</span><span class=\"bp\">.</span><span class=\"n\">endPos</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">==</span> <span class=\"sc\">'b'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"mi\">7</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>so I expect it's something to do with the nesting of <code>if</code> expressions in <code>String.anyAux</code>, but I don't immediately see where the problem is.</p>",
        "id": 387976196,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693346396
    },
    {
        "content": "<p>I take it back, maybe it's just a unification problem:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.isDefEq</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">String.contains</span> <span class=\"s2\">\"b\"</span> <span class=\"sc\">'b'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">String.contains</span> <span class=\"s2\">\"b\"</span> <span class=\"sc\">'b'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> the trace for the first example contains this, where the second example doesn't.</span>\n<span class=\"cm\">[Meta.isDefEq] ✅ String.contains \"b\" (Char.ofNat 98) = true =?= ?m.34608 = ?m.34608 ▼</span>\n<span class=\"cm\">  [] ✅ Bool =?= ?m.34607 ▼</span>\n<span class=\"cm\">    [] Bool [nonassignable] =?= ?m.34607 [assignable]</span>\n<span class=\"cm\">    [] ✅ Sort ?u.34606 =?= Type</span>\n<span class=\"cm\">  [] ✅ String.contains \"b\" (Char.ofNat 98) =?= ?m.34608 ▼</span>\n<span class=\"cm\">    [] String.contains \"b\" (Char.ofNat 98) [nonassignable] =?= ?m.34608 [assignable]</span>\n<span class=\"cm\">    [] ✅ Bool =?= Bool</span>\n<span class=\"cm\">  [] ✅ true =?= String.contains \"b\" (Char.ofNat 98) ▼</span>\n<span class=\"cm\">    [] ✅ true =?= String.contains \"b\" (Char.ofNat 98) ▼</span>\n<span class=\"cm\">      [] ✅ true =?= String.any \"b\" fun a =&gt; a == Char.ofNat 98 ▼</span>\n<span class=\"cm\">        [] ✅ true =?= String.anyAux \"b\" (String.endPos \"b\") (fun a =&gt; a == Char.ofNat 98) 0 ▼</span>\n<span class=\"cm\">          [] ✅ true =?= WellFounded.fix</span>\n<span class=\"cm\">                (_ :</span>\n<span class=\"cm\">                  WellFounded (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1)</span>\n<span class=\"cm\">                (fun i a =&gt;</span>\n<span class=\"cm\">                  if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                    if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                    else</span>\n<span class=\"cm\">                      let_fun this :=</span>\n<span class=\"cm\">                        (_ :</span>\n<span class=\"cm\">                          (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                            (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                      a (String.next \"b\" i)</span>\n<span class=\"cm\">                        (_ :</span>\n<span class=\"cm\">                          (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1</span>\n<span class=\"cm\">                            (String.next \"b\" i) i)</span>\n<span class=\"cm\">                  else false)</span>\n<span class=\"cm\">                0 ▼</span>\n<span class=\"cm\">            [] ✅ true =?= WellFounded.fixF</span>\n<span class=\"cm\">                  (fun i a =&gt;</span>\n<span class=\"cm\">                    if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                      if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                      else</span>\n<span class=\"cm\">                        let_fun this :=</span>\n<span class=\"cm\">                          (_ :</span>\n<span class=\"cm\">                            (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                              (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                        a (String.next \"b\" i)</span>\n<span class=\"cm\">                          (_ :</span>\n<span class=\"cm\">                            (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1</span>\n<span class=\"cm\">                              (String.next \"b\" i) i)</span>\n<span class=\"cm\">                    else false)</span>\n<span class=\"cm\">                  0 (_ : Acc (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1 0) ▼</span>\n<span class=\"cm\">              [] ✅ true =?= Acc.rec</span>\n<span class=\"cm\">                    (fun x₁ h ih =&gt;</span>\n<span class=\"cm\">                      (fun i a =&gt;</span>\n<span class=\"cm\">                          if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                            if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                            else</span>\n<span class=\"cm\">                              let_fun this :=</span>\n<span class=\"cm\">                                (_ :</span>\n<span class=\"cm\">                                  (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                                    (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                              a (String.next \"b\" i)</span>\n<span class=\"cm\">                                (_ :</span>\n<span class=\"cm\">                                  (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                        instWellFoundedRelation).1</span>\n<span class=\"cm\">                                    (String.next \"b\" i) i)</span>\n<span class=\"cm\">                          else false)</span>\n<span class=\"cm\">                        x₁ ih)</span>\n<span class=\"cm\">                    (_ : Acc (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1 0) ▼</span>\n<span class=\"cm\">                [] ✅ true =?= if h : 0 &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                      if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" 0) = true then true</span>\n<span class=\"cm\">                      else</span>\n<span class=\"cm\">                        let_fun this :=</span>\n<span class=\"cm\">                          (_ :</span>\n<span class=\"cm\">                            (String.endPos \"b\").byteIdx - (String.next \"b\" 0).byteIdx &lt;</span>\n<span class=\"cm\">                              (String.endPos \"b\").byteIdx - 0.byteIdx);</span>\n<span class=\"cm\">                        (fun y a =&gt;</span>\n<span class=\"cm\">                            Acc.rec</span>\n<span class=\"cm\">                              (fun x₁ h ih =&gt;</span>\n<span class=\"cm\">                                (fun i a =&gt;</span>\n<span class=\"cm\">                                    if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                                      if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                                      else</span>\n<span class=\"cm\">                                        let_fun this :=</span>\n<span class=\"cm\">                                          (_ :</span>\n<span class=\"cm\">                                            (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                                              (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                                        a (String.next \"b\" i)</span>\n<span class=\"cm\">                                          (_ :</span>\n<span class=\"cm\">                                            (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                                  instWellFoundedRelation).1</span>\n<span class=\"cm\">                                              (String.next \"b\" i) i)</span>\n<span class=\"cm\">                                    else false)</span>\n<span class=\"cm\">                                  x₁ ih)</span>\n<span class=\"cm\">                              (_ :</span>\n<span class=\"cm\">                                Acc (InvImage WellFoundedRelation.rel fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                  y))</span>\n<span class=\"cm\">                          (String.next \"b\" 0)</span>\n<span class=\"cm\">                          (_ :</span>\n<span class=\"cm\">                            (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1</span>\n<span class=\"cm\">                              (String.next \"b\" 0) 0)</span>\n<span class=\"cm\">                    else false ▼</span>\n<span class=\"cm\">                  [] ✅ true =?= Decidable.casesOn (instDecidableLtPosInstLTPos 0 (String.endPos \"b\")) (fun h =&gt; false) fun h =&gt;</span>\n<span class=\"cm\">                        if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" 0) = true then true</span>\n<span class=\"cm\">                        else</span>\n<span class=\"cm\">                          let_fun this :=</span>\n<span class=\"cm\">                            (_ :</span>\n<span class=\"cm\">                              (String.endPos \"b\").byteIdx - (String.next \"b\" 0).byteIdx &lt;</span>\n<span class=\"cm\">                                (String.endPos \"b\").byteIdx - 0.byteIdx);</span>\n<span class=\"cm\">                          (fun y a =&gt;</span>\n<span class=\"cm\">                              Acc.rec</span>\n<span class=\"cm\">                                (fun x₁ h ih =&gt;</span>\n<span class=\"cm\">                                  (fun i a =&gt;</span>\n<span class=\"cm\">                                      if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                                        if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                                        else</span>\n<span class=\"cm\">                                          let_fun this :=</span>\n<span class=\"cm\">                                            (_ :</span>\n<span class=\"cm\">                                              (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                                                (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                                          a (String.next \"b\" i)</span>\n<span class=\"cm\">                                            (_ :</span>\n<span class=\"cm\">                                              (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                                    instWellFoundedRelation).1</span>\n<span class=\"cm\">                                                (String.next \"b\" i) i)</span>\n<span class=\"cm\">                                      else false)</span>\n<span class=\"cm\">                                    x₁ ih)</span>\n<span class=\"cm\">                                (_ :</span>\n<span class=\"cm\">                                  Acc</span>\n<span class=\"cm\">                                    (InvImage WellFoundedRelation.rel fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                    y))</span>\n<span class=\"cm\">                            (String.next \"b\" 0)</span>\n<span class=\"cm\">                            (_ :</span>\n<span class=\"cm\">                              (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1</span>\n<span class=\"cm\">                                (String.next \"b\" 0) 0) ▼</span>\n<span class=\"cm\">                    [] ✅ true =?= if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" 0) = true then true</span>\n<span class=\"cm\">                        else</span>\n<span class=\"cm\">                          let_fun this :=</span>\n<span class=\"cm\">                            (_ :</span>\n<span class=\"cm\">                              (String.endPos \"b\").byteIdx - (String.next \"b\" 0).byteIdx &lt;</span>\n<span class=\"cm\">                                (String.endPos \"b\").byteIdx - 0.byteIdx);</span>\n<span class=\"cm\">                          (fun y a =&gt;</span>\n<span class=\"cm\">                              Acc.rec</span>\n<span class=\"cm\">                                (fun x₁ h ih =&gt;</span>\n<span class=\"cm\">                                  (fun i a =&gt;</span>\n<span class=\"cm\">                                      if h : i &lt; String.endPos \"b\" then</span>\n<span class=\"cm\">                                        if h : (fun a =&gt; a == Char.ofNat 98) (String.get \"b\" i) = true then true</span>\n<span class=\"cm\">                                        else</span>\n<span class=\"cm\">                                          let_fun this :=</span>\n<span class=\"cm\">                                            (_ :</span>\n<span class=\"cm\">                                              (String.endPos \"b\").byteIdx - (String.next \"b\" i).byteIdx &lt;</span>\n<span class=\"cm\">                                                (String.endPos \"b\").byteIdx - i.byteIdx);</span>\n<span class=\"cm\">                                          a (String.next \"b\" i)</span>\n<span class=\"cm\">                                            (_ :</span>\n<span class=\"cm\">                                              (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                                    instWellFoundedRelation).1</span>\n<span class=\"cm\">                                                (String.next \"b\" i) i)</span>\n<span class=\"cm\">                                      else false)</span>\n<span class=\"cm\">                                    x₁ ih)</span>\n<span class=\"cm\">                                (_ :</span>\n<span class=\"cm\">                                  Acc</span>\n<span class=\"cm\">                                    (InvImage WellFoundedRelation.rel fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx)</span>\n<span class=\"cm\">                                    y))</span>\n<span class=\"cm\">                            (String.next \"b\" 0)</span>\n<span class=\"cm\">                            (_ :</span>\n<span class=\"cm\">                              (invImage (fun a =&gt; (String.endPos \"b\").byteIdx - a.byteIdx) instWellFoundedRelation).1</span>\n<span class=\"cm\">                                (String.next \"b\" 0) 0) ▼</span>\n<span class=\"cm\">--- I cut some out to appease Zulip ...</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>",
        "id": 387979659,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693347794
    },
    {
        "content": "<p><code>by simp</code> is just doing <code>by decide</code> in this case</p>",
        "id": 388024897,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367090
    },
    {
        "content": "<p>and <code>by decide</code> should basically just be doing <code>by rfl</code> after a bit of reduction</p>",
        "id": 388024935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367119
    },
    {
        "content": "<p>I should note that this isn't really expected to work. This function was not designed for kernel evaluation, and it very quickly becomes a mess</p>",
        "id": 388025703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367544
    },
    {
        "content": "<p>I don't think this is exponentially slow, based on the way the term is growing I would guess it is more like quadratic or cubic time</p>",
        "id": 388025917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367683
    },
    {
        "content": "<p>The fundamental issue is that lean itself uses call-by-value evaluation semantics, and functions are usually written to take advantage of this, but the kernel uses call-by-name evaluation order (when using <code>rfl</code> / unification as a way to evaluate complex functions), which can end up generating huge thunks of unresolved computation</p>",
        "id": 388026131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367811
    },
    {
        "content": "<p>It is possible to write programs that stay reasonable in a call-by-name setting (see: haskell), but you have to write the function differently</p>",
        "id": 388026369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693367934
    },
    {
        "content": "<p>Here's a kernel-optimized contains function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">String.contains'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s.data.contains</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hello!\"</span><span class=\"bp\">.</span><span class=\"n\">contains'</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hello!\"</span><span class=\"bp\">.</span><span class=\"n\">contains'</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"s2\">\"Hegjdfgdfjgfgfdgfdkgfsdgfsllo!\"</span><span class=\"bp\">.</span><span class=\"n\">contains'</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"s2\">\"Hello\"</span><span class=\"bp\">.</span><span class=\"n\">contains'</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"s2\">\"Hello long string without exclamation mark\"</span><span class=\"bp\">.</span><span class=\"n\">contains'</span> <span class=\"sc\">'!'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 388027176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693368364
    },
    {
        "content": "<p>So why is <code>by rfl</code> fast?</p>",
        "id": 388028767,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1693369424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> That suggests that the definition of <code>String.contains</code> should be changed to avoid accidentally making a mess. It would be useful to be able to make such a thing as a function that takes a string that must not contain NUL characters without putting the caller at risk.</p>\n<p>Now I use the <code>String.data</code> workaround:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">contains_no_nul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">!</span><span class=\"n\">a.data.contains</span> <span class=\"sc\">'\\x00'</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">function</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">contains_no_nul</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"o\">:=</span> <span class=\"o\">()</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">function</span> <span class=\"s2\">\"A long string containing no NUL characters\"</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 388037201,
        "sender_full_name": "Fredrik",
        "timestamp": 1693374985
    },
    {
        "content": "<p>The thing is that most lean functions are not designed for kernel evaluation, this is not really a supported use case and only works at all by \"accident\"</p>",
        "id": 388037415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375174
    },
    {
        "content": "<p>If you want to have kernel evaluation you need to write all the functions yourself or audit your dependencies carefully</p>",
        "id": 388037506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375208
    },
    {
        "content": "<p>The <code>String.data</code> approach is not at all suitable to be used upstream because it makes <code>#eval</code> much slower</p>",
        "id": 388037592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375257
    },
    {
        "content": "<p>It is also quite common for evaluating these functions to just get stuck and not evaluate to a normal form at all, because the proof of well foundedness or termination uses an axiom</p>",
        "id": 388037756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375326
    },
    {
        "content": "<p>The preferred way to evaluate lean functions is either via <code>#eval</code> or a tactic like <code>norm_num</code>, depending on whether you want a proof out</p>",
        "id": 388038188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"638770\">@Fredrik</span> Could you elaborate on your no-nul example? There are a few ways one could implement that but it depends on what you want to achieve with that <code>function</code></p>",
        "id": 388038536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693375789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> I'm interesting in verifying the correctness of programs. I'm still just figuring out how. One major category of things I want to verify is that every function call satisfies the preconditions of the function being called. Functions that take strings that must not contain NUL bytes are common when interacting with C. Rust has the type <code>CStr</code> for this. It has the constructor <code>from_bytes_with_nul</code> which makes a costly validation on runtime and may panic, and the constructor <code>from_bytes_with_nul_unchecked</code> which specifies a precondition in the documentation, but does no validation whatsoever and requires that the code is marked as unsafe and that the programmer promises that the precondition is satisfied. My current approach is to model a Rust program in Lean, and prove that the program satisfies all preconditions, even though the model when translated to Rust code would contain code marked as unsafe.</p>\n<p>I expect that if a function is called with constant arguments, the preconditions could trivially be checked by evaluating them on compile time. The <code>String.data</code> workaround works for my purpose, but I'm surprised that I need an especially optimized function for such a simple thing, especially since I don't require generating a step-by-step proof.</p>",
        "id": 388041174,
        "sender_full_name": "Fredrik",
        "timestamp": 1693377426
    },
    {
        "content": "<p>Here's an implementation of a compile-time checked <code>CString</code> constructor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">CString</span> <span class=\"n\">where</span>\n  <span class=\"n\">contents</span> <span class=\"o\">:</span> <span class=\"n\">String</span>\n  <span class=\"n\">null_terminated</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">contents.data</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"sc\">'\\x00'</span><span class=\"o\">]</span> <span class=\"bp\">∧</span> <span class=\"sc\">'\\x00'</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.data</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">ih</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">null_terminated_of_isValid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">isValid</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">s.data</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"sc\">'\\x00'</span><span class=\"o\">]</span> <span class=\"bp\">∧</span> <span class=\"sc\">'\\x00'</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">CString.ofValid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">isValid</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">CString</span> <span class=\"n\">where</span>\n  <span class=\"n\">contents</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n  <span class=\"n\">null_terminated</span> <span class=\"o\">:=</span> <span class=\"n\">null_terminated_of_isValid</span> <span class=\"n\">s</span> <span class=\"n\">h</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"n\">elab</span> <span class=\"s2\">\"c!\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.getString</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.contains</span> <span class=\"sc\">'\\x00'</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"string contains null byte\"</span>\n  <span class=\"n\">return</span> <span class=\"n\">mkApp2</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">CString.ofValid</span> <span class=\"o\">[])</span> <span class=\"o\">(</span><span class=\"n\">mkStrLit</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\x00</span><span class=\"s2\">\"</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">Meta.mkEqRefl</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"bp\">``</span><span class=\"n\">true</span> <span class=\"o\">[]))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c</span><span class=\"bp\">!</span><span class=\"s2\">\"</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla\"</span>\n</code></pre></div>",
        "id": 388041305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693377494
    },
    {
        "content": "<p>there are simpler ways to do this which are less efficient and/or give less pointed error messages</p>",
        "id": 388041502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693377625
    },
    {
        "content": "<p>It can also be significantly simplified if you don't require a proof in the type system that the string is null-terminated and are satisfied with just compile-time checking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">local</span> <span class=\"n\">elab</span> <span class=\"s2\">\"c!\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">s.getString</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.contains</span> <span class=\"sc\">'\\x00'</span> <span class=\"k\">then</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"string contains null byte\"</span>\n  <span class=\"n\">return</span> <span class=\"n\">mkStrLit</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">++</span> <span class=\"s2\">\"</span><span class=\"se\">\\x00</span><span class=\"s2\">\"</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c</span><span class=\"bp\">!</span><span class=\"s2\">\"</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla</span>\n<span class=\"s2\">  bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla\"</span>\n</code></pre></div>",
        "id": 388041725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693377765
    },
    {
        "content": "<p>and here's a proof of that sorry:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">s.data</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">l</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">==</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">b</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">!=</span> <span class=\"mi\">0</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">ih</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Char.ofNat_toNat</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">Char.ofNat</span> <span class=\"n\">c.toNat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Char.ofNat</span><span class=\"o\">,</span> <span class=\"n\">dif_pos</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Char.toNat_inj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Char</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a.toNat</span> <span class=\"bp\">=</span> <span class=\"n\">b.toNat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a.ofNat_toNat</span><span class=\"o\">,</span> <span class=\"n\">b.ofNat_toNat</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">null_terminated_of_isValid</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">isValid</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">s.data</span> <span class=\"bp\">=</span> <span class=\"n\">l</span> <span class=\"bp\">++</span> <span class=\"o\">[</span><span class=\"sc\">'\\x00'</span><span class=\"o\">]</span> <span class=\"bp\">∧</span> <span class=\"sc\">'\\x00'</span> <span class=\"bp\">∉</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">unfold</span> <span class=\"n\">isValid</span>\n  <span class=\"n\">split</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro.</span>\n  <span class=\"bp\">·</span> <span class=\"n\">next</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"n\">eq</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">clear</span> <span class=\"n\">eq</span><span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Char.toNat_inj</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"sc\">'\\x00'</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨[],</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"k\">fun</span><span class=\"bp\">.</span><span class=\"o\">⟩</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">h4</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">b</span> <span class=\"n\">h2</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h3</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h4</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 388043203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693378601
    },
    {
        "content": "<p>Here's a fancier implementation of the compile-time checker which actually highlights the null bytes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Lean.Position</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Syntax</span>\n\n<span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">findNull</span> <span class=\"o\">(</span><span class=\"n\">off</span> <span class=\"o\">:</span> <span class=\"n\">String.Pos</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">String.Pos</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">String</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">s.get</span> <span class=\"n\">i</span>\n  <span class=\"k\">let</span> <span class=\"n\">i'</span> <span class=\"o\">:=</span> <span class=\"n\">s.next</span> <span class=\"n\">i</span>\n  <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"bp\">==</span> <span class=\"sc\">'\\\"'</span> <span class=\"k\">then</span> <span class=\"n\">return</span> <span class=\"n\">acc</span>\n  <span class=\"k\">if</span> <span class=\"n\">s.atEnd</span> <span class=\"n\">i'</span> <span class=\"k\">then</span> <span class=\"n\">Elab.throwUnsupportedSyntax</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"bp\">==</span> <span class=\"sc\">'\\\\'</span> <span class=\"k\">then</span> <span class=\"n\">decodeQuotedChar</span> <span class=\"n\">s</span> <span class=\"n\">i'</span> <span class=\"k\">else</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">i'</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Elab.throwUnsupportedSyntax</span>\n  <span class=\"k\">if</span> <span class=\"n\">c</span> <span class=\"bp\">==</span> <span class=\"sc\">'\\x00'</span> <span class=\"k\">then</span>\n    <span class=\"n\">logErrorAt</span> <span class=\"o\">(</span><span class=\"n\">ofRange</span> <span class=\"o\">⟨</span><span class=\"n\">off</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">off</span> <span class=\"bp\">+</span> <span class=\"n\">i'</span><span class=\"o\">⟩)</span> <span class=\"s2\">\"string contains null byte\"</span>\n    <span class=\"n\">findNull</span> <span class=\"n\">off</span> <span class=\"n\">s</span> <span class=\"n\">i'</span> <span class=\"n\">acc</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">findNull</span> <span class=\"n\">off</span> <span class=\"n\">s</span> <span class=\"n\">i'</span> <span class=\"o\">(</span><span class=\"n\">acc.push</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kn\">local</span> <span class=\"n\">elab</span> <span class=\"s2\">\"c!\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">isLit</span><span class=\"bp\">?</span> <span class=\"n\">strLitKind</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">Elab.throwUnsupportedSyntax</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"k\">if</span> <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"n\">s.raw.getPos</span><span class=\"bp\">?</span> <span class=\"k\">then</span>\n    <span class=\"n\">findNull</span> <span class=\"n\">pos</span> <span class=\"n\">val</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">⟩</span> <span class=\"s2\">\"\"</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">let</span> <span class=\"n\">some</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">decodeStrLit</span> <span class=\"n\">val</span> <span class=\"bp\">|</span> <span class=\"n\">Elab.throwUnsupportedSyntax</span>\n    <span class=\"k\">if</span> <span class=\"n\">s.contains</span> <span class=\"sc\">'\\x00'</span> <span class=\"k\">then</span>\n      <span class=\"n\">logError</span> <span class=\"s2\">\"string contains null byte\"</span>\n    <span class=\"n\">pure</span> <span class=\"n\">s</span>\n  <span class=\"n\">return</span> <span class=\"n\">mkStrLit</span> <span class=\"o\">(</span><span class=\"n\">s.push</span> <span class=\"sc\">'\\x00'</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">c</span><span class=\"bp\">!</span><span class=\"s2\">\"</span><span class=\"se\">\\x00</span><span class=\"s2\"> bla </span><span class=\"se\">\\x00</span><span class=\"s2\"> bla\"</span>\n</code></pre></div>",
        "id": 388046576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693380143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> Interesting. That's the kind of examples of practical usage of Lean that I would like to learn more from. Current books about Lean are quite lacking in examples.</p>",
        "id": 388049637,
        "sender_full_name": "Fredrik",
        "timestamp": 1693381541
    },
    {
        "content": "<p>The best thing we have for metaprogramming right now is <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book\">https://github.com/leanprover-community/lean4-metaprogramming-book</a>, but the API is pretty huge and still mostly undocumented so it's a long road</p>",
        "id": 388051662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693382386
    },
    {
        "content": "<p>The basic idea is \"everything lean does is implemented in some lean function, so you can just copy and modify it to suit your goals\"</p>",
        "id": 388051861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693382446
    },
    {
        "content": "<p>for example <code>findNull</code> is adapted from <code>decodeStrLitAux</code> which is called by <code>TSyntax.getString?</code> which is how string literals are decoded</p>",
        "id": 388052056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1693382523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> I'll have to read the metaprogramming book once I'm done with the functional programming book and the theorem proving book.</p>",
        "id": 388058490,
        "sender_full_name": "Fredrik",
        "timestamp": 1693384850
    }
]