[
    {
        "content": "<p>I have a proof which is mysteriously (to me) failing to synthesize a type class instance.  I've distilled the issue into a simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"c1\">-- failed to synthesize PartialEquivBEq (Option T)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">PartialEquivBEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Because <code>EquivBEq T</code> implies <code>PartialEquivBEq T</code> (right?), I'm surprised that we can't synthesize <code>PartialEquivBEq (Option T)</code>.  I've been able to synthesize <code>PartialEquivBEq (Option ...)</code> in other examples and even adding <code>variable [PartialEquivBEq T]</code> to the above doesn't correct the problem.  Is there a good way to diagnose why a type class instance can't be synthesized or what steps Lean attempted to take to synthesize it?</p>",
        "id": 540516038,
        "sender_full_name": "Zach",
        "timestamp": 1758307440
    },
    {
        "content": "<p>Well, there is no <code>EquivBEq</code> instance for <code>Option</code>. In other cases it presumably went through <code>LawfulBEq</code></p>",
        "id": 540516428,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758307619
    },
    {
        "content": "<p>I see; thanks!  Is there a way for me to ask lean <em>how</em> it has synthesized a type class instance so I can see this line of reasoning?</p>",
        "id": 540516611,
        "sender_full_name": "Zach",
        "timestamp": 1758307700
    },
    {
        "content": "<p>Well, for one you can recursively hover over the output of <code>#synth</code> to see which instances it used. If you want to know how it got the answer you can also use <code>set_option trace.Meta.synthInstance true in</code> above the <code>#synth</code></p>",
        "id": 540518905,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1758308670
    },
    {
        "content": "<p>Thanks again!  This is helpful.  It hadn't occurred to me that the solution to my other tests was via <code>LawfulBEq</code>.  I'm trying to write some proofs generally enough that <code>==</code> could over-equate things (e.g. two sets represented as lists could use <code>==</code> to canonicalize).  Perhaps that's against the grain of how I'm expected to work.</p>\n<p>I'm a little surprised that there's no <code>PartialEquivBEq</code> for <code>Option</code>, but I'm guessing that's just because not everything can be in the standard library.  The upside is that I can declare my own instance if I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialEquivBEq</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PartialEquivBEq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">PartialEquivBEq</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">  </span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">H1</span><span class=\"w\"> </span><span class=\"n\">H2</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"n\">c'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">PartialEquivBEq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">H1</span><span class=\"w\"> </span><span class=\"n\">H2</span>\n</code></pre></div>\n<p>Thanks for the help!</p>",
        "id": 540520519,
        "sender_full_name": "Zach",
        "timestamp": 1758309397
    }
]