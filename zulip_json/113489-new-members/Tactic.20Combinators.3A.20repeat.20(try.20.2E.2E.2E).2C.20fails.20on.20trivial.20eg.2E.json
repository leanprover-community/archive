[
    {
        "content": "<p>Been playing around with tactic combinators but I can't wrap my head around the following example I came up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">assumption</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This returns a maximum recursion depth, why? Now, I know that <code>repeat</code> will keep going until the tactic it was given fails, and one of the form <code>try ...</code> never does. It seems like the <code>repeat</code> tactic doesn't stop when the goal is satisfied, which I guess matches the documentation '<code>repeat tac</code> repeatedly applies <code>tac</code> so long as it succeeds.' Shouldn't it stop when the goal is proven? This really wrecked my understanding of how the <code>repeat</code> tactic works.<br>\nDoes this mean that for this example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">assumption</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>assumption</code> is ran once proving the goal, then it is run again which would fail because there is nothing to do, leading <code>repeat</code> to stop? <br>\nI have read the part where <code>repeat</code> first appears in chapter 5 in tpil4,  but the book doesn't convey this. Should this be explicitly mentioned because it threw me off for a bit.</p>",
        "id": 459517864,
        "sender_full_name": "Jad Abou Hawili",
        "timestamp": 1723220742
    },
    {
        "content": "<p>What is probably going on here is that, once no goals are left, you are not automatically \"outside\" of the proof.  For instance, the tactic <code>done</code> is specifically designed to check that... you are done!  So it lives exactly in the very small space between where there are no goals and where the next command starts.</p>",
        "id": 459519531,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723221238
    },
    {
        "content": "<p>Here, you are observing the same thing, I think: <code>assumption</code> fails in that narrow margin, since there are no goals, but <code>try assumption</code> succeeds, so <code>repeat (try assumption)</code> continues on indefinitely.</p>",
        "id": 459519675,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723221280
    },
    {
        "content": "<p>On the other hand, <code>repeat assumption</code> succeeds once, closing the goal, fails the second time around and reverts to the previous unfailing state, which is where the goal had been solved.</p>",
        "id": 459519780,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1723221318
    },
    {
        "content": "<p>not sure what the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> is that made you run into this, but maybe <code>any_goals assumption</code> helps?</p>",
        "id": 459521304,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723221846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Thanks for emphasizing the rolling back behavior and the <code>done</code> tactic. That helps.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Tactic.20Combinators.3A.20repeat.20.28try.20.2E.2E.2E.29.2C.20fails.20on.20trivial.20eg.2E/near/459521304\">said</a>:</p>\n<blockquote>\n<p>not sure what the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> is that made you run into this, but maybe <code>any_goals assumption</code> helps?</p>\n</blockquote>\n<p>I guess the 'root problem' would be that the automation is not transparent, i can't see what it's doing/trying and i don't know what algorithm it follows. Any pointers would help out alot. Maybe this should have been the question, how to see what proof automation is doing/trying. Can this be visualized as well, like a search tree or something?</p>",
        "id": 459871194,
        "sender_full_name": "Jad Abou Hawili",
        "timestamp": 1723371432
    },
    {
        "content": "<p>I am sure other people have asked a similar question but haven't found relevant channels yet.</p>",
        "id": 459871393,
        "sender_full_name": "Jad Abou Hawili",
        "timestamp": 1723371636
    }
]