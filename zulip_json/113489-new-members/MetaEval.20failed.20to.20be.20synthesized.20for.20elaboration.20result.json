[
    {
        "content": "<p>Looking at the <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/03_expressions.html\">metaprogramming book, ch.3</a>, the following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">addOne</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat.add</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">bvar</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"n\">BinderInfo</span><span class=\"bp\">.</span><span class=\"n\">default</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mapAddOneNil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">mkAppN</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``List.map</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">levelOne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">levelOne</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">addOne</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``List.nil</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">levelOne</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"o\">]</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"mapAddOneNil\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">mapAddOneNil</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mapAddOneNil</span>\n<span class=\"c1\">-- List.map (fun x =&gt; Nat.add x 1) [] : List Nat</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">universes</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">explicit</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">mapAddOneNil</span>\n<span class=\"c1\">-- @List.map.{1, 1} Nat Nat (fun x =&gt; Nat.add x 1) (@List.nil.{1} Nat) : List.{1} Nat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">mapAddOneNil</span>\n<span class=\"c1\">-- []</span>\n</code></pre></div>\n<p>However, adding <code>#eval mapAddOneNil</code> gives the error </p>\n<blockquote>\n<p>&lt;...&gt; has type  List ℕ but instance  MetaEval (List ℕ) failed to be synthesized</p>\n</blockquote>\n<p>Even though there definitely is such an instance. Why does this happen?</p>",
        "id": 462895029,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723864216
    },
    {
        "content": "<p>The example code is faulty, all <code>levelOne</code>s should be <code>levelZero</code>s as <code>List</code> takes <code>Type u</code> and <code>Nat</code> is a <code>Type 0</code></p>",
        "id": 462965893,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723891588
    },
    {
        "content": "<p>Right, thanks! Made a <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book/pull/144\">PR on the book repo</a> (which doesn't seem to be very actively maintained though)</p>\n<p>In that case, why does check and reduce work though? And how does one do a <code>.const</code> of a <code>Sort 0</code> (i.e. <code>Prop</code>)?</p>",
        "id": 462968921,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723893755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">Adomas Baliuka</span> <a href=\"#narrow/stream/113489-new-members/topic/MetaEval.20failed.20to.20be.20synthesized.20for.20elaboration.20result/near/462968921\">said</a>:</p>\n<blockquote>\n<p>In that case, why does check and reduce work though?</p>\n</blockquote>\n<p>The plumbing level of Lean necessarily assumes that all input expressions are well-formed; if a metaprogram breaks that assumption, some things may break and others may not.</p>\n<blockquote>\n<p>And how does one do a <code>.const</code> of a <code>Sort 0</code> (e.g. <code>Prop</code>)?</p>\n</blockquote>\n<p>If, unlike <code>List</code>, a type is defined in <code>Sort u</code>, then substituting <code>u</code> with <code>levelZero</code> does give you <code>Prop</code>. It entirely depends on the definition of the constant.</p>",
        "id": 462970449,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723894686
    },
    {
        "content": "<p>Last question: Is there a way to make the kernel \"check everything\" somehow and get a proper error message? For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expr_1eq1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``tmp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"elab_1eq1\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">expr_1eq1</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">elab_1eq1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">tmp</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>works but having a wrong universe level, e.g., switching <code>.const ``Eq [1]</code> to <code>.const ``Eq [0]</code> gives an error</p>\n<blockquote>\n<p>application type mismatch<br>\n Eq<br>\nargument has type<br>\n Type<br>\nbut function has type<br>\n {α : Prop} → α → α → Prop</p>\n</blockquote>\n<p>which I guess even makes sense when you think about it, but is there a way to find out that <code>elab_1eq1</code> is already malformed? The output of <code>#check elab_1eq1</code> looks misleadingly correct and <code>#eval</code> just fails to synthesize <code>Decidable</code>.</p>",
        "id": 462972024,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723895855
    },
    {
        "content": "<p>You could put in an explicit type check in your elaborator:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expr_1eq1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``tmp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Eq</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkNatLit</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"elab_1eq1\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">expr_1eq1</span>\n<span class=\"w\">  </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">e</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">elab_1eq1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"c1\">--^ \"application type mismatch ...\"</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">tmp</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 463009549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723912882
    },
    {
        "content": "<p>That's certainly nice, but I was hoping for something that doesn't require changing the elaborator (or even knowing which elaborator or macros are called while elaborating something)... I guess that's going into the direction of <a href=\"https://github.com/leanprover/lean4checker\">lean4checker</a>?</p>\n<p>Another question: Why does <code>#reduce elab_1eq1</code> not unfold <code>tmp</code>?</p>",
        "id": 463010002,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723912999
    },
    {
        "content": "<p>I don't think it's going in that direction — without the <code>Meta.check</code>, you see the type error on <code>example</code>. There's a typecheck happening somewhere without need for any external tools. (I don't remember if the <code>example</code> command itself is doing it, or if it's when the definition is passed to the kernel).</p>",
        "id": 463010775,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723913274
    },
    {
        "content": "<p>Potentially there could be some option you could set for debugging term elaborators, to type check every result from every elaboration, but elaborators can circumvent these checks in any number of ways, since they can, for example, assign unchecked expressions to metavariables. Without intercepting every metavariable assignment too, it's only at the very end of term elaboration that you can see that there's a type error.</p>",
        "id": 463011271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723913407
    },
    {
        "content": "<p>I guess I probably just want a version of <code>#check</code> that actually makes the kernel check the type (which I would naively have expected it would do)</p>",
        "id": 463011458,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723913466
    },
    {
        "content": "<p>Or at least the elaborator check the type (<code>Meta.check</code> is the elaborator's type checker, which is aware of things like metavariables, but then there's also the kernel type checker)</p>",
        "id": 463011653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723913520
    },
    {
        "content": "<p>There's an assumption that elaborators produce type correct terms, throwing an error themselves if the user supplied something that can't type check.</p>\n<p>It seems like it would make sense to have <code>#check</code> do a <code>Meta.check</code> just to be sure</p>",
        "id": 463011919,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723913575
    },
    {
        "content": "<p><code>#reduce</code> doesn't reduce types by default. Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">elab_1eq1</span>\n</code></pre></div>",
        "id": 463012188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723913623
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover/lean4/pull/5079\">lean4#5079</a> adds typechecking to <code>#check</code> and <code>#reduce</code>)</p>",
        "id": 463015120,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723914582
    },
    {
        "content": "<p>Thanks a lot! I hope this gets merged. </p>\n<p>This is still not a kernel check, right? How could one \"call the kernel explicitly\"? It doesn't seem like the metaprogramming book explains this (though I haven't read all of it carefully...). Why are there separate \"kernel\" and \"elaborator\" versions of type checking?</p>",
        "id": 463016776,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723915328
    },
    {
        "content": "<p>It's still not a kernel check. Regarding the difference between the elaborator and the kernel type checkers, the kernel type checker is only for fully elaborated terms without any metavariables, and the elaborator type checker is able to handle metavariables (and in general every expression that can appear partway through elaboration).</p>\n<p>As far as I know, the only way to invoke the kernel type checker is to create a declaration and try to add it to the environment.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"o\">:</span><span class=\"s2\">\"#typecheck \"</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">runTermElabM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withSynthesize</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">usedOnly</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">levelMVarToParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">instantiateMVars</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">hasMVar</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">throwError</span><span class=\"w\"> </span><span class=\"s2\">\"expression contains metavariables{indentD e}\"</span>\n<span class=\"w\">  </span><span class=\"n\">withoutModifyingEnv</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">      </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`_typecheck</span>\n<span class=\"w\">      </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getLevelNames</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span>\n<span class=\"w\">      </span><span class=\"n\">hints</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ReducibilityHints</span><span class=\"bp\">.</span><span class=\"kn\">abbrev</span>\n<span class=\"w\">      </span><span class=\"n\">safety</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DefinitionSafety</span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">    </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">logInfoAt</span><span class=\"w\"> </span><span class=\"n\">tk</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{e} : {← inferType e}\"</span>\n\n<span class=\"bp\">#</span><span class=\"n\">typecheck</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"c1\">-- expression contains metavariables</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"bad\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Option</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``True</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n<span class=\"bp\">#</span><span class=\"n\">typecheck</span><span class=\"w\"> </span><span class=\"n\">bad</span>\n<span class=\"c1\">-- application type mismatch</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">typecheck</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"c1\">-- fun x =&gt; 2 + x : Nat → Nat</span>\n</code></pre></div>",
        "id": 463082762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723948079
    },
    {
        "content": "<p>Thanks, this is great! </p>\n<p>The docstring of <code>inferType</code> says that it</p>\n<blockquote>\n<p>Returns the inferred type of the given expression, or fails if it is not type-correct.</p>\n</blockquote>\n<p>What is the meaning of \"type-correct\" here? Or is the docstring wrong, since it does actually accept <code>bad</code> (if  the<code>addDecl</code> step is removed)?</p>",
        "id": 463157570,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723982637
    },
    {
        "content": "<p>It will certainly detect type errors that make it impossible to infer a type but there are no guarantees that it will find all of them, no</p>",
        "id": 463172862,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723988142
    },
    {
        "content": "<p>So \"type-correct\" is a vaguely defined concept here? Meaning something like \"type-correct enough, as judged by this function's internals\"?</p>",
        "id": 463173407,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1723988384
    },
    {
        "content": "<p>Essentially yes. Detecting type errors is not its goal.</p>",
        "id": 463177851,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1723990153
    },
    {
        "content": "<p>I think the documentation is not correct here; it should say it fails <em>only if</em> it is not type-correct (or rather something like \"or fails if it detects it is not type-correct\"). Type-correctness shouldn't be a vaguely defined concept in a proof checker!</p>\n<p><a href=\"https://github.com/leanprover/lean4/pull/5087\">lean4#5087</a> has a clarified docstring.</p>",
        "id": 463220434,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724006884
    }
]