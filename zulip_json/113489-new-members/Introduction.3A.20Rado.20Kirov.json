[
    {
        "content": "<p>In leau of introduction, I wrote up a quick blog post about my experience finishing Theorem Proving in Lean4 - <a href=\"https://rkirov.github.io/posts/lean1\">https://rkirov.github.io/posts/lean1</a> and has more info about my background.</p>",
        "id": 500266690,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739822833
    },
    {
        "content": "<p>Re <code>Decidable</code>, here's another way the class could have been written:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Decidable'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"n\">eval_eq_true_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>It's a structure that records whether or not the given proposition is true. This lets you lift a given proposition to a boolean value that you can compute with. Propositions themselves do not have any computational content on their own (that's to say, there's no algorithm that can automatically prove that <code>p</code> is <code>True</code> or <code>False</code>), so this is a way to \"reflect\" logical propositions into a computable form.</p>\n<p>The actual <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a> is an inductive type with two constructors; I think of as being a \"heavy Bool\" that also records <em>what</em> is true or false and why.</p>\n<p>(I'm hoping in the future Lean will switch to a variant of <code>Decidable'</code>. It will help with some definitional equality issues we run into with <code>BEq</code>.)</p>",
        "id": 500269900,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739824342
    },
    {
        "content": "<p>Re <code>#eval</code> vs <code>#reduce</code>, the first takes the expression, compiles it, and evaluates the compiled code (it doesn't build a binary, but it at least runs the IR (intermediate representation) in a VM). If you <code>#eval</code> a proposition, it will try to find a <code>Decidable</code> instance and evaluate the proposition as a <code>Bool</code> (hence why you see <code>true</code> and <code>false</code> rather than <code>True</code> and <code>False</code> as the result!).</p>\n<p>The second, <code>#reduce</code>, instead uses the reduction rules of lambda calculus, and symbolically tries to evaluate the expression to normal form. Sometimes <code>#reduce</code> gets stuck on computations that <code>#eval</code> doesn't get stuck on. The main difference is that <code>#eval</code> erases all types and proofs during compilation, essentially simplifying the expression first into an untyped lambda calculus, which is more flexible for computation.</p>",
        "id": 500270697,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739824717
    },
    {
        "content": "<p>Re <code>simp</code>: don't confuse it for <code>Simplify[...]</code>. It <em>tends</em> to simplify, but it's not a simplifier per se. It's a rewrite rule engine, with features that handle applying rewrites deep within expressions automatically (while generating proofs of course!) using so-called congruence lemmas.</p>\n<p>The <code>Simplify[...]</code> function in Mathematica also is a rewrite rule system, but it is actually trying to simplify the expression, and in contrast to <code>simp</code> it applies its rules <em>nondeterministically</em> (i.e., it explores rewrites along a graph of possibilities). It tries applying a good number of rewrites and then returns the expression it finds that minimizes some complexity measure.</p>\n<p>In principle we could (and probably should!) have a <code>Simplify[...]</code> in Lean, especially with some of the congruence closure modules in the <code>cc</code> and/or <code>grind</code> tactics.</p>",
        "id": 500271409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739825060
    },
    {
        "content": "<p>Re <code>rfl</code> and defeq: it's best to use <code>rfl</code> only if you know the definitions, and you know the definitions are supposed to be unfolded. Breaking through the abstraction barriers with <code>rfl</code> and forcing a computation (in the <code>#reduce</code> sense) is sometimes known as a \"heavy <code>rfl</code>\".</p>\n<p>In large library design, we tend to prefer using rewrite lemmas.</p>",
        "id": 500271730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739825218
    },
    {
        "content": "<p>Thanks for all the answers again, it will take me a bit of time to absorb :)</p>",
        "id": 500271972,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739825336
    },
    {
        "content": "<p>What’s the simplest non decidable prop with  Nats? Since decidable is a class, can it be make decidable with an extra instance ?</p>",
        "id": 500272072,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739825397
    },
    {
        "content": "<p>I do not know if the example below is undecidable in the technical sense (and probably it isn't), but the statement \"there are odd perfect numbers\" is something for which it would be interesting to have a <code>Decidable</code> instance!</p>",
        "id": 500272835,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739825755
    },
    {
        "content": "<p>For an actually undecidable statement, you can look at <a href=\"https://math.uchicago.edu/~shmuel/lg-readings/martin%20davis,%20hilbert%2010.pdf\">Hilbert's Tenth Problem</a>.</p>",
        "id": 500273062,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1739825855
    },
    {
        "content": "<p>Yeah that’s what I am struggling with - separating proven to be non decidable in all systems and practically non-decidable because something is missing an type class instance</p>",
        "id": 500273345,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739825991
    },
    {
        "content": "<p>Along those lines, given an arbitrary function <code>f : Nat -&gt; Nat</code>, you can't generally decide <code>forall n, f n = 0</code>. Hilbert's 10th problem is a special case of this, where we restrict the possibilities of <code>f</code> to be multivariable polynomials (one can encode multivariables polynomials as such an <code>f</code>).</p>",
        "id": 500273456,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826025
    },
    {
        "content": "<p>What would the algorithm be? We could <em>semi</em>decide it by evaluating <code>f</code> at successive integers, returning <code>false</code> as soon as we find an <code>n</code> where <code>f n != 0</code>. But we can't know for sure that <code>f</code> is always zero.</p>",
        "id": 500273653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826117
    },
    {
        "content": "<p>For specific examples of <code>f</code>, of course one can decide whether it's true without needing to fall back on evaluating it over its whole domain. Here's one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">push_neg</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 500273989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826260
    },
    {
        "content": "<p>That one would have been semidecided, so here another</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 500274139,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826330
    },
    {
        "content": "<p>Perfect that’s helpful, now I wonder for which of the proved props one has to write that instance vs it gets automatically generated because of some type class magic ?</p>",
        "id": 500274252,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739826376
    },
    {
        "content": "<p>(Complicating things, in Lean <em>every proposition is technically decidable</em> via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.propDecidable#doc\">docs#Classical.propDecidable</a>, but that is <code>noncomputable</code> and can't be used with <code>#eval</code>. It uses the <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a> to \"construct\" a decision. There's no code backing that up however, hence the need for the <code>noncomputable</code> modifier to tell Lean to not try to compile it.)</p>",
        "id": 500274377,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826457
    },
    {
        "content": "<p>The typeclass magic consists of a whole library of instances like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instDecidableAnd#doc\">docs#instDecidableAnd</a>, which can decide <code>p ∧ q</code> by deciding <code>p</code> and <code>q</code>.</p>",
        "id": 500274555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826549
    },
    {
        "content": "<p>The instances syntactically match on the proposition, which is how it can be broken apart and \"compiled\" into a decision procedure for it.</p>",
        "id": 500274705,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739826621
    },
    {
        "content": "<p>So if I start building more complicated props when do they stop being decidable - x=y is decidable, adding propositional logic basic ops is too, but is it at first order - existential and universal quantifiers when props stop being decidable or when one uses LEM?</p>",
        "id": 500275153,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739826855
    },
    {
        "content": "<p><code>x = y</code> isn't actually decidable by default -- there's the abbreviation <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DecidableEq#doc\">docs#DecidableEq</a> to bring in <code>forall (x y : T), Decidable (x = y)</code></p>",
        "id": 500275669,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739827132
    },
    {
        "content": "<p>Actually, <code>x = y</code> is not always decidable, even for fairly simple constructs. In contrast, every formula in a decidable theory is decidable.</p>\n<p>Once you start being able to encode turing machines in your propositions, is when it stops being decidable</p>",
        "id": 500275715,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1739827158
    },
    {
        "content": "<blockquote>\n<p>My main critique is that sometimes it starts using concepts or syntax that was not introduced earlier (the curse of knowledge for the authors).</p>\n</blockquote>\n<p>I would argue this is not because of the curse of knowledge but because authors wanted relatively short and \"practical\" tutorial. So a lot of essential background is missing.</p>",
        "id": 500275761,
        "sender_full_name": "suhr",
        "timestamp": 1739827195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/Introduction.3A.20Rado.20Kirov/near/500275153\">said</a>:</p>\n<blockquote>\n<p>existential and universal quantifiers</p>\n</blockquote>\n<p>Yeah, this is a way nondecidability creeps in. Also inductively defined <code>Prop</code>s in general (<code>Eq</code> is such an example).</p>\n<p>For what it's worth, there are <code>Decidable</code> instances for quantifiers when the domain is finite (via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a>).</p>",
        "id": 500275989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739827298
    },
    {
        "content": "<p>Ok that is starting to make sense on decidability and gives me enough pointers to look more into it. I see newcomers get tripped on prop vs bool. Funny enough coming from typescript I am very comfortable with that - types are checked and erased, there is no reification at runtime, the whole type language is separately evolved and bolted on a Js runtime. But decidable makes lean not only have that separation but also allow one to bridge it when needed, which is wild :)</p>",
        "id": 500276462,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739827534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/113489-new-members/topic/Introduction.3A.20Rado.20Kirov/near/500275761\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>My main critique is that sometimes it starts using concepts or syntax that was not introduced earlier (the curse of knowledge for the authors).</p>\n</blockquote>\n<p>I would argue this is not because of the curse of knowledge but because authors wanted relatively short and \"practical\" tutorial. So a lot of essential background is missing.</p>\n</blockquote>\n<p>I have some concrete example where for example “class … extend …” was used for the first time in a section for another concept and had me “ah type classes can extend like structures” but that wasn’t said directly just used in a fancier example. So not really background. Anyways I will file GitHub issues for those and can discuss them there.</p>",
        "id": 500276751,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739827682
    },
    {
        "content": "<p>It’s hard to capture how “alien tech” lean feels even for someone that has done programming and math for awhile</p>",
        "id": 500278047,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739828394
    },
    {
        "content": "<p>Yeah, constructive logic turned into a programming language with some extras (like type classes) borrowed from other functional programming languages is not that a classical mathematician or an ordinary programmer is used to see. Though, programmers sometimes play with a lot of weird stuff.</p>",
        "id": 500282871,
        "sender_full_name": "suhr",
        "timestamp": 1739830673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/stream/113489-new-members/topic/Introduction.3A.20Rado.20Kirov/near/500275715\">said</a>:</p>\n<blockquote>\n<p>Actually, <code>x = y</code> is not always decidable, even for fairly simple constructs. In contrast, every formula in a decidable theory is decidable.</p>\n<p>Once you start being able to encode turing machines in your propositions, is when it stops being decidable</p>\n</blockquote>\n<p>To give a concrete example:</p>\n<p>Equality on real numbers is undecidable. You could have <code>0.000...</code>, and without inspecting infinitely many digits, you wouldn't know if it's all zeros (hence equal to <code>0</code>), or it actually ends in <code>...0001</code>.</p>",
        "id": 500288277,
        "sender_full_name": "Chris Wong",
        "timestamp": 1739834107
    },
    {
        "content": "<p>Wrote up some more random notes on Lean as I finished first half of MIL - <a href=\"https://rkirov.github.io/posts/lean2/\">https://rkirov.github.io/posts/lean2/</a> . It's been lots of fun so far and I have learned a lot from all the conversations happening on here.</p>",
        "id": 502916813,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740962283
    },
    {
        "content": "<p>The links to the puzzle games didn't work for me</p>",
        "id": 502966678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740990479
    },
    {
        "content": "<p>It's <a href=\"https://rkirov.github.io/posts/puzzles2024/\">https://rkirov.github.io/posts/puzzles2024/</a></p>",
        "id": 502998391,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741000050
    },
    {
        "content": "<p>ops, fixed the links, thanks for catching that. Speaking of puzzles, I have been wondering how would an even more gamified version of the number game look like - like visually represent inductive types and their reductions though something like moving boxes, etc. Patrick's Parabox is an example of a puzzle game that has non-trivial math content (though not matching any real math theory) as it reifies infinity paradoxes.</p>",
        "id": 503053410,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741015302
    },
    {
        "content": "<p>Theorem proving always reminds me of Baba Is You.</p>",
        "id": 503055929,
        "sender_full_name": "suhr",
        "timestamp": 1741015928
    }
]