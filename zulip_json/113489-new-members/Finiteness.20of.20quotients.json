[
    {
        "content": "<p>I am trying to show that if the set of equivalence classes of an equivalence relation <code>r : Setoid α</code> (in the sense of <code>Setoid.classes r</code>) is finite, then the quotient is finite. For this I hoped to use some bijection or equivalence between the quotient and the set of equivalence classes, but I can't find anything in this direction.</p>",
        "id": 394019847,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696031147
    },
    {
        "content": "<p>I suppose you could look around <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Setoid.classes#doc\">docs#Setoid.classes</a></p>",
        "id": 394020337,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696031542
    },
    {
        "content": "<p>But having said that, if you’re using equivalence classes then it’s likely that you’re trying to do something in a suboptimal way. Can you un - <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> ?</p>",
        "id": 394020388,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696031597
    },
    {
        "content": "<p>I want to show that in a compact topological group <code>G</code>, any open subgroup <code>U</code> has finite index. This is because the cosets of <code>U</code> form a disjoint open cover of <code>G</code>. Then by compactness, one obtains that the number of cosets is finite. But now I somehow have to say that the number of cosets, aka cardinality of <code>Setoid.classes (QuotientGroup.leftRel U)</code>, is the cardinality of <code>G / U</code>.</p>",
        "id": 394020807,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696031947
    },
    {
        "content": "<p>What is your definition of index?</p>\n<p>Every definition matters in lean. In maths we just say \"the following five things are equal and they're all called the index\". In lean it doesn't work like that, you have to say much more precisely what you mean. The best way to ask your question is not to post what you've written above, but to post something called an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (this is a link explaining what I mean). Then it's much easier to help you. It's work writing a MWE but it's work well spent because it enables people to quickly answer your actual precise question as well as being able to comment on design decisions. You've chosen a very nice mathematical question to work on but now we need to see the details.</p>",
        "id": 394052297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696053110
    },
    {
        "content": "<p>I use the definition in <code>Mathlib.GroupTheory.Index</code>. The idea was to use <code>Subgroup.index_ne_zero_of_finite</code>, so I only need to show <code>Finite (G / U)</code>. Here is a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Index</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Group.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Setoid.Partition</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">Partition</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">IsCompact.openPartition_finite</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.IsPartition</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">IsOpen</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">c.Finite</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- I have a proof for this, deduced from IsCompact.elim_finite_subcover</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Partition</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">U.index</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.classes</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.leftRel</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_partition</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.IsPartition</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.isPartition_classes</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.leftRel</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_finite</span> <span class=\"o\">:</span> <span class=\"n\">A.Finite</span> <span class=\"o\">:=</span> <span class=\"n\">IsCompact.openPartition_finite</span> <span class=\"n\">A</span> <span class=\"n\">A_partition</span> <span class=\"n\">A_open</span>\n    <span class=\"gr\">admit</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Subgroup.index_ne_zero_of_finite</span>\n</code></pre></div>\n<p>Maybe one can try building an indexed partition and use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IndexedPartition.equivQuotient#doc\">docs#IndexedPartition.equivQuotient</a></p>",
        "id": 394056652,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696056851
    },
    {
        "content": "<p>One can certainly construct  an <code>IndexedPartition</code> <code>P</code> using the noncomputable <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IndexedPartition.mk%27#doc\">docs#IndexedPartition.mk'</a> and one then obtains an equivalence <code>A ≃ IndexedPartition.Quotient P</code>. But now I still need to have some equivalence from the actual quotient <code>G / U</code> and <code>IndexedPartition.Quotient P</code>.</p>",
        "id": 394061415,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696060058
    },
    {
        "content": "<p>Yeah it seems like there's not much API for <code>Setoid.classes</code>. That file was initially written by Amelia Livingston, who was at the time an undergraduate at Imperial (maybe 2019?), because I assured her that the relationship between equivalence classes and partitions was fundamental to mathematics (why else would I spend an entire hour proving this to 1st year undergraduates every year?). To my great surprise this file got very little use; even now, according to <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Setoid/Partition.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Setoid/Partition.html</a> , it is only imported by one other file (in graph theory). So it looks like you found a hole in the API (which should be filled). In fact what is fundamental to mathematics is the universal property of quotients, it turns out.</p>",
        "id": 394064380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696062854
    },
    {
        "content": "<p>Do you think it is a good idea to try to establish an equivalence between <code>Quotient s</code> and <code>Setoid.classes s</code>?</p>",
        "id": 394064561,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696063026
    },
    {
        "content": "<p>I'm pretty sure that exists, because I remember Kevin PRing a docstring for it!</p>",
        "id": 394064678,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696063108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span>  Quotient, Setoid.classes</p>",
        "id": 394064895,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696063243
    },
    {
        "content": "<p>I can't find it. Modulo that, you're done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">maybe_missing_api</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Setoid.classes_equiv_quotient</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.classes</span> <span class=\"n\">r</span> <span class=\"bp\">≃</span> <span class=\"n\">Quotient</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">maybe_missing_api</span>\n\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">U.index</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">let</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.classes</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.leftRel</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_partition</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.IsPartition</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.isPartition_classes</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.leftRel</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_open</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">have</span> <span class=\"n\">A_finite</span> <span class=\"o\">:</span> <span class=\"n\">A.Finite</span> <span class=\"o\">:=</span> <span class=\"n\">IsCompact.openPartition_finite</span> <span class=\"n\">A</span> <span class=\"n\">A_partition</span> <span class=\"n\">A_open</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">Set.finite_coe_iff</span><span class=\"o\">,</span>\n         <span class=\"n\">Equiv.finite_iff</span> <span class=\"o\">(</span><span class=\"n\">QuotientGroup.leftRel</span> <span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">classes_equiv_quotient</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">A_finite</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Subgroup.index_ne_zero_of_finite</span>\n</code></pre></div>",
        "id": 394064915,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696063269
    },
    {
        "content": "<p>Yes, thats what I was aiming for.</p>",
        "id": 394065005,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696063329
    },
    {
        "content": "<p>I don't know why loogle isn't responding here but the <a href=\"https://loogle.lean-fro.org/?q=Quotient%2C+Setoid.classes\">web version</a> is reporting 0 matches</p>",
        "id": 394065085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696063439
    },
    {
        "content": "<p>Maybe we lost it in the port?</p>",
        "id": 394065298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1696063611
    },
    {
        "content": "<p>Ask Jeremy to look under the benches at the Hoskinson</p>",
        "id": 394065322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696063635
    },
    {
        "content": "<p>I PR'ed this docstring:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The order-preserving bijection between equivalence relations on a type `α`, and</span>\n<span class=\"sd\">  partitions of `α` into subsets. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Partition.orderIso</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"o\">{</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">//</span> <span class=\"n\">IsPartition</span> <span class=\"n\">C</span> <span class=\"o\">}</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 394065479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696063775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> In graph theory, the way <code>Setoid.classes</code> pops up is in going from a graph coloring to a graph partition (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Coloring.toPartition#doc\">docs#SimpleGraph.Coloring.toPartition</a>). The difference between a coloring and a partition is that a coloring is a labeled partition, or conversely a partition is a coloring modulo the symmetry group for the colors. Maybe it's telling that <code>Mathlib.Combinatorics.SimpleGraph.Partition</code> isn't imported by anything yet... In any case, this gives a nice construction to remove unused colors via an adjunction between colorings and partitions (you re-color the graph using the color classes themselves as colors).</p>",
        "id": 394065518,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1696063804
    },
    {
        "content": "<p>So I suppose it does not exist yet, so I try to write a version myself.</p>",
        "id": 394065711,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696063958
    },
    {
        "content": "<p>It will be fiddly :-/ Get the maps right and hope <code>aesop</code> proves the diagrams commute.</p>",
        "id": 394066267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696064377
    },
    {
        "content": "<p>I wrote something down using the universal property of the quotient, it is still quite unpolished, but I am stuck at one seemingly trivial step:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Setoid.Partition</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span> <span class=\"bp\">≃</span> <span class=\"n\">Setoid.classes</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">cls</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.classes</span> <span class=\"n\">s</span>\n  <span class=\"k\">have</span> <span class=\"n\">is_part</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.IsPartition</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.isPartition_classes</span> <span class=\"n\">s</span>\n  <span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">},</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n  <span class=\"k\">have</span> <span class=\"n\">f_val</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"n\">f_respects_relation</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">a_rel_b</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.symm</span> <span class=\"n\">a_rel_b</span>\n    <span class=\"k\">have</span> <span class=\"n\">eq_cls</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">Setoid.eq_of_mem_classes</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">a</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Setoid.symm</span> <span class=\"n\">a_rel_b</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">b</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Setoid.refl</span> <span class=\"n\">b</span>\n    <span class=\"k\">let</span> <span class=\"n\">cl_a</span> <span class=\"o\">:</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n    <span class=\"k\">let</span> <span class=\"n\">cl_b</span> <span class=\"o\">:</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"o\">⟨{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">cl_a</span> <span class=\"bp\">=</span> <span class=\"n\">cl_b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">eq_cls</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">,</span> <span class=\"n\">f_val</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">f_val</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">eq_cls</span>\n  <span class=\"c1\">--have h : Quotient s → cls := Quot.lift f f_respects_relation</span>\n  <span class=\"k\">have</span> <span class=\"n\">h_bij</span> <span class=\"o\">:</span> <span class=\"n\">Function.Bijective</span> <span class=\"o\">(</span><span class=\"n\">Quot.lift</span> <span class=\"n\">f</span> <span class=\"n\">f_respects_relation</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">.</span> <span class=\"n\">intro</span> <span class=\"o\">(</span><span class=\"n\">q_a</span> <span class=\"o\">:</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q_b</span> <span class=\"o\">:</span> <span class=\"n\">Quotient</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.exists_rep</span> <span class=\"n\">q_a</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.exists_rep</span> <span class=\"n\">q_b</span>\n      <span class=\"n\">intro</span> <span class=\"n\">h_eq</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hb</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Quotient.lift_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h_eq</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"n\">Subtype.val</span> <span class=\"n\">h_eq</span>\n      <span class=\"k\">have</span> <span class=\"n\">cls_eq</span> <span class=\"o\">:</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">f_val</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">f_val</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n        <span class=\"n\">assumption</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.refl</span> <span class=\"n\">a</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">cls_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n        <span class=\"n\">exact</span> <span class=\"n\">this</span>\n      <span class=\"n\">exact</span> <span class=\"n\">Quotient.sound</span> <span class=\"n\">this</span>\n    <span class=\"bp\">.</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Quot.surjective_lift</span> <span class=\"n\">f_respects_relation</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n      <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c_in_cls</span><span class=\"o\">⟩</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">c.Nonempty</span> <span class=\"o\">:=</span> <span class=\"n\">Setoid.nonempty_of_mem_partition</span> <span class=\"n\">is_part</span> <span class=\"n\">c_in_cls</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a_in_c</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span>\n      <span class=\"k\">let</span> <span class=\"n\">cl_a</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Setoid.r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span>\n      <span class=\"k\">have</span> <span class=\"n\">cl_a_eq_c</span> <span class=\"o\">:</span> <span class=\"n\">cl_a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n        <span class=\"n\">apply</span> <span class=\"n\">Setoid.eq_of_mem_classes</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Setoid.mem_classes</span> <span class=\"n\">s</span> <span class=\"n\">a</span>\n        <span class=\"n\">exact</span> <span class=\"n\">Setoid.refl</span> <span class=\"n\">a</span>\n        <span class=\"n\">exact</span> <span class=\"n\">c_in_cls</span>\n        <span class=\"n\">exact</span> <span class=\"n\">a_in_c</span>\n      <span class=\"n\">exists</span> <span class=\"n\">a</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">cl_a_eq_c</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">f_val</span> <span class=\"n\">a</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Equiv.ofBijective</span> <span class=\"o\">(</span><span class=\"n\">Quot.lift</span> <span class=\"n\">f</span> <span class=\"n\">f_respects_relation</span><span class=\"o\">)</span> <span class=\"n\">h_bij</span>\n</code></pre></div>\n<p>I can't resolve the <code>sorry</code>. Neither <code>rfl</code>, <code>simp</code>, <code>aesop</code>, <code>exact?</code> proof this, although I feel like this should hold by the very definition of <code>f</code>.</p>",
        "id": 394070565,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696068057
    },
    {
        "content": "<p>I fixed it by replacing <code>have</code> with <code>let</code>. Now I dont even need the <code>f_val</code>. Somehow I thought <code>have</code> and <code>let</code> are the same thing.</p>",
        "id": 394070981,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696068451
    },
    {
        "content": "<p><code>have</code> can't be used for data because it forgets the answer. <code>have a : Nat := 37</code> only ends up with Lean knowing <code>a</code> is a Nat so you can't prove it's 37. Whereas <code>let a : Nat := 37</code> means that <code>a = 37</code> and the proof is <code>rfl</code>.</p>",
        "id": 394071096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696068562
    },
    {
        "content": "<p>I see, makes sense. Thank you.</p>",
        "id": 394071117,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696068595
    },
    {
        "content": "<p>This is Ok with proofs becase if I have <code>h : P</code> then who cares what the proof was, all we need to know is that <code>h</code> has type <code>P</code> and is thus a proof of <code>P</code>. Indeed any two proofs of <code>P</code> are equal and the proof is <code>rfl</code>.</p>",
        "id": 394071154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696068605
    },
    {
        "content": "<p>Well done for getting that out by the way!</p>",
        "id": 394071180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696068632
    },
    {
        "content": "<p>Should I PR a polished version of this? If yes, where should it go? I suppose in <code>Setoid.Data.Partition</code>?</p>",
        "id": 394073178,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696070213
    },
    {
        "content": "<p>This is what I came up with but it's still pretty horrible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">maybe_missing_api</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.class_eq_class_of_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≈</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">c</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">trans'</span> <span class=\"n\">r</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">symm'</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">trans'</span> <span class=\"n\">r</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">symm'</span> <span class=\"n\">r</span> <span class=\"n\">h'</span><span class=\"o\">))⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.equiv_of_class_eq_class</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≈</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">refl'</span> <span class=\"n\">r</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Setoid.classes_equiv_quotient</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Setoid.classes</span> <span class=\"n\">r</span> <span class=\"bp\">≃</span> <span class=\"n\">Quotient</span> <span class=\"n\">r</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦</span><span class=\"n\">x.2.choose</span><span class=\"bp\">⟧</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">r.Rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">},</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">r.class_eq_class_of_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"n\">y</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Quotient.lift_mk</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.choose_spec</span> <span class=\"o\">(</span><span class=\"n\">Subtype.property</span>\n      <span class=\"o\">(⟨{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">x</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Quotient.inductionOn</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.sound</span> <span class=\"bp\">&lt;|</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">r.equiv_of_class_eq_class</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.choose_spec</span> <span class=\"o\">(</span><span class=\"n\">Subtype.property</span>\n      <span class=\"o\">(</span><span class=\"n\">Quotient.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"o\">(⟨{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">r.class_eq_class_of_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">])</span>\n      <span class=\"o\">(</span><span class=\"n\">Quotient.mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Quotient.lift</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"o\">(⟨{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">)))</span>\n        <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Quotient.mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">maybe_missing_api</span>\n</code></pre></div>",
        "id": 394073927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696070845
    },
    {
        "content": "<p>I don't have the permission to open branches on <code>mathlib4</code> yet. Could you grant me this? My github handle is @chrisflav</p>",
        "id": 394074162,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696071082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Finiteness.20of.20quotients/near/394073927\">said</a>:</p>\n<blockquote>\n<p>This is what I came up with but it's still pretty horrible:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">maybe_missing_api</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.class_eq_class_of_equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≈</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">c</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">trans'</span> <span class=\"n\">r</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">h'</span> <span class=\"bp\">↦</span> <span class=\"n\">symm'</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">trans'</span> <span class=\"n\">r</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">symm'</span> <span class=\"n\">r</span> <span class=\"n\">h'</span><span class=\"o\">))⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Setoid.equiv_of_class_eq_class</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≈</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.ext_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">refl'</span> <span class=\"n\">r</span> <span class=\"n\">a</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">Setoid.classes_equiv_quotient</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Setoid.classes</span> <span class=\"n\">r</span> <span class=\"bp\">≃</span> <span class=\"n\">Quotient</span> <span class=\"n\">r</span> <span class=\"n\">where</span>\n  <span class=\"n\">toFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"bp\">⟦</span><span class=\"n\">x.2.choose</span><span class=\"bp\">⟧</span>\n  <span class=\"n\">invFun</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"n\">Quotient.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨{</span> <span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">r.Rel</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">},</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">r.class_eq_class_of_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">])</span> <span class=\"n\">y</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Quotient.lift_mk</span><span class=\"o\">,</span> <span class=\"n\">Subtype.mk.injEq</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.choose_spec</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subtype.property</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">},</span>\n        <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">})</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">x</span>\n    <span class=\"n\">refine</span> <span class=\"n\">Quotient.inductionOn</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">↦</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Quotient.sound</span>\n    <span class=\"n\">apply</span> <span class=\"n\">r.equiv_of_class_eq_class</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">Exists.choose_spec</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subtype.property</span> <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">Quotient.lift</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">})</span>\n      <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"bp\">↦</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">r.class_eq_class_of_equiv</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">])</span>\n      <span class=\"o\">(</span><span class=\"n\">Quotient.mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">Quotient.lift</span>\n        <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">y</span> <span class=\"bp\">↦</span> <span class=\"o\">({</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">Rel</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">},</span> <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">)))</span>\n        <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Quotient.mk</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">∈</span> <span class=\"n\">classes</span> <span class=\"n\">r</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">maybe_missing_api</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Battling myself with <code>Classical.choose</code> was exactly what I tried to avoid :D</p>",
        "id": 394074304,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696071213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> <a href=\"#narrow/stream/113489-new-members/topic/Finiteness.20of.20quotients/near/394074162\">said</a>:</p>\n<blockquote>\n<p>I don't have the permission to open branches on <code>mathlib4</code> yet. Could you grant me this? My github handle is @chrisflav</p>\n</blockquote>\n<p><span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span></p>",
        "id": 394076435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696072986
    },
    {
        "content": "<p>yeah, when I was a beginner I would avoid it but I'm more confident now. It's still a bit annoying I have to cut and paste the precise existence statement into <code>Exists.choose_spec</code>.</p>",
        "id": 394076505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696073043
    },
    {
        "content": "<p>The advantage of my approach is that both <code>toFun</code> and <code>invFun</code> are concrete functions by definition. Your approach via <code>Equiv.ofBijective</code> has the disadvantage that you don't know what the <code>invFun</code> is, all you know is that it's the inverse of the <code>toFun</code>. So for example if someone wanted to prove that the map you're implicitly defining from <code>Setoid.classes</code> to <code>Quotient</code> is <code>fun x ↦ ⟦x.2.choose⟧</code> they'd have to do what I'm doing in my approach.</p>",
        "id": 394076756,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696073235
    },
    {
        "content": "<p>In constructive mathematics, a function + proof that it's a bijection is a slightly weaker amount of data than a function plus an inverse function plus the two proofs. Even the inverse of a computable function might not be computable, as I discovered to my surprise when I was trying to get on top of this stuff (see <a href=\"https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/\">https://xenaproject.wordpress.com/2019/06/11/the-inverse-of-a-bijection/</a> )</p>",
        "id": 394076906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1696073345
    },
    {
        "content": "<p>Invitation sent!</p>",
        "id": 394076959,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1696073399
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/7444\">https://github.com/leanprover-community/mathlib4/pull/7444</a></p>",
        "id": 394082326,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696078199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Finiteness.20of.20quotients/near/394076756\">said</a>:</p>\n<blockquote>\n<p>The advantage of my approach is that both <code>toFun</code> and <code>invFun</code> are concrete functions by definition. Your approach via <code>Equiv.ofBijective</code> has the disadvantage that you don't know what the <code>invFun</code> is, all you know is that it's the inverse of the <code>toFun</code>. So for example if someone wanted to prove that the map you're implicitly defining from <code>Setoid.classes</code> to <code>Quotient</code> is <code>fun x ↦ ⟦x.2.choose⟧</code> they'd have to do what I'm doing in my approach.</p>\n</blockquote>\n<p>I see, do you think we should put your version instead then?</p>",
        "id": 394082585,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696078421
    },
    {
        "content": "<p>If you’re going to use <code>choose</code> for one direction of the equiv, you may as well just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.ofBijective#doc\">docs#Equiv.ofBijective</a> IMO</p>",
        "id": 394083025,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1696078836
    },
    {
        "content": "<p>The reason why we never use <code>Setoid.classes</code> is there is always something more efficient to do. In the case at hand the answer is pretty clear. If your actual goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span>   <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then the nice proof is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=finite_of_compact_of_discrete#doc\">docs#finite_of_compact_of_discrete</a>. The quotient is compact because it is the image of a compact space under a continuous map, and it it discrete because every singleton is open (because its preimage is a copy of the open set U).</p>",
        "id": 394090507,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696084588
    },
    {
        "content": "<p>That is very nice and way more elegant than the way around <code>Setoid.classes</code>. Thanks!</p>",
        "id": 394090963,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696085097
    },
    {
        "content": "<p>I thought it would be a fun exercise to implement this approach. It seems I found a hole in the subgroup quotient API, but maybe I didn't search correctly. In any case, the whole thing doesn't have to be longer than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Function</span> <span class=\"n\">Set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">QuotientGroup.preimage_mk_singleton_mk</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">mk</span> <span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">ext</span> <span class=\"n\">g'</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton_iff</span><span class=\"o\">,</span> <span class=\"n\">QuotientGroup.eq</span><span class=\"o\">,</span> <span class=\"n\">image_mul_left</span><span class=\"o\">,</span> <span class=\"n\">SetLike.mem_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">H.inv_mem_iff</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Subgroup.discreteTopology</span>  <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">DiscreteTopology</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">singletons_open_iff_discrete.mp</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">⟩</span>\n  <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">isOpen_mk</span><span class=\"o\">,</span> <span class=\"n\">QuotientGroup.preimage_mk_singleton_mk</span><span class=\"o\">]</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Homeomorph.mulLeft</span> <span class=\"n\">g</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">isOpen_image</span><span class=\"bp\">|&gt;.</span><span class=\"n\">mpr</span> <span class=\"n\">U_open</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Subgroup.finite_quotient</span> <span class=\"o\">[</span><span class=\"n\">CompactSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">Finite</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">CompactSpace</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Quotient.compactSpace</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">DiscreteTopology</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">U.discreteTopology</span> <span class=\"n\">U_open</span>\n  <span class=\"n\">finite_of_compact_of_discrete</span>\n</code></pre></div>",
        "id": 394092503,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696086536
    },
    {
        "content": "<p>I was just trying it out myself and found it quite annoying to show the equality you call <code>QuotientGroup.preimage_mk_singleton_mk</code>. Your solution is quite elegant.</p>",
        "id": 394093782,
        "sender_full_name": "Christian Merten",
        "timestamp": 1696087758
    },
    {
        "content": "<p>In case this isn't clear, the big <code>simp only</code> in the middle comes from <code>simp?</code> and I didn't try to optimize it.</p>",
        "id": 394097351,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1696090590
    }
]