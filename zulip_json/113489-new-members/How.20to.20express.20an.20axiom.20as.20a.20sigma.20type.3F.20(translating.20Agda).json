[
    {
        "content": "<p>I have the following bit of Agda I'm trying to express in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Agda\"><pre><span></span><code><span class=\"kr\">data</span><span class=\"w\"> </span>_-&gt;&gt;_<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span>Term<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span>Term<span class=\"w\"> </span><span class=\"ow\">→</span><span class=\"w\"> </span><span class=\"kt\">Set</span><span class=\"w\"> </span><span class=\"kr\">where</span>\n<span class=\"w\">  </span><span class=\"nf\">_∎</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">∀</span><span class=\"w\"> </span>M\n<span class=\"w\">      </span><span class=\"c1\">---------</span>\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span>M<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>M\n\n<span class=\"w\">  </span><span class=\"nf\">step—→</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">∀</span><span class=\"w\"> </span>L<span class=\"w\"> </span><span class=\"o\">{</span>M<span class=\"w\"> </span>N<span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span>M<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>N\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span>L<span class=\"w\"> </span>!&gt;<span class=\"w\"> </span>M\n<span class=\"w\">      </span><span class=\"c1\">---------</span>\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span>L<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>N\n\n<span class=\"kr\">postulate</span>\n<span class=\"w\">  </span><span class=\"nf\">confluence</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span>L<span class=\"w\"> </span>M<span class=\"w\"> </span>N<span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span><span class=\"o\">((</span>L<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>M<span class=\"o\">)</span><span class=\"w\"> </span>×<span class=\"w\"> </span><span class=\"o\">(</span>L<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>N<span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"c1\">--------------------</span>\n<span class=\"w\">    </span><span class=\"ow\">→</span><span class=\"w\"> </span>∃[<span class=\"w\"> </span>P<span class=\"w\"> </span>]<span class=\"w\"> </span><span class=\"o\">((</span>M<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>P<span class=\"o\">)</span><span class=\"w\"> </span>×<span class=\"w\"> </span><span class=\"o\">(</span>N<span class=\"w\"> </span><span class=\"ow\">-&gt;</span>&gt;<span class=\"w\"> </span>P<span class=\"o\">))</span>\n</code></pre></div>\n<p>(from <a href=\"https://plfa.github.io/Lambda/\">https://plfa.github.io/Lambda/</a>)<br>\nWhat I've come up with is: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">clos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">M</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">N</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">confluence</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But it bothers me that Agda's expression seems to be closer to the type-theoretical notion of existentials since it maps to <code>Set</code> instead of to <code>Prop</code>, and seems to express the axiom purely as a type instead of a proposition. Would there be a way to do the same in Lean, maybe using sigma types?</p>",
        "id": 467381870,
        "sender_full_name": "nrs",
        "timestamp": 1725409840
    },
    {
        "content": "<p>In Lean you can use <code>Term -&gt; Term -&gt; Type</code> if you want the inductive to be type-valued, and to turn it back into a prop for the existential you can write <code>Nonempty (pclos M P)</code> for example.</p>\n<p>You can also factor the <code>Nonempty</code>s out of the <code>Exists</code> to form the equivalent <code>Nonempty (Σ P : Term, pclos M P × pclos N P)</code></p>",
        "id": 467393222,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725416838
    },
    {
        "content": "<p>(Note: in your <code>step</code>, the second <code>pclos</code> should be the type for the reduction rule <a href=\"https://plfa.github.io/Lambda/#plfa_plfa-part2-Lambda-20283\">https://plfa.github.io/Lambda/#plfa_plfa-part2-Lambda-20283</a>)</p>",
        "id": 467393346,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725416888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20express.20an.20axiom.20as.20a.20sigma.20type.3F.20.28translating.20Agda.29/near/467393222\">said</a>:</p>\n<blockquote>\n<p>In Lean you can use <code>Term -&gt; Term -&gt; Type</code> if you want the inductive to be type-valued, and to turn it back into a prop for the existential you can write <code>Nonempty (pclos M P)</code> for example.</p>\n<p>You can also factor the <code>Nonempty</code>s out of the <code>Exists</code> to form the equivalent <code>Nonempty (Σ P : Term, pclos M P × pclos N P)</code></p>\n</blockquote>\n<p>Thanks for the answer (and the note)! In your opinion, would it make more sense then to express the axiom using <code>Nonempty</code>, or is there a way to express the axiom as a function with <code>-&gt;</code> between <code>Type</code>-level expressions? Otherwise, expressed using <code>Nonempty</code>, the axiom would just be a <code>Prop</code>, right?</p>",
        "id": 467398631,
        "sender_full_name": "nrs",
        "timestamp": 1725418746
    },
    {
        "content": "<p>I'm not sure. I suppose you could write it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">confluence</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>if you think it makes sense that there could be a function that computes this <code>P</code>. If not, then I'm not sure it makes any real difference (you could \"compute\" the <code>P</code> for an existential using choice).</p>",
        "id": 467404712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725421786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20express.20an.20axiom.20as.20a.20sigma.20type.3F.20.28translating.20Agda.29/near/467404712\">said</a>:</p>\n<blockquote>\n<p>I'm not sure. I suppose you could write it as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">confluence</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">pclos</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>if you think it makes sense that there could be a function that computes this <code>P</code>. If not, then I'm not sure it makes any real difference (you could \"compute\" the <code>P</code> for an existential using choice).</p>\n</blockquote>\n<p>I see, thanks a lot for the help!</p>",
        "id": 467408350,
        "sender_full_name": "nrs",
        "timestamp": 1725423435
    }
]