[
    {
        "content": "<p>Hi! In general, can we algorithmically list all elements in any finite type? Or do we have to prove some properties of a type before such a thing can be done? Or is it not possible in general?</p>",
        "id": 470444269,
        "sender_full_name": "nrs",
        "timestamp": 1726460563
    },
    {
        "content": "<p>It depends on what you mean by \"finite\". If you have an instance of <code>Fintype X</code> that was not constructed using the axiom of choice, then yes: such a list is included in the definition of <code>Fintype</code> and can be extracted algorithmically because no choice was used.</p>\n<p>But if you mean <code>Finite X</code>, then it is generally not possible to get such a list. Because <code>Finite X</code> only gives you the information that the type is finite, but nothing about what the elements actually are.</p>",
        "id": 470453188,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1726462852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/In.20general.2C.20can.20we.20list.20all.20elements.20of.20a.20finite.20type.3F/near/470453188\">said</a>:</p>\n<blockquote>\n<p>It depends on what you mean by \"finite\". If you have an instance of <code>Fintype X</code> that was not constructed using the axiom of choice, then yes: such a list is included in the definition of <code>Fintype</code> and can be extracted algorithmically because no choice was used.</p>\n<p>But if you mean <code>Finite X</code>, then it is generally not possible to get such a list. Because <code>Finite X</code> only gives you the information that the type is finite, but nothing about what the elements actually are.</p>\n</blockquote>\n<p>Thanks for the answer! Hm. Then, the type must satisfy some sort minimal order-theoretic properties in order for this to be possible, right?</p>",
        "id": 470454723,
        "sender_full_name": "nrs",
        "timestamp": 1726463359
    },
    {
        "content": "<p>Ah, found a lead for  investigating this. Leaving this here if anyone is interested in the same question: <a href=\"https://en.wikipedia.org/wiki/Computably_enumerable_set\">https://en.wikipedia.org/wiki/Computably_enumerable_set</a></p>",
        "id": 470457516,
        "sender_full_name": "nrs",
        "timestamp": 1726464285
    },
    {
        "content": "<p>hm, it seems that the most fundamental type satisfying this is<code>Mathlib.Data.List</code> (or a literal subset of the integers), everything else that satisfies this is a List with more structure.</p>",
        "id": 470491118,
        "sender_full_name": "nrs",
        "timestamp": 1726472788
    },
    {
        "content": "<p>The typeclass you want in the general case is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Encodable#doc\">docs#Encodable</a></p>",
        "id": 470499679,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1726474240
    },
    {
        "content": "<p>You don't need to have a linear order to define a <code>Fintype</code> instance. Though of course, if you can list all the elements of your type, you can surely define an ordering based on that.</p>",
        "id": 470583770,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1726489997
    },
    {
        "content": "<p>You do need an order to safely extract a <em>list</em>, though</p>",
        "id": 470590336,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1726490777
    }
]