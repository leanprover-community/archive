[
    {
        "content": "<p>Is it possible to have sigma type with first element being Prop?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_pred?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all_arith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all_arith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">head_pred?</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">head_isPos'</span><span class=\"w\"> </span><span class=\"n\">l</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos_to_head_pred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">head_isPos</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₀</span>\n<span class=\"w\">  </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I've tried using <code>\\exists</code> instead of <code>\\S</code>, but that makes it impossible to use it in non-Prop context.</p>",
        "id": 504838654,
        "sender_full_name": "MrQubo",
        "timestamp": 1741699144
    },
    {
        "content": "<p>Are you looking for <code>PSigma</code>?</p>",
        "id": 504839564,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741699324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504839564\">said</a>:</p>\n<blockquote>\n<p>Are you looking for <code>PSigma</code>?</p>\n</blockquote>\n<p>It's written <code>Σ'</code>, right? I've tried it, doesn't work either.</p>",
        "id": 504864448,
        "sender_full_name": "MrQubo",
        "timestamp": 1741704688
    },
    {
        "content": "<p>Ah, wait, it works, but the type of <code>Σ' _ : l.length &gt; 0, head_isPos' l</code> is Type, not Prop.<br>\nShouldn't it be Prop if the second element of a sigma pair is Prop?</p>",
        "id": 504864977,
        "sender_full_name": "MrQubo",
        "timestamp": 1741704793
    },
    {
        "content": "<p>unfortunately, using the same thing in either case will give bad API</p>",
        "id": 504865360,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741704869
    },
    {
        "content": "<p>Not formally, it's kinda the same as <code>l.length &gt; 0 ∧ head_isPos' l</code>, but I need <code>_ : l.length &gt; 0</code> to pass it as an argument to <code>head_isPos' l</code>.</p>",
        "id": 504865390,
        "sender_full_name": "MrQubo",
        "timestamp": 1741704878
    },
    {
        "content": "<p>this is because if you want an inductive to vary over <code>Sort u</code>, it can't have large elimination even when it is <code>Sort 1</code> or above</p>",
        "id": 504865559,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741704916
    },
    {
        "content": "<p>because of that, inductives are always(*) either <code>Type u</code> or <code>Prop</code></p>",
        "id": 504865768,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741704957
    },
    {
        "content": "<p>*there is an option to disable the check enforcing this resulting in a <code>Sort _</code>-typed inductive with Prop-only elimination</p>",
        "id": 504866093,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741705010
    },
    {
        "content": "<p>as a result, you really should not try to use the same type in both cases</p>",
        "id": 504866364,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741705069
    },
    {
        "content": "<p>use <code>PSigma</code> when you need a <code>Type</code> and <code>Exists</code> when you need a <code>Prop</code></p>",
        "id": 504866719,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741705140
    },
    {
        "content": "<p>Why does <code>∃ _ : l.length &gt; 0, head_isPos' l</code> not work for you?</p>",
        "id": 504871712,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741706176
    },
    {
        "content": "<p>If the problem with <code>∃</code> is that you cannot write <code>obtain ... :=</code> in defining, say, a number, the solution is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Classical.html#Classical.choose\">Classical.choose</a> instead of <code>obtain</code>.</p>",
        "id": 504892407,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741710071
    },
    {
        "content": "<p>(in that case this is a nice example of an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem :))</p>",
        "id": 504892707,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741710133
    },
    {
        "content": "<p>In this case since both fields are a <code>Prop</code>, you can actually just use the field notation.</p>",
        "id": 504896622,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741710906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504838654\">schrieb</a>:</p>\n<blockquote>\n<p>I've tried using <code>\\exists</code> instead of <code>\\S</code>, but that makes it impossible to use it in non-Prop context.</p>\n</blockquote>\n<p>That's not correct, projections <code>x.1</code> and <code>x.2</code> should work if you have <code>Prop</code>s on both sides.</p>",
        "id": 504907981,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1741713891
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504907981\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">MrQubo</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504838654\">schrieb</a>:</p>\n<blockquote>\n<p>I've tried using <code>\\exists</code> instead of <code>\\S</code>, but that makes it impossible to use it in non-Prop context.</p>\n</blockquote>\n<p>That's not correct, projections <code>x.1</code> and <code>x.2</code> should work if you have <code>Prop</code>s on both sides.</p>\n</blockquote>\n<p><code>head_isPos_to_head_pred</code> in my example shows that <code>\\exists</code> doesn't work. The error is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">recursor</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">casesOn'</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">eliminate</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>This error is explained in the documentation for Exists.</p>",
        "id": 504910440,
        "sender_full_name": "MrQubo",
        "timestamp": 1741714591
    },
    {
        "content": "<p>It looks like this works, would it be a problem if PSigma from Init.Core was defined in a way that for a Prop argument type of PSigma is also Prop?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_pred?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all_arith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all_arith</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">head_pred?</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isSome</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SigmaProp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">fst</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">SigmaProp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">head_isPos'</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">head_isPos_to_head_pred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">head_isPos</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₀</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pred?</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">head_pred?</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pred?</span><span class=\"bp\">.</span><span class=\"n\">isSome</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">head_isPos'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">pred?</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 504910861,
        "sender_full_name": "MrQubo",
        "timestamp": 1741714714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504865559\">said</a>:</p>\n<blockquote>\n<p>this is because if you want an inductive to vary over <code>Sort u</code>, it can't have large elimination even when it is <code>Sort 1</code> or above</p>\n</blockquote>\n<p>Indeed, this means it's impossible to have PSigma be Prop. I.e., this doesn't work <code>structure PSigma' {α : Sort u} (β : α → Sort v) : Sort (max u v)</code>.</p>",
        "id": 504912786,
        "sender_full_name": "MrQubo",
        "timestamp": 1741715299
    },
    {
        "content": "<p>Would it be possible to define exists elimination in a way that if first argument is Sort 0, than it can be eliminated in a non-Prop goal? This  would make sense, as there's only one instance (up to propext) for the first argument of Exists.</p>",
        "id": 504913358,
        "sender_full_name": "MrQubo",
        "timestamp": 1741715470
    },
    {
        "content": "<p>I'll try with PSigma, maybe it won't cause a problem if type of <code>head_isPos</code> is <code>Type</code> and not <code>Prop</code>.</p>",
        "id": 504914192,
        "sender_full_name": "MrQubo",
        "timestamp": 1741715715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@MrQubo</span> You're misunderstanding what Robin's saying: you can use projection notation, like <code>h₀.1</code> and <code>h₀.2</code>. Using <code>have ⟨_, _⟩ := h₀</code> won't work</p>",
        "id": 504914201,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741715718
    },
    {
        "content": "<p>(I didn't test it — in principle it should work with numerical projections. There's a chance that there's some artificial limitation in the elaborator that causes an error still. But, I do expect numerical projections to work with <code>Exists</code> if both types are Props.)</p>",
        "id": 504914440,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741715772
    },
    {
        "content": "<p>Oh, you're right. In my brain <code>have ⟨_, _⟩ := h₀</code> was just a syntax sugar for <code>have _ := h₀.1; have _ := h₀.2</code>.</p>",
        "id": 504949361,
        "sender_full_name": "MrQubo",
        "timestamp": 1741725200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504892407\">said</a>:</p>\n<blockquote>\n<p>If the problem with <code>∃</code> is that you cannot write <code>obtain ... :=</code> in defining, say, a number, the solution is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Classical.html#Classical.choose\">Classical.choose</a> instead of <code>obtain</code>.</p>\n</blockquote>\n<p>you shouldn't be in tactic mode when <code>def</code>ining a number anyway <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 504971715,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741732165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504971715\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Sigma.20type.20with.20Prop/near/504892407\">said</a>:</p>\n<blockquote>\n<p>If the problem with <code>∃</code> is that you cannot write <code>obtain ... :=</code> in defining, say, a number, the solution is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Classical.html#Classical.choose\">Classical.choose</a> instead of <code>obtain</code>.</p>\n</blockquote>\n<p>you shouldn't be in tactic mode when <code>def</code>ining a number anyway <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>Tbh, in same cases I find it easier to use tactic mode, this is because things like <code>apply?</code> can help you find functions you need, and I can rewrite to term mode later.</p>",
        "id": 504972184,
        "sender_full_name": "MrQubo",
        "timestamp": 1741732322
    }
]