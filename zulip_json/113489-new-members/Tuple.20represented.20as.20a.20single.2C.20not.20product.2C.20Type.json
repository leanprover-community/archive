[
    {
        "content": "<p>Hi, I would expect a tuple (i.e <code>(Nat, Int)</code>) to be a <code>Type</code>. Of course, it's a <code>Type x Type</code>, but should also not be able to be represented as a single <code>Type</code>?</p>\n<p>In other words, is there any way to express the following as a single <code>Type</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- error expecting Type x Type</span>\n</code></pre></div>",
        "id": 453493529,
        "sender_full_name": "Luis Enrique Muñoz Martín",
        "timestamp": 1721760444
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n</code></pre></div>\n<p>is what you mean probably</p>",
        "id": 453493918,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721760586
    },
    {
        "content": "<p>Ouch! You're right! I'm creating a value <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> Thanks!</p>",
        "id": 453494332,
        "sender_full_name": "Luis Enrique Muñoz Martín",
        "timestamp": 1721760730
    },
    {
        "content": "<p>Doesn't help that Haskell conflates both notations!</p>",
        "id": 453494584,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1721760800
    },
    {
        "content": "<p>i'm curious, is there a reason why this cannot be equality?</p>",
        "id": 453496058,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721761236
    },
    {
        "content": "<p>does it lead to a contradiction in the type theory?</p>",
        "id": 453496316,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721761300
    },
    {
        "content": "<p>i suppose you'd have to have <code>Type = Type x Type</code></p>",
        "id": 453496907,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721761440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/Tuple.20represented.20as.20a.20single.2C.20not.20product.2C.20Type/near/453496058\">said</a>:</p>\n<blockquote>\n<p>i'm curious, is there a reason why this cannot be equality?</p>\n</blockquote>\n<p>You could achieve this with overloaded notation, but I think largely people don't want that notation anyway</p>",
        "id": 453517522,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1721766543
    },
    {
        "content": "<p>You can also achieve it with a coercion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 453520147,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721767122
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> If that were an equality, then not only would every pair of types give a type (the product type), but every type would be a product of types. I think there's nothing wrong with that as an axiom it, but it's probably not what you'd want (why should <code>Nat</code> be a product of types?)</p>\n<p>The coercion implements a one-directional <code>Type x Type -&gt; Type</code>.</p>",
        "id": 453521049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1721767362
    },
    {
        "content": "<p>I should think that in the cardinality model of Lean, you could have Type = Type x Type. I've seen a model of ordered pairs in set theory where every set is an ordered pair :-)</p>",
        "id": 453768405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721845506
    }
]