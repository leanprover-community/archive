[
    {
        "content": "<p><a href=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/mdWdddM_K9mX6dgtF86Jsm6F/image.png\"></a></div><p>Hello,</p>\n<p>I've implemented a prime sieve based on juggling arithmetic sequences around, and I see that it works. But now I would like to prove it.</p>\n<p><a href=\"https://github.com/tangentstorm/treesiv/blob/main/Main.lean\">https://github.com/tangentstorm/treesiv/blob/main/Main.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- arithmetic series (k + dn)</span>\n<span class=\"w\">  </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- constant</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- difference</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ord</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- but there's no List.sort? !!</span>\n<span class=\"w\">  </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"bp\">.</span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ord</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ord</span>\n\n<span class=\"c1\">-- mk k d = k + d*n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- apply formula to n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- apply one formula to another: r(n) := s(t(n))</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">compose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- identity series</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">id1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">partition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">compose</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"s2\">\"n\"</span>\n<span class=\"w\">      </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.d}n\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.k}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"n + {s.k}\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.d}n + {s.k}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">         </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"ps: {s.ps}, pr: {s.pr}, np: {s.np}, ss: {s.ss}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">id1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ss0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">partition</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">join</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss0</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">s0</span><span class=\"bp\">.</span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"bp\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- strip out multiples of np</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">minimum?</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"o\">:=</span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">get!</span><span class=\"w\"> </span><span class=\"c1\">-- series with next prime</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s</span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">forM</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">15</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">formula</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">pushn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">take</span><span class=\"w\"> </span><span class=\"n\">width</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{formula}: {(terms s n)}\"</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"w\">  </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"mi\">5</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">sv</span>\n<span class=\"w\">    </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"s2\">\"----------------\"</span>\n<span class=\"w\">    </span><span class=\"n\">printStep</span><span class=\"w\"> </span><span class=\"n\">sv</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">main</span>\n</code></pre></div>\n<p>But how do I even start?</p>\n<p>Currently, it tracks a list of known primes and a next prime (<code>np</code>). I think I want to force things so that the next prime is of type <code>Prime</code>... Would I just bake a \"prime\" type directly into my data structure?</p>\n<p>I <em>think</em> what I want to do is use the type system to assert:</p>\n<ul>\n<li>the \"next prime\" is a prime</li>\n<li>the \"known primes\" are all prime, and also contain ALL primes less than \"next prime\"</li>\n</ul>\n<p>Then I think I to prove that I calculate the next prime correctly, I'd have to demonstrate that my list of arithmetic series together generate all natural numbers that are not multiples of a known prime, and (since they all have the same slope) the next prime is the minimal term in one of the series.</p>\n<p>Does this general plan make sense? And if so, how do I even express it?</p>\n<p>I'm going to start by just setting the type of \"next prime\" and see where it leads, but if anyone could give me a few hints, I'd really appreciate it.</p>\n<p>Thanks!</p>",
        "id": 446923432,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719330786
    },
    {
        "content": "<p>We prefer <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> to unreadable screenshots. Can you update?</p>",
        "id": 446937306,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1719333796
    },
    {
        "content": "<p>I think the link to the code matches what's in the screenshot (minus the infoview output)</p>",
        "id": 446939162,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1719334223
    },
    {
        "content": "<p>Yes, but I'll post the code directly. :)</p>",
        "id": 446943206,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719335200
    },
    {
        "content": "<p>(oops, I'm sorry, I missed this <code>SHOW MORE</code> button this time, my apologies)</p>",
        "id": 446949262,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1719336557
    },
    {
        "content": "<p>It seems like <code>Mathlib.Data.Nat.Prime</code> is a proposition, not just a Type.</p>\n<p>I found this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.val}\"</span>\n</code></pre></div>\n<p>Then I was able to declare my types like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">      </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">           </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASer</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>\n<p>So far that required two changes: every time I assign the <code>np</code> field, I now need to pair it with a proof that the number is prime in special angle brackets.</p>\n<p>The proof that the initial 2 is prime is provided by the Mathlib:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_two</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">id1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>But for <code>step</code>, I'm on my own:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">np</span><span class=\"o\">,</span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm not sure how I can even start to prove this without knowing that <code>ps</code> contains <em>all</em> the primes less than  np, which won't be true unless I bake it into the type, and I don't know how to express that yet.</p>\n<p>Possibly I can just add any proposition to the type with the magic <code>//</code> symbol?</p>",
        "id": 446976613,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719343816
    },
    {
        "content": "<p>You can add fields to your structure that are propositions</p>",
        "id": 446984294,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1719346160
    },
    {
        "content": "<p>Interesting.. I can almost see how that would work. I think the proof outline is something like this:</p>\n<ul>\n<li>theorem: <code>np</code> really is the next prime after each <code>step</code>, because<ul>\n<li>the items in <code>ss</code> together contain all nats &gt; 2 that are not multiples of a current prime (and i need to prove that this holds at each partition step). this means:<ul>\n<li>the <code>partition</code> operation must actually partition the series (and not accidentally lose a value that might be the next prime)</li>\n<li>the <code>filter</code> operation removes exactly the multiples of the current <code>next prime</code></li>\n</ul>\n</li>\n<li>the sequences all have the same slope (.ss[i].d = .pr) so the lowest first term is the next prime (though currently I still have a 1 floating around as the first term in one series at each step)</li>\n</ul>\n</li>\n</ul>",
        "id": 446988226,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719347365
    },
    {
        "content": "<p>On further reflection, I think what I really ought to do is prove a basic theorem about the idea of prime sieves:</p>\n<ul>\n<li>The smallest natural number that is coprime to all primes smaller than it is prime.</li>\n</ul>\n<p>Then for my particular implementation, I need to show that:</p>\n<ul>\n<li>the list of known primes is complete up to the \"next prime\" variable</li>\n<li>the list of arithmetic progressions together represent every natural number except those coprime to the list of known primes. </li>\n<li>that from these, i am correctly identifying the minimal coprime number</li>\n</ul>\n<p>I think the \"representing all the coprimes\" part is two more or less induction, except not using the \"induction\" tactic but an invariant on the type itself, so:</p>\n<ul>\n<li>the initial sieve value represents all natural numbers (maybe all &gt; 2)</li>\n<li>at each step we remove exactly the multiples of the next prime (so we use the proof on the input as the induction hypothesis)</li>\n</ul>\n<p>So the first part is an obvious-to-me mathematical statement about why prime sieves produce primes (so hopefully easy to prove in lean??)... And then once that framework is in place to describe formally what a prime sieve is, I can prove that this particular algorithm and data structure actually is a prime sieve.</p>\n<p>I will continue to post here to document my progress. If anyone has observations/ideas for making any of this more approachable, please comment!</p>",
        "id": 447271099,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719420397
    },
    {
        "content": "<p>Woo! I managed to prove that if a natural number greater than 1 has no prime factors less than it, it must be prime:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hcg2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is greater than 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hno</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"c1\">-- c has no divisors at all</span>\n<span class=\"w\">      </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hmc</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"c1\">-- give names to the above assumptions</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hnme1</span><span class=\"w\">   </span><span class=\"c1\">-- assume ¬(m=1) and show contradiction</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmn1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">assumption</span>\n<span class=\"w\">      </span><span class=\"c1\">-- obtain a prime factor of m since it isn't 1</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"n\">hmn1</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"n\">hmdc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_dvd_of_pos</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"n\">hzlc</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">hzlm</span><span class=\"w\"> </span><span class=\"n\">hpm</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n<span class=\"w\">      </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hcg2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hno</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>This was the main step that was worrying me, because it maps the conditions provided by a sieve to the conditions that mathlib uses in the definition of <code>Nat.Prime</code>.</p>",
        "id": 447872026,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719608618
    },
    {
        "content": "<p>I guess if you are using <code>Nat.exists_prime_and_dvd</code> you may as well do this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hcg2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is greater than 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hcn1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ne</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">ne_of_lt</span><span class=\"w\"> </span><span class=\"n\">hcg2</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"n\">hcn1</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">hzlc</span><span class=\"w\"> </span><span class=\"n\">hpc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpgc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"w\"> </span><span class=\"n\">hpc</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"w\"> </span><span class=\"n\">hplc</span><span class=\"w\"> </span><span class=\"n\">hpgc</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">hpec</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n</code></pre></div>",
        "id": 447921047,
        "sender_full_name": "Bbbbbbbbba",
        "timestamp": 1719635251
    },
    {
        "content": "<p>I am quite stuck at the moment. I want to refer to the infimum of the following set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- the set of naturals with no prime factors less than some c</span>\n<span class=\"c1\">-- \"remaining set\"? \"residual set?\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I want to prove that :</p>\n<ul>\n<li>my algorithm produces the infimum of this set, and</li>\n<li>the infimum of the set is prime</li>\n</ul>\n<p>I am pretty sure I can prove both of these statements, but I'm stuck trying to figure out how to express the idea of an infimum... I see that <code>Inf $ rs c</code> is an expression that produces a type, but I don't understand what to do with it.</p>\n<p>How would I obtain a member of that type? What would I do with it? I think I'm missing something basic here.</p>",
        "id": 448089996,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719737190
    },
    {
        "content": "<p>Actually I might even be using the term wrong. I want the minimal element of the set. I know it exists. I can obtain it. I just don't know how to express the concept so I can prove I'm doing it. Any ideas?</p>",
        "id": 448090276,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719737447
    },
    {
        "content": "<p>You want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=sInf#doc\">docs#sInf</a>, s for set</p>",
        "id": 448093036,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739210
    },
    {
        "content": "<p>That will give you a Nat. Plain Inf is the binary operator of two elements</p>",
        "id": 448093102,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739243
    },
    {
        "content": "<p>Regarding your definition, wouldn't 1 be in the set?</p>",
        "id": 448093165,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719739280
    },
    {
        "content": "<p>If c&lt;=2 then the min is zero and if c&gt;2 it's 1, so in fact the minimum is never prime. Is there a typo somewhere?</p>",
        "id": 448093993,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1719739660
    },
    {
        "content": "<p>Perhaps adding the predicate that c &lt; n to the set will rescue the definition?</p>",
        "id": 448118550,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719756701
    },
    {
        "content": "<p>It might be easier to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a> ?</p>",
        "id": 448129077,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1719761582
    },
    {
        "content": "<p>you realize you are reinventing <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.minFac#doc\">docs#Nat.minFac</a> ?</p>",
        "id": 448135041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719764407
    },
    {
        "content": "<p><code>no_prime_factors_im_no_factors</code> also looks like a theorem that should already exist</p>",
        "id": 448135106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719764443
    },
    {
        "content": "<p>I don't understand what you guys are saying. I'm trying to express the idea that rs(c) is the set of all natural numbers (n) such that n is not a multiple of a prime less than c.    It's a prime sieve, so I'm trying to describe all the numbers that haven't been crossed out yet, and then I want to obtain the smallest number in that set so I can demonstrate that it is prime.</p>",
        "id": 448139952,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766062
    },
    {
        "content": "<p>Is <code>rs</code> saying something other than that?</p>",
        "id": 448140045,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766091
    },
    {
        "content": "<p>this already works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- if c is a member of rs c, then c is prime</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">≥</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcrc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">hh</span>\n\n<span class=\"c1\">-- show that 2 is part of rs 2 for initial case</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt_succ</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_le_of_gt</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 448140384,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719766291
    },
    {
        "content": "<p>Oh ... I see my error now. Yes, I need to add <code>c ≤ n</code>... I think in this case the infimum is also the minimum but I'm not sure. I'll try to proceed with <code>sInf</code>. Thanks!</p>",
        "id": 448142222,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719767087
    },
    {
        "content": "<p>do you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of this?</p>",
        "id": 448143067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719767517
    },
    {
        "content": "<p>Sort of. Here's what I have so far, and all of this typechecks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Linarith</span><span class=\"bp\">.</span><span class=\"n\">Frontend</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- c is a candidate prime</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h2lc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\">                              </span><span class=\"c1\">-- c is at least 2</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hnpf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">))</span><span class=\"w\">      </span><span class=\"c1\">-- c has no prime factors</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">=</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\">  </span><span class=\"c1\">-- c has no divisors but 1 and c</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hmc</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\">  </span><span class=\"c1\">-- give names to the above assumptions</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\">         </span><span class=\"c1\">-- assume ¬(m=1) and show contradiction</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_prime_and_dvd</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">›</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">dvd_trans</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"n\">hmdc</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_dvd_of_pos</span><span class=\"w\"> </span><span class=\"n\">hmdc</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_dvd</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">hpm</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hnpf</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">hpp</span>\n<span class=\"w\">      </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">⟨‹</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">›</span><span class=\"w\"> </span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">≥</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hcrc</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hcrc</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">no_prime_factors_im_no_factors</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"n\">hh</span>\n\n<span class=\"c1\">-- show that 2 is part of rs 2 for initial case</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">cprime2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt_succ</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_def_lt</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_le_of_gt</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>But I don't have anything about the minimal item, because I don't know how to express it.</p>",
        "id": 448143988,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719767968
    },
    {
        "content": "<p>what happened to the sieve program?</p>",
        "id": 448144556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768198
    },
    {
        "content": "<p>Oh, the sieve is here: <a href=\"https://github.com/tangentstorm/treesiv/blob/main/Main.lean\">https://github.com/tangentstorm/treesiv/blob/main/Main.lean</a></p>",
        "id": 448144715,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768244
    },
    {
        "content": "<p>What is it you are trying to prove?</p>",
        "id": 448144720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768245
    },
    {
        "content": "<p>I think what you want to prove by induction or execution is that <code>minFac n &gt;= a</code></p>",
        "id": 448144996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768338
    },
    {
        "content": "<p>and if <code>a</code> gets to <code>n</code> then you know <code>n</code> is prime</p>",
        "id": 448145033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768350
    },
    {
        "content": "<p>Hang on. I'm trying to put the answer to your first question into words.</p>",
        "id": 448145224,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768430
    },
    {
        "content": "<blockquote>\n<p><code>-- but there's no List.sort? !!</code></p>\n</blockquote>\n<p>There is <code>List.mergeSort</code></p>",
        "id": 448146319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768700
    },
    {
        "content": "<p>What is the purpose of this program? It seems like it does exponential work compared to the actual list of primes coming out in <code>ps</code></p>",
        "id": 448146848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768828
    },
    {
        "content": "<p>A prime sieve (at least one that works like the sieve of eratosthenes) is some algorithm that at each step, has identified all the primes up to some prime P, and has \"scratched out\" all the multiples of those primes from the set of all natural numbers.</p>\n<p>I have implemented a prime sieve, and want to prove that the algorithm works: that it always finds the next prime.</p>\n<p>But I guess there are many ways you could implement a sieve like this. For example, the traditional implementation generates an array of booleans corresponding to a range of numbers, and then loops through and flips the bit for each multiple... The algorithm here is not as efficient. It's taking an initial arithmetic sequence (2 + n) and at each step is partitioning it into sub-sequences, using this to find the next prime, and removing the sequences that are multiples of a prime.</p>",
        "id": 448147076,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768879
    },
    {
        "content": "<p>The first step in proving an algorithm like this correct is to define the invariants. What are all the properties you expect to be true of the input and result of the <code>step</code> function?</p>",
        "id": 448147232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768917
    },
    {
        "content": "<p>Yes. There's no real practical point to it, other than as an exercise. Although it does have a nice property that it very quickly generates a bunch of huge candidate numbers that are somewhat likely to be prime.</p>",
        "id": 448147322,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719768942
    },
    {
        "content": "<p>Some of them are in comments, and you can move them to fields of the structure like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n</code></pre></div>\n<p>as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">pr_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 448147350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768951
    },
    {
        "content": "<p>Oh I wasn't questioning the practicality, only trying to understand what properties you are going for</p>",
        "id": 448147505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719768987
    },
    {
        "content": "<p>From a doc I'm writing:</p>\n<p>The sieve tracks this info:</p>\n<ul>\n<li>C is the “current prime”</li>\n<li>S is the set of all primes less than C.</li>\n<li>R (for “remaining”) is the set of naturals with no prime factors in S.</li>\n<li>Q is the set of sequences that model R</li>\n</ul>\n<p>The smallest of these is the next prime. (May still need to prove this.) </p>\n<p>I suppose I would need to show the following:</p>\n<ul>\n<li>At each step, I have a correct mapping to R.</li>\n<li>R’ := R - multiples of C</li>\n<li>C’ is the smallest one.</li>\n</ul>\n<p>How do I prove that I’m tracking R correctly?<br>\nAgain by “induction” using a proposition field.</p>\n<p>-The field says I have a mapping to all naturals that are not multiples of found primes.</p>\n<ul>\n<li>I’m now removing multiples of one new prime.</li>\n<li>\n<p>A sequence is of the form ( k + dn )<br>\n- k∣d this means it’s k + (jk)n or  k(1+jn)]</p>\n</li>\n<li>\n<p>Same applies to any ik + (jk)n </p>\n</li>\n<li>Every item in these series will be a multiple of K.</li>\n<li>How to show that only sequences whose constant terms are multiples of k yield multiples of k?</li>\n<li>K∣(X + JKN) iff X%K=0, because (JKN+X)%K reduces to X%K</li>\n<li>D is of the form JK, since D is the primorial whose largest factor is K</li>\n<li>So this is how we justify the step of partitioning the previous list of sequences by K: the goal is to make the difference coefficient a multiple of K. The way to do that is to split each sequence into K sequences, or rather to apply each sequence to the sequences  0+Kn, 1+Kn, 2+Kn… (K-1)+Kn</li>\n</ul>\n<p>How do I prove that my algorithm finds the smallest item in R?</p>\n<ul>\n<li>Q partitions R into sequences of the form K+Dn</li>\n<li>The smallest item in R must be the smallest constant coefficient in one of these</li>\n</ul>",
        "id": 448147594,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769060
    },
    {
        "content": "<p>I guess you renamed everything in the lean code? I don't see C, S, R, Q</p>",
        "id": 448147694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769106
    },
    {
        "content": "<p>C S R Q are like an abstract description of what any prime sieve along the lines of eratosthenes must be doing... But the actual implementation can vary.</p>",
        "id": 448147960,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769289
    },
    {
        "content": "<p>well I'm asking more specifically what properties hold of the object you have called <code>PrimeSieve</code></p>",
        "id": 448147989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769314
    },
    {
        "content": "<p>First, if it's not clear: I'm a software developer, not in any way a mathematician.... So I'm thinking like a software developer, and that might be a problem here. In my mind, I don't want to just directly prove that this prime sieve works... I want to make a general description of what a generic prime sieve does, and then demonstrate that this particular one does all those things.</p>\n<p>So, I'm attempting to write an abstract proof in terms of these C S R Q  things, and then I want to demonstrate that at each step, the prime sieve is somehow modelling these things.</p>",
        "id": 448148380,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769500
    },
    {
        "content": "<p>I think you end up with this list of invariants:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">      </span><span class=\"c1\">-- all primes we've used so far</span>\n<span class=\"w\">  </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">              </span><span class=\"c1\">-- current primorial (product of ps)</span>\n<span class=\"w\">  </span><span class=\"n\">np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">           </span><span class=\"c1\">-- next prime</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\">        </span><span class=\"c1\">-- list of sequences</span>\n<span class=\"w\">  </span><span class=\"n\">pr_eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pr</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"bp\">.</span><span class=\"n\">foldr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- pr is the product of ps</span>\n<span class=\"w\">  </span><span class=\"n\">ps_sorted</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">np</span><span class=\"o\">])</span><span class=\"bp\">.</span><span class=\"n\">Pairwise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·.</span><span class=\"m\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- ps ++ [np] is sorted</span>\n<span class=\"w\">  </span><span class=\"n\">all_primes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"c1\">-- ps ++ [np] contains the complete list of primes</span>\n<span class=\"w\">  </span><span class=\"n\">divisible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">np</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">np</span><span class=\"o\">]),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"c1\">-- a number larger than np is contained in one of the sequences iff it does not divide all listed primes</span>\n</code></pre></div>",
        "id": 448148413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769519
    },
    {
        "content": "<p>If you want to describe a \"generic prime sieve\", then write that down as a definition and prove that this prime sieve relates to that</p>",
        "id": 448148597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769664
    },
    {
        "content": "<p>Like, I'm also looking at another sieve someone else implemented:  <a href=\"https://github.com/ykonstant1/esiv\">https://github.com/ykonstant1/esiv</a><br>\nAnd I want to show that that, too, has the behaviors I want in terms of C/S/R/Q.</p>\n<p>But none of these algorithms actually have the \"set of all natural numbers\" lying around... You'd need infinite RAM. But instead, you can show that the algorithm somehow has a mapping to these  numbers (a traditional sieve just generates it a bit at a time, this one models it as the list of sequences...)</p>",
        "id": 448148709,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769706
    },
    {
        "content": "<p>no worries, lean is good at holding \"the set of all natural numbers\" in its head :)</p>",
        "id": 448148718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769729
    },
    {
        "content": "<p>Yes, that's what I want to do. But I basically need to say \"C' is the min item in R\" and I don't know how to write that sentence.</p>",
        "id": 448148744,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769753
    },
    {
        "content": "<p>the simple way is to just write that out as a predicate: <code>C' ∈ R ∧ ∀ x ∈ R, C' ≤ x</code></p>",
        "id": 448148862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719769808
    },
    {
        "content": "<p>Let me try to actually write <code>AbstractPrimeSieve</code> in terms of these numbers.</p>",
        "id": 448148870,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769814
    },
    {
        "content": "<p>... that... looks... pretty straightforward... :D</p>",
        "id": 448148915,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769853
    },
    {
        "content": "<p>Hrm. Okay. I will try this. Thanks, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> !!</p>",
        "id": 448149204,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719769935
    },
    {
        "content": "<p>It seems like the \"generic PrimeSieve\" ought to be defined as like <code>class PrimeSieve</code> and then I should rename the current thing and show <code>instance : PrimeSieve MyPrimeSieve</code>.</p>",
        "id": 448149976,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719770353
    },
    {
        "content": "<p>That depends, the way you described a prime sieve was more like a concrete prime sieve but for the fact that it deals in noncomputable objects, and you would instead have some representation relation between your prime sieve and the abstract one</p>",
        "id": 448150228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770469
    },
    {
        "content": "<p>this is basically the same situation as between <code>Set A</code> and <code>Finset A</code>: the former is an abstract mathematical thing and the latter is a concrete computable representation which can be interpreted to a <code>Set</code></p>",
        "id": 448150379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770530
    },
    {
        "content": "<p>It is possible to describe <code>PrimeSieve</code> as a class but in that case it's still not very abstract, more like parametric over representations</p>",
        "id": 448150530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719770617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423842\">Michal Wallace (tangentstorm)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448149976\">said</a>:</p>\n<blockquote>\n<p>It seems like the \"generic PrimeSieve\" ought to be defined as like <code>class PrimeSieve</code> and then I should rename the current thing and show <code>instance : PrimeSieve MyPrimeSieve</code>.</p>\n</blockquote>\n<p>Note, in lean, <code>class</code> and <code>instance</code> don't mean what they mean in Python, for example. Instead, <code>class</code> in Python is equivalent to <code>structure</code> in lean. And one creates an instance of a structure by a <code>def foo : MyStruct := ...</code> declaration.</p>\n<p><code>class</code> in lean defined a structure that _additionally_, for the parameters provided, should be found automatically by the typeclass search system, and as such, there should morally be only one <code>instance</code> for every <code>MyStruct X</code>.</p>",
        "id": 448152916,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1719771589
    },
    {
        "content": "<p>So... I wanted to define actual sets, but whenever I refer to membership in the sets, I get errors about being unable to synthesize a \"Membership\" instance, and I don't know how to address that. It would have made the code look kind of nice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NonWorkingPrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"c1\">-- primes &lt; C</span>\n<span class=\"w\">  </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"c1\">-- ^ failed to synthesize  Membership ?m.512 ↑{n | ↑n &lt; ↑(C x)}</span>\n</code></pre></div>",
        "id": 448167171,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719777693
    },
    {
        "content": "<p>So here is what I came up with. So far, it's just a definition, but it typechecks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"c1\">-- nltC says a naturals less than C</span>\n<span class=\"w\">  </span><span class=\"n\">nltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"c1\">-- primes less than C (the \"known primes\")</span>\n<span class=\"w\">  </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"c1\">-- natural number coprime to all the known primes</span>\n<span class=\"w\">  </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- this is the invariant we need to have a sieve.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- if I can show that a particular instance produces a C</span>\n<span class=\"w\">  </span><span class=\"c1\">-- that is the smallest natural that is coprime</span>\n<span class=\"w\">  </span><span class=\"c1\">-- to all the known primes, then I should be able to</span>\n<span class=\"w\">  </span><span class=\"c1\">-- prove the main result (hSiv) below.</span>\n<span class=\"w\">  </span><span class=\"n\">hMin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">                 </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">    </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"c1\">-- the key property to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- we generate the next consecutive prime at each step</span>\n<span class=\"w\">  </span><span class=\"n\">hSiv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">        </span><span class=\"c1\">-- \"after each step\"</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- \"we have a new, bigger prime\"</span>\n<span class=\"w\">      </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\">   </span><span class=\"c1\">-- \"and there is no prime between them\"</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"c1\">-- I *think* I can prove this for all sieves,</span>\n<span class=\"w\">      </span><span class=\"c1\">-- provided the sieve gives me the hMin fact</span>\n</code></pre></div>",
        "id": 448168104,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719777967
    },
    {
        "content": "<p>When you write <code>S : (x:α) → { n: NPrime | n.val &lt; (C x).val }</code>, you aren't declaring a set, you are declaring an element of a set. <code>{ n: NPrime | n.val &lt; (C x).val }</code> is one particular set and <code>S</code> is a function producing elements of that set</p>",
        "id": 448168356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778106
    },
    {
        "content": "<p>I am somewhat worried that the predicates here are like \"default definitions\" and that it's possible to override them with <em>any</em> proposition. I want a keyword like \"final\" in java.</p>",
        "id": 448168378,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778125
    },
    {
        "content": "<p>as a result, writing <code>p ∈ (S x)</code> later doesn't make sense because <code>S x</code> isn't a set</p>",
        "id": 448168426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778149
    },
    {
        "content": "<blockquote>\n<p>I am somewhat worried that the predicates here are like \"default definitions\" and that it's possible to override them with <em>any</em> proposition. I want a keyword like \"final\" in java.</p>\n</blockquote>\n<p>That's correct, this is not what you want. Try defining functions like <code>nltC</code> before the class, taking <code>C</code> as an argument</p>",
        "id": 448168556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778214
    },
    {
        "content": "<p>... ah, so the set comprehension is also a type signature. how would I declare a function that returns a set then?</p>",
        "id": 448168624,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778253
    },
    {
        "content": "<p><code>S : A -&gt; Set NPrime</code> or something</p>",
        "id": 448168975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778434
    },
    {
        "content": "<p>and then you can put constraints on the set in later arguments</p>",
        "id": 448169086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719778483
    },
    {
        "content": "<p>Hrm. Okay, I see how to do it as a separate proposition...</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">hS</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>When you say \"later argument\", are you saying I can define S and hS together in one definition?</p>",
        "id": 448170140,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719778999
    },
    {
        "content": "<p>no, I was saying you can write <code>hS</code></p>",
        "id": 448170231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779032
    },
    {
        "content": "<p>got it. thanks! this is very helpful!</p>",
        "id": 448170288,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719779047
    },
    {
        "content": "<p>you can bundle some information inside <code>S</code> as well, but you will have to change the uses slightly since it won't be a plain <code>Set NPrime</code> anymore</p>",
        "id": 448170327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779073
    },
    {
        "content": "<p>for example for that <code>hS</code> example you could also say</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but then any later statements using <code>S x</code> should use <code>(S x).1</code> instead</p>",
        "id": 448170563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779152
    },
    {
        "content": "<p>or alternatively</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but now it's not a set of <code>NPrime</code> so you will have some proof obligations or so when talking about <code>NPrime</code>s being a member of the set</p>",
        "id": 448170880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779222
    },
    {
        "content": "<p>I would usually opt for the version you wrote, with a plain set and then constraints on it, so that usage code isn't mucked up with casting things into the correct subtypes</p>",
        "id": 448171356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719779331
    },
    {
        "content": "<p>It seems like lean will completely ignore a proof in a class definition, presumably until you instantiate that class.<br>\nis there a way to force it to check the proof without an instance of the class?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">hMyAssertion</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">234234</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">you_can_say_anything_here</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 448185279,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719787714
    },
    {
        "content": "<p>The syntax <code>:= by</code> in class declarations is sneakily a separate thing, it means to run the provided tactic if the field is omitted</p>",
        "id": 448185317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787795
    },
    {
        "content": "<p>if you put the by block in parentheses it will be checked at declaration time instead, as a regular optional value</p>",
        "id": 448185369,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787813
    },
    {
        "content": "<p>aha! thanks!</p>",
        "id": 448185421,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719787886
    },
    {
        "content": "<p>But I think you don't really want that either, especially for proof fields. If you can prove it outright from earlier fields then there is no point putting it in the structure</p>",
        "id": 448185429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787899
    },
    {
        "content": "<p>This particular example of course can't be proved outright, since an arbitrary function <code>C : α → NPrime</code> need not have its values all greater than 234234</p>",
        "id": 448185510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719787957
    },
    {
        "content": "<p>if you think that <code>C</code> will normally be given in some explicitly computable way such that <code>by decide</code> or <code>by omega</code> or something will prove this side goal then you can use <code>:= by decide</code> for that</p>",
        "id": 448185547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788004
    },
    {
        "content": "<p>Well, again, I'm thinking about this from a software perspective. I think of a <code>class</code> as something like an <code>interface</code> in java or C#, where there might be many sieves lying around. I want to define some hypotheses / contracts that any algorithm has to fufill, and then provide one proof that demonstrates that those conditions are enough to give you a working prime sieve.</p>",
        "id": 448185609,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788063
    },
    {
        "content": "<p>(I was just making up an assertion that was obviously false for that example)</p>",
        "id": 448185621,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788091
    },
    {
        "content": "<p>Can this proof be conducted only using the assumptions in the structure?</p>",
        "id": 448185627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788097
    },
    {
        "content": "<p>if so, the proof should not be in the structure itself</p>",
        "id": 448185640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788109
    },
    {
        "content": "<p>the structure is where you put the initial data and assumptions about that data that every implementer must prove</p>",
        "id": 448185660,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788141
    },
    {
        "content": "<p>here's what i have currently:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToString</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"{s.val}\"</span>\n\n<span class=\"c1\">-- naturals less than C</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"c1\">-- primes less than C</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"c1\">-- natural numbers coprime to some known primes:</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ks</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ks</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- this class defines some sets for you to</span>\n<span class=\"w\">  </span><span class=\"c1\">-- refer to when proving that it works:</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- S: the set of \"known primes\", less than C</span>\n<span class=\"w\">  </span><span class=\"n\">S</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pltC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- R is the remainding nats, coprime to all p∈S</span>\n<span class=\"w\">  </span><span class=\"n\">R</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- these are tne steps you need to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apostrophe indicates result of the 'next' operation</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">             </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">          </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"c1\">-- C' &gt; C</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span>\n<span class=\"c1\">-- demonstrate that (hS, hR, hMin, hNew) are enough to prove</span>\n<span class=\"c1\">-- that a sieve generates the next consecutive prime at each step</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hs_suffice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x'</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hnx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- \"we have a new, bigger prime\"</span>\n<span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\">   </span><span class=\"c1\">-- \"and there is no prime between them\"</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"c1\">-- \"new bigger prime\" is class invariant</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">hnx</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hNewC</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">ex_p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ex_p</span><span class=\"w\"> </span><span class=\"c1\">-- assume p exists.</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cpks</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hR</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"n\">x'</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">cpks</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hc'g2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc'coprime</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"c1\">-- if there's a prime between C and C', then</span>\n<span class=\"w\">      </span><span class=\"c1\">-- C'</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hnx</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 448185666,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788154
    },
    {
        "content": "<p>I'm thinking that for any sieve implementation, you want to somehow talk about these sets... Otherwise you're tightly coupling the proof to the implementation.</p>",
        "id": 448185760,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788238
    },
    {
        "content": "<p>but the sets depend on a value in the structure (<code>C</code>, the \"current prime\")</p>",
        "id": 448185788,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788280
    },
    {
        "content": "<p>This does feel like a clunky way to structure it, though. Maybe a class isn't the right tool for the job?</p>",
        "id": 448185848,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788343
    },
    {
        "content": "<p>(afk for a couple hours, will be back on this tonight)</p>",
        "id": 448185952,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719788419
    },
    {
        "content": "<p>Here's how I would structure this class, since you have some fields, some definitions and then some more fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span>\n\n<span class=\"sd\">/-- S: the set of \"known primes\", less than C -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- R is the remainding nats, coprime to all p∈S -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- a generic prime sieve</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveBase</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- these are the steps you need to prove:</span>\n<span class=\"w\">  </span><span class=\"c1\">-- apostrophe indicates result of the 'next' operation</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">             </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">          </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"c1\">-- C' &gt; C</span>\n</code></pre></div>",
        "id": 448186269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719788739
    },
    {
        "content": "<p>Here's an alternative structuring which eliminates the type alpha entirely and just uses an abstract state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- S: the set of \"known primes\", less than C -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- R is the remainding nats, coprime to all p∈S -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- implement your algorithm in terms of these:</span>\n<span class=\"w\">  </span><span class=\"n\">hCp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">             </span><span class=\"c1\">-- C is prime</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">               </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">      </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\">       </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">     </span><span class=\"c1\">-- C' &gt; C</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">no_prime_between</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"bp\">.</span><span class=\"n\">hCp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">&lt;</span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">next</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"bp\">.</span><span class=\"n\">hCp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">PrimeSieveOK</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(I was going to have a structure for the state but in this formulation there is only one number in the state, the current prime value <code>C</code>, so it's overkill.) The idea is that in practice you would prove that your prime sieve relates to some abstract state <code>C</code> satisfying <code>PrimeSieveOK</code>, and <code>next</code> returns a value which is related via <code>PrimeSieveNext</code></p>",
        "id": 448187578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719789964
    },
    {
        "content": "<p>At this point though <code>PrimeSieveOK</code> is just some predicate on natural numbers which probably has a name already. Indeed:</p>\n<ul>\n<li><code>hCinR</code> is provable outright, because C, being prime, is coprime to all primes less than it</li>\n<li><code>hRmin</code> is false because it contains (non-prime) natural numbers less than C, but if you add <code>n &gt;= C</code> instead of <code>n &gt;= 2</code> to the definition of R then it becomes trivially provable outright</li>\n<li><code>hSmax</code> is trivially true by definition</li>\n</ul>\n<p>So all of the additional assumptions are unnecessary and <code>PrimeSieveOK C</code> is just another name for <code>Nat.Prime C</code> (and similarly <code>PrimeSieveNext</code> has two assumptions which are redundant with each other), suggesting a reformulation as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">               </span><span class=\"c1\">-- C is in R</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">      </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveNext</span><span class=\"bp\">.</span><span class=\"n\">next</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>although at this point we're clearly missing some assumption with which to prove <code>C'</code> is prime; most likely you want to say that <code>C'</code> is in <code>R C</code> or something along those lines</p>",
        "id": 448188368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719790742
    },
    {
        "content": "<p>Oh, wow. Thanks for all this! Lots to process. :)</p>",
        "id": 448200071,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719798610
    },
    {
        "content": "<blockquote>\n<p><code>hRmin</code> is false because it contains (non-prime) natural numbers less than C,</p>\n</blockquote>\n<p>Are you sure? Because if you're right, I'm misunderstanding something about my definition:</p>\n<p><code>def R (C : Nat) : Set Nat := { n | n ≥ 2 ∧ ∀ p ∈ S C, ¬(p.val ∣ n) }</code></p>\n<p>I think this is a \"set comprehension\" that says \"the set of natural numbers that greater than or equal to two, and are co-prime to every (prime) number in S\"... So if C is 11, a non-prime number smaller than C (like 4) can't be in the set, because 4 is divisible by 2, and <code>2 ∈ S C</code>.</p>",
        "id": 448200864,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799197
    },
    {
        "content": "<p><code>structure PrimeSieveOK (C : Nat) : Prop where ...</code> is warping my mind a little bit. It's a <code>structure</code> that can be applied like a function, and when applied, returns a <code>Prop</code> ?</p>",
        "id": 448201236,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799292
    },
    {
        "content": "<p><code>PrimeSieveOK C</code> is a predicate, like <code>Nat.Prime C</code>. When your predicate is a big conjunction of things <code>structure</code> is a natural way to define it and give the sub-properties names</p>",
        "id": 448201768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423842\">Michal Wallace (tangentstorm)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448200864\">said</a>:</p>\n<blockquote>\n<p>I think this is a \"set comprehension\" that says \"the set of natural numbers that greater than or equal to two, and are co-prime to every (prime) number in S\"... So if C is 11, a non-prime number smaller than C (like 4) can't be in the set, because 4 is divisible by 2, and <code>2 ∈ S C</code>.</p>\n</blockquote>\n<p>You are right, that was my mistake. <code>R</code> will not have any numbers less than C in it</p>",
        "id": 448202108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448201768\">said</a>:</p>\n<blockquote>\n<p><code>PrimeSieveOK C</code> is a predicate, like <code>Nat.Prime C</code>. When your predicate is a big conjunction of things <code>structure</code> is a natural way to define it and give the sub-properties names</p>\n</blockquote>\n<p>Very cool! I guess that's similar to <code>__call__</code> in python, but for some reason I didn't expect to find something like that in a functional language.</p>",
        "id": 448202806,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719799682
    },
    {
        "content": "<p>I'm not sure what you mean: Lean does have an analogue of <code>__call__</code> but this isn't it</p>",
        "id": 448202928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799717
    },
    {
        "content": "<p>This is just \"propositions are types\"</p>",
        "id": 448203019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799743
    },
    {
        "content": "<p><code>structure</code> can be used to make data, and it can also be used to make propositions</p>",
        "id": 448203090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799766
    },
    {
        "content": "<p>and <code>structure</code> can depend on parameters, which makes parametric data types when applied to data and predicates when used with propositions</p>",
        "id": 448203352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799812
    },
    {
        "content": "<p>another aspect of this is the fact that you can have properties next to data fields in a structure, and lean doesn't differentiate between them, they are all just fields in the structure but some are data values and some are proofs</p>",
        "id": 448203637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719799891
    },
    {
        "content": "<blockquote>\n<p><code>hSmax</code> is trivially true by definition<br>\nI couldn't see that before, because that was buried way down in the definition of <code>pltC</code>... Your rewrite makes the available facts much clearer.</p>\n</blockquote>",
        "id": 448204617,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719800211
    },
    {
        "content": "<p>By the way, the analogue of <code>__call__</code> is <code>CoeFun</code>, for example if we wanted your <code>ASeq</code> to act like a function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\">  </span><span class=\"c1\">-- arithmetic sequence (k + dn)</span>\n<span class=\"w\">  </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- constant</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">  </span><span class=\"c1\">-- difference</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"c1\">-- apply formula to n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeFun</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ap</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ASeq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mySeq</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- (5, 8, 11)</span>\n</code></pre></div>",
        "id": 448204743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800284
    },
    {
        "content": "<p>Oh, that's nice. That's definitely going in! </p>\n<p>I see the difference between this and the previous code (namely this has an implementation), but in my mind, I read <code>struct Foo (arg:Nat) : Prop</code> as \"Foo takes a Nat and returns a Prop\"</p>\n<p>It seems like the only reason you can't say <code>structure ASeq (n:Nat) : Nat where...</code> to do what you just did is because <code>structure</code> doesn't have anywhere to put the <code>:= ⟨ap⟩</code>.</p>\n<p>But... You can do that with <code>Prop</code> because prop doesn't require an implementation? </p>\n<p>Or is <code>: Prop</code> somehow special and means \"take the AND-sum of all the proposition fields in this structure\" ?</p>",
        "id": 448205309,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719800681
    },
    {
        "content": "<p>The reason you can't write <code>structure ASeq (n:Nat) : Nat where</code> is because <code>structure</code> declares a type, and the type of a type must be <code>Prop</code> or <code>Type u</code> for some <code>u</code> (these two cases are subsumed by the more general <code>Sort u</code>, where <code>Prop = Sort 0</code> and <code>Type u = Sort (u+1)</code>)</p>",
        "id": 448205562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800860
    },
    {
        "content": "<p>That is, you should read <code>Prop</code> as a kind of type universe, similar to <code>Type</code> and unlike <code>Nat</code></p>",
        "id": 448205677,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719800933
    },
    {
        "content": "<p>You can also write <code>structure Foo : Type 37 where</code> if you want, although there aren't many reasons to use such big universes</p>",
        "id": 448205811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801017
    },
    {
        "content": "<p>Got it. So it <em>is</em> a bit like an AND of all the facts, but it isn't magic... If you have a value of this type, you must have instances of all those facts attached, or it wouldn't type check.</p>",
        "id": 448205929,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801086
    },
    {
        "content": "<p>(and if you want the OR of facts, you will want to look into <code>inductive</code>, which <code>structure</code> is actually syntax sugar for, and which also works to make both data and propositions)</p>",
        "id": 448206109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801234
    },
    {
        "content": "<p>Okay. I like what you've done here. I think <code>no_prime_between</code> still has to be part of the spec, because otherwise I think <code>next $ StateWhereCis 5</code> might return <code>next $ StateWhereCis 11</code> ... Like it might internally track 7, but you would never be able to observe C=7 because it got skipped over.</p>",
        "id": 448206201,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801277
    },
    {
        "content": "<p>right, the idea was that this goes into <code>PrimeSieveNext</code>, although it's not clear how you want to state this property in a way that doesn't make it tautological</p>",
        "id": 448206289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801344
    },
    {
        "content": "<p>but if it's just one or two assumptions you might just not bother with a structure and just have a theorem that says everything you want from the abstraction</p>",
        "id": 448206420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801430
    },
    {
        "content": "<p>I also think maybe this spec ought to be called something like <code>PrimeGenerator</code> because it isn't <em>necessarily</em> a sieve, and whether it is or not, who cares? (Like, given C, you could just test whether each subsequent number is prime or not, without ever remembering any primes)</p>",
        "id": 448206439,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801445
    },
    {
        "content": "<p>I did not try very hard at the names :)</p>",
        "id": 448206459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801464
    },
    {
        "content": "<p>Oh, I didn't mean you. I'm the one calling it a Sieve the whole time. :)</p>",
        "id": 448206482,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801482
    },
    {
        "content": "<p>I agree at this level of abstraction it's not very sieve-like</p>",
        "id": 448206495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801482
    },
    {
        "content": "<p>the concrete implementation was sieve like but this is just a sequence of primes</p>",
        "id": 448206539,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801508
    },
    {
        "content": "<p>in fact with my refactoring it's not even really a sequence, it's just a relation between adjacent primes</p>",
        "id": 448206557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719801540
    },
    {
        "content": "<p>Do I even need sets? I was sort of imagining these prop fields as induction hypotheses... So at each step <code>(S' :=  S ∪ {C})</code> and I just have to say something about removing the multiples of C from R. But maybe I can say this with types?</p>",
        "id": 448207121,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719801960
    },
    {
        "content": "<p>sets are just sugar over predicates, but it can be nice to have the notation of e.g. adding an element like you just wrote</p>",
        "id": 448207241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719802033
    },
    {
        "content": "<p>I don't know if anyone would be interested in hanging out for this, but I'm live-streaming some work on this today. <a href=\"https://youtube.com/live/MNz6R4g0pOU?feature=share\">https://youtube.com/live/MNz6R4g0pOU?feature=share</a></p>",
        "id": 448381343,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719851475
    },
    {
        "content": "<p>Well, that probably wasn't worth watching since it was just me fumbling around and looking dumb, but here's the main result: a second prime generator that just uses <code>Nat.find</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">simple_gen</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">inferInstanceAs</span>\n\n<span class=\"w\">  </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- because the line below has ≤ and we need &lt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hcp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hprime</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_infinite_primes</span><span class=\"w\"> </span><span class=\"n\">d</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hprime</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Use Nat.find to get the smallest n that satisfies P</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- !! seems like this would do the search twice?</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">find_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ex_prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">PrimeGt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prime_gt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">prime_gt</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next_nprime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SimpleGen</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n\n<span class=\"w\">  </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PrimeSieveState</span><span class=\"w\"> </span><span class=\"n\">SimpleGen</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">c</span>\n<span class=\"w\">    </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">prime_two</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">nprime_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next_primegt</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">simple_gen</span>\n</code></pre></div>",
        "id": 448431496,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719865619
    },
    {
        "content": "<p>I broke the code up into separate files, too.. the prime generator spec is now here: <a href=\"https://github.com/tangentstorm/treesiv/blob/main/PrimeGen.lean\">https://github.com/tangentstorm/treesiv/blob/main/PrimeGen.lean</a></p>",
        "id": 448432691,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719865974
    },
    {
        "content": "<p>So. This one is <em>not</em> a sieve, and having it to compare kind of helps me think a little. The core thing I really want to show is that from a given state of the system, I can generate the next prime in sequence.</p>\n<p>For this simple generator, the entire state of the algorithm is contained in C (the current prime). It doesn't remember any other primes that it has found, and it doesn't do any sieving, so there's no need to refer to those sets R and S.</p>\n<p>So... I guess my goal now is to make a <code>PrimeGenOk</code> type that just demands a proof that C' is the next consecutive prime after C, and then prove that this simple generator succeeds here. (Looks like Nat.find_min will make this easy enough.)</p>\n<p>From there, I think I make a general rule about prime sieves using the sets I've been talking about. The argument would be: <em>if</em> you track these three things C (a prime), S (primes less than C) and R (all naturals greater than 1 and coprime to C), and at each step, C' &gt; C, <em>then</em> your prime generator is a sieve.</p>",
        "id": 448435165,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719866846
    },
    {
        "content": "<p>Does it matter if it's a sieve? Probably not, but I still have a hunch this framework is going to make it easier to prove that an arbitrary sieving algorithm generates the next prime from its internal state. In fact, maybe you only have to implement a proof that you're returning the smallest natural number in  R, and the \"prime sieve machinery\" provides the proof that you have the next prime.</p>",
        "id": 448436113,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719867225
    },
    {
        "content": "<hr>\n<p>I feel like I'm down to one last hurdle, but I'm still a tiny bit stuck. Here's where I'm at:</p>\n<ul>\n<li>\n<p>A<code>PrimeGenerator</code> is an algorithm that generates a natural number <code>P</code> at each step, and  proves:<br>\n-- <code>P</code> is prime<br>\n-- the next <code>P</code>  (<code>P'</code>) is greater than the current <code>P</code><br>\n-- There is no other prime number between <code>P</code> and <code>P'</code></p>\n</li>\n<li>\n<p>A <code>PrimeSieve</code> is a <code>PrimeGenerator</code> that generates <code>P'</code> by producing some <code>C : Nat</code> and proving that <code>C</code> is the smallest <code>Nat</code> not divisible by any prime less than or equal to the original <code>P</code>. </p>\n</li>\n</ul>\n<p>Obviously, every <code>PrimeGenerator</code> will generate a number of this kind since that's one of the definitions of a prime. But some algorithms specifically use data structures that model the set of remaining coprimes, and specifically reduce the set at each step by filtering out multiples of known primes.</p>\n<p>So now the problem is moving from math world to programming world. </p>\n<p>I have two actual sieve algorithms in lean4 - mine and <a href=\"https://github.com/ykonstant1/esiv/blob/master/Main.lean\">ykonstant1/esiv</a>.</p>\n<p>Esiv inspects a bitmask at each step so it potentially generates multiple primes at each step. It does not provide a proof of correctness, and  I think with a little work I could refactor it into a form that fits my rule above.</p>\n<p>Neither algorithm explicitly mentions \"the set of naturals coprime to the primes found so far\"  but they both manipulate some data structure from which the minimal value of this set can be extracted.</p>\n<p>I think the correctness proof proceeds by induction, but not using the <code>induction</code> keyword, because it's induction on function application rather than a recursive data type: in order to implement <code>PrimeSieve</code>, you have to provide <code>init</code> and <code>next</code> functions that produce a value of the type... And therefore have to provide all the necessary proofs.</p>\n<p>Since <code>next </code> has type <code>α → α</code>, we can use any proof attached to the input value as the induction hypothesis.</p>\n<p>I'm still unclear how to actually do it, though...</p>",
        "id": 448694183,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719951117
    },
    {
        "content": "<p>My instinct is to break it into several pieces, and prove:</p>\n<ol>\n<li>there is some way to produce an element of R (the set of un-scratched-off numbers) from the data</li>\n<li>there is a way to produce the minimal value of this set.</li>\n<li>there is some change being made to the data that filters out the multiples of the newly found prime</li>\n</ol>",
        "id": 448695090,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719951389
    },
    {
        "content": "<p>By the way, if you are collecting sieve implementations, I posted a prime sieve method (with a proof of correctness) here not too long ago: <a href=\"#narrow/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture/near/429974821\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/Checking.20the.20Goldbach.20conjecture/near/429974821</a></p>",
        "id": 448695612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719951568
    },
    {
        "content": "<blockquote>\n<p><code> have : buf[i] = true ↔ i.Prime := by</code></p>\n</blockquote>\n<p>Aha!! This is exactly the sort of thing I need.</p>",
        "id": 448696381,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719951782
    },
    {
        "content": "<p>I'm aiming for the <code>PrimeSieve</code> class to actually provide the <code>.Prime</code> part based on some lower-level fact, but I think I see the invariant I want to track now.</p>\n<ul>\n<li>show that some operation (<code>extract</code>) on the state produces only numbers in R</li>\n<li>let <code>R'</code> be <code>R</code> without the multiples of <code>P</code></li>\n<li>show that there is some operation called <code>filter</code> that changes the state so that <code>extract</code> now only produces numbers from <code>R'</code>  (possibly using the previous proof as an induction hypothesis)</li>\n<li>show that there is some operation <code>extractMin</code> to <code>extract</code> the minimum value in <code>R'</code></li>\n</ul>\n<p>(off to study your proof in detail now...)</p>",
        "id": 448699103,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719952693
    },
    {
        "content": "<p>Oh, interesting. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>,  you mentioned Oliveira e Silva's Goldbach verification project in the thread Mario just linked. He also has a similar project for the Collatz conjecture.</p>\n<p>Me using arithmetic sequences to model a prime sieve is rather silly and inefficient, but the actual reason I was thinking about modelling arithmetic sequences was to illustrate how his Collatz verifier works.</p>\n<p>It's essentially building a binary tree of arithmetic sequences in a top down, breadth-first manner, and then marking some of the nodes as dead before generating the next level.</p>",
        "id": 448702942,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1719954262
    },
    {
        "content": "<p>My go-to reference for an <em>actually efficient</em> sieve of Erastosthenes is <a href=\"https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\">this</a>. She also explains what makes most of the \"standard implementations\" rubbish.</p>",
        "id": 448898583,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1720024207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> yeah, the distinction she's making is kind of what I'm trying to get at with the separate definitions of <code>PrimeGenerator</code> and <code>PrimeSieve</code>...</p>\n<p>I find it interesting that there doesn't seem to be any way to define a proposition in Lean that would distinguish the different cases.</p>",
        "id": 448919033,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720030523
    },
    {
        "content": "<p>Her idea of using a priority queue of iterators is kinda neat.</p>",
        "id": 448919273,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720030594
    },
    {
        "content": "<p>I think I have a plan now:</p>\n<hr>\n<p><strong>Informal proof that we have a mapping from natural numbers to the residual set.</strong></p>\n<p>First, we show that the array of sequences ss represent a map from Nat to the residual set.</p>\n<p>If q is the number of sequences, then we can map an input n to ss[q%n] (q/n)</p>\n<p>In an arithmetic sequence A d k, if prime p | d, then p | A n iff p | k</p>\n<p>Since we use a primorial for our delta, the individual sequences either never or always divide the primorial’s factors.</p>\n<p>So the proof is by induction: first we know that in the input state, we had already filtered out all the other known primes. So all we have to do is filter out the “new” prime.</p>\n<p><strong>Informal proof that we can filter the set.</strong></p>\n<p>The filtering procedure is:</p>\n<ul>\n<li>\n<p>First, “partition” the sequence by composing it with the sequences (i + p) for i in range(p). </p>\n</li>\n<li>\n<p>This produces p new sequences, with a common delta divisible by p.</p>\n</li>\n<li>\n<p>Of these p sequences, exactly 1 will produce multiples of p. Remove this one.</p>\n</li>\n</ul>\n<p><strong>Informal proof that we can find the minimal value:</strong></p>\n<p>We track a list/set of arithmetic sequences (ASeq) that all have the same delta.</p>\n<p>Delta is a natural number, so term n &lt;= term (n+1), and term 0 is the minimal term.</p>\n<p>Since all sequences in our list have the same delta, the minimal value we can produce is term 0 of the sequence with smallest k.</p>",
        "id": 448954569,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720042869
    },
    {
        "content": "<hr>\n<p>It seems like it might be useful to have a notion of a <code>Comb</code> structure that represents a set or list of arithmetic sequences that all have the same delta. (\"Comb\" because if you plot the lines formed by the individual sequences, they’re parallel so it looks like running a comb through the sand).</p>\n<p>Partitioning a sequence would produce a comb, and you should be able to merge combs and sequences that have the same delta. (Really, a sequence could just be a special case of a comb that has only one tooth) </p>\n<p>( \"Rake\" maybe? Apparently this might also be called a Delta-set in math?)</p>",
        "id": 448954807,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720042996
    },
    {
        "content": "<p>Progress: I created a <a href=\"https://github.com/tangentstorm/treesiv/blob/main/Rake.lean\">Rake type</a>,  constructed an \"identity rake\" and showed that it maps the natural numbers to themselves by proving <code>theorem idr_id (n:Nat) : (idr.term n = n)</code>.</p>",
        "id": 448968404,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720049349
    },
    {
        "content": "<p>The rake works like a function from Nat -&gt; Nat. I suspect that in order to demonstrate that a particular Rake models a given subset of the naturals, I'm going to have to show that this function is a bijection.</p>",
        "id": 448969404,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720049944
    },
    {
        "content": "<p>(It occurs to me that a Rake might be exactly the same concept as what sieve theory calls a Wheel.)<br>\n<strong>edit:</strong> <em>It is not, but can be used to make one.</em></p>",
        "id": 448977969,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720055048
    },
    {
        "content": "<p>I implemented <code>aseq.gte n</code>, which fiddles with the sequence to give you only the results greater than or equal to n:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"n\">evens</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\">         </span><span class=\"c1\">-- [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">evens</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"c1\">-- [6, 8, 10, 12, 14, 16, 18, 20, 22, 24]</span>\n</code></pre></div>\n<p>I proved that the results are &gt;= n, but didn't yet prove that I haven't accidentally removed a result I shouldn't have.</p>",
        "id": 449007087,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720072209
    },
    {
        "content": "<p>I've also now got the concept of a <code>RakeMap</code> which makes the connection between a given <code>Rake</code> and a <code>Prop</code> that defines the corresponding set of natural numbers explicit:</p>\n<p>So, for example, here's a proof that the <code>idr</code> (identity rake) models the set <code>{ n : Nat | True }</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">idr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"c1\">-- the identity rake (maps n -&gt; n)</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">seqs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">dseq</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">],</span>\n<span class=\"w\">  </span><span class=\"n\">hsort</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">sorted_singleton</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_one</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prop</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">rake</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span>\n<span class=\"w\">  </span><span class=\"n\">hbij</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- proof that idr represents the identity function</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">idrm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">rake</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">idr</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">hbij</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">Rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">idr</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">dseq</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 449014249,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720075742
    },
    {
        "content": "<p>The plan is to now implement <code>RakeMap.gte n</code> that filters out results less than <code>n</code> (using the <code>ASeq.gte</code> function that I just mentioned), and something like <code>RakeMap.remove_multiples (p:NPrime)</code>, which will do what it says by using <code>partition</code> to split each sequence into <code>p</code> sequences with a common delta divisble by <code>p</code>, and then filter out the ones whose constant term is a multiple of <code>p</code>.</p>\n<p>I'm pretty sure I will be able to show that both <code>gte</code> and <code>remove_multiples</code> preserve whatever property was there before, but also filter out the appropriate values. Since the identity <code>idrm : RakeMap</code> models the entire set of naturals, I will then be able to reduce that to those &gt; 2, and filter out multiples of any prime, and (because the lists are sorted and I have a proof that the <code>Rakemap.term 0</code> always returns the minimal element of the modeled set... Then I will have all the pieces necessary to demonstrate a formally verified prime sieve.</p>\n<p>(yay!)</p>",
        "id": 449015753,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720076381
    },
    {
        "content": "<p>It looks like I'm going to have some minor hurdles to overcome with the \"the tines of the rake are sorted\" proof, but I will worry about that tomorrow.</p>",
        "id": 449015969,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720076428
    },
    {
        "content": "<p>Small update:</p>\n<p>I got the issues with proving the list is sorted worked out in <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Proving.20List.2ESorted.20after.20a.20mergeSort\">another thread</a>.</p>\n<p>I'm still working on <code>RakeMap</code>. I think I have a decent plan here. I already have the \"identity rake\" above. Now I need to show that for <code>gte</code> and <code>remove_multiples</code>, three facts hold:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">gte_lemmas</span>\n\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_drop</span><span class=\"w\"> </span><span class=\"c1\">-- gte drops terms &lt; p</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_keep</span><span class=\"w\"> </span><span class=\"c1\">-- gte keeps terms ≥ p</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">≥</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_same</span><span class=\"w\"> </span><span class=\"c1\">-- gte introduces no new terms</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">gte_lemmas</span>\n</code></pre></div>\n<p>From those three laws, I can prove the main result for the operation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_prop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rake</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"bp\">.</span><span class=\"n\">hbij</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">gte_drop</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">≥</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">gte_keep</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">hpm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">gte_same</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">&lt;</span><span class=\"n\">p</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">rake</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rake</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hbij</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>The logic for proving <code>remove_multiples</code> should be almost exactly the same. If there were more than two operations, I might consider making a <code>RakeMapRefinement</code> class, but since there are only two, I'll probably just write out both proofs.</p>",
        "id": 449446949,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720247440
    },
    {
        "content": "<p>Doing another live-proving stream in a bit if anyone cares to come hang out. <a href=\"https://youtube.com/live/CVJ7aZ6tRqY?feature=share\">https://youtube.com/live/CVJ7aZ6tRqY?feature=share</a></p>",
        "id": 449554483,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720296497
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448188368\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>hSmax</code> is trivially true by definition</li>\n</ul>\n</blockquote>\n<p>This was quite tricky.  You were correct. My initial formulation was:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">             </span><span class=\"c1\">-- C is in R</span>\n<span class=\"w\">  </span><span class=\"n\">hCinS</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">          </span><span class=\"c1\">-- C is in S'</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\">  </span><span class=\"c1\">-- C is max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"c1\">-- C' &gt; C</span>\n</code></pre></div>\n<p>The problem was that <code>hSmax</code> didn't express what my comment says it did. It should have said <code>S &lt;| next x</code>. </p>\n<p>My goal was to prove that from laws like these:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hs_suffice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>I was unable to prove this until I finally re-added the informal rule in the comment. The final rules look more or less like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">PrimeGen</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">prime_sieve</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- S: the set of \"known primes\", less than C</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- R: the set of \"remaining\" numbers, coprime to all known primes</span>\n<span class=\"w\">  </span><span class=\"c1\">-- describe the set of naturals with no prime factors less than some c</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">prime_sieve</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">    </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hCmax</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">  </span><span class=\"c1\">-- C is the max of S'</span>\n<span class=\"w\">  </span><span class=\"n\">hNewC</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\">           </span><span class=\"c1\">-- C &lt; C'</span>\n</code></pre></div>",
        "id": 449752937,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720404898
    },
    {
        "content": "<p>I may break the definition of <code>PrimeGen</code> up so that it generates <code>C x : Nat</code> and separately provides a proof of <code>Nat.Prime C x </code>... I believe have enough scraps lying around to prove that <code>C x</code> is still prime for all<code>PrimeSieve</code> instances, given the above definitions.</p>",
        "id": 449753424,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720405150
    },
    {
        "content": "<p>In trying to implement <code>instance : PrimeSieve RakeSieve</code> I realized I had to re-add most of the \"trivial\" statements I threw away before... Only instead of <em>defining</em> the current prime <code>C</code> in terms of the sets I'm tracking, the correct approach was to define the sets in relation to some highest known <code>Nat.Prime P</code>, and then have the <code>PrimeSieve</code> implementation produce a <code>C:Nat</code> together with a proof that <code>C</code> has the generic properties a prime sieve would look for.</p>\n<p>The <code>PrimeSieve</code> class itself provides the generic proof that C is actually the next prime.</p>\n<p>So... Now PrimeGen just generates a prime P at each step: (the change was just renaming C to P):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>And then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">prime_sieve</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- S: the set of \"known primes\", ≤ P</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"c1\">-- R: the set of \"remaining\" numbers, coprime to all known primes</span>\n<span class=\"w\">  </span><span class=\"c1\">-- describe the set of naturals with no prime factors less than some c</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">prime_sieve</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">A PrimeSieve is a PrimeGen that uses a sieve to generate primes.</span>\n<span class=\"sd\">In practice, this means that it somehow models the set of natural</span>\n<span class=\"sd\">numbers greater than 1 that are coprime to a list of known primes,</span>\n<span class=\"sd\">and then repeatedly:</span>\n<span class=\"sd\">  - obtains the minimum of this set as the next prime</span>\n<span class=\"sd\">  - eliminates multiples of the new prime. -/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- P (g:α) : NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- the \"current\" or \"candidate\" prime</span>\n<span class=\"w\">  </span><span class=\"n\">hSmax</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">   </span><span class=\"c1\">-- P is the max of S</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\">            </span><span class=\"c1\">-- C is an element of R</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">   </span><span class=\"c1\">-- C is min of R</span>\n<span class=\"w\">  </span><span class=\"n\">hCgtP</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\">            </span><span class=\"c1\">-- C &gt; P</span>\n<span class=\"w\">  </span><span class=\"n\">hP'C</span><span class=\"w\">   </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P'</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\">           </span><span class=\"c1\">-- P' = C</span>\n</code></pre></div>",
        "id": 450634460,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720681452
    },
    {
        "content": "<p>and from those definitions, i was able to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- demonstrate that g generates the next consecutive prime at each step.</span>\n<span class=\"c1\">-- \"we have a new, bigger prime, and there is no prime between them\".</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hs_suffice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeGen</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\">  </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">split_ands</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">c_prime</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"bp\">.</span><span class=\"n\">hCgtP</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">no_skipped_prime</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>",
        "id": 450634520,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720681496
    },
    {
        "content": "<p>I really like this because it formally verifies the basic concept of a Prime Sieve, completely independent of the specific data structure or algorithm that's doing the work.</p>",
        "id": 450634711,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720681567
    },
    {
        "content": "<p>Current snapshot: <a href=\"https://github.com/tangentstorm/treesiv/blob/856e41a57f7ab5897d63b532934b4c666b7060af/PrimeSieve.lean\">https://github.com/tangentstorm/treesiv/blob/856e41a57f7ab5897d63b532934b4c666b7060af/PrimeSieve.lean</a></p>",
        "id": 450635659,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720681995
    },
    {
        "content": "<p>Actually hSmax looks like it might be trivial again, but the proofs are using it. I'll see if I can get rid of it tomorrow. Then I just need to expose the right parts of the <code>RakeSieve</code> algorithm to prove that it meets these criteria.</p>",
        "id": 450638392,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720683052
    },
    {
        "content": "<h1>an unexpected problem</h1>\n<p>Uh-oh. I may need to rethink something here. In the previous design, the sieve provided its own proof that C was prime at each step.</p>\n<p>Now, implementing <code>class PrimeSieve</code> and proving that your <code>C:Nat</code> has certain properties is meant to be sufficient to show that <code>C</code> is prime.</p>\n<p>But this all depends on the sieve having access to a maximum known prime <code>P</code>.  The idea was that each step, <code>C</code> is proven prime and becomes the new <code>P</code>.</p>\n<p>Currently, in order to be a <code>PrimeSieve</code>, a type has to first be a <code>PrimeGen</code> that generates a prime P.</p>\n<p>In order to implement <code>PrimeGen</code>, I just need to produce any prime. Okay.</p>\n<p>But in order to implement <code>PrimeSieve</code>, that prime has to be the C from the previous step.</p>\n<p>But I can't prove that C is prime without implementing <code>PrimeSieve</code>.</p>\n<p>This is backwards.</p>\n<p>The sieve should not have to be a <code>PrimeGen</code> first. Instead:</p>\n<ul>\n<li><code>class PrimeSieve a</code> should be <code>structure PrimeSieve a [SieveState a]</code></li>\n<li>C and all the certifications about C move to this SieveState type.</li>\n<li>SieveState's <code>next</code> function should take as an argument a proof that C is prime</li>\n</ul>\n<p>Then maybe make PrimeGen a bit stronger so that it actually generates the primes in sequence, and have the final proof be that <code>PrimeSieve</code> implements <code>PrimeGen</code>.</p>",
        "id": 451010729,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720798248
    },
    {
        "content": "<p><span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> The fix is done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SieveState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">P</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">hNext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<ul>\n<li><code>class PrimeSieve α</code>, <code>S</code>, <code>R</code> require only <code>SieveState α</code></li>\n<li>there is no longer a need for <code>hSmax</code></li>\n<li><code>PrimeGen</code> requires a proof that there are no gaps between generated primes</li>\n<li><code>SimpleGen</code> (a <code>PrimeGen</code> based on <code>Nat.find</code>) supplies such a proof (this was quite educational)</li>\n<li>there is a basic outline for <code>RakeSieve</code> which implements <code>SieveState</code>.</li>\n</ul>\n<p>Current snapshot is here: <a href=\"https://github.com/tangentstorm/treesiv/blob/6f1ab7145c1fc1e5e6f773cbdf8b6a033b1d907b/PrimeSieve.lean\">https://github.com/tangentstorm/treesiv/blob/6f1ab7145c1fc1e5e6f773cbdf8b6a033b1d907b/PrimeSieve.lean</a></p>",
        "id": 451095703,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720827746
    },
    {
        "content": "<h1>What's left to do</h1>\n<ul>\n<li>prove that I can model a bijection to the set R by removing multiples of each new prime from the <code>RakeMap</code></li>\n<li>that will require showing that the existing functions can isolate the arithmetic sequences that produce multiples of the prime (they can) and that I correctly detect and remove them.</li>\n<li>implement <code>instance PrimeGen PrimeSieve</code>(all the important lemmas are proven, but I still have to write the <code>instance</code>).</li>\n<li>prove 3 lemmas about <code>RakeMap.gte n</code> (that it can filter out terms less than n)</li>\n<li>prove 3 lemmas about <code>RakeMap.rem p</code> (that it removes multiples of a prime)</li>\n<li>implement <code>instance PrimeSieve RakeSieve</code></li>\n</ul>\n<p>It's possible <code>PrimeSieve</code> might wind up having to be a <code>structure</code> rather than a <code>class</code>, but the basic proof requirements are the same either way.</p>\n<p>After that, I have some optimizations in mind, but the more important thing is to write and animate the video I'm making about all this for 3blue1browns' Summer of Math Exposition contest (which, aside from just wanting to learn lean, was the whole point of this project, and why I keep posting a devlog here).</p>\n<p>Anyway, I may do a live-proving stream tonight after my kids go to bed.</p>",
        "id": 451097773,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720828920
    },
    {
        "content": "<p>Doing live stream for a bit. Currently rebooting mid stream because this 10 iterations of this sieve crashed my whole machine :)</p>",
        "id": 451130726,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720850783
    },
    {
        "content": "<p>back online and streaming for an hour or two at <a href=\"https://www.youtube.com/live/wU3RisZt9tk\">https://www.youtube.com/live/wU3RisZt9tk</a></p>",
        "id": 451130989,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720851044
    },
    {
        "content": "<p>The major result of last night's stream was to remove the need for a <code>SieveState</code> to provide the proof that candidate prime <code>C</code> is greater than highest known prime <code>P</code>:</p>\n<p><code>hCgtP (g:α) : C g &gt; P g -- C &gt; P</code></p>\n<p>I still need this fact, but I was <a href=\"https://github.com/tangentstorm/treesiv/commit/2f85d9b148c0de434f2507ce646fce6e44c59a47?diff=unified&amp;w=0\">able to prove it</a> from the other definitions.</p>",
        "id": 451215039,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720897703
    },
    {
        "content": "<p>This brings the \"burden of proof\" for a SieveState down to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SieveState</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">P</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">hNext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hC</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PrimeSieve</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SieveState</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\">            </span><span class=\"c1\">-- C is an element of R</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\">   </span><span class=\"c1\">-- C is min of R</span>\n</code></pre></div>\n<p><code>hNext</code> is just a contract that you have to always make your <code>(state.next hC)</code> set the new <code>P</code> to the old <code>C</code>, so that's trivial.</p>\n<p>Now this is looking a bit messy to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SieveState</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- S: the set of \"known primes\", ≤ P</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"c1\">-- R: the set of \"remaining\" numbers, coprime to all known primes</span>\n<span class=\"w\">  </span><span class=\"c1\">-- describe the set of naturals with no prime factors less than some c</span>\n<span class=\"w\">  </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I think I will simplify R to a single function <code>R</code> from <code>Nat</code> to <code>Set Nat</code>, (like <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F/near/448187578\">mario suggested</a>), then just inline <code>S</code> (because it's no longer used anywhere), and then maybe provide a <code>SieveState.Rp</code> that just returns <code>(R x.P)</code>.</p>\n<p>I'm a little worried that refactoring will break all my proofs, but I guess I can just try it and if it's too hard to change, I'll roll it back.</p>\n<p>(tracking as <a href=\"https://github.com/tangentstorm/treesiv/issues/1\">issue 1</a>)</p>",
        "id": 451216574,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720898433
    },
    {
        "content": "<p>Actually, this seems like it might actually be a blocker.</p>\n<p>It's the same sort of circular dependency mistake I made with <code>PrimeGen</code> and <code>PrimeSieve</code>... This time, in order to prove my <code>RakeSieve</code> is a <code>SieveState</code>, I have to make statements about the set <code>R</code>, but <code>R</code> is un-necessarily defined in terms of <code>SieveState</code>, so I can't use the definition of <code>R</code>.</p>",
        "id": 451222055,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720901743
    },
    {
        "content": "<h1>What is this mistake I keep making?</h1>\n<p>I suppose it's a form of circular reasoning. I define an abstraction in terms of some property I want it to have, but then either:</p>\n<ul>\n<li>assume i have the property when i should instead be proving it, or</li>\n<li>tightly couple the property's definition to the abstraction's definition, so I can't prove anything has the property without it already being the thing I want to prove that it is.</li>\n</ul>\n<p>Well that's a mouthful, and maybe there are two different mistakes here, but at least I can watch out for this in the future.</p>",
        "id": 451225042,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720903372
    },
    {
        "content": "<hr>\n<p>Decoupling <code>R</code> and getting rid of <code>S</code> was easy.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- R: the \"residue\", or \"remaining\" nats coprime to all primes &lt; p.</span>\n<span class=\"c1\">-- In a sieve, these are the numbers that haven't yet been \"sifted out.\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"n\">NPrime</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Most of the proofs were fixed by just replacing <code>R g</code>, with<code>R(P g)</code> everywhere.</p>",
        "id": 451227183,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720905455
    },
    {
        "content": "<hr>\n<p>Every time I try to demonstrate that RakeSieve is a SieveState, I find a new problem or learn something about Lean.</p>\n<p>For example, this is not possible to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">RakeSieve</span><span class=\"bp\">.</span><span class=\"n\">hCinR</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"n\">RakeSieve</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\">            </span><span class=\"c1\">-- C is an element of R</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Why not? Well, because it doesn't follow from anything specific about the RakeSieve structure. Rather it's a statement that would have to cover every possible way of constructing a RakeSieve, and this is an open set.</p>\n<p>I could prove this theorem for an individual function... Something like <code>g' = next g →  C g' ∈ R (P g')</code>, but I don't like that, and it wouldn't let me prove that it holds for every RakeSieve object, so RakeSieve still couldn't be a PrimeSieve. </p>\n<p>So instead, the proposition has to be attached to the structure itself, and each individual function has to supply its own proof.</p>\n<p>I already knew how to do this, and it's obvious to me in retrospect, but I still had the mistake sitting in the stub file this whole time, and it was still surprising to me when I sat down to prove it. :)</p>",
        "id": 451228442,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720906679
    },
    {
        "content": "<p>Well, even that's not true. I still need the standalone theorem to prove <code>instance : PrimeSieve RakeSieve</code>... But I can't prove it unless there's a corresponding proof on the structure. And <code>C</code> and <code>P</code> aren't even part of the structure... Those are defined as part of <code>SieveState</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SieveState</span><span class=\"w\"> </span><span class=\"n\">RakeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">c</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hC</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RakeSieve</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hC</span>\n<span class=\"w\">  </span><span class=\"n\">hNext</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n</code></pre></div>\n<p>It seems like the general rule is that if you want ensure that a property holds in a class, you have to also prove a very similar thing for the structure itself. (But in this case, instead of writing it in terms of <code>C x</code> and <code>P x</code>, I have to write it in terms of <code>x.c</code> and <code>x.p</code>... and then hopefully derive the same facts for <code>C x</code> and <code>P x</code>...</p>",
        "id": 451228801,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720907018
    },
    {
        "content": "<p>Live-proving again tonight, starting in a few minutes.<br>\n<a href=\"https://youtube.com/live/jQ_b5-y623o?feature=share\">https://youtube.com/live/jQ_b5-y623o?feature=share</a></p>",
        "id": 451253169,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720927276
    },
    {
        "content": "<h1>almost there.</h1>\n<p>In the <a href=\"https://github.com/tangentstorm/treesiv/blob/77f0da1b2031d5361e8ba99ab4b1b8bd9099c9bd/RakeSieve.lean\">latest version of RakeSieve</a> includes proofs for all of the following properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RakeSieve</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">rm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"n\">prop</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPrime</span><span class=\"w\">               </span><span class=\"c1\">-- the current prime</span>\n<span class=\"w\">  </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\">                  </span><span class=\"c1\">-- the candidate for next prime</span>\n<span class=\"w\">  </span><span class=\"n\">hprop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">hCinR</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">hRmin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">r</span>\n</code></pre></div>\n<p>... except it doesn't yet prove <code>hRmin</code> for the <code>next</code> operation. That proof, and everything else in the whole system, is now waiting on me to verify the properties of <code>RakeMap</code> itself, which is just a list of arithmetic sequences that doesn't need to know anything about primes.</p>\n<p>The remaining issues until the proof is complete:</p>\n<ul>\n<li>demonstrate that term 0 of a Rakemap is the smallest term</li>\n<li>deal with the possibility that <code>rem</code> (removing multiples of a number) could remove all the sequences, which means that the set is empty and <code>term</code> can't return a value (therefore, <code>rem</code> has to return <code>Option RakeMap</code> instead of <code>RakeMap</code>)</li>\n<li>fill in the six lemmas to verify<code>gte</code> and <code>rem</code> accurately model the set operations they're supposed to reflect.</li>\n<li>write the (hopefully tiny amount of) code to show <code>instance : PrimeSieve PrimeGen</code></li>\n</ul>\n<p>... And then it's done. Still kind of a long list, but it at least feels like it's all downhill from here. :)</p>\n<p>(I still want to add some laziness to make it not so embarrassingly slow, but that'll have to wait until I've made enough progress on the <a href=\"https://some.3b1b.co/\">SoME</a> video.)</p>",
        "id": 451711135,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721120006
    },
    {
        "content": "<h1>(still) almost there</h1>\n<p>The only proofs left to do are in <code>Rake</code> itself. I'm currently doing some refactoring work to eliminate the <code>DSeq</code> type, which was just a subtype of <code>ASeq</code> where the <code>d</code> was baked into  the type (so I could assert that all the sequences in the Rake had the same delta). Instead, the new version of <code>Rake</code> just stores a list of Nats (<code>ks</code>) for the different constant terms, and has only one copy of <code>d</code>, and just instantiates <code>aseq r.ks[i] r.d</code> whenever it needs the sequence.</p>\n<p>I've also discovered I have a problem that will not actually arise in a prime sieve, but that complicates my type: basically, a rake is a list of parallel arithmetic sequences, and if that list were empty, then it would be meaningless to talk about the nth term. But one of my core operations is to remove multiples of a number.</p>\n<p>Since the number I'm passing in is always prime, and conditions in the prime sieve are set up so that each arithmetic sequence I'm dealing with always contains numbers coprime to it, I will never actually create an empty list. But proving all that would be a lot of work, so if I don't prove it, lean won't know for certain that the list of sequences is non-empty. That makes me want to return an <code>Option Rake</code>... But that's a pain. Instead, I think what I will do is basically what <code>Nat</code> does for <code>2 - 5</code>... return something like a 0.</p>\n<p>So, I'm thinking I allow d=0, and then I can create rakes that return arbitrary repeating patterns of constants... And in particular,   the rake  <code>{ d := 0,  ks := [0] }</code> would just give you 0 for every term. So, rather than <code>Option Rake</code>, I'll just return  this predefined <code>rake0</code>... I probably will have to pass in another hypothesis or two to the <code>rem</code> operation to get away with this, but I'm cross that bridge when I come to it.</p>",
        "id": 453609406,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721803225
    },
    {
        "content": "<h1>Rake invariants</h1>\n<p>I'm down to the last 6 lemmas... Three each to say that the <code>gte</code> and <code>rem</code> operations remove, retain, and don't add extra elements of the set...</p>\n<p>They're all looking like they're going to be very unpleasant. Why? Because for both operations, I'm first calling out to a lower level operation on arithmetic sequences in <code>ASeq</code>, and then after the important work is done, I'm doing a bunch of extra work to make sure the sequences within the rake are sorted.</p>\n<p>But the thing is, it's easy to sort the sequences at any time, so I think instead of forcing the thing to always be sorted, I'm going to add a Boolean field that says whether it's sorted, and then the proof field will contain an implication: <code>sorted → List.Sorted (·&lt;·) ks</code>...</p>\n<p>That would also allow rakes to produce a wider variety of sequences. (For example, with d=0 it could produce arbitrary cyclic patterns).</p>\n<p>The reason for all this is that the proofs seem to require me to break the pipeline down into small steps and prove that the same properties hold at each step. You can see it in the <em>implementation</em> of <code>gte</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"w\">  </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">aseq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ASeq</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ks₀</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ks₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ks₀</span><span class=\"bp\">.</span><span class=\"n\">dedup</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ks₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">sort_nodup</span><span class=\"w\"> </span><span class=\"n\">ks₁</span><span class=\"w\"> </span><span class=\"n\">ks₀</span><span class=\"bp\">.</span><span class=\"n\">nodup_dedup</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ks₂</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ks₀</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_lt_of_eq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"bp\">.</span><span class=\"n\">length_map</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ks₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">length_pos_of_dedup</span><span class=\"w\"> </span><span class=\"n\">h₀</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ks₂</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ks₁</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ks₁</span><span class=\"bp\">.</span><span class=\"n\">length_mergeSort</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_lt_of_eq</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ks</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ks₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hsort</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ks₂</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>If I don't break this apart, I don't see how I can avoid duplicating that same kind of logic for each of the 6 proofs. (And possibly for 3 more proofs that the <code>partition</code> step  called by <code>rem</code> works).</p>\n<p>The other alternative I was considering was writing a macro or tactic, but so far I'm having a hard time just writing one proof by hand to see what it is I'd need to generate...</p>",
        "id": 454157504,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721964966
    },
    {
        "content": "<p>update : making that change simplified things tremendously.<br>\n<a href=\"https://github.com/tangentstorm/treesiv/commit/205aef38d7bb377d2ebcc9bc8322c471e767a219?diff=split&amp;w=0\">https://github.com/tangentstorm/treesiv/commit/205aef38d7bb377d2ebcc9bc8322c471e767a219?diff=split&amp;w=0</a></p>",
        "id": 454170395,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721971434
    },
    {
        "content": "<p>Here's how that same function looks now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"w\">  </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">aseq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ASeq</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ks</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_of_lt_of_eq</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"bp\">.</span><span class=\"n\">length_map</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 454170458,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721971471
    },
    {
        "content": "<h1>the other 90%....</h1>\n<p>I thought these last few proofs would be easy, but I've had a hard time even getting started on them.</p>\n<p>I think I may actually need 8 proofs: 2 for the <code>partition</code> operation, to show that every generated term in the old rake is in the new rake and vice versa.... Whereas the <code>gte</code> and <code>rem</code> operations have to show:</p>\n<ul>\n<li>every term in the new rake was in the old rake</li>\n<li>every term in the old rake that we want to keep is in the new rake</li>\n<li>every term in the old rake that we want to discard got discarded.</li>\n</ul>\n<p><code>rem</code> calls <code>partition</code> under the hood, so i imagine I'll need to verify it along the way.</p>\n<p>But how do I make the proofs? The statements I wrote weeks ago all look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_drop</span><span class=\"w\"> </span><span class=\"c1\">-- gte drops terms &lt; p</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_keep</span><span class=\"w\"> </span><span class=\"c1\">-- gte keeps terms ≥ p</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">≥</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">RakeMap</span><span class=\"bp\">.</span><span class=\"n\">gte_same</span><span class=\"w\"> </span><span class=\"c1\">-- gte introduces no new terms</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">gte</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">pm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rm</span><span class=\"bp\">.</span><span class=\"n\">rake</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">pm</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>For the <code>keep</code> and <code>same</code> lemmas, it seems like I have to demonstrate that a particular input produced a particular output before and after the transformation.</p>\n<p>In my other <code>Rake</code> proofs, I've completely unfolded <code>Rake.term</code> and do a bunch of modular arithmetic to map a specific input to a specific position in the sequence... But I think I can avoid doing this for every proof if I just had a theorem that says it's sufficient to show that one of the constants in <code>rake.ks</code> plus some <code>m * rake.d</code> produces the desired value. In other words, it shouldn't really matter <em>which</em> term it is, or where it is in the sequence.</p>\n<p>For the proof of <code>gte_drop</code>, I guess I need to show that the minimum term is greater than or equal to the given number.</p>\n<p>For <code>rem_drop</code>... I think I have to show that <code>partition</code> can produce sequences that either always produce or never produce multiples of the given prime, and that those are the ones I remove.</p>\n<p>It all seems easy enough in my head, but I'm still struggling a bit to express this in lean...</p>",
        "id": 454387452,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722034405
    },
    {
        "content": "<p>.... It occurs to me that <code>gte</code> is only used once at the moment, to remove 0 and 1 (since these can't be prime). In the interest of time, I think I'll just cut it out for now, and manually prove that <code>{ d := 1, ks := [2] }</code> corresponds to <code>{ n : Nat // n ≥ 2 }</code>.</p>",
        "id": 454393002,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722037054
    },
    {
        "content": "<h1><code>Rake.term_iff</code></h1>\n<blockquote>\n<p>if I just had a theorem that says it's sufficient to show that one of the constants in <code>rake.ks</code> plus some <code>m * rake.d</code> produces the desired value</p>\n</blockquote>\n<p>Welp. It took me 5 hours, but I proved it (<a href=\"https://github.com/tangentstorm/treesiv/commit/74aaf6fee0f5ca64018152b7c98a9f031d867a31\">Rake.lean</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Rake</span><span class=\"bp\">.</span><span class=\"n\">term_iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">Rake</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">∈</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"o\">,</span><span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 454447606,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722071166
    },
    {
        "content": "<p>I live-streamed that session, btw. I don't really expect anyone to want to watch me flounder around, but on the off chance you do, there's now six of these videos from the past month in the playlist is here:</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLwI69hwjdBsY-hn-JTA7fG-v3gWWVmTxq\">https://www.youtube.com/playlist?list=PLwI69hwjdBsY-hn-JTA7fG-v3gWWVmTxq</a><br>\n<a href=\"/user_uploads/3121/htJFgDLw7NJ3LrWL8d3Pxkwv/hqdefault.webp\">hqdefault.webp</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/htJFgDLw7NJ3LrWL8d3Pxkwv/hqdefault.webp\" title=\"hqdefault.webp\"><img data-original-dimensions=\"336x188\" src=\"/user_uploads/thumbnail/3121/htJFgDLw7NJ3LrWL8d3Pxkwv/hqdefault.webp/840x560.webp\"></a></div>",
        "id": 454448219,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722071793
    },
    {
        "content": "<p>I think the effort I put into <code>term_iff</code> is paying off. I was able to prove that <code>sort</code> preserves the set of terms the rake produces by applying the exact same argument in both directions simultaneously using a long chain of tactics under <code>all_goals</code>. The only differences at the end were the direction a few rewrite rules were applied.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sort_term_iff_term</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span><span class=\"n\">Rake</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">m'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">m'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">sorted</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">rs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hd</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hsort</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hperm</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">sort</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">∈</span><span class=\"n\">rs</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">∈</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"bp\">.</span><span class=\"n\">dedup</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"bp\">.</span><span class=\"n\">mem_iff</span><span class=\"w\"> </span><span class=\"n\">hperm</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">∈</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">∈</span><span class=\"n\">rs</span><span class=\"bp\">.</span><span class=\"n\">ks</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">aesop</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">all_goals</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">term_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hk₁</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">hmem</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">term_iff</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hmem</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"o\">[</span><span class=\"n\">hd</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"o\">[</span><span class=\"n\">hmem</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hd</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(commit <a href=\"https://github.com/tangentstorm/treesiv/commit/fd5c45db6211a0694c862e6612194096674e97d6\">fd5c45d</a>)</p>",
        "id": 454683813,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722212611
    },
    {
        "content": "<h1>even more \"asmost there\"</h1>\n<p>I've made some pretty decent progress, after a long night of fighting with natural number division and temporarily giving up on my proof that <code>partition</code> retains the same set of terms, I moved on to proving the properties of the <code>rem</code> operation (removing multiples of a number).</p>\n<p>I proved all 3 properties of <code>rem</code>, that I needed, but there's a problem: I have to do something if a rake contains nothing but multiples of x and you tell it to remove all multiples of x... I could have <code>rem</code> return <code>Option Rake</code> but I knew that would cause a ton of headache down the line, so instead I just have it return a <code>zer</code> that has the formula <code>0 + 0*n</code> (so an infinite stream of zeros).</p>\n<p>Unfortunately, this also causes headaches for the caller, so I've realized what I really need to pass in is a proof that the Rake can produce numbers that are not divisible by X.</p>\n<p>In fact, <a href=\"https://en.wikipedia.org/wiki/Dirichlet%27s_theorem_on_arithmetic_progressions\">Dirichlet's prime number theorem</a> tells us that any arithmetic sequence <code>k + d *n</code> where <code>k</code> and <code>d</code> are co-prime will yield an infinite number of primes, and there is an <a href=\"https://www.jstor.org/stable/1969454?origin=crossref\">elementary proof</a> of this due to Atle Selberg that I think <em>might</em> be approachable in Lean.... At some point.</p>\n<p>But I don't think I'll need anything like that for my purposes, since I've already got a prime sieve, and I already know that the set of \"numbers I haven't crossed off yet\" contain all the primes. In fact, term 0 is the next prime, and multiples of all smaller primes are already crossed out, so the next compound number must be (term 0)^2... and there must be a prime in between because <a href=\"https://en.wikipedia.org/wiki/Bertrand%27s_postulate\">a prime always exists between n and 2*n</a>... a fact which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/Bertrand.html\">already in mathlib</a>...</p>\n<p>All together, that means either <code>term 1</code> is also a new prime. (I might have to prove that the nth prime is always smaller than the nth primorial, which seems obvious but might be hard (???).... But even if I can't prove that, the next smallest term after term 0 would be <code>term (ks.length)</code> so either way it should be good.)</p>\n<p>So, in short, I now need to:</p>\n<ul>\n<li>finish the proof that <code>partition</code> leaves the terms unchanged</li>\n<li>patch the <code>rem</code> proofs to eliminate the <code>zer</code> case using proof of a second prime in the rake</li>\n<li>create and supply that proof</li>\n</ul>",
        "id": 455556396,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722491104
    },
    {
        "content": "<h1><a href=\"https://github.com/tangentstorm/treesiv/tree/e97c80ea306b1bd5cba3092d07018e4a6f4282e3\">QED</a></h1>",
        "id": 456402073,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1722812578
    }
]