[
    {
        "content": "<p>When I define something by recursion, it's defined by what the lean reference calls the definitional reductions,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">constructor</span><span class=\"bp\">ᵢ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span><span class=\"bp\">ᵢ</span> <span class=\"n\">b</span> <span class=\"bp\">...</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">δ</span><span class=\"bp\">ᵢⱼ</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">ⱼ</span> <span class=\"n\">d</span><span class=\"o\">))</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>Is there an easy way to get these definitional reductions in a way that can be passed to rw or simp or the like?</p>\n<p>They're easy to prove using the constructor tactic, but the only way I've found to do that is to manually prove n trivial lemmas, one for each constructor, after each inductive definition. On the other hand, things like rw F, unfold F, or simp [F] all replace F with the whole recursive definition, which is inconvenient when there are inductive hypotheses stated interms of F.</p>",
        "id": 354991062,
        "sender_full_name": "Henry Towsner",
        "timestamp": 1682981721
    },
    {
        "content": "<p>Is this lean 3 or lean 4? In either case probably the correct answer is that if you're making the definition then it's your job to make the API, so state the things you want, give them good names, prove them with <code>rfl</code> and tag them with <code>simp</code>, and Bob's your uncle.</p>",
        "id": 354992174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682982354
    },
    {
        "content": "<p>You might find that prepending <code>@[simps]</code> to your definition does some of this automatically -- you can check what it did with <code>whatsnew in</code> in lean 4 and <code>#print prefix &lt;declname&gt;</code> in Lean 3</p>",
        "id": 354992382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1682982457
    },
    {
        "content": "<p>It's lean 3. I take it @[simps] is lean 4 only for definitions (it's telling me the target is not a structure when I try to add it). Is there a lean 3 analog?</p>",
        "id": 354995558,
        "sender_full_name": "Henry Towsner",
        "timestamp": 1682984538
    },
    {
        "content": "<p>Yes, it's <code>@[simps]</code>. You will have to give us more context on what you're doing, in particular on what the type of <code>F</code> is.</p>",
        "id": 354995929,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1682984867
    },
    {
        "content": "<p>For a simple example, say I want to define the 2^n operation inductively on nat, by</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pow2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span>\n<span class=\"mi\">1</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The equality I'd expect to get in this case is pow2 (succ n) = 2*(pow 2 n). (Of course I can prove it manually very easily, but once there are more constructors and a lot of inductive definitions, it starts to get tedious, and given that these equalities are literally the definition of what the recursor is supposed to do, I was hoping there was an easier way to get them.)</p>",
        "id": 354996703,
        "sender_full_name": "Henry Towsner",
        "timestamp": 1682985475
    },
    {
        "content": "<p>In fact, they are already autogenerated. Do <code>#print prefix pow2</code></p>",
        "id": 354996809,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1682985550
    },
    {
        "content": "<p>But these <em>equation lemmas</em> are not meant for human consumption. The idiomatic thing to do is to <code>rw pow2</code> or to write the autogenerated lemmas yourself and give them nice names.</p>",
        "id": 354996924,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1682985615
    },
    {
        "content": "<p>Also note that, when pattern-matching on several arguments, your cases might be unexpectedly split up. It is then wiser to write the equation lemmas yourself to keep control of the situation.</p>",
        "id": 354997055,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1682985704
    },
    {
        "content": "<p>If you use pattern matching instead of <code>rec_on</code> lean writes these lemmas for you</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pow2</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">pow2</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 354999557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1682987231
    },
    {
        "content": "<p>Thanks! That was exactly what I was looking for.</p>",
        "id": 355003583,
        "sender_full_name": "Henry Towsner",
        "timestamp": 1682989242
    },
    {
        "content": "<p>Hi Henry! I'm sure you have already noticed, but you don't need the <code>constructor</code> tactic, as these are true by definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pow2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.rec_on</span> <span class=\"n\">n</span>\n<span class=\"mi\">1</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">n</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pow2_zero</span> <span class=\"o\">:</span> <span class=\"n\">pow2</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pow2_succ</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pow2</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">pow2</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 355013185,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1682994924
    }
]