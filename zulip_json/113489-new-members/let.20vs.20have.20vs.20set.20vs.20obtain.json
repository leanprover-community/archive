[
    {
        "content": "<p>It took me several months to really appreciate the difference between <code>let</code>, <code>have</code>,<code>set</code>, and <code>obtain</code>. Maybe I was reading the wrong educational resources but I was surprised that this doesn't seem to be centered in explanations despite it being fairly essential.</p>\n<p>Here's my current condensed understanding. I'd appreciate any corrections:</p>\n<ul>\n<li>\n<p><code>let</code> is the simplest one. It's just giving a local name to a thing. If you have <code>let a := foo</code>, and later you have some expression with <code>a</code>, you can <code>unfold a</code> to \"see\" that it's \"really\" <code>foo</code>. You can also include <code>a</code> in simps, like <code>simp only [a]</code>, to unfold it. I noticed that sometimes <code>rw</code> and <code>simp</code> on the underlying <code>foo</code> will \"pierce through\" <code>a</code> anyway but sometimes they won't; I'm not sure why that is, but <code>unfold a</code> will generally always work and you can later try removing it.</p>\n</li>\n<li>\n<p><code>have</code> is like <code>let</code> but more \"opaque\". You can't unwrap it! It's like it forgets what you put there. So <code>have a := foo</code> now introduces <code>a</code> as its own thing, and you can't ever go back to seeing it as a <code>foo</code>. If you need to unwrap that connection later, don't use <code>have</code> ‚Äî use <code>let</code>. This is handy for \"forgetting\" unnecessary details. It's also why <code>have</code> is often used for proofs since the internals of a proof should never matter (even though technically a proof is just another value). Again, you can't unwrap <code>have</code>, that's why putting it in <code>unfold</code> or <code>simp</code> won't work. It's also why, if you declare objects with <code>have</code>, you risk \"forgetting\" some of their properties you might need for later.</p>\n</li>\n<li>\n<p><code>set</code> ... I'm actually not sure it does anything special compared to <code>let</code> when you just do <code>set a := foo</code>. I used to think it does something special (compared to <code>have</code>) but that was before I learned about <code>let</code>. So now I just assume it's like <code>let</code> but also has some additional syntax (<code>set ... with ...</code>) which I've never needed so far.</p>\n</li>\n<li>\n<p><code>obtain</code> is, from what I understand, like <code>have</code> but it gets rid of the stuff it \"consumes\".  So <code>obtain ‚ü®h1, h2‚ü© := h</code> will remove <code>h</code> from the context. So it's nice for keeping the tactic state clean. Other than that I presume it has no differences from <code>let</code>.</p>\n</li>\n</ul>\n<p>All of the above is in the tactic mode. In term mode, my understanding is that:</p>\n<ul>\n<li><code>let</code> is (mostly?) same as above.</li>\n<li><code>have</code> is (mostly?) same as above.</li>\n<li><code>set</code> and <code>obtain</code> don't exist.</li>\n</ul>\n<hr>\n<p>As a meta-comment, I think it's interesting that there is no obvious place to read about all of these and compare them. Yes, TPIL explains this in a few places, but you have to dig for these comparisons, and they're pretty deep in the book. </p>\n<p>In a programming language tutorial, a distinction like this would be one of the first things being discussed. IMO the fact that I only managed to learn about these a few months in (by explicitly googling it) and it turned out to be so crucial (I didn't understand how important <code>unfold</code>-ability of <code>let</code> is) means it probably wouldn't hurt to push this explanation way up in common resources. For example, maybe MIL could explain this better. That's feedback for MIL though.</p>\n<p>Is the understanding above mostly correct? Did I misrepresent anything?</p>\n<p>Thanks!</p>",
        "id": 534306423,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755120231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> I should say that actually if you hover over them, it gives you some sort of description of what they do</p>",
        "id": 534309787,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755121993
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 534309807,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755121999
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/FuuiQ7dvPssYpDX90e4Sd3Ba/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/FuuiQ7dvPssYpDX90e4Sd3Ba/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"859x476\" src=\"/user_uploads/thumbnail/3121/FuuiQ7dvPssYpDX90e4Sd3Ba/image.png/840x560.webp\"></a></div>",
        "id": 534309843,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122015
    },
    {
        "content": "<p>Here are the docstrings:</p>\n<p>The <code>let</code> tactic is for adding definitions to the local context of the main goal.</p>\n<ul>\n<li><code>let x : t := e</code> adds the definition <code>x : t := e</code> if <code>e</code> is a term of type <code>t</code>.</li>\n<li><code>let x := e</code> uses the type of <code>e</code> for <code>t</code>.</li>\n<li><code>let : t := e</code> and <code>let := e</code> use <code>this</code> for the name of the hypothesis.</li>\n<li><code>let pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,<br>\n  where <code>_</code> stands for the tactics that follow this one.<br>\n  It is convenient for types that let only one applicable constructor.<br>\n  For example, given <code>p : Œ± √ó Œ≤ √ó Œ≥</code>, <code>let ‚ü®x, y, z‚ü© := p</code> produces the<br>\n  local variables <code>x : Œ±</code>, <code>y : Œ≤</code>, and <code>z : Œ≥</code>.</li>\n</ul>",
        "id": 534309944,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122065
    },
    {
        "content": "<p>The <code>have</code> tactic is for adding hypotheses to the local context of the main goal.</p>\n<ul>\n<li><code>have h : t := e</code> adds the hypothesis <code>h : t</code> if <code>e</code> is a term of type <code>t</code>.</li>\n<li><code>have h := e</code> uses the type of <code>e</code> for <code>t</code>.</li>\n<li><code>have : t := e</code> and <code>have := e</code> use <code>this</code> for the name of the hypothesis.</li>\n<li><code>have pat := e</code> for a pattern <code>pat</code> is equivalent to <code>match e with | pat =&gt; _</code>,<br>\n  where <code>_</code> stands for the tactics that follow this one.<br>\n  It is convenient for types that have only one applicable constructor.<br>\n  For example, given <code>h : p ‚àß q ‚àß r</code>, <code>have ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h</code> produces the<br>\n  hypotheses <code>h‚ÇÅ : p</code>, <code>h‚ÇÇ : q</code>, and <code>h‚ÇÉ : r</code>.</li>\n</ul>",
        "id": 534309980,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122087
    },
    {
        "content": "<p><code>set a := t with h</code> is a variant of <code>let a := t</code>. It adds the hypothesis <code>h : a = t</code> to<br>\nthe local context and replaces <code>t</code> with <code>a</code> everywhere it can.</p>\n<p><code>set a := t with ‚Üê h</code> will add <code>h : t = a</code> instead.</p>\n<p><code>set! a := t with h</code> does not do any replacing.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">x : Nat</span>\n<span class=\"cm\">y : Nat := x</span>\n<span class=\"cm\">h : y + y - y = 3</span>\n<span class=\"cm\">h2 : x = y</span>\n<span class=\"cm\">‚ä¢ y + y - y = 3</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 534309984,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122088
    },
    {
        "content": "<p>I will agree with you that the docstrings for let vs have are a bit subtle, but the key points are there:</p>\n<ul>\n<li><code>let</code> adds a <em>definition</em>, and <code>have</code> adds a <em>hypothesis</em>, this information is in the first sentences of the docstrings</li>\n</ul>",
        "id": 534310067,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122126
    },
    {
        "content": "<p>The <code>obtain</code> tactic is a combination of <code>have</code> and <code>rcases</code>. See <code>rcases</code> for<br>\na description of supported patterns.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">patt</span><span class=\"o\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proof</span>\n</code></pre></div>\n<p>is equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">proof</span>\n<span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"o\">‚ü®</span><span class=\"n\">patt</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>If <code>‚ü®patt‚ü©</code> is omitted, <code>rcases</code> will try to infer the pattern.</p>\n<p>If <code>type</code> is omitted, <code>:= proof</code> is required.</p>",
        "id": 534310364,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122242
    },
    {
        "content": "<p>so <code>obtain</code> allows you to do case matching, and the other three don't</p>",
        "id": 534310405,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755122270
    },
    {
        "content": "<p>Thanks! I did read through all of those.</p>\n<p>Personally I find ‚Äúadds a defintion‚Äù vs ‚Äúadds a hypothesis‚Äù more confusing than helpful. Them being introduced like this is actually one of the main causes of my overall confusion.</p>\n<p>It‚Äôs just untrue. You‚Äôre perfectly able to define hypotheses (which I understand as terms whose type is some prop) via <code>let</code>. One is also perfectly able to define arbitrary bindings like <code>have a : Nat := 1</code> with <code>have</code> (so <code>have</code> seems to have no actual semantics related to hypotheses). </p>\n<p>What these allude to seem to be assumptions about common usage (‚Äúif you define proofs via <code>have</code> and other things via <code>let</code>, you‚Äôll follow the intended usage and run into fewer problems‚Äù). But since they don‚Äôt explain the critical bit (use <code>have</code> when you want an opaque definition, use <code>let</code> when you want an unfoldable definition, use <code>unfold</code> to pierce through a <code>let</code>). This information seems critical to me and it actually explains why <code>have</code> is used for proofs. </p>\n<p>Hope that makes sense.</p>",
        "id": 534312638,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755123471
    },
    {
        "content": "<p>Maybe another way to phrase it: I think <code>let</code> should be taught together with <code>unfold</code>. It‚Äôs crucial to understand both to be able to progress in a proof. One undoes what the other does (at least in InfoView).</p>\n<p>Then when <code>have</code> is first taught, it can be noted that <code>unfold</code> doesn‚Äôt work with it. That explains why it‚Äôs different from <code>let</code>. There‚Äôs no point to unfolding proofs so this also explains why <code>have</code> is used for proofs.</p>\n<p>I‚Äôm maybe slightly exaggerating (okay, not the first explanation, but maybe the first chapter). But this connection between defining and unfolding and opaqueness was competently lost on me until I started googling precisely this thing.</p>",
        "id": 534313096,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755123726
    },
    {
        "content": "<p>Another point is that Lean has a bunch of ways to do the same thing that accommodate different writing styles or are baggage from past versions. So it‚Äôs hard to guess that <code>let</code> and <code>have</code> are <em>actually</em> subtly different and aren‚Äôt just two conventional words that mathematicians like to use for definitions and theorems.</p>",
        "id": 534313313,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755123849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534312638\">said</a>:</p>\n<blockquote>\n<p>you‚Äôll follow the intended usage and run into fewer problems</p>\n</blockquote>\n<p>but this is true</p>",
        "id": 534317869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755126819
    },
    {
        "content": "<p>I think teaching the intended usage is more important than teaching all the details</p>",
        "id": 534317887,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755126838
    },
    {
        "content": "<p>Should there be a linter that disallows declaring proofs with <code>let</code>? And non-proofs with <code>have</code>? Or are there legit exceptions?</p>",
        "id": 534324410,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755132448
    },
    {
        "content": "<p>no???</p>",
        "id": 534324454,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132487
    },
    {
        "content": "<p>(typo)</p>",
        "id": 534324477,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755132503
    },
    {
        "content": "<p>oh</p>",
        "id": 534324482,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132507
    },
    {
        "content": "<p>yeah it's still no</p>",
        "id": 534324485,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132510
    },
    {
        "content": "<p>sometimes I <code>have</code> data because I don't want to look inside</p>",
        "id": 534324552,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132555
    },
    {
        "content": "<p>The docstring Kenny quoted mentions this but just to call it out again explicitly --</p>\n<blockquote>\n<p><code>set</code> ... I'm actually not sure it does anything special compared to <code>let</code> when you just do <code>set a := foo</code>. I used to think it does something special (compared to <code>have</code>) but that was before I learned about <code>let</code>. So now I just assume it's like <code>let</code> but also has some additional syntax (<code>set ... with ...</code>) which I've never needed so far.</p>\n</blockquote>\n<p><code>set</code> is \"give a name to an expression, and also update all the spots that that expression appears throughout the goal state anywhere\". So it does something special to <em>other</em> hypotheses other than the new one that is being added by using <code>set</code>. (It's convenient for giving a name to something you decide you need at some point through a proof, and then simultaneously ensuring that all the spots the expression already appears in immediately use the new name you gave it.)</p>",
        "id": 534324577,
        "sender_full_name": "Julian Berman",
        "timestamp": 1755132580
    },
    {
        "content": "<p>this also stops the typechecker from getting stuck trying to unfold it since it shouldn't need to do that</p>",
        "id": 534324596,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132594
    },
    {
        "content": "<p>Btw I generally agree that teaching intended usage is important but I also think ‚Äúunfolding‚Äù and opaqueness are part of ‚Äúintended usage‚Äù and not just implementation details.</p>",
        "id": 534324644,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755132633
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span>, now I remember that‚Äôs what I used to think it does! But for some reason I couldn‚Äôt always get it working consistently, and then I thought I misunderstood. I‚Äôll need to check if I can repro‚Ä¶</p>",
        "id": 534324732,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755132726
    },
    {
        "content": "<p>Also on <code>obtain</code> -- and I always forget whether this is 100% accurate or not so Aaron may remind me I'm wrong -- but I think <code>obtain</code> (== <code>rcases</code>) supports all the things <code>have</code> does, plus additional patterns-- though not the ones you mentioned, that one <code>have</code> can do too. But e.g. compare:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚àß</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚à®</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(where <code>have</code> cannot do the case split from the second one if you try changing to <code>have</code>).</p>\n<p>So yeah (unless I'm forgetting something which someone will point out) have is \"pointless\", obtain dominates it as a tactic, but have is the lower level tactic so it doesn't go away, and clearly it's still ubiquitous.</p>",
        "id": 534324916,
        "sender_full_name": "Julian Berman",
        "timestamp": 1755132874
    },
    {
        "content": "<p><code>have</code> and <code>obtain</code> have slightly non-overlapping patterns: <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Is.20cases.27.20deprecated.3F/near/433802047\">#mathlib4 &gt; Is cases' deprecated? @ üí¨</a></p>",
        "id": 534340368,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1755146077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/stream/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534324644\">said</a>:</p>\n<blockquote>\n<p>but I also think ‚Äúunfolding‚Äù and opaqueness are part of ‚Äúintended usage‚Äù</p>\n</blockquote>\n<p>For what it's worth I (almost) never <code>unfold</code> anything. More often than not, if you are <code>unfold</code>ing, it means you are missing API lemmas.</p>",
        "id": 534344179,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755149324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534340368\">said</a>:</p>\n<blockquote>\n<p><code>have</code> and <code>obtain</code> have slightly non-overlapping patterns: <a class=\"message-link\" href=\"/#narrow/channel/287929-mathlib4/topic/Is.20cases.27.20deprecated.3F/near/433802047\">#mathlib4 &gt; Is cases' deprecated? @ üí¨</a></p>\n</blockquote>\n<p>Yeah, but I still think the ideal outcome would be to merge them and pick one or the other where they don't agree</p>",
        "id": 534413144,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1755156765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534312638\">said</a>:</p>\n<blockquote>\n<p>It‚Äôs just untrue. You‚Äôre perfectly able to define hypotheses (which I understand as terms whose type is some prop) via <code>let</code>. One is also perfectly able to define arbitrary bindings like <code>have a : Nat := 1</code> with <code>have</code> (so <code>have</code> seems to have no actual semantics related to hypotheses).</p>\n</blockquote>\n<p>I mean, it's perfectly true as long as you understand what the difference between a definition and a hypothesis <em>is</em> in Lean. Which I suppose could be explained more clearly. But ultimately, the difference is precisely that a hypothesis is a value-less definition, where the only accessible information is its type; this is definitely sufficient whenever the value is a <code>Prop</code>, is usually sufficient when the value is a typeclass instance, and may be sufficient in misc other cases.</p>\n<p>I also agree that <code>unfold</code> is rarely used, though in part that's because <code>simp</code> and <code>simp_rw</code> will do the same thing.</p>",
        "id": 534433062,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1755160124
    },
    {
        "content": "<p>I was thinking there could be a tactic <code>xyzzy</code>, such that<br>\n(syntax very preliminary, please improve!)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\">  </span><span class=\"c1\">-- let</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"c1\">-- have</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\">  </span><span class=\"c1\">-- have</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"c1\">-- obtain</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"c1\">-- generalize/set</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"c1\">-- set x := some expr with hx</span>\n<span class=\"n\">xyzzy</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">subexpr</span><span class=\"w\"> </span><span class=\"c1\">-- we don't have a one-liner for this</span>\n</code></pre></div>\n<p>That last line would be a combination of <code>generalize/set</code> and <code>rcases</code>, where you get two subgoals,</p>\n<ol>\n<li><code>hn : 0 = some subexpr</code> -- and the rest of the context has <code>0</code> where <code>some subexpr</code> used to be</li>\n<li><code>hn : n+1 = some subexpr</code> -- and the rest of the context has <code>n+1</code> where <code>some subexpr</code> used to be</li>\n</ol>",
        "id": 534434209,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1755160524
    },
    {
        "content": "<p>I think it would be very useful also to have a way to combine <code>let</code>/<code>set</code> with <code>clear_value</code>, as it is often the case that one wants to forget the value to be able to eg do induction on the new variable</p>",
        "id": 534434667,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755160693
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">foo_eq_bar</span>\n<span class=\"n\">clear_value</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p>is halfway between <code>let foo := bar</code> and <code>have foo := bar</code>, in the sense that <code>foo</code> isn't defeq to <code>bar</code>, but you still have <code>foo = bar</code> in context</p>",
        "id": 534434956,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755160787
    },
    {
        "content": "<p>To me, this is what <code>xyzzy +opaque x : my type := some value</code> could mean</p>",
        "id": 534435003,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755160803
    },
    {
        "content": "<p>By the way, why would you prefer <code>have</code> over <code>let</code>? Why is forgetting definitions useful?</p>",
        "id": 534440013,
        "sender_full_name": "suhr",
        "timestamp": 1755162769
    },
    {
        "content": "<p>To me this is a bit like asking \"why use <code>theorem</code> instead of <code>def</code>?\" Remembering a proof is useless because all proofs are equal so it‚Äôs just noise, <code>have</code> is cleaner.</p>",
        "id": 534442551,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1755163809
    },
    {
        "content": "<p>That's a not a very convincing explanation. Even though proofs are irrelevant, why would you need to actively forget them?</p>",
        "id": 534444118,
        "sender_full_name": "suhr",
        "timestamp": 1755164430
    },
    {
        "content": "<p>You don‚Äôt need, it‚Äôs just nicer.</p>",
        "id": 534444250,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1755164480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534324410\">said</a>:</p>\n<blockquote>\n<p>Should there be a linter that disallows declaring proofs with <code>let</code>? And non-proofs with <code>have</code>? Or are there legit exceptions?</p>\n</blockquote>\n<p>There is half of such a linter, it is just not active by default:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">linter</span><span class=\"bp\">.</span><span class=\"n\">haveLet</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">7</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 534450809,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1755167247
    },
    {
        "content": "<p>The linter warns you when <code>have</code> is used for a non-<code>Prop</code>.</p>\n<p>The linter has 3 behaviours:</p>\n<ol start=\"0\">\n<li><code>set_option linter.haveLet 0</code> means that the linter says nothing;</li>\n<li><code>set_option linter.haveLet 1</code> means that the linter warns on <code>have</code> introducing a non-<code>Prop</code>, but only in incomplete proofs.</li>\n<li><code>set_option linter.haveLet 2</code> means that the linter warns on <code>have</code> introducing a non-<code>Prop</code>, regardless of whether the proof is complete or not.</li>\n</ol>\n<p>The \"normal\" behaviour of the linter, were it not set to <code>0</code>, would be <code>1</code>.</p>",
        "id": 534451525,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1755167532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534435003\">said</a>:</p>\n<blockquote>\n<p>To me, this is what <code>xyzzy +opaque x : my type := some value</code> could mean</p>\n</blockquote>\n<p>Plus the <code>(eq := foo_eq_bar)</code> option (modulo syntax improvements).</p>",
        "id": 534465756,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1755172301
    },
    {
        "content": "<p>Thanks for the discussion! I want to clarify a few points.</p>\n<p>First, I want to clarify the reason for my posting. I have a fair amount of experience programming and I found this distinction confusing and under-explained. Or rather, explained in a way that doesn't make the consequences clear and that caused me to stumble in proofs. I try to report things like these because, having been on the other end (having worked on developer tooling), stumbling blocks like this are easy to forget as you get deeper into practice. So they're underreported: beginners don't know that they misunderstand something, and experienced people don't remember that they ever misunderstood it. I try to report confusing things while I still remember they're confusing. This makes me look like a bit of a clown but I hope it's worth bringing up for consideration.</p>\n<p>As such, more RTFM-y responses aren't necessarily helpful since I've already RTFM'd; I'm just sharing that more people might be confused by this who wouldn't know to report it, and that it might be worth tweaking early educational materials and/or linters for this. Ideally, the goal is that the next person wouldn't stumble the same exact way as I did.</p>\n<p>Now, coming back to the topic, I understand that you're \"not supposed\" to <code>unfold</code> things. However, this seems more of a \"best practices\" thing which, in my opinion, builds <em>on top of</em> a good understanding of the syntax and semantics. You can't always learn bottom-up either of course, so it's a balance. But in reality I think there's multiple situations in the beginning of the learning process where unfolding is an important tool:</p>\n<ul>\n<li>Some common things, like <code>Function.Bijective</code>, don't seem to have an \"API\". I guess you can just <code>constructor</code> on them directly. But if you don't know what to do, <code>unfold</code> is useful to \"peek\" into it.</li>\n<li>As an exploratory tool, <code>unfold</code> is the equivalent of Cmd+Clicking but it's more convenient because it's applied to the exact thing you already have. I often <code>unfold</code> specific things in specific goals before I decide <em>whether</em> to pursue a certain route. It's much more convenient than doing many clicks (and works much better with more complex hypotheses because I see the result applied inline). I'm not saying I'll <em>keep</em> <code>unfold</code> in the code (I get the importance of an \"API\"); I'm saying that <code>unfold</code> is a very useful tool for \"exploring\" what I'm dealing with. I think I can be trusted to use it, and if I say that I find it helpful, it is because it has actually been helpful for me in a way other tools haven't.</li>\n<li>Regardless of the above, I brought up <code>unfold</code> in the context of unfolding <em>my own local bindings</em>, not some library (so the question about it being unidiomatic is irrelevant). My own local bindings don't have an API. In fact, creating that API (even locally) <em>is</em> when the distinction between <code>have</code> and <code>let</code> becomes crucial. Before I understood the actual difference between <code>have</code> and <code>let</code>, it seemed mysterious that sometimes rewrites were able to \"pierce through\" my bindings and sometimes not. I could pass some things to simp and some I couldn't. Sometimes I'd see <code>a</code> and have no idea how to turn it back into <code>foo</code>. It seemed arbitrary and confusing. What I'm saying is, it took me a while to notice that the choice of <code>let</code> vs <code>have</code> actually has to do with definitions ‚Äî and that <code>let</code>s are \"unfoldable\" (whether with <code>unfold</code>, <code>simp</code>, or whatever) while <code>have</code>s are opaque.</li>\n</ul>\n<p>To give a more concrete example of what I'm describing, here's a little fragment of the proof:</p>\n<p><a href=\"/user_uploads/3121/pjHT0PI_UmQ8pxm4FoWLmHjy/Screenshot-2025-08-14-at-13.29.01.png\">Screenshot 2025-08-14 at 13.29.01.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/pjHT0PI_UmQ8pxm4FoWLmHjy/Screenshot-2025-08-14-at-13.29.01.png\" title=\"Screenshot 2025-08-14 at 13.29.01.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2162x1000\" src=\"/user_uploads/thumbnail/3121/pjHT0PI_UmQ8pxm4FoWLmHjy/Screenshot-2025-08-14-at-13.29.01.png/840x560.webp\"></a></div><p>This works fine. But if I change just one line near the top, it no longer works:</p>\n<p><a href=\"/user_uploads/3121/jZ2wsuw3AHuJb9L_mnmdhOed/Screenshot-2025-08-14-at-13.28.37.png\">Screenshot 2025-08-14 at 13.28.37.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jZ2wsuw3AHuJb9L_mnmdhOed/Screenshot-2025-08-14-at-13.28.37.png\" title=\"Screenshot 2025-08-14 at 13.28.37.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2726x986\" src=\"/user_uploads/thumbnail/3121/jZ2wsuw3AHuJb9L_mnmdhOed/Screenshot-2025-08-14-at-13.28.37.png/840x560.webp\"></a></div><p>The fact that the choice of <code>let</code> vs <code>have</code> has the effect that I'm unable to progress on a proof (or even have any idea about <em>how</em> to progress on it ‚Äî assuming I don't know <code>unfold</code> can unfold a <code>let</code>) is IMO significant. In my learner shoes (yes, I get how it works <em>now</em>; I'm explaining how it <em>felt</em>) it just seems like I'm stuck on the proof. With a programming background, the idea that I can further \"peel off\" something that \"looks like a variable\" is just plain weird! It's not how programming works. I understand this is not programming. But I'm saying that, for a programming audience, teaching that <em>definitions are unfoldable</em> together with <code>let</code> seems beneficial. And also teaching that <code>have</code> is opaque around the same time also seems beneficial. Then they won't get stuck like I used to. (When I was a beginner, I was trying to \"solve my way out of this\" by doing <code>rw [a]</code> which of course doesn't work.)</p>\n<p>Finally, I want to note that, while I did RTFM both docstrings, they feel too similar‚Äîalmost as if they were copy-pasted with a string replace for hypothesis/definition.</p>\n<p><a href=\"/user_uploads/3121/flAUpE505AuUIWq2Rk-CjMmM/Screenshot-2025-08-14-at-13.32.43.png\">Screenshot 2025-08-14 at 13.32.43.png</a><br>\n<a href=\"/user_uploads/3121/N3_l3Qt2xFzaQNLqULztIo5S/Screenshot-2025-08-14-at-13.32.48.png\">Screenshot 2025-08-14 at 13.32.48.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/flAUpE505AuUIWq2Rk-CjMmM/Screenshot-2025-08-14-at-13.32.43.png\" title=\"Screenshot 2025-08-14 at 13.32.43.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1486x370\" src=\"/user_uploads/thumbnail/3121/flAUpE505AuUIWq2Rk-CjMmM/Screenshot-2025-08-14-at-13.32.43.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/N3_l3Qt2xFzaQNLqULztIo5S/Screenshot-2025-08-14-at-13.32.48.png\" title=\"Screenshot 2025-08-14 at 13.32.48.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1436x360\" src=\"/user_uploads/thumbnail/3121/N3_l3Qt2xFzaQNLqULztIo5S/Screenshot-2025-08-14-at-13.32.48.png/840x560.webp\"></a></div><p>I understand (and support) the desire for consistency. But I do think that one-sentence mention that <code>let</code> is unfoldable (on the <code>let</code> docstring) and that <code>have</code> is opaque (on the <code>have</code> docstring) would have helped here.</p>\n<p>Alternatively, like I mentioned, a lint that nudges you the right way in introductory materials (e.g. MIL repo, FM course, etc) would've also worked. But as we see above there's some discussion about whether hiding non-proofs intentionally is sometimes useful. Which is why I thought it might be better addressed educationally.</p>\n<p>Also, I want to emphasize again that \"use this for definitions, use this for proofs\" doesn't feel strong enough of a hint that you can unfold one but not the other. I didn't think this crucial distinction (without understanding which you can get stuck) was obvious, and that's why I'm posting. If Lean was known for always having \"one right way\" to do each thing, I would agree more that a recommendation (like \"<code>have</code> is for proofs\") is enough. But given that in Lean, there's a myriad way to do the same thing (<code>rintro</code> vs <code>intro</code>, <code>have</code> vs <code>obtain</code>, <code>cases</code> vs <code>cases'</code> vs <code>rcases</code> vs <code>match</code>, <code>apply</code> vs <code>refine</code> vs <code>exact</code>, <code>constructor</code> vs <code>use</code>), it's not obvious that <em>this particular one</em> is actually a deep distinction that, although you seemingly can use it either way, will bite you half the proof later with no obvious indication of what bit you.</p>",
        "id": 534475019,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755175314
    },
    {
        "content": "<p>Yet another option for improving this may be to catch \"silly\" attempts to rewrite. Since trying to <code>rw</code> it away is the first thing I (and I presume many others) tried.</p>\n<p>For example, this:</p>\n<p><a href=\"/user_uploads/3121/pcPSrV4_l-yxJBXpqeT-XvPq/Screenshot-2025-08-14-at-13.47.37.png\">Screenshot 2025-08-14 at 13.47.37.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/pcPSrV4_l-yxJBXpqeT-XvPq/Screenshot-2025-08-14-at-13.47.37.png\" title=\"Screenshot 2025-08-14 at 13.47.37.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1254x774\" src=\"/user_uploads/thumbnail/3121/pcPSrV4_l-yxJBXpqeT-XvPq/Screenshot-2025-08-14-at-13.47.37.png/840x560.webp\"></a></div><p>Could have a special-cased error message that suggests \"Did you mean to <code>unfold acc</code>?\" or such. And then once I try to do that:</p>\n<p><a href=\"/user_uploads/3121/emsCfvkG_8Z95-9wBxd83ClW/Screenshot-2025-08-14-at-13.48.19.png\">Screenshot 2025-08-14 at 13.48.19.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/emsCfvkG_8Z95-9wBxd83ClW/Screenshot-2025-08-14-at-13.48.19.png\" title=\"Screenshot 2025-08-14 at 13.48.19.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1266x808\" src=\"/user_uploads/thumbnail/3121/emsCfvkG_8Z95-9wBxd83ClW/Screenshot-2025-08-14-at-13.48.19.png/840x560.webp\"></a></div><p>This error message could be special-case to say something like \"Cannot <code>unfold acc</code> because <code>acc</code> is declared with <code>have</code>. Only <code>let</code> bindings can be unfolded.\"</p>\n<p>Then I would have organically learned about both <code>unfold</code> and <code>let</code>/<code>have</code> distinction guided by the tool, at the point where it actually became important.</p>",
        "id": 534476375,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755175760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534476375\">said</a>:</p>\n<blockquote>\n<p>This error message could be special-case to say something like \"Cannot <code>unfold acc</code> because <code>acc</code> is declared with <code>have</code>. Only <code>let</code> bindings can be unfolded.\"</p>\n</blockquote>\n<p>I am not sure this is technically possible: I do not think the context remembers <em>how</em> a variable entered it</p>",
        "id": 534479628,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755176776
    },
    {
        "content": "<p>I think we <em>can</em> do that actually</p>",
        "id": 534482316,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177614
    },
    {
        "content": "<p>since <code>have</code> now produces nondependent ldecls</p>",
        "id": 534482344,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177627
    },
    {
        "content": "<p>instead of cdecls</p>",
        "id": 534482431,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177646
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.LocalDecl#doc\">docs#Lean.LocalDecl</a></p>",
        "id": 534482460,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177658
    },
    {
        "content": "<p>Oh god, that's a hack</p>",
        "id": 534482518,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755177674
    },
    {
        "content": "<p>is it?</p>",
        "id": 534482609,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177702
    },
    {
        "content": "<p>No actually I don't get it, sorry. How do you differentiate</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>from</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n</code></pre></div>\n<p>?</p>",
        "id": 534483085,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755177851
    },
    {
        "content": "<p>well one of them is a nondep ldecl and the other one is a cdecl I'm guessing</p>",
        "id": 534483150,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177873
    },
    {
        "content": "<p>In the second one, it makes no sense to say that <code>have</code> could be replaced by <code>let</code></p>",
        "id": 534483156,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755177875
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534483150\">said</a>:</p>\n<blockquote>\n<p>well one of them is a nondep ldecl and the other one is a cdecl I'm guessing</p>\n</blockquote>\n<p>Can you try?</p>",
        "id": 534483192,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1755177885
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">foo</span><span class=\"bp\">‚ü©</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">  </span><span class=\"n\">run_tac</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">withMainContext</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">getLCtx</span>\n<span class=\"w\">    </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">lctx</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">decl</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ldecl</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"n\">fvarId</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">nondep</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{name} is {repr kind} {bif nondep then \"</span><span class=\"n\">non</span><span class=\"s2\">\" else \"\"}dep ldecl\"</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cdecl</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"n\">fvarId</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">binderInfo</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{name} is {repr kind} cdecl\"</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 534483792,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755178080
    },
    {
        "content": "<p>aha, nice</p>",
        "id": 534483966,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755178136
    },
    {
        "content": "<blockquote>\n<p>Again, you can't unwrap¬†<code>have</code>, that's why putting it in¬†<code>unfold</code>¬†or¬†<code>simp</code>¬†won't work.</p>\n</blockquote>\n<p>I think phrasing is a bit confusing. Let's say I had the following tactic</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bar</span>\n<span class=\"o\">[</span><span class=\"bp\">...</span><span class=\"o\">]</span>\n<span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- expecting to unfold `a` in the goal</span>\n<span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- expecting to _use the proposition whose proof I named `b` to simplify_</span>\n</code></pre></div>\n<p>That is, when one has <code>have b := bar</code>, or often, <code>have b : somePropStatement := bar</code>, then the importance of <code>b</code> isn't in the term that defined it, but rather the _type_ of <code>b</code>. Because the type of <code>b</code> is the proposition we care about, and the term of <code>b</code> is irrelevant, the only important thing about it is that the type is inhabited -- we have a proof of the proposition.</p>\n<p>So when one says \"putting it in <code>simp</code> won't work\" -- these are two very different uses of <code>simp</code>. And the value of <code>have</code> is to provide a fact that some (Prop) type is inhabited, not locally declaring some particular term.</p>",
        "id": 534505538,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1755184805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> sorry if my response seemed like a call to RTFM, it was not intended as such. And I agree, the <code>let</code> / <code>have</code> hovers are far too close to being identical for comfort. I think your suggestion here is a good one. Although honestly, Johan's suggestion to combine everything into \"ash krimpul durbatul√ªk\" (i.e., one tool to rule them all) seems like the ideal choice to me, so long as it includes a fantastic docstring!</p>",
        "id": 534524094,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755190675
    },
    {
        "content": "<p>I've copied Johan's suggestion here: <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/.22Missing.20Tactics.22.20list/near/534524887\">#general &gt; \"Missing Tactics\" list @ üí¨</a></p>",
        "id": 534524974,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755191010
    },
    {
        "content": "<p>isn't the difference between <code>let</code> and <code>have</code> the same as the difference between <code>def</code> and <code>theorem</code>? Lean doesn't care how the theorem is proved, just that it's proved (in fact that's essential, so you can use a fact without reference to its proof). But if you <code>def</code> something, you actually need to remember the construction. Same thing with <code>let</code> vs <code>have</code>; the latter can forget the proof, but it's needed for the former.</p>",
        "id": 534525170,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1755191087
    },
    {
        "content": "<p>yeah it's similar</p>",
        "id": 534525273,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755191119
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534434209\">said</a>:</p>\n<blockquote>\n<p>I was thinking there could be a tactic <code>xyzzy</code>, such that [...]</p>\n</blockquote>\n<p>That tactic is called <code>let</code> :-)</p>\n<p>Though, to be fair, it just does a subset of what you propose:</p>\n<ul>\n<li><code>have x : ty := v</code> is <code>let</code> with the <code>+nondep</code> option (<code>let +nondep x : ty := v</code>). Maybe <code>opaque</code> could be a synonym; <code>nondep</code> was chosen since internally a <code>have</code> expression is a \"nondependent let\", i.e., the body cannot depend on the value of the variable.</li>\n<li>Both <code>let</code> and <code>have</code> support the <code>+generalize</code> option.</li>\n<li>Both <code>let</code> and <code>have</code> support the <code>(eq := h)</code> option to create an equation. If you want multiple cases in the pattern, we have the <code>match</code> tactic, and maybe <code>match</code> should be preferred in that case since it promotes writing structured proofs.</li>\n</ul>",
        "id": 534571372,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755212143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Ya√´l Dillies</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534479628\">said</a>:</p>\n<blockquote>\n<p>I do not think the context remembers <em>how</em> a variable entered it</p>\n</blockquote>\n<p>You are correct, this is not something we can know in general. There's no guarantee that a \"nondep ldecl\" will not eventually be turned into a cdecl. Plus, variables can enter the context through tactics in other ways, and we shouldn't expose internal details about the workings of tactics.</p>\n<p>There aren't too many ways a variable can enter a context at least, so if someone tries to unfold a variable that doesn't have a value, it's reasonably safe to give a hint like \"if this variable was introduced with <code>have</code>, recall that it is opaque and cannot be unfolded, and perhaps you meant to use <code>let</code>\".</p>",
        "id": 534571949,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755212524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534324410\">said</a>:</p>\n<blockquote>\n<p>Should there be a linter that disallows declaring proofs with <code>let</code>? And non-proofs with <code>have</code>? Or are there legit exceptions?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/3559\">lean4#3559</a> is an older issue about this. (Mathlib has a linter too, mentioned by Damiano earlier: <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/let.20vs.20have.20vs.20set.20vs.20obtain/near/534450809\">#new members &gt; let vs have vs set vs obtain @ üí¨</a>)</p>\n<p>There are legitimate reasons for automation performance to use <code>have</code> as much as possible ‚Äî but, using <code>have</code> for data can bite you in really confusing ways. What we did in core this year was make Lean responsible for aggressively turning <code>let</code>s into <code>have</code>s, so that way people can comfortably use <code>let</code> for data and <code>have</code> for proofs without having to worry about <code>simp</code> performance implications.</p>\n<p>By the way, I just made <a href=\"https://github.com/leanprover/lean4/pull/9956\">lean4#9956</a> to extend the <code>let</code>/<code>have</code> tactic docstrings.</p>\n<p>Looking at your screenshots, something that I find interesting to know is that you're finding the keyword <code>have</code> to be meaningful for defining functions. That's something we were debating when we were finalizing what the keywords should be. There were a lot of ideas for possible keywords for them (<code>let</code>, <code>have</code>, <code>const</code>, <code>let_fun</code>, <code>let_dep</code>, <code>nondep_let</code>, <code>opaque</code>, <code>opaque_let</code>, and so on), and there was an argument that no one would ever see \"have\" in any sense but \"having an additional fact\", but I thought people would get used to seeing \"have\" for data, in the more general sense of \"having something\". That's part of the mnemonic for me: \"let x be such-and-such\" vs \"have x, from such-and-such\". The first more actively says that x stands for something else, but the second is that we merely have something, provided there's evidence that such a thing exists.</p>",
        "id": 534856872,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755478275
    },
    {
        "content": "<p>Just a +1 as a new comer to theorem proving (but a long time programmer) having very similar experiences to <span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> . I did accidentally use ‚Äòhave‚Äô by habit for a term that should have been ‚Äòlet‚Äô and took me a bit of time to debug, but it wasn‚Äôt too bad. Docstrings definitely help, but it does feel some of this is so foundational to theorem proving with lean that somewhat surprising it was not in the tutorials I read (or it was there but I didn‚Äôt retain it)</p>",
        "id": 535065114,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1755586439
    },
    {
        "content": "<p>the infoview is your friend</p>",
        "id": 535107604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755603109
    },
    {
        "content": "<p>when you use <code>let</code> the infoview shows a hypothesis that look like <code>name : type := value</code> but when you use <code>have</code> the infoview shows <code>name : type</code> with no value</p>",
        "id": 535107756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755603163
    },
    {
        "content": "<p>this has helped me catch problems with let vs have twice</p>",
        "id": 535107827,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755603191
    },
    {
        "content": "<p>I realized part of the reason I picked up bad habit of using <code>have</code> for data is because I often do <code>have := ...</code> for messing around with tactic state (before I commit to naming things) and I can't do <code>let :=</code> (that's a syntax error) so I just started doing <code>have :=</code> on everything.</p>",
        "id": 535226127,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755655003
    },
    {
        "content": "<p>is <code>let :=</code> still a syntax error?</p>",
        "id": 535226279,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755655110
    },
    {
        "content": "<p>I thought the name was changed to be optional</p>",
        "id": 535226298,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755655125
    },
    {
        "content": "<p>Oh nice! I'm on an old version it seems</p>",
        "id": 535226372,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1755655184
    }
]