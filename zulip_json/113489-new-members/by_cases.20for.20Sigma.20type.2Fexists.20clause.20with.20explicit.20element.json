[
    {
        "content": "<p>Hello,</p>\n<p>say I have a function <code>f: Nat → Nat</code> and then want to prove a theorem like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Σ'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>using some properties of <code>f</code>. (The important point here being that <code>g</code> explicitly names an <code>x</code>, and is not just a <code>Prop</code>).<br>\nIn the proof, I (in my example) want to make a distinction of cases on whether <code>f n &lt; 10</code> for all <code>n &lt; 1000</code>, or not. In the latter case, I want to find an explicit <code>n</code> where <code>¬(f n &lt; 10)</code>. <br>\nNow, I can run <code>by_cases ∀ (n: Fin 1000), f n &lt; 10</code> just fine, and <code>∀ (n: Fin 1000), f n &lt; 10</code> is even computable, but in the negative case I obtain <code>¬(∀ (n: Fin 1000), f n &lt; 10)</code>, which (as far as I know) I can only turn into <code>∃ (n: Fin 1000), ¬(f n &lt; 10)</code>, which is a Prop (so that I cannot get an explicit <code>n</code> out of it when not proving a Prop).</p>\n<p>Is there some clean solution here, or do I need to define my own helper functions to recursively find such an <code>n</code> given the assumption that <code>¬(∀ (n: Fin 1000), f n &lt; 10)</code>?</p>",
        "id": 466769192,
        "sender_full_name": "Theo Müller",
        "timestamp": 1725229501
    },
    {
        "content": "<p>You can get an explicit <code>n</code> out using <code>Nat.find</code>, which by construction is the least such <code>n</code> satisfying your predicate</p>",
        "id": 466771680,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725231144
    }
]