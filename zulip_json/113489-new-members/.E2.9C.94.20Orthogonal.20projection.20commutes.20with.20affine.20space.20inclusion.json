[
    {
        "content": "<p>I'd like to show (if this is not already hidden somewhere in mathlib that I haven't found!) that the orthogonal projection onto a<br>\nsubspace S ‚äÜ ‚Ñù‚Åø is extensionally the same function regardless of whether<br>\n(a) we're straightforwardly projecting onto S considered as a linear subspace, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/InnerProductSpace/Projection.html#Submodule.orthogonalProjection\">Submodule.orthogonalProjection</a><br>\n(b) we're projecting onto S considered as an affine subspace, via <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Euclidean/Projection.html#EuclideanGeometry.orthogonalProjection\">EuclideanGeometry.orthogonalProjection</a></p>\n<p>Briefly, \"the inclusion of linear subspaces into affine subspaces commutes with orthogonal projection\".</p>\n<p>My plan for proving this is</p>\n<ol>\n<li>Identify a pair of affine maps that correspond to (a) and (b) above respectively.</li>\n<li>Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AffineMap.ext_linear#doc\">AffineMap.ext_linear</a> to show that<br>\nthey are equal as affine maps, by showing that they have the same <code>.linear</code> (which should be easy because of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Geometry/Euclidean/Projection.html#EuclideanGeometry.orthogonalProjection_linear\">EuclideanGeometry.orthogonalProjection_linear</a>) and coincide on at least one point (i.e. the origin).</li>\n</ol>\n<p>However, I am running into difficulties even with step 1. I can get as far as the code below indicates, with typings of the codomain of the affine maps I'm interested in that differ only in <code>s</code> vs. <code>s.toAffineSubspace</code>. Naively changing either one to match results in some rather messy errors deep down in implicit arguments with lots of coercions that I could try puzzling through but it's enough of a mess that it makes me want to ask:</p>\n<p>Is there a better way of approaching this in the first place? Should I<br>\nbe thinking about this problem in a different way?</p>\n<p>Here's a minimal running version of what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- Nonemptiness of a linear subspace is inherited by the corresponding affine subspace</span>\n<span class=\"c1\">-- Q: should this be in mathlib already?</span>\n<span class=\"kd\">instance</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">p.toAffineSubspace</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">‚ü®</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submodule.mem_toAffineSubspace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Submodule.zero_mem</span><span class=\"o\">]‚ü©</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">affine_projection_eq_linear_projection_euclidean</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">EuclideanGeometry.orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s.toAffineSubspace</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s.orthogonalProjection.toAffineMap</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">‚Üí·µÉ</span><span class=\"o\">[</span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">s.toAffineSubspace</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">EuclideanGeometry.orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s.toAffineSubspace</span>\n<span class=\"w\">    </span><span class=\"c1\">---- not well-typed:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- let s1 : EuclideanSpace ‚Ñù I ‚Üí·µÉ[‚Ñù] s := EuclideanGeometry.orthogonalProjection s.toAffineSubspace</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"bp\">‚Üí·µÉ</span><span class=\"o\">[</span><span class=\"n\">‚Ñù</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s.orthogonalProjection.toAffineMap</span>\n<span class=\"w\">    </span><span class=\"c1\">---- not well-typed:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- let s2 : EuclideanSpace ‚Ñù I ‚Üí·µÉ[‚Ñù] s.toAffineSubspace := s.orthogonalProjection.toAffineMap</span>\n<span class=\"w\">    </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 527494321,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751898981
    },
    {
        "content": "<p>(This arose from trying to realize <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> 's suggestion for how to generalize the Rupert property discussed in <a class=\"message-link\" href=\"/#narrow/channel/113488-general/topic/Rupert.2Elean/near/526506861\">#general &gt; Rupert.lean @ üí¨</a> )</p>",
        "id": 527494832,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751899122
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"c1\">-- Nonemptiness of a linear subspace is inherited by the corresponding affine subspace</span>\n<span class=\"c1\">-- Q: should this be in mathlib already?</span>\n<span class=\"kn\">instance</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">mem_toAffineSubspace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">zero_mem</span><span class=\"o\">]</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">affine_projection_eq_linear_projection_euclidean</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection</span><span class=\"bp\">.</span><span class=\"n\">toAffineMap</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"n\">ext1</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">eq_of_mem_singleton</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">inter_eq_singleton_orthogonalProjection</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_inter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace_direction</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">coe_toAffineMap</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"n\">ContinuousLinearMap</span><span class=\"bp\">.</span><span class=\"n\">coe_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">mem_coe</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"bp\">.</span><span class=\"n\">mem_mk'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">vsub_eq_sub</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">neg_mem_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">neg_sub</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 527508094,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751903116
    },
    {
        "content": "<p>Ok thanks I'll take a look at what you're doing here!</p>",
        "id": 527508182,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751903145
    },
    {
        "content": "<p>Honestly though, there is API missing for <code>EuclideanGeometry.orthogonalProjection</code>. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EuclideanGeometry.inter_eq_singleton_orthogonalProjection#doc\">docs#EuclideanGeometry.inter_eq_singleton_orthogonalProjection</a> should have a follow-up lemma which has hypotheses <code>{p v : P} (hv‚ÇÅ : v ‚àà s) (hv‚ÇÇ : v ‚àà AffineSubspace.mk' p s.direction·óÆ) : v = ‚Üë(orthogonalProjection s p</code>. That would eliminate some of the juggling in the proof above.</p>",
        "id": 527508966,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751903411
    },
    {
        "content": "<p>Huh, I see; you have bypassed the question of how to construct two affine maps with the same type. Which is fine. I really only need that the extension of the two functions I have in mind, as raw maps from the ambient space to itself, are equal, for my purposes.</p>",
        "id": 527509192,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751903485
    },
    {
        "content": "<p>The existence of <code>ext1</code> is separately a useful thing to know about; I was exactly wishing for it the other day for unrelated reasons. Thanks much!</p>",
        "id": 527509340,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751903533
    },
    {
        "content": "<p>Also, if there was a version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.sub_orthogonalProjection_mem_orthogonal#doc\">docs#Submodule.sub_orthogonalProjection_mem_orthogonal</a> that turned the subtraction around, then we could have ended the proof with <code>exact Set.mem_inter (by simp) (by simp)</code>.</p>",
        "id": 527509343,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751903535
    },
    {
        "content": "<p>So basically, if you fill in the missing API, this should be a 1-line proof.</p>",
        "id": 527509460,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751903573
    },
    {
        "content": "<p>I'll consider trying to do that as an exercise, thanks!</p>",
        "id": 527509542,
        "sender_full_name": "Jason Reed",
        "timestamp": 1751903601
    },
    {
        "content": "<p>done, but I'll hide it in a spoiler in case you want to do it yourself:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection_sub_mem_orthogonal</span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">HasOrthogonalProjection</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">·óÆ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"w\"> </span><span class=\"n\">neg_mem_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">neg_sub</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">eq_orthogonalProjection</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">MetricSpace</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddTorsor</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">direction</span><span class=\"bp\">.</span><span class=\"n\">HasOrthogonalProjection</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hv‚ÇÅ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hv‚ÇÇ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">AffineSubspace</span><span class=\"bp\">.</span><span class=\"n\">mk'</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">direction</span><span class=\"bp\">·óÆ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">eq_of_mem_singleton</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">inter_eq_singleton_orthogonalProjection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">‚ñ∏</span><span class=\"w\"> </span><span class=\"bp\">‚ü®</span><span class=\"n\">hv‚ÇÅ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hv‚ÇÇ</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">instance</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">‚ü®</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">mem_toAffineSubspace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">zero_mem</span><span class=\"o\">]</span><span class=\"bp\">‚ü©</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fun_prop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">continuity</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">Continuous</span><span class=\"bp\">.</span><span class=\"n\">subtype_map</span>\n\n<span class=\"c1\">-- The assumptions are probably too strong here, and probably we also want a non-continuous version.</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspaceEquiv</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">RCLike</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ·¥¨</span><span class=\"o\">[</span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">linear</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ofEq</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">map_vadd'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">affine_projection_eq_linear_projection_euclidean</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspace</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">      </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toAffineSubspaceEquiv</span><span class=\"bp\">.</span><span class=\"n\">toContinuousAffineMap</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">orthogonalProjection</span><span class=\"bp\">.</span><span class=\"n\">toContinuousAffineMap</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ContinuousAffineMap</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">Subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span>\n<span class=\"w\">    </span><span class=\"n\">EuclideanGeometry</span><span class=\"bp\">.</span><span class=\"n\">eq_orthogonalProjection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>",
        "id": 527510897,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751904004
    },
    {
        "content": "<p>Indeed though, this is not well-typed, so it shouldn't be included as-is. Let me come up with a slightly more suitable statement.</p>",
        "id": 527513155,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751904710
    },
    {
        "content": "<p>Okay, I've updated the spoiler above so that it's a well-typed equality between <code>ContinuousAffineMap</code>s.</p>",
        "id": 527517867,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1751906315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">Jason Reed</span> has marked this topic as resolved.</p>",
        "id": 527523284,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751908384
    }
]