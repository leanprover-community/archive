[
    {
        "content": "<p>I want to prove that a certain function can create an isomorphism between groups.<br>\nIn my example I prove AddEquiv on Z to show that the group (Z, +) -&gt; (Z, +) will be isomorphic with the function f: x =&gt; -x.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃+</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Function.LeftInverse</span> <span class=\"n\">f</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Function.RightInverse</span> <span class=\"n\">f</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n\n  <span class=\"n\">constructor</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">hom.toFun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"n\">linarith</span>\n</code></pre></div>\n<p>The main problem is restricting it so that I must use the particular function for the isomorphism. I <em>could</em> just use the identity here and the proof would still be valid. I don't know of a way to bind the resulting AddEquiv instance.<br>\nIf I could, I would have some <code>H: AddEquiv ℤ ℤ</code>, then I think can restrict the goal to <code>: H ∧ Equiv.toFun H = f</code>.</p>",
        "id": 403778110,
        "sender_full_name": "SaNoy SaKnoi",
        "timestamp": 1700742020
    },
    {
        "content": "<p>I'm not really sure I understand your question, but if you are trying to create a structure I'd avoid using tactic mode like this and instead give the fields directly.<br>\nAfterwards you can check that the function is the <code>f</code> supplied as input</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyEquiv</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃+</span> <span class=\"n\">ℤ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toEquiv</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Function.LeftInverse</span> <span class=\"n\">f</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">Function.RightInverse</span> <span class=\"n\">f</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span>\n\n  <span class=\"n\">map_add'</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">MyEquiv_spec</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MyEquiv</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 403779076,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1700742410
    },
    {
        "content": "<p>Thank you, I wasn't exactly aware of the direct construction using <code>where</code>.<br>\nIt seems like you need to do some additional tactics to prove <code>MyEquiv_spec</code>, this worked for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">MyEquiv_spec</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MyEquiv</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">a</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>My motivation was to create a self-contained <code>example</code> that could demonstrate that 1) there exists an isomorphism between <code>Z</code> to <code>Z</code>, and 2) that isomorphism can be described using the function at the assumption.<br>\nSo translated into code would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"bp\">&lt;</span><span class=\"n\">our</span> <span class=\"n\">bijective</span> <span class=\"n\">function</span><span class=\"bp\">&gt;</span> <span class=\"bp\">&lt;</span><span class=\"n\">proof</span> <span class=\"n\">that</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">homomorpic</span><span class=\"bp\">&gt;</span><span class=\"o\">:</span> <span class=\"bp\">&lt;</span><span class=\"n\">the</span> <span class=\"n\">two</span> <span class=\"n\">groups</span> <span class=\"n\">are</span> <span class=\"n\">isomorphic</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">that</span> <span class=\"n\">is</span> <span class=\"n\">because</span> <span class=\"n\">we</span> <span class=\"n\">used</span> <span class=\"n\">the</span> <span class=\"n\">bijective</span> <span class=\"n\">function</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>This now works, but do you know of a way to do this without defining a new function?</p>",
        "id": 403781258,
        "sender_full_name": "SaNoy SaKnoi",
        "timestamp": 1700743292
    },
    {
        "content": "<p>My code works in the web editor, the proof should be <code>rfl</code> after all</p>",
        "id": 403782615,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1700743787
    },
    {
        "content": "<p>Probably the cleanest way is actually</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyEquiv</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃+</span> <span class=\"n\">ℤ</span> <span class=\"n\">where</span>\n  <span class=\"n\">toEquiv.toFun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">toEquiv.invFun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">toEquiv.left_inv</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"n\">toEquiv.right_inv</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n\n  <span class=\"n\">map_add'</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">linarith</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">MyEquiv_spec</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">MyEquiv</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toFun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 403782643,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1700743800
    },
    {
        "content": "<p>You could use <code>{e : ℤ ≃+ ℤ // ⇑e = f}</code> as your return type (<code>⇑</code> is the preferred spelling of <code>toFun</code>)</p>",
        "id": 403782758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1700743833
    },
    {
        "content": "<p>Yeah or prove an existential</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">MyEquiv</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">≃+</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">φ.toFun</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨{</span>\n  <span class=\"n\">toEquiv.toFun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">toEquiv.invFun</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n  <span class=\"n\">toEquiv.left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"n\">toEquiv.right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">]</span>\n    <span class=\"n\">linarith</span><span class=\"o\">},</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>which is essentially the same</p>",
        "id": 403783332,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1700744042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> This should work, thank you!</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thank you for the suggestion, I'll look into how to use Subtypes in the future.</p>",
        "id": 403784702,
        "sender_full_name": "SaNoy SaKnoi",
        "timestamp": 1700744514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"667038\">SaNoy SaKnoi</span> has marked this topic as resolved.</p>",
        "id": 403784714,
        "sender_full_name": "Notification Bot",
        "timestamp": 1700744519
    }
]