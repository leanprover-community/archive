[
    {
        "content": "<p>I'd like to be able to induct directly on the recursion of a function instead of on the inputs to that function.<br>\nI want to prove a property of a function and have the inductive hypothesis that all of the recursive calls satisfy the property for their inputs.</p>\n<p>Something like this silly example (which can obviously be done in another way):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">fib</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">property_of_function</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- base cases etc...</span>\n\n  <span class=\"c1\">-- I want to be able to get this inductive hypothesis in the case where k &gt; 2 and we recur</span>\n  <span class=\"k\">have</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">∧</span> <span class=\"n\">fib</span> <span class=\"n\">k.pred.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k.pred.pred</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262015646,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637284388
    },
    {
        "content": "<p>Are you asking about how to do strong induction?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"n\">using</span> <span class=\"n\">nat.strong_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">ih</span>\n</code></pre></div>\n<p>This gives you the hypotheses <code>∀ (m : ℕ), m &lt; k → (fib m &gt; 0 ↔ m &gt; 0)</code></p>",
        "id": 262016815,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637285411
    },
    {
        "content": "<p>(I guess it's just an example, but if you simplify the definition of <code>fib</code> to not include the the <code>2</code> case, then you'll have fewer things to prove in the induction.)</p>",
        "id": 262016880,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637285497
    },
    {
        "content": "<p>Strong induction should work in the case I have in mind, but it would be nice if you could just induct on recursion itself.<br>\nThis would make things easier when the well_foundedness measure is a pain to work with I think.<br>\nFair enough if this isn't possible in general.</p>",
        "id": 262017096,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637285654
    },
    {
        "content": "<p>I've been using mathlib's <code>induction'</code> which generalizes everything by default.<br>\nDo you know the syntax for generalizing a given variable with the standard <code>induction</code> or how to do strong induction with mathlib (google/docs don't seem to very helpful here...)</p>",
        "id": 262018110,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286646
    },
    {
        "content": "<p>Ah, looks like mathlib <code>induction'</code> doesn't support  <code>using</code></p>",
        "id": 262018129,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"457807\">@Ryan Greenblatt</span> One way to induct on the recursion itself is to have an inductive type that implements the function.  I'm not sure how to really set this up properly, but here's an attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fib</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"o\">(</span><span class=\"n\">nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">fib</span> <span class=\"n\">n.succ</span> <span class=\"bp\">+</span> <span class=\"n\">fib</span> <span class=\"n\">n</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">fib_fun</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">case0</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"n\">case1</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"n\">recur</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fsn</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n.succ.succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- not used here -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_fun_is_fib</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">fib</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fib_is_fib_fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib_fun</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">fib</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">using</span> <span class=\"n\">nat.strong_induction_on</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.case0</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.case1</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">fib_fun.recur</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.refl</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ih</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.step</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">nat.less_than_or_equal.refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">property_of_function</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fib</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">k</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">fib_is_fib_fun</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"c1\">-- induct on the recursion</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">omega</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 262018138,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637286688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457807\">Ryan Greenblatt</span> <a href=\"#narrow/stream/113489-new-members/topic/Inducting.20directly.20on.20recursive.20calls/near/262018110\">said</a>:</p>\n<blockquote>\n<p>I've been using mathlib's <code>induction'</code> which generalizes everything by default.<br>\nDo you know the syntax for generalizing a given variable with the standard <code>induction</code> or how to do strong induction with mathlib (google/docs don't seem to very helpful here...)</p>\n</blockquote>\n<p>Does <code>induction ... generalizing ...</code> do what you want? <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#induction\">tactic#induction</a></p>",
        "id": 262018204,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637286748
    },
    {
        "content": "<p>Huh, cool. Thanks for all the help!</p>",
        "id": 262018220,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286774
    },
    {
        "content": "<p>Will probably just use strong induction.</p>",
        "id": 262018235,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637286789
    },
    {
        "content": "<p>Maybe this is a version issue, but <code> induction k generalizing ...</code> results in a syntax error : <code>invalid 'begin-end' expression, ',' expected</code><br>\nI'm on lean community 3.35</p>",
        "id": 262018459,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287056
    },
    {
        "content": "<p>The <code>...</code> is meant to be the the list of variables you're generalizing (space-separated), sorry</p>",
        "id": 262018530,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637287100
    },
    {
        "content": "<p>Ah, yep, I'm dumb<br>\nThought that ... meant generalize all</p>",
        "id": 262018555,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287126
    },
    {
        "content": "<p>That said, it doesn't work with using (as far as I can tell)<br>\nGetting syntax error with <code>  induction n generalizing f using nat.strong_induction_on with n ih</code></p>",
        "id": 262018665,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287210
    },
    {
        "content": "<p>It's sensitive to the order of the clauses</p>",
        "id": 262018720,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637287239
    },
    {
        "content": "<p>(I can't tell you off the top of my head which it is -- it's usually trial-and-error for me)</p>",
        "id": 262018745,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637287274
    },
    {
        "content": "<p>I think I've tried them all... (puting it at the end syntax checks, but doesn't actually generalize <code>f</code>)</p>",
        "id": 262018776,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287298
    },
    {
        "content": "<p>Nvm</p>",
        "id": 262018787,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287308
    },
    {
        "content": "<p>end works</p>",
        "id": 262018790,
        "sender_full_name": "Ryan Greenblatt",
        "timestamp": 1637287310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457807\">Ryan Greenblatt</span> has marked this topic as resolved.</p>",
        "id": 262018838,
        "sender_full_name": "Notification Bot",
        "timestamp": 1637287327
    },
    {
        "content": "<p>One way to tell is to follow the definition of <code>induction</code> itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">meta</span> <span class=\"kd\">def</span> <span class=\"n\">induction</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">cases_arg_p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rec_name</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">using_ident</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ids</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"n\">with_ident_list</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">revert</span> <span class=\"o\">:</span> <span class=\"n\">parse</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">tk</span> <span class=\"s2\">\"generalizing\"</span> <span class=\"bp\">*&gt;</span> <span class=\"n\">ident</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"bp\">?</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>You can follow definitions of each of the arguments to see what they're trying to parse, but we can see <code>generalizing</code> comes at the end without having to do that.</p>",
        "id": 262018847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637287348
    },
    {
        "content": "<p>I'd never really thought about inducting on a definition itself before.  It seems like it would be nice if Lean could generate the inductive type I wrote automatically and show it characterizes definition.  Especially if it would use the equations as you write them, vs the ones that the equation compiler might generate.</p>",
        "id": 262019063,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637287608
    }
]