[
    {
        "content": "<p>What is the general mechanism for using definitions/theorems which expect a given type to have instances for multiple type classes with a shared ancestor? This problem must come up in mathlib's algebraic hierarchy all the time, so I bet there's a good solution. </p>\n<p>Say I have the following type classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₁</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt₉</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₂</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">gt₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₃</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"n\">where</span>\n  <span class=\"n\">gt₅</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">B₁</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B₂</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B₃</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Now if I have a type with instances for <code>B₁</code> and <code>B₂</code> I should be able to combine their properties. The naive approach doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">A</span> <span class=\"n\">B₁</span> <span class=\"n\">B₂</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">B₁</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B₂</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">lt₉</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">gt₁</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">application type mismatch</span>\n<span class=\"cm\">  And.intro (lt₉ a)</span>\n<span class=\"cm\">argument</span>\n<span class=\"cm\">  lt₉ a</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  @nat α B₁.toA a &lt; 9 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  @nat α B₂.toA a &lt; 9 : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I understand that I could fix this by explicitly telling Lean which instances to use for each application of <code>nat</code>, but of course the problem is that I would like the instances of <code>B₁ α</code> and <code>B₂ α</code> to have the same underlying instance of <code>A α</code>.<br>\nFrom what I've seen, the solution for this is to explicitly create a class which combines the two classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">B₁₂</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">B₁</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">B₂</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">range₁₉</span> <span class=\"o\">[</span><span class=\"n\">B₁₂</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">lt₉</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">gt₁</span> <span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"c1\">-- works</span>\n</code></pre></div>\n<p>It seems like this would lead to a combinatorial explosion once you have many type classes that you want to combine in various ways, but I can live with that. What I can't figure out though is how to handle the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">C</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">range₁₉</span> <span class=\"c1\">-- failed to synthesize instance B₁₂ ?m.684</span>\n</code></pre></div>\n<p>It makes sense that since <code>C</code> is based on <code>B₁</code>, <code>B₂</code> and <code>B₃</code> instead of <code>B₁₂</code> and <code>B₃</code>, Lean can't find an instance for <code>B₁₂</code>. Now I could change the definition of <code>C</code> to use <code>B₁₂</code> instead of <code>B₁</code> and <code>B₂</code>, but then what do I do if I have a theorem over <code>B₂₃</code>?</p>",
        "id": 347419985,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1680788668
    },
    {
        "content": "<p>You're missing an instance <code>C α → B₁₂ α</code>.</p>",
        "id": 347427463,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680789769
    },
    {
        "content": "<p>It seems that your confusion stems from the fact that you think that the only typeclasses used for TC search are the ones coming from <code>extends</code> clauses. This is (fortunately!) wrong. You can register extra instances after the fact using the <code>instance</code> keyword.</p>",
        "id": 347427976,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1680789879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Thanks!</p>",
        "id": 347433251,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1680790793
    },
    {
        "content": "<p>Just in case it's helpful for you, an alternative approach would be to use mixins, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₁</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">lt₉</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₂</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">gt₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">B₃</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"n\">where</span>\n  <span class=\"n\">gt₅</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">5</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">B₁</span> <span class=\"n\">B₂</span> <span class=\"n\">B₃</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">range₁₉</span> <span class=\"o\">[</span><span class=\"n\">A</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B₁</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">B₂</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">9</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"n\">a</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">lt₉</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">gt₁</span> <span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 347435514,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1680791167
    }
]