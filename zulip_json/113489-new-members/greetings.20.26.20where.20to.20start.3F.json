[
    {
        "content": "<p>Hi everyone! I am a third year student in Math &amp; CS and I really enjoy playing with Lean. </p>\n<p>Maybe I can bring some benefit to the community? I have seen the page <a href=\"https://leanprover-community.github.io/undergrad_todo.html\">https://leanprover-community.github.io/undergrad_todo.html</a> about undergraduate topics still uncovered in mathlib, and I want to work on some of them.  I have checked the PR list and, for example, the following topics do not seem to be done:</p>\n<ol>\n<li>Matrices: Jordan normal form</li>\n<li>Fourier analysis: Dirichlet theorem, Fejer theorem, Plancherel’s theorem.</li>\n<li>ODE: exit theorem of a compact subspace, stability of equilibrium points (linearisation theorem), linear differential systems, etc</li>\n</ol>\n<p>I just want to become more familiar with mathlib and lean and would be happy to pick any of them. I will be grateful if someone would outline the situation in these subjects and give advice on how and where to start.</p>",
        "id": 307811941,
        "sender_full_name": "Vasily Nesterov",
        "timestamp": 1667500271
    },
    {
        "content": "<p>The undergrad_todo is a place where new members sometimes go to die :-( There is often a reason these things are not yet done, perhaps the community demands that they're done in a specific way and an expert is needed :-/</p>",
        "id": 307854985,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667516137
    },
    {
        "content": "<p>Don't listen to Kevin, there are many things that are still doable on this list. Many items are not done because they are boring elementary mathematics.</p>",
        "id": 307858609,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1667518097
    },
    {
        "content": "<p>There is also a tag on the issue tracker on github for good beginner projects: <a href=\"https://github.com/leanprover-community/mathlib/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Agood-first-project\">https://github.com/leanprover-community/mathlib/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Agood-first-project</a></p>",
        "id": 307860111,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667519026
    },
    {
        "content": "<p>From undergrad_todo, the special orthogonal/unitary groups should be rather easy and there are examples of matrix groups that you could follows. Looking at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.special_linear_group\">docs#matrix.special_linear_group</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.orthogonal_group\">docs#matrix.orthogonal_group</a> should suffice to implement <code>matrix.special_orthogonal_group</code></p>",
        "id": 307860382,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667519253
    },
    {
        "content": "<p>btw: why is the special linear group still on the list? there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.special_linear_group\">docs#matrix.special_linear_group</a></p>",
        "id": 307860507,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667519371
    },
    {
        "content": "<p>@Fourier Series: There was the idea to rewrite the Fourier series, but I don't know what became out of that. If you are interested in working on that you should ping Heather Macbeth and you might have to do some refactoring of existing code. So it might take a some time to get to the interesting parts, but if you really want to learn Lean, then it can be worthwhile.</p>",
        "id": 307860947,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667519708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz Doll</span> <a href=\"#narrow/stream/113489-new-members/topic/greetings.20.26.20where.20to.20start.3F/near/307860507\">said</a>:</p>\n<blockquote>\n<p>btw: why is the special linear group still on the list? there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.special_linear_group\">docs#matrix.special_linear_group</a></p>\n</blockquote>\n<p>Probably same answer as <a href=\"https://github.com/leanprover-community/mathlib/pull/12752#discussion_r828781309\">here</a>, unless you have more to say, <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>?</p>",
        "id": 307889076,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1667541654
    },
    {
        "content": "<p>I think that the truth is that there might be some items on there which are accessible (as well as some items which are not at all accessible to beginners but which look accessible, which is very disheartening) but there problem is that the more detailed descriptions of what needs doing and how the mathlib community want it done are often described in threads like this which are transient and get lost. My main point is that it's not like 2-3 years ago where people could just say \"oh you don't have X, here I can do X\" and then they do X and get it merged. It's now much more complicated which is why the list has stagnated.</p>",
        "id": 307900045,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667548468
    },
    {
        "content": "<p>Newcomers stumble onto the list but not the details of what we know needs actually doing.</p>",
        "id": 307900174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667548551
    },
    {
        "content": "<p>There's an undergraduate at Imperial who has essentially done partial factions by the way. Should I record this somewhere as WIP?</p>",
        "id": 307900260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667548587
    },
    {
        "content": "<p>In my opinion the github issue tracker is way better for maintaining a list of \"beginner issues\". The problem with the undergrad list is as you say that \"mathematically easy\" != \"Lean easy\".</p>",
        "id": 307901400,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667549126
    },
    {
        "content": "<p>As for the partial fractions: if the student is ok with it, then you could create a WIP PR and tag it with \"please-adopt\"</p>",
        "id": 307901634,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1667549235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/113489-new-members/topic/greetings.20.26.20where.20to.20start.3F/near/307858609\">said</a>:</p>\n<blockquote>\n<p>Don't listen to Kevin, there are many things that are still doable on this list. Many items are not done because they are boring elementary mathematics.</p>\n</blockquote>\n<p>I barely even know the terms on the list /o\\</p>",
        "id": 308015770,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1667584397
    },
    {
        "content": "<p>Thank you for the answers! OK, I will try to complete the matrix group examples for now.</p>",
        "id": 308026806,
        "sender_full_name": "Vasily Nesterov",
        "timestamp": 1667587316
    },
    {
        "content": "<p>Hello! <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> I'm Heinrich and I'm new to Lean. I have a background in mathematics and functional programming (Haskell).</p>\n<p>I have a question. Is this a good channel to ask this? If not, where would be more appropriate?</p>\n<p>Background: I'm interested in proving statements about functional programs (written in Haskell); think Bird-style proofs. I have had success proving that <code>reverse (reverse xs) = xs</code> for any <code>xs : list α</code> in Lean and now I would like to step up my game by proving statements about abstract data types. In Haskell, we typically build new abstract data types by combining old ones.</p>\n<p>Question: I'm constructing an abstract data type, let's call it <code>Foo</code>, by using an abstract data type called <code>Set α</code> (where <code>α : Type</code>) which represents a set of values of type <code>α</code>. I expect that <code>Set</code> will be implemented as an inductive type in terms of binary search trees, with some equivalence relation <code>==</code> representing equality of <code>Set</code>. (I don't understand the distinction between computational and noncomputational well enough to force this to <code>=</code>, I'm happy to live with an equivalence relation on inductive terms.) However, I don't really care how <code>Set</code> is implemented — all I care about are some functions that operate on it and some lemmas about how these functions behave (e.g. a complete axiomatization). In other words, when defining my inductive type <code>Foo</code>, I would like to use the <code>Set α</code> type and functions that operate on it, but I don't want to import an actual implementation — all I care about is a structure that holds a collection of operations and theorems about them, i.e. a \"module interface\" in programming language speak. How would I go about declaring and using such a module interface (without implementing it)? Should I use type classes?</p>\n<p>I have tried <code>constant</code>, but then I run into \"noncomputational\" issues. I have tried declaring a lot of <code>variable</code>, but that does not give me enough control about their namespace — I would like to write <code>Set.insert x (Set.empty)</code> where e.g. <code>empty : Set α</code> is part of the module interface.</p>\n<p>Put differently, I'm writing the abstract data type <code>Foo</code> as follows: \"Assume that I have a data type <code>Set α</code> with some lemmas. Then, I define <code>Foo</code> as follows … . Now, from the lemmas about <code>Set</code>, I can prove the following lemmas about <code>Foo</code>: … \". I'm looking for a syntactically nice way of specifying \"Assume that I have a data type<code>Set α</code>\".</p>",
        "id": 308145434,
        "sender_full_name": "Heinrich Apfelmus",
        "timestamp": 1667656897
    },
    {
        "content": "<p>Welcome! This is certainly the right place to ask your first questions.</p>",
        "id": 308146422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667657293
    },
    {
        "content": "<p>I think that you are looking for <code>structure</code>.</p>",
        "id": 308146463,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667657320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/greetings.20.26.20where.20to.20start.3F/near/308146463\">said</a>:</p>\n<blockquote>\n<p>I think that you are looking for <code>structure</code>.</p>\n</blockquote>\n<p>Maybe. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>  Ok, so when I extract the <code>Set</code> interface into a structure, I get the following, which does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">SetAPI</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">Set</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">member</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">prop_insert_member</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">member</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">tt</span>\n  <span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">prop_insert_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">y</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">insert</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">Set</span> <span class=\"o\">:</span> <span class=\"n\">SetAPI</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">Set.Set</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n   <span class=\"o\">(</span><span class=\"n\">baz</span> <span class=\"o\">:</span> <span class=\"n\">Set.Set</span> <span class=\"n\">nat</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Foo</span>\n<span class=\"c1\">-- Foo : SetAPI → Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">insertBar</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Foo</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Foo.mk</span> <span class=\"o\">(</span><span class=\"n\">Set.insert</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">foo.bar</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">foo.baz</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Here <code>SetAPI</code> is a structure that represents the API of the module that I want to import. I define a variable <code>Set</code> in order to \"import\" it into my namespace. However, this does not quite work as I want it, as <code>Foo</code> gets the type <code>Foo : SetAPI -&gt; Type</code> rather than the type <code>Foo : Type</code>. I understand that this is ultimately correct (the type <code>Foo</code> needs to be supplied with an actual implementation in order to make sense; <code>Foo</code> behaves like a \"module functor\" in the ML programming language), but for the sake of my own sanity, I would like to have <code>Set : SetAPI</code> as an implicit hypothesis of my entire source file rather than an explicit argument. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Is there a way to do this?</p>",
        "id": 308149031,
        "sender_full_name": "Heinrich Apfelmus",
        "timestamp": 1667658453
    },
    {
        "content": "<p>You can use <code>parameter Set : SetAPI</code>. This is a feature that isn't used so much in the Lean community. But it should do what you want.</p>",
        "id": 308150840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667659224
    },
    {
        "content": "<p>It doesn't do exactly the same as in ML modules, but within one file, the behaviour is roughly the same.</p>",
        "id": 308150899,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667659250
    },
    {
        "content": "<p>Awesome, thank you! <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span>  Using <code>parameter</code> for assuming a module API works for me at this stage. (I can imagine this becoming unwieldy in larger projects, but I can ask more questions if I get to that point. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> )</p>",
        "id": 308152969,
        "sender_full_name": "Heinrich Apfelmus",
        "timestamp": 1667660402
    }
]