[
    {
        "content": "<p>Working through Kevin and Bhavik's course, I saw <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2024/blob/c4cfdc64d59c12e07e0c88d702bfe654d518c0bd/FormalisingMathematics2024/Section07subgroupsAndHomomorphisms/Sheet1.lean#L158-L159\">this exercise</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">conjugate_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">conjugate</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">conjugate</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Alas, I couldn't figure out how to \"unroll\" the goal so I ended up glancing at the <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2024/blob/c4cfdc64d59c12e07e0c88d702bfe654d518c0bd/FormalisingMathematics2024/Solutions/Section07subgroupsAndHomomorphisms/Sheet1.lean#L179C1-L183C10\">solution</a> which includes the relevant hint:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">conjugate_mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">conjugate</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">conjugate</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- start with `intro g` because the goal is definitionally</span>\n<span class=\"w\">  </span><span class=\"c1\">-- `∀ g, g ∈ conjugate H x → g ∈ conjugate K x`</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>\n<p>What are some ways I could have realized that this goal is <code>intro</code>-able?</p>\n<p>I'm aware of the following:</p>\n<ul>\n<li><code>hint</code> tactic suggests <code>intro</code> here, which would have helped if I remembered to use it.</li>\n<li>Similarly, <code>whnf</code> would  reframe the goal to <code>∀ ⦃x_1 : G⦄, x_1 ∈ conjugate H x → x_1 ∈ conjugate K x</code></li>\n</ul>\n<p>However, suppose that I don't want to \"pierce through the abstraction\". I know there's no automated way to look up the relevant definition (or even to be sure it exists).</p>\n<p>But is there any way I could have discovered the relevant definition manually via inspecting the IDE? In fact, I still don't know <em>which</em> definition it unfolded.</p>\n<p>What I'd expect is to hover <code>H ≤ K</code> and then through some more combination of hovers and clicking to find the thing that defines it to be <code>∀ ⦃x : G⦄, x ∈ H → x ∈ K</code>. What <em>is</em> that thing? Where is it defined? Is it an instance of some typeclass?</p>\n<p>I tried doing <code>set_option trace.Meta.synthInstance true</code> and I got</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Preorder</span><span class=\"bp\">.</span><span class=\"n\">toLE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">PartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPreorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">OmegaCompletePartialOrder</span><span class=\"bp\">.</span><span class=\"n\">toPartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">CompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">instOmegaCompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">instCompleteLattice</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">inst</span><span class=\"bp\">✝</span><span class=\"o\">)))))</span>\n</code></pre></div>\n<p>I suppose maybe this \"definition\" of <code>≤</code> is somehow spread between these pieces?</p>\n<p>Is there any better way I could have found that <code>H ≤ K</code> means <code>∀ ⦃x : G⦄, x ∈ H → x ∈ K</code> here?</p>",
        "id": 507581167,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1742748158
    },
    {
        "content": "<p>For now I'll send <a href=\"https://github.com/b-mehta/formalising-mathematics-notes/pull/10\">https://github.com/b-mehta/formalising-mathematics-notes/pull/10</a></p>",
        "id": 507581552,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1742748449
    },
    {
        "content": "<p>indeed the source of this definition is quite hidden... As far as i can tell, one source for this definition is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/SetLike/Basic.html#SetLike.instPartialOrder\">SetLike.instPartialOrder</a>, but it does take some detective work to recognise that this is a source of the definition of <code>≤</code> for <code>Subgroup</code></p>",
        "id": 507582757,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1742749254
    },
    {
        "content": "<p>i was able to find this because the notation is used <a href=\"https://github.com/leanprover-community/mathlib4/blob/df882075248003a227363d639e2fb53b5a3c658d/Mathlib/Algebra/Group/Subgroup/Defs.lean#L332C1-L334C10\">here</a>, while there were only 3 instances on <code>Subgroup</code> defined at that point, and the only one that to me would make sense to imbue a partial ordering was <code>SetLike</code></p>",
        "id": 507582949,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1742749372
    },
    {
        "content": "<p>My 2c: To figure this out myself I followed this chain to see where the instance is defined:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the last one is <code>Subgroup.instCompleteLattice</code> which looks like where the instance is actually coded. So I clicked to see that instance and you see this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Subgroups of a group form a complete lattice. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">to_additive</span><span class=\"w\"> </span><span class=\"s2\">\"The `AddSubgroup`s of an `AddGroup` form a complete lattice.\"</span><span class=\"kd\">]</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">completeLatticeOfInf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">IsGLB</span><span class=\"bp\">.</span><span class=\"n\">of_image</span><span class=\"w\"> </span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">coe_subset_coe</span><span class=\"w\"> </span><span class=\"n\">isGLB_biInf</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"n\">bot</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊥</span>\n<span class=\"w\">    </span><span class=\"n\">bot_le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem_bot</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">one_mem</span>\n<span class=\"w\">    </span><span class=\"n\">top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span>\n<span class=\"w\">    </span><span class=\"n\">le_top</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mem_top</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">⊓</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">le_inf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">inf_le_left</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">left</span>\n<span class=\"w\">    </span><span class=\"n\">inf_le_right</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and here I spotted <code>SetLike.coe_subset_coe</code>so it seems like the definition is in terms of subsets.</p>\n<p>This might be hindsight, but I think I would've tried intro simply because that seems like the way to do this mathematically is to show that every element of <code>conjugate H x</code>is an element of <code>conjugate K x</code>.</p>",
        "id": 507583012,
        "sender_full_name": "Michał Mrugała",
        "timestamp": 1742749422
    },
    {
        "content": "<p>This is somewhat of a bad habit, though - it would be better to create a lemma that says what the definition of <code>\\le</code> is, and you should rewrite with that first</p>",
        "id": 507583073,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1742749445
    },
    {
        "content": "<p>you mean <a href=\"https://florisvandoorn.com/carleson/docs/Mathlib/Data/SetLike/Basic.html#SetLike.le_def\">SetLike.le_def</a></p>",
        "id": 507583114,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1742749482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 507583160,
        "sender_full_name": "Notification Bot",
        "timestamp": 1742749517
    },
    {
        "content": "<p>Ah nice, thanks, all of this is helpful.</p>",
        "id": 507583177,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1742749528
    },
    {
        "content": "<p>My experience is that for many \"subtype\" definitions (subgroups, subrings, subfields etc) the LE is by definition a \"forall x, x \\in small =&gt; x \\in big\" definition (what else could it be?) so I just always try <code>intro</code> when faced with a LE between \"setlike terms\". Another way of doing it is <code>set_option pp.notation false</code> and then just start <code>unfold</code>ing everything like <code>LE.le</code> etc until you get to the definition or you get stuck. If you get stuck first, use <code>dsimp only</code> and start unfolding again. I do this sort of thing far more often than I would like to admit.</p>",
        "id": 507586201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742751452
    }
]