[
    {
        "content": "<p>Hi all,</p>\n<p>I'm having trouble implementing a nondeterministic search algorithm. For context, you can refer to <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Cracking.20down.20on.20memory.20usage.20when.20using.20Lists\">this earlier post</a> where I explain what I'm trying to do, or <a href=\"https://github.com/WalrusGumboot/sorting-trees-new\">my new repository</a>.</p>\n<p>Concretely, the following algorithm works, but crashes on relatively small input sizes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mkTree'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pOrder</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">POrder</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">depth</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">maxDepth</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Many</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">pOrder</span><span class=\"bp\">.</span><span class=\"n\">incompPairs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Many</span><span class=\"bp\">.</span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"n\">pOrder</span><span class=\"bp\">.</span><span class=\"n\">toOrder</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Many</span><span class=\"bp\">.</span><span class=\"n\">none</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">depth'</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Many</span><span class=\"bp\">.</span><span class=\"n\">fromList</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkTree'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pOrder</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">depth'</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">gt</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkTree'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pOrder</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">depth'</span><span class=\"bp\">;</span>\n<span class=\"w\">        </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"bp\">.</span><span class=\"n\">Branch</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">gt</span>\n</code></pre></div>\n<p>and this is the only way I see to write this algorithm.</p>\n<p>Is there a more suitable nondeterminism monad than the one described in Functional Programming With Lean's <a href=\"https://lean-lang.org/functional_programming_in_lean/monads/arithmetic.html#nondeterministic-search\">chapter on monads</a>? I tried using <code>MLList Thunk</code> to little avail (I blew through stack space way too quickly anyway) and <code>Nondet Id</code> from <code>Batteries</code> ;  but I think I don't know enough about how that works concretely to have implemented it correctly. Any pointers would be nice.</p>",
        "id": 508365543,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1743018711
    },
    {
        "content": "<p>I think what you want is a depth-first search</p>",
        "id": 508373871,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743021822
    },
    {
        "content": "<p>yes, I agree, and I thought <code>Nondet</code>'s <code>iterate</code> method looked promising, but I'm feeling quite lost tbh...</p>",
        "id": 508374088,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1743021901
    },
    {
        "content": "<p>Why not just write a depth-first search - have a stack <code>State</code> that you append to each time you search and pop from each time you backtrack</p>",
        "id": 508374278,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743021964
    },
    {
        "content": "<p>Make sure to make it tail recursive</p>",
        "id": 508374324,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743021980
    },
    {
        "content": "<p>Wait <code>State</code> as in the state monad?</p>",
        "id": 508374755,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1743022137
    },
    {
        "content": "<p>or a custom <code>State</code> structure that holds the necessary information to backtrack</p>",
        "id": 508374832,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1743022166
    },
    {
        "content": "<p>Your choice</p>",
        "id": 508375291,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1743022319
    }
]