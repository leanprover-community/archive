[
    {
        "content": "<p>EDIT: <code>subst</code> does not suffice if the equality is over expressions, not variables.</p>\n<p>I'm running into an issue when trying to proceed with a proof over <code>BitVec</code>s. I try to perform a rewriting on a term which appears both in a expression and in the type of the expression, and Lean complains that the motive used for the rewriting is not type correct. I've managed to reduce the instance of this problem to the following example.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I was wondering what was the general way to deal with this. I've tried using an extensionality lemma over <code>BitVec</code> to remove the use of <code>BitVec.cast</code> with <code>BitVec.getElem_cast</code> and then <code>congr</code> to reduce the goal to <code>res = foo</code> but I'm left dealing with <code>HEq</code>s which I don't know how to handle. </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>My attempt so far</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>This is as far as I've gotten with the example, using my own <code>BitVec.ext</code> lemma.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"c1\">-- for `generalize_proofs`</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">{</span><span class=\"n\">bv1</span><span class=\"w\"> </span><span class=\"n\">bv2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">point_eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">bv1</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bv2</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]}</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bv1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bv2</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a_lt</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bv1</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b_lt</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bv2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">getElem_eq_testBit_toNat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">point_eq</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">eq_of_testBit_eq</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">point_eq</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a_lt</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow_le_pow_of_le</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_lt_two</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_gt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">testBit_lt_two_pow</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b_lt</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow_le_pow_of_le</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_lt_two</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_gt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">testBit_lt_two_pow</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">i_idx</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">i_idx_foo</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>",
        "id": 514049405,
        "sender_full_name": "Ayhon",
        "timestamp": 1745483457
    },
    {
        "content": "<p>While making sure that my examples worked in the playground, I thought of using <code>aesop</code> to close the goal, and discovered that I could use <code>subst h</code> to close the goal. This doesn't translate to the original proof I had this issue over, however, since the <code>Nat</code> terms are not variables, but results of an expression.</p>\n<p>I adapted my example to include an intermediate function <code>g</code> which prevents <code>subst</code> from working.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This prevents <code>aesop?</code> from finding a proof from the start, but still allows it to finish the proof when using <code>BitVec.ext</code> and <code>congr</code>, using <code>simp_all only [heq_eq_eq]</code> to prove <code>HEq a b</code> with <code>a: i &lt; g res</code> and <code>b: i &lt; g foo</code>. I'm not sure what this tactic is doing though, and how it's able to close the goal.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>My attempt so far</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"w\"> </span><span class=\"c1\">-- for `generalize_proofs`</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">{</span><span class=\"n\">bv1</span><span class=\"w\"> </span><span class=\"n\">bv2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">point_eq</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">bv1</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bv2</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]}</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bv1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">bv2</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a_lt</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bv1</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b_lt</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bv2</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">getElem_eq_testBit_toNat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">point_eq</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">eq_of_testBit_eq</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">point_eq</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a_lt</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow_le_pow_of_le</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_lt_two</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_gt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">testBit_lt_two_pow</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b_lt</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">pow_le_pow_of_le</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">one_lt_two</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_not_gt</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">testBit_lt_two_pow</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">example</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span>\n<span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">i_idx</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">generalize_proofs</span><span class=\"w\"> </span><span class=\"n\">i_idx_foo</span>\n<span class=\"w\">    </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">heq_eq_eq</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 514054041,
        "sender_full_name": "Ayhon",
        "timestamp": 1745484067
    },
    {
        "content": "<p>What about</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat_cast</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Or is that also not what you're really dealing with?</p>",
        "id": 514070056,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1745487790
    },
    {
        "content": "<p>Translating the equality to work over <code>Nat</code> instead of <code>BitVec</code> does away with the issue. Now I'm encountering another problem where <code>rw</code> will perform the rewrite but <code>simp</code> will not, but this is a separate concern (this is a problem because I have a bunch of rewritings I'd like to do, and manually figuring out which rewritings I have to take is not what I'd like to do. I'd like to just <code>simp [*]</code>), so if I don't manage to figure it out on my own I'll open a new topic.</p>\n<p>Thanks!</p>",
        "id": 514073136,
        "sender_full_name": "Ayhon",
        "timestamp": 1745488613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690100\">Ayhon</span> has marked this topic as resolved.</p>",
        "id": 514073473,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745488709
    },
    {
        "content": "<p>What about</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat_eq</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat_cast</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 514073586,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1745488743
    },
    {
        "content": "<p>although I'm not sure whether that works too well with <code>simp [*]</code></p>",
        "id": 514073780,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1745488799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690100\">Ayhon</span> has marked this topic as unresolved.</p>",
        "id": 514074712,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745489037
    },
    {
        "content": "<p>I've been trying a bit more in the larger proof I'm working with, and it seems like my previous example does not do it enough justice. I have a bunch of equalities over <code>BitVec n</code> which I'm not able to rewrite, probably because of similar issues. With the <code>toNat_eq</code> trick I'm able to perform some of the rewrites, by removing the equality over dependent types, but I'm unable to apply other rewritings in nested expressions.</p>\n<p>The actual usecase I'm dealing with is the following goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- ...</span>\n<span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Slice</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Aeneas</span><span class=\"bp\">.</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"bp\">#</span><span class=\"n\">usize</span>\n<span class=\"n\">new_s6_post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Slice</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"mi\">1600</span><span class=\"bp\">#</span><span class=\"n\">usize</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">⟨↑</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">mk_s5</span><span class=\"w\"> </span><span class=\"n\">s5</span><span class=\"o\">)</span>\n<span class=\"c1\">-- ...</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">Keccak</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">absorb</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">chunks_exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"n\">rest</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">suffix</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">Spec</span><span class=\"bp\">.«</span><span class=\"n\">pad10</span><span class=\"bp\">*</span><span class=\"mi\">1</span><span class=\"bp\">»</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">↑</span><span class=\"n\">rest</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">suffix</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>\n<p>In this case I'm unable to perform <code>rw [new_s6_post s6]</code>. I'll try to minimize the example after lunch, but it can probably be represented in my previous example by wrapping everything in another function call. I guess I could tweak all such functions to do away with the <code>BitVec</code>s and use <code>Nat</code>s instead, but that would require that I do so for a bunch of definitions, and at that point I'd perhaps rather change the definitions themselves.</p>",
        "id": 514076807,
        "sender_full_name": "Ayhon",
        "timestamp": 1745489448
    },
    {
        "content": "<p>Can you  use <code>conv</code>?</p>",
        "id": 514096894,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494347
    },
    {
        "content": "<p>I tried to, but it gives a similar error about the motive not begin type correct.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Full error message</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>Diagnostics:\ntactic &#39;rewrite&#39; failed, motive is not type correct:\n  fun _a =&gt; (Spec.Keccak.P 6 24 (BitVec.cast ⋯ _a.toBitVec)).toList.toBitVec\nError: application type mismatch\n  Eq.trans (List.Vector.length_val (new_s6 s6))\nargument\n  List.Vector.length_val (new_s6 s6)\nhas type\n  (↑(new_s6 s6)).length = ↑1600#usize : Prop\nbut is expected to have type\n  _a.length = ↑1600#usize : Prop\n\nExplanation: The rewrite tactic rewrites an expression &#39;e&#39; using an equality &#39;a = b&#39; by the following process. First, it looks for all &#39;a&#39; in &#39;e&#39;. Second, it tries to abstract these occurrences of &#39;a&#39; to create a function &#39;m := fun _a =&gt; ...&#39;, called the *motive*, with the property that &#39;m a&#39; is definitionally equal to &#39;e&#39;. Third, we observe that &#39;congrArg&#39; implies that &#39;m a = m b&#39;, which can be used with lemmas such as &#39;Eq.mpr&#39; to change the goal. However, if &#39;e&#39; depends on specific properties of &#39;a&#39;, then the motive &#39;m&#39; might not typecheck.\n\nPossible solutions: use rewrite&#39;s &#39;occs&#39; configuration option to limit which occurrences are rewritten, or use &#39;simp&#39; or &#39;conv&#39; mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and &#39;Decidable&#39; instances whose types depend on the rewritten term, and &#39;simp&#39; can apply user-defined &#39;@[congr]&#39; theorems as well).\nrest suffix : Std.Slice Bool\nr : Std.Usize\ns : Aeneas.Std.Array Bool 1600#usize\nr_pos : ↑r &gt; 0\nr_big_enough : ↑r ≥ 6\nrest_lt : rest.length &lt; ↑r\nsuffix_le : suffix.length ≤ 4\nno_overflow : rest.length + suffix.length &lt; Std.Usize.max\nnb_left : Std.Usize\n_✝¹⁶ : [&gt; let nb_left ← rest.len + suffix.len &lt;]\nnb_left_post : ↑nb_left = ↑rest.len + ↑suffix.len\norig_s : Std.Slice Bool\nmk_s1 : Std.Slice Bool → Aeneas.Std.Array Bool 1600#usize\n_✝¹⁵ : [&gt; let(orig_s, mk_s1) ← ↑s.to_slice_mut &lt;]\norig_s_post : ↑orig_s = ↑s\nmk_s1_post : ∀ (s_1 : Std.Slice Bool), ↑(mk_s1 s_1) = ↑(s.from_slice s_1)\ns1 : Std.Slice Bool\n_✝¹⁴ : [&gt; let s1 ← xor_long orig_s rest &lt;]\ns1_val :\n  (↑s1).toBitVec = BitVec.setWidth s1.length ((↑orig_s).toBitVec ^^^ BitVec.setWidth orig_s.length (↑rest).toBitVec)\ns1_len : (↑s1).length = 1600\nold_s1 : Std.Slice Bool\nmk_s2 : Std.Slice Bool → Aeneas.Std.Array Bool 1600#usize\n_✝¹³ : [&gt; let(old_s1, mk_s2) ← ↑(mk_s1 s1).to_slice_mut &lt;]\nold_s1_post : ↑old_s1 = ↑(mk_s1 s1)\nmk_s2_post : ∀ (s : Std.Slice Bool), ↑(mk_s2 s) = ↑((mk_s1 s1).from_slice s)\ns2 : Std.Slice Bool\n_✝¹² : [&gt; let s2 ← xor_long_at old_s1 suffix rest.len &lt;]\ns2_val :\n  ∀ j &lt; old_s1.length,\n    s2[j]! = if ↑rest.len ≤ j ∧ j &lt; ↑rest.len + suffix.length then old_s1[j]! ^^ suffix[j - ↑rest.len]! else old_s1[j]!\ns2_len : (↑s2).length = 1600\nleftover : Std.Usize\n_✝¹¹ : [&gt; let leftover ← ↑(Std.core.num.Usize.saturating_sub nb_left r) &lt;]\nleftover_post : ↑leftover = ↑nb_left - ↑r\nleftover_pos : leftover &gt; 0#usize\ns3 : Aeneas.Std.Array Bool 1600#usize\n_✝¹⁰ : [&gt; let s3 ← keccak_p (mk_s2 s2) &lt;]\ns3_val : ↑s3 = (Spec.Keccak.P 6 24 (BitVec.cast ⋯ (↑(mk_s2 s2)).toBitVec)).toList\ns3_len : Spec.b 6 = 1600\nold_s3 : Std.Slice Bool\nmk_s4 : Std.Slice Bool → Aeneas.Std.Array Bool 1600#usize\n_✝⁹ : [&gt; let(old_s3, mk_s4) ← ↑s3.to_slice_mut &lt;]\nold_s3_post : ↑old_s3 = ↑s3\nmk_s4_post : ∀ (s : Std.Slice Bool), ↑(mk_s4 s) = ↑(s3.from_slice s)\nleft : Std.Slice Bool\n_✝⁸ :\n  [&gt; let left ←\n    Std.core.slice.index.Slice.index (Std.core.slice.index.SliceIndexRangeFromUsizeSlice Bool) suffix\n      { start := leftover } &lt;]\nleft_post : ↑left = (↑suffix).extract ↑leftover\ns4 : Std.Slice Bool\n_✝⁷ : [&gt; let s4 ← xor_long old_s3 left &lt;]\ns4_val : ↑s4 = List.zipWith xor ↑old_s3 ↑left ++ List.drop left.length ↑old_s3\ns4_len : (↑s4).length = (↑s3).length\nold_s4 : Std.Slice Bool\nmk_s5 : Std.Slice Bool → Aeneas.Std.Array Bool 1600#usize\n_✝⁶ : [&gt; let(old_s4, mk_s5) ← ↑(mk_s4 s4).to_slice_mut &lt;]\nold_s4_post : ↑old_s4 = ↑(mk_s4 s4)\nmk_s5_post : ∀ (s : Std.Slice Bool), ↑(mk_s5 s) = ↑((mk_s4 s4).from_slice s)\na_one : Std.Slice Bool\n_✝⁵ : [&gt; let a_one ← ↑(Std.Array.make 1#usize [true] proof_4).to_slice &lt;]\na_one_post : a_one = ⟨↑(Std.Array.make 1#usize [true] proof_4), ⋯⟩\npos1 : Std.Usize\n_✝⁴ : [&gt; let pos1 ← suffix.len - leftover &lt;]\npos1_post : ↑suffix.len = ↑pos1 + ↑leftover\ns5 : Std.Slice Bool\n_✝³ : [&gt; let s5 ← xor_long_at old_s4 a_one pos1 &lt;]\ns5_len : (↑s5).length = 1600\ns5_val :\n  ∀ j &lt; (↑old_s4).length,\n    s5[j]! =\n      if ↑pos1 ≤ j ∧ j &lt; ↑pos1 + 1 then old_s4[j]! ^^ ⟨↑(Std.Array.make 1#usize [true] proof_4), ⋯⟩[j - ↑pos1]!\n      else old_s4[j]!\nold_s5 : Std.Slice Bool\nnew_s6 : Std.Slice Bool → Aeneas.Std.Array Bool 1600#usize\n_✝² : [&gt; let(old_s5, new_s6) ← ↑(mk_s5 s5).to_slice_mut &lt;]\nold_s5_post : ↑old_s5 = ↑(mk_s5 s5)\nnew_s6_post : ∀ (s : Std.Slice Bool), ↑(new_s6 s) = ↑(if h : (↑s).length = ↑1600#usize then ⟨↑s, h⟩ else mk_s5 s5)\npos2 : Std.Usize\n_✝¹ : [&gt; let pos2 ← r - 1#usize &lt;]\npos2_post : ↑r = ↑pos2 + 1\ns6 : Std.Slice Bool\n_✝ : [&gt; let s6 ← xor_long_at old_s5 a_one pos2 &lt;]\ns6_val :\n  ∀ j &lt; old_s5.length,\n    s6[j]! = if ↑pos2 ≤ j ∧ j &lt; ↑pos2 + a_one.length then old_s5[j]! ^^ a_one[j - ↑pos2]! else old_s5[j]!\ns6_len : (↑s6).length = 1600\nres : Aeneas.Std.Array Bool 1600#usize\n_ : [&gt; let res ← keccak_p (new_s6 s6) &lt;]\nres_len : res.length = (new_s6 s6).length\nres_val : ↑res = (Spec.Keccak.P 6 24 (BitVec.cast ⋯ (↑(new_s6 s6)).toBitVec)).toList\n| (Spec.Keccak.P 6 24 (BitVec.cast ⋯ (↑(new_s6 s6)).toBitVec)).toList.toBitVec\n</code></pre></div>\n</div></div>",
        "id": 514097083,
        "sender_full_name": "Ayhon",
        "timestamp": 1745494411
    },
    {
        "content": "<p>Where did you <code>conv</code> to?</p>",
        "id": 514097530,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494555
    },
    {
        "content": "<p>You should enter the <code>BitVec.cast</code>.</p>",
        "id": 514097605,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494570
    },
    {
        "content": "<p>Then you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=apply_dite#doc\">docs#apply_dite</a> to push the cast through.</p>",
        "id": 514097770,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494626
    },
    {
        "content": "<p>Fair enough. I actually didn't go as deep as I originally wanted to, since <code>conv</code> gives me an error when I try to go past the <code>BitVec.cast</code>.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/KTESuaHV18GiIpFhiV_kBirQ/image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"813x615\" src=\"/user_uploads/thumbnail/3121/KTESuaHV18GiIpFhiV_kBirQ/image.png/840x560.webp\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/FeOOP6aZxUlbcOH5g72SWCOr/image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"813x615\" src=\"/user_uploads/thumbnail/3121/FeOOP6aZxUlbcOH5g72SWCOr/image.png/840x560.webp\"></a></div>",
        "id": 514098321,
        "sender_full_name": "Ayhon",
        "timestamp": 1745494808
    },
    {
        "content": "<p>This is a deficiency in <code>conv</code> then</p>",
        "id": 514098422,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494840
    },
    {
        "content": "<p>specifically, a missing conv lemma</p>",
        "id": 514098475,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745494853
    },
    {
        "content": "<p>I see. If I understood correctly, the issue is that when trying to perform the rewriting, <code>rw</code> by default abstracts away too much, which we can regulate with <code>conv</code>, but since I have not extended <code>conv</code> with the appropiate lemmas, it's unable to do so. Correct?</p>\n<p>Could the previous case also be solved by using <code>conv</code> instead of applying <code>BitVec.toNat_eq</code>?</p>",
        "id": 514098874,
        "sender_full_name": "Ayhon",
        "timestamp": 1745494988
    },
    {
        "content": "<p>Furthermore, I didn't know about <code>conv</code> lemmas, I'll have a look at that</p>",
        "id": 514098931,
        "sender_full_name": "Ayhon",
        "timestamp": 1745495008
    },
    {
        "content": "<p>Wait, which argument are you entering? I might have misinterpreted the error message.</p>",
        "id": 514099209,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745495078
    },
    {
        "content": "<p>This would be so much easier with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 514099256,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745495088
    },
    {
        "content": "<p>Ok clearly the problem is with <code>List.toBitVec</code>, which I can't find any reference for and so I must assume you defined that function. What's it's type?</p>",
        "id": 514099715,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745495201
    },
    {
        "content": "<p>Yes, I'll work on a MWE. It just takes me a bit of time since there's a bunch of definitions I have to abstract over.</p>\n<p>I was trying to enter the first argument, which would perform the following (in my head)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">Keccak</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span>\n<span class=\"w\"> </span><span class=\"bp\">↓</span>\n<span class=\"o\">(</span><span class=\"n\">Spec</span><span class=\"bp\">.</span><span class=\"n\">Keccak</span><span class=\"bp\">.</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"bp\">⋯</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toList</span>\n</code></pre></div>",
        "id": 514099800,
        "sender_full_name": "Ayhon",
        "timestamp": 1745495225
    },
    {
        "content": "<p>What's the type of <code>List.toBitVec</code>?</p>",
        "id": 514099941,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745495271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20deal.20with.20equalities.20over.20.60BitVec.2Ecast.60/near/514099715\">said</a>:</p>\n<blockquote>\n<p>Ok clearly the problem is with <code>List.toBitVec</code>, which I can't find any reference for and so I must assume you defined that function. What's it's type?</p>\n</blockquote>\n<p>Yes, sorry, this whole situation is happening inside a project with a bunch of definitions. This one in particular</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">ofBoolListLE</span><span class=\"w\"> </span><span class=\"n\">self</span>\n</code></pre></div>",
        "id": 514100080,
        "sender_full_name": "Ayhon",
        "timestamp": 1745495300
    },
    {
        "content": "<p>And <code>BitVec.ofBoolListLE</code> is in <code>Init</code>. I just wanted the postfix notation</p>",
        "id": 514100116,
        "sender_full_name": "Ayhon",
        "timestamp": 1745495311
    },
    {
        "content": "<p>You'll probably have to write an explicit substitution motive then</p>",
        "id": 514100316,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745495377
    },
    {
        "content": "<p>I'm unsure of how to do this. Looking over at the code in <code>conv</code>, is this the part specified after the <code>in</code>?  I can't see anything in the page about <code>conv</code> in <a href=\"https://lean-lang.org/theorem_proving_in_lean4/conv.html\">TPiL</a>, but the <a href=\"https://lean-lang.org/doc/reference/latest/////Tactic-Proofs/Targeted-Rewriting-with--conv/#conv-next\">language reference</a> makes it seem to me that it's not its purpose.</p>",
        "id": 514102636,
        "sender_full_name": "Ayhon",
        "timestamp": 1745496033
    },
    {
        "content": "<p>Like <code>refine Eq.rec (motive := fun a h =&gt; explicit_motive) ?_ prf</code></p>",
        "id": 514102887,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745496093
    },
    {
        "content": "<p>Ah, I see, fully manually</p>",
        "id": 514102986,
        "sender_full_name": "Ayhon",
        "timestamp": 1745496116
    },
    {
        "content": "<p>The reason is you have to introduce a cast and rewrite half of it, which is probably too complicated for existing tactics.</p>",
        "id": 514103307,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745496188
    },
    {
        "content": "<p>Sorry, I have difficulty following with this last part. I'll try to reduce to a MWE to make it easier for me to follow. </p>\n<p>Also, I see no reference to <code>conv</code> lemmas. Are there any examples of custom <code>conv</code> lemmas anywhere I could have a look at?</p>",
        "id": 514104923,
        "sender_full_name": "Ayhon",
        "timestamp": 1745496599
    },
    {
        "content": "<p>I think <code>conv</code> uses the simp-congr lemmas</p>",
        "id": 514105949,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745496790
    },
    {
        "content": "<p>I was thinking that perhaps instead of changing the <code>motive</code> I could change the equality I wanted to use. Instead of rewriting <code>↑(new_s6 s6) = ...</code> I could transform this one to <code>BitVec.cast pf (↑(new_s6 s6)).toBitVec = BitVec.cast pf (...).toBitVec</code> using <code>congrArg</code>.</p>\n<p>However, <code>congrArg (f := List.toBitVec)</code> doesn't seem to work in this case.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Error message</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Diagnostics</span><span class=\"o\">:</span>\n<span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">1251537</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">imax</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">1251534</span><span class=\"o\">)</span>\n</code></pre></div>\n</div></div>\n<p>However, this doesn't work because if <code>a = b</code> and <code>f: (n: Nat) → BitVec n</code> then <code>f a : BitVec a</code>, <code>f b: BitVec b</code> and so <code>f a = f b</code> is not type correct. I guess then that the <code>congr</code> lemma would be <code>(h: a = b) → f a = (f b).cast h</code>, but I see what I cannot define it as <code>congr</code> since it requires for the first function application to be the same.</p>\n<p>With an auxiliary lemma, I've been able to perform the rewriting of <code>(↑(new_s6 s6)).toBitVector.cast pf</code><br>\nby transforming</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"bp\">↓</span>\n<span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toBitVector</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBitVector</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">pf'</span>\n<span class=\"w\">    </span><span class=\"bp\">↓</span>\n<span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">new_s6</span><span class=\"w\"> </span><span class=\"n\">s6</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">toBitVector</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toBitVector</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">pf'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">pf</span>\n</code></pre></div>\n<p>and then performing the rewriting.</p>\n<p>However, the process was a bit involved. Ideally I'd like to be able to automate it, maybe by making more use of <code>HEq</code>? Would this scale?</p>",
        "id": 514119810,
        "sender_full_name": "Ayhon",
        "timestamp": 1745499756
    },
    {
        "content": "<p>I can think of how this can be automated</p>",
        "id": 514120465,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745499924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20deal.20with.20equalities.20over.20.60BitVec.2Ecast.60/near/514120465\">said</a>:</p>\n<blockquote>\n<p>I can think of how this can be automated</p>\n</blockquote>\n<p>Is this possible with the current tactics, or simply implementable as a new tactic?</p>",
        "id": 514123793,
        "sender_full_name": "Ayhon",
        "timestamp": 1745500741
    },
    {
        "content": "<p>I mean as a new tactic, but I guess you could patch together a curated simp set with some congr</p>",
        "id": 514124118,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745500820
    }
]