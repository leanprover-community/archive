[
    {
        "content": "<p>I'm determined to understand <strong>inductive types</strong> as I feel I don't fully grasp the connection between them, <strong>recursion</strong> and <strong>proof by induction</strong>.</p>\n<p>I previously read Kevin Buzzard's <a href=\"https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/\">blog</a> to start to get an initial picture of this space.</p>\n<p>I then read TPIL4 chapter 2 (Dependent Type Theory) to get introduced to some of the machinery of Lean - and am now working through chapter 7 (<a href=\"https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html\">Inductive Types</a>) - and I will attempt to work through each example rather than skim it.</p>\n<p>I'm happy with the initial examples of <code>Weekday</code> which I think understand, and I can follow the example proofs of <code>next</code>, <code>previous</code> and <code>next (previous weekday)</code>.</p>\n<p>However at this point the chapter starts to talk about <strong>recursors</strong>, <strong>introduction and elimination rules</strong>, which I don't think have been introduced in the book before this point. </p>\n<p>I did a \"print\" to see the full content and did a search to find the first mentions of <strong>elimination rules</strong> and it is actually after the Weekday example. Similarly <strong>recursor</strong> is only mentioned with the Weekday example but not actually explained (imho). <strong>Introduction rules</strong> are mentioned earlier in Chapter 3 so I'll read that.</p>\n<p><strong>Question</strong> - where can I find an explanation (and illustration) of recursors, introduction and elimination rules?  Perhaps they are so simple a reply here can explain them?</p>",
        "id": 493198681,
        "sender_full_name": "rzeta0",
        "timestamp": 1736696235
    },
    {
        "content": "<p>An introduction rule is a way to make terms of your new type. An elimination rule is a way to define functions from your type to other types. A recursor is the \"universal\" way to define functions from your type to other types.</p>",
        "id": 493203405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736700267
    },
    {
        "content": "<p>specifically, the introduction rules for an inductive type are its constructors.</p>",
        "id": 493203536,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736700417
    },
    {
        "content": "<p>a recursor is a function that captures a recursion pattern. For example, consider the following <code>BinTree</code> type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fork</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span>\n</code></pre></div>\n<p>As you can see, this type has two kinds of values: they are either a simple <code>t : T</code> value wrapped in <code>BinTree.node</code>, or they are two <code>BinTree</code>s combined via <code>BinTree.fork</code>.</p>\n<p>in order to find out the depth of such a tree, you can use recursion: the depth of a <code>.nil</code> node is, let's say, <code>1</code>, while the depth of a <code>.fork l r</code> node is one plus the maximum depth of either subtree.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fork</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">depth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>Similarly, in order to find out the total number of nodes, you again can use recursion: a <code>.nil</code> tree has 1 node, while a <code>.fork l r</code> node has however many nodes the <code>l</code> and <code>r</code> trees have, plus the fork node itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fork</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>A third example we might care about is the total value of the <code>T</code>-values in a bintree. the value of <code>.nil v</code> will be <code>v</code>, while the value of <code>.fork l r</code> will be the sum of the values of <code>l</code> and <code>r</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fork</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n</code></pre></div>\n<p>Can you see how the pattern of recursion we're using is similar each time? Every time, we define a function value based on which constructor is used (<code>.nil</code> or <code>.fork</code>), based on the \"simple\" arguments of those constructors (<code>v</code>, <code>l</code> and <code>r</code>) as well as the function value of those arguments which have the same type as our original value.</p>\n<p>To put this into the language of type theory, to construct a value of some type <code>X</code> from a value of <code>BinTree T</code> (calling this function <code>f</code>), we provide two functions:</p>\n<ul>\n<li>we provide a function <code>f_nil : (v : T) -&gt; X</code>, which we use in the case of <code>.nil v</code> to produce value <code>f_nil v</code></li>\n<li>we provide a function <code>f_fork : (l : BinTree T) -&gt; (r : BinTree T) -&gt; (f_l : X) -&gt; (f_r : X) -&gt; X</code>. Here, the arguments correspond to the values <code>l</code>, <code>r</code>, <code>f l</code> and <code>f r</code> respectively, and we use the function in the case of <code>.fork l r</code> to produce value <code>f_fork l r (f l) (f r)</code>.</li>\n</ul>\n<p>We can abstract this pattern into a function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"bp\">.</span><span class=\"n\">simpleRec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f_fork</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BinTree</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f_nil</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fork</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f_fork</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">simpleRec</span><span class=\"w\"> </span><span class=\"n\">f_nil</span><span class=\"w\"> </span><span class=\"n\">f_fork</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">simpleRec</span><span class=\"w\"> </span><span class=\"n\">f_nil</span><span class=\"w\"> </span><span class=\"n\">f_fork</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is an example of a recursor: It is a function which abstracts a pattern of recursion.</p>\n<p>now if you take a look at the type of <code>BinTree.rec</code> vs that of <code>BinTree.simpleRec</code>, you can see that these are pretty similar. the differences are (modulo argument ordering):</p>\n<ul>\n<li><code>BinTree.rec</code> has universe variables, where <code>BinTree.simpleRec</code> has not</li>\n<li>the argument <code>X : Type</code> to <code>BinTree.simpleRec</code> has been subsumed by <code>BinTree.rec</code>s <code>motive : BinTree T -&gt; Sort v</code>. This allows us to also create values whose type depends on the value from a <code>BinTree</code> (for <code>Type _</code>), as well as to create proofs (for <code>Prop</code>).</li>\n</ul>\n<p>Changing <code>BinTree.simpleRec</code> to match the type of <code>BinTree.rec</code> is a simple exercise.</p>",
        "id": 493204812,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736701469
    },
    {
        "content": "<p>some other nice exercises might be to write <code>depth</code>, <code>size</code> and <code>sum</code> using <code>BinTree.simpleRec</code></p>",
        "id": 493204949,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736701575
    },
    {
        "content": "<p>Thanks for the replies, I will re-read them in parallel to re-reading the TPIl chapters.</p>\n<p>Thanks especially to Edward for explaining that a recursor is a generalisation of an inductive type and that Lean can create it automatically - I think ...</p>",
        "id": 493207638,
        "sender_full_name": "rzeta0",
        "timestamp": 1736703799
    },
    {
        "content": "<p>no, that's not right.... a recursor is a function which captures a recursion pattern on a  type, and as a result allows you to create a function from that type by providing a function for each constructor.</p>",
        "id": 493207894,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736704013
    },
    {
        "content": "<p>a recursor is (generally) not a type</p>",
        "id": 493208027,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736704113
    },
    {
        "content": "<p>so it's like a \"function template\" with placeholders for \"type\", which when filled, creates a function that applies to the inductive type we defined?</p>\n<p>that's a lot of words - but I think I'll read the chapters and try the hands-on examples to get a better feel for it</p>",
        "id": 493208521,
        "sender_full_name": "rzeta0",
        "timestamp": 1736704554
    }
]