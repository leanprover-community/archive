[
    {
        "content": "<p>I am beginning development with inductive types, decidable ones, and I want to verify properties of these involving membership (of List's in the first instance).  I lack understanding of much of these typeclasses, or how to prove results using them.  My toy example is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- tiny logic</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Micro</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\">  </span><span class=\"c1\">-- Negation</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"c1\">-- , Hashable, Repr, Inhabited</span>\n</code></pre></div>\n<p>I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"n\">s2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">s2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"n\">m2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"n\">m1</span><span class=\"w\"> </span><span class=\"n\">m2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"bp\">.</span><span class=\"n\">beq</span>\n</code></pre></div>\n<p>Q1: if I have to do this, how was it helpful to derive BEq in my declaration?  What did that actually do?<br>\nNext I found I needed results such as provided by LawfulBEq, in order to reason on membership of List's of Micros; I could do LawfulBEq.rfl but I'm a bit stuck on<br>\n<code>eq_of_beq : {a b : Micro} → (a == b) = true → a = b := by</code><br>\nfor 2 reasons: 1. it seems that induction is needed, and as there are two arguments, it should be double induction! and 2. if I just specify tactic <code>induction</code> then I end up finding I want to refer to an inaccessible hypothesis by name<br>\nQ2: is there a resource explaining why having inaccessible names created for me is beneficial?<br>\nQ3: to use a named induction hypothesis it seems I have use <code>with</code> to specify the entire datatype template and fill it in (so if I end up doing double induction on a much more complex datatype that won't be feasible); do I have to do this?<br>\nQ4: is there any other way to get names for induction hypotheses?<br>\nQ5: am I missing a much simpler approach? List membership uses Bool so I can't see how to avoid doing all this work even though I've got an instance of DecidableEq Micro already.</p>",
        "id": 473337871,
        "sender_full_name": "Matthew Fairtlough",
        "timestamp": 1727523880
    },
    {
        "content": "<p>Regarding Q1, I don't know but this seems to prove that writing <code>deriving BEq</code> didn't do much:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- tiny logic</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">atom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Micro</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">neg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\">  </span><span class=\"c1\">-- Negation</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myfun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myfun</span><span class=\"w\"> </span><span class=\"n\">Micro</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- works!</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myfun</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't work</span>\n</code></pre></div>",
        "id": 473415655,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1727588929
    },
    {
        "content": "<p>If you need LawfulBEq, I think the situation is that <code>deriving DecidableEq</code> is all you need, and in that case you <em>shouldn't</em> introduce <code>deriving BEq</code> as well. <code>DecidableEq</code> entails a <code>BEq</code> and <code>LawfulBEq</code>.</p>",
        "id": 473416926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727589992
    },
    {
        "content": "<p>(<code>deriving BEq</code> is useful if the types involved intentionally don't have lawful <code>BEq</code>)</p>",
        "id": 473416957,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727590025
    },
    {
        "content": "<p>thanks Kyle, I clearly didn't' know what I was doing (being hopeful of finding shortcuts)!  But I still need to define BEq.beq, right?  And prove the necessary instances of LawfulBEq.  Guess that's obvious.</p>",
        "id": 473437990,
        "sender_full_name": "Matthew Fairtlough",
        "timestamp": 1727607185
    },
    {
        "content": "<p>you don't; <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#instBEqOfDecidableEq\">instBEqOfDecidableEq</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#instLawfulBEq\">instLawfulBEq</a> should have you covered.</p>",
        "id": 473446775,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727614531
    },
    {
        "content": "<p>in case you're curious, in this case <code>a == b</code> is defined to be <code>decide (a = b)</code></p>",
        "id": 473446885,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727614595
    },
    {
        "content": "<p>Goodness.  When I first started making proofs in CIC using a now-long-gone tool Lego, all this stuff had to be done by hand using the most basic of tactics: Refine, Expand were about the only ones.  Thanks a lot!</p>",
        "id": 473447736,
        "sender_full_name": "Matthew Fairtlough",
        "timestamp": 1727615255
    },
    {
        "content": "<p>My queries about induction are still interesting (to me at least :-) but as my main concerns (Q1 and Q5) have been very satisfactorily resolved, I'll wait until I need answers in future work.  I think I have found a way to name hidden hyps in the docs, so that answers Q4 and I'll close the topic.  Thanks so much!</p>",
        "id": 473449287,
        "sender_full_name": "Matthew Fairtlough",
        "timestamp": 1727616524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"759359\">Matthew Fairtlough</span> has marked this topic as resolved.</p>",
        "id": 473449331,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727616583
    },
    {
        "content": "<p>Q2: Inaccessible variables is to make sure that your proofs don't depend on the accidental naming of variables. There are a number of ways to make variables accessible — if you have a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> you can get precise answers.</p>",
        "id": 473468769,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727629335
    }
]