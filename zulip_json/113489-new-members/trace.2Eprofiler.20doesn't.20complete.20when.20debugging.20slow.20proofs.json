[
    {
        "content": "<p>I have <a href=\"https://github.com/pandaman64/lean-regex/blob/main/correctness/RegexCorrectness/VM/EpsilonClosure/Lemmas.lean\">a file</a> with many theorems each taking a lot of time to type check. To learn which part is slow, I tried to enable profiler by adding these lines at the top of the file:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler.output</span><span class=\"w\"> </span><span class=\"s2\">\"~/Regex/correctness/epsilon_closure_lemmas.json\"</span>\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler.threshold</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler.useHeartbeats</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace.profiler</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"c1\">-- set_option maxHeartbeats 1000000</span>\n</code></pre></div>\n<p>However, when I enabled <code>trace.profiler</code>, Lean started to conplain that the heartbeat is exhausted. And if I increase the heartbeat, it just ran forever. What's the best way to optimize the type checking time in this case? Any ideas are appreciated!</p>",
        "id": 493951624,
        "sender_full_name": "pandaman",
        "timestamp": 1736954352
    },
    {
        "content": "<p><code>threshold 0</code> likely creates way too much data for a nontrivial proof</p>",
        "id": 493952621,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1736954636
    },
    {
        "content": "<p>Thank you. I put the following to <code>lakefile.toml</code>, and <code>lake build</code> completed within a reasonable time with threshold set to 5000. </p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"k\">[[lean_lib]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"RegexCorrectness\"</span>\n<span class=\"n\">moreLeanArgs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span>\n<span class=\"w\">    </span><span class=\"s2\">\"-Dtrace.profiler.output=./profile-5000.json\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s2\">\"-Dtrace.profiler.useHeartbeats=true\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s2\">\"-Dtrace.profiler.threshold=5000\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s2\">\"-Dtrace.profiler=true\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s2\">\"-DmaxHeartbeats=0\"</span>\n<span class=\"p\">]</span>\n</code></pre></div>\n<p>However, the emitted profile file contains no info (<a href=\"https://share.firefox.dev/3PBCCrI\">link</a>). Maybe the top-level file has overwritten the generated profiling data... Do you have any guidance on running the profiler for the whole package?</p>",
        "id": 494157656,
        "sender_full_name": "pandaman",
        "timestamp": 1737037181
    },
    {
        "content": "<p>Instead of adding the arguments to the lakefile, after compiling the project once, you can call <code>lake lean</code> on each file in turn and specify a file-specific <code>output</code> path. There is a script in the lean4 repo for combining profile files but it loses some information so it may not be that helpful to you.</p>",
        "id": 494298038,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1737098947
    },
    {
        "content": "<p>Thank you for the suggestion! I managed to get a trace by adding <code>trace.profiler true</code> to <a href=\"https://github.com/pandaman64/lean-regex/blob/df13dfdd367150c8f677c84b4134b956c84398fb/correctness/RegexCorrectness/VM/EpsilonClosure/Basic.lean#L59\">one of the slowest theorem</a>. Unfortunately, it displays that <code>Elab.command: Lean.Parser.Command.theorem</code> takes 84% of the time, but it's not captured in any of its sub-traces. Since the theorem uses functional induction principle, I'll look at how it's implemented and maybe I can learn something to make it faster (and less memory-hungry).</p>\n<p>Here is the trace: <a href=\"https://share.firefox.dev/4fYy9dH\">https://share.firefox.dev/4fYy9dH</a></p>",
        "id": 494496926,
        "sender_full_name": "pandaman",
        "timestamp": 1737190040
    },
    {
        "content": "<p>What threshold did you use?</p>",
        "id": 494504825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737196100
    },
    {
        "content": "<p>The 5000 from your message above is 5s, which seems very coarse. You'll do much better with 50 or even 5.</p>",
        "id": 494504889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737196162
    },
    {
        "content": "<p>When I used <code>threshold=5000</code>, I also set <code>trace.profiler.useHeartbeats=true</code>, so I guess it's 5000 steps?</p>\n<p>The issue is that Lean takes significantly more time as I decrease the threshold. For example, Lean didn't complete checking proofs after &gt;1h when I used <code>threshold=1000</code> for <a href=\"https://github.com/pandaman64/lean-regex/blob/main/correctness/RegexCorrectness/VM/EpsilonClosure/Lemmas.lean\">this file</a>. (With <code>threshold=5000</code>, it took around a few minutes)<br>\nThe pasted trace was taken by enabling profiler only for a single theorem.</p>",
        "id": 494507665,
        "sender_full_name": "pandaman",
        "timestamp": 1737198437
    },
    {
        "content": "<p>Does not using heartbeats change anything about the coverage of the profile?</p>",
        "id": 494523458,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1737210098
    },
    {
        "content": "<p>I was able to get more traces with a time-based 5ms threshold. Since the slowness comes from <a href=\"https://github.com/pandaman64/lean-regex/blob/df13dfdd367150c8f677c84b4134b956c84398fb/correctness/RegexCorrectness/VM/EpsilonClosure/Basic.lean#L59\">the declaration of <code>εClosure'.induct'</code></a> and <a href=\"https://github.com/pandaman64/lean-regex/blob/main/correctness/RegexCorrectness/VM/EpsilonClosure/Lemmas.lean\">its usage</a>, let me report them together here. (the trace in <a href=\"#narrow/channel/113489-new-members/topic/trace.2Eprofiler.20doesn't.20complete.20when.20debugging.20slow.20proofs/near/494496926\">the previous message</a> was from the declaration only)</p>\n<h2>Declaration of <code>εClosure'.induct'</code></h2>\n<p>I took a file-level trace and I got <a href=\"https://share.firefox.dev/4hiWOKW\">https://share.firefox.dev/4hiWOKW</a></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Command</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>lake<span class=\"w\"> </span>build<span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"nb\">time</span><span class=\"w\"> </span>lake<span class=\"w\"> </span>env<span class=\"w\"> </span>lean<span class=\"w\"> </span>-Dtrace.profiler.output<span class=\"o\">=</span><span class=\"s1\">'./epsilon_closure_basic_threshold_5.json'</span><span class=\"w\"> </span>-Dtrace.profiler.threshold<span class=\"o\">=</span><span class=\"m\">5</span><span class=\"w\"> </span>-Dtrace.profiler<span class=\"o\">=</span><span class=\"nb\">true</span><span class=\"w\"> </span>RegexCorrectness/VM/EpsilonClosure/Basic.lean\n<span class=\"go\">Build completed successfully.</span>\n\n<span class=\"go\">real    0m15.507s</span>\n<span class=\"go\">user    0m14.922s</span>\n<span class=\"go\">sys     0m0.760s</span>\n</code></pre></div>\n</div></div>\n<p>The 60% of the processing time is still spent on unattributed <code>Elab.command: Lean.Parser.Command.theorem</code> stack, so there is no change in the coverage.</p>\n<h2>Usages of <code>εClosure'.induct'</code></h2>\n<p>For this, I got more insightful traces: <a href=\"https://share.firefox.dev/42lEywm\">https://share.firefox.dev/42lEywm</a></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Command</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>lake<span class=\"w\"> </span>build<span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"nb\">time</span><span class=\"w\"> </span>lake<span class=\"w\"> </span>env<span class=\"w\"> </span>lean<span class=\"w\"> </span>-Dtrace.profiler.output<span class=\"o\">=</span><span class=\"s1\">'./epsilon_closure_lemmas_threshold_5.json'</span><span class=\"w\"> </span>-Dtrace.profiler.threshold<span class=\"o\">=</span><span class=\"m\">5</span><span class=\"w\"> </span>-Dtrace.profiler<span class=\"o\">=</span><span class=\"nb\">true</span><span class=\"w\"> </span>-DmaxHeartbeats<span class=\"o\">=</span><span class=\"m\">0</span><span class=\"w\"> </span>RegexCorrectness/VM/EpsilonClosure/Lemmas.lean\n<span class=\"go\">Build completed successfully.</span>\n\n<span class=\"go\">real    0m38.007s</span>\n<span class=\"go\">user    0m38.212s</span>\n<span class=\"go\">sys     0m0.235s</span>\n</code></pre></div>\n</div></div>\n<p>Lean is spending 71% of time for <code>Meta.isDefEq</code>! I can see many <code>Meta.isDefEq.delta</code> inside the stack. I guess Lean is unfolding some definitions? I'll take a look at which defeq is causing the trouble.</p>\n<p>Thank you for many suggestions!</p>",
        "id": 494591745,
        "sender_full_name": "pandaman",
        "timestamp": 1737251930
    },
    {
        "content": "<p>I was able to narrowed down the problematic <code>Meta.isDefEq</code> to a pattern like <code>exact SparseSet.mem_of_mem_of_subset mem (εClosure.subset h)</code>. They are defined as this (links: <a href=\"https://github.com/pandaman64/lean-regex/blob/df13dfdd367150c8f677c84b4134b956c84398fb/correctness/RegexCorrectness/Data/SparseSet.lean#L45\"><code>SparseSet.mem_of_mem_of_subset</code></a>, <a href=\"https://github.com/pandaman64/lean-regex/blob/df13dfdd367150c8f677c84b4134b956c84398fb/correctness/RegexCorrectness/VM/EpsilonClosure/Lemmas.lean#L19\"><code>εClosure.subset</code></a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SparseSet</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_of_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SparseSet</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">sub</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">mem</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">εClosure</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">εClosure'</span><span class=\"w\"> </span><span class=\"n\">nfa</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">matched</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">matched'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">next'</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"bp\">.</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">next'</span><span class=\"bp\">.</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"bp\">&lt;</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"bp\">&gt;</span>\n</code></pre></div>\n<p>When I pass <code>εClosure.subset h</code> as an immediate argument to <code>SparseSet.mem_of_mem_of_subset</code>, Lean seems to check the defeq of <code>s₁ ⊆ s₂</code>, unfolding the definitions of the subset operator of the <code>SparseSet</code> data structure and consuming ~5s each. Since I had several invocations of this pattern, they added up and consumed around 40s in total.</p>\n<p>I was able to work around this issue by lifting <code>εClosure.subset h</code> to a local variable like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">εClosure</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">SparseSet</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_of_subset</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>\n<p>Now I don't see Lean unfold <code>s₁ ⊆ s₂</code>, and the file only takes 5-6s to type-check. The <a href=\"https://share.firefox.dev/3DZsqah\">profiling</a> shows a more spread attributions between <code>simp</code> and other stuff, so I think it's reasonable.</p>",
        "id": 494594573,
        "sender_full_name": "pandaman",
        "timestamp": 1737254409
    },
    {
        "content": "<p>FYI this is the trace where Lean checks defeq when processing <code>exact SparseSet.mem_of_mem_of_subset mem (εClosure.subset h)</code>. I'm not really sure why Lean tries to check it though. <br>\n<a href=\"/user_uploads/3121/0GaZQyo1lYVB6hNJOWIMrwAg/2025-01-19-123722_annotated.png\">スクリーンショット 2025-01-19 123722_annotated.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/0GaZQyo1lYVB6hNJOWIMrwAg/2025-01-19-123722_annotated.png\" title=\"スクリーンショット 2025-01-19 123722_annotated.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1751x1960\" src=\"/user_uploads/thumbnail/3121/0GaZQyo1lYVB6hNJOWIMrwAg/2025-01-19-123722_annotated.png/840x560.webp\"></a></div>",
        "id": 494599342,
        "sender_full_name": "pandaman",
        "timestamp": 1737258674
    },
    {
        "content": "<p>I would guess that <code>exact SparseSet.mem_of_mem_of_subset mem (εClosure.subset h :)</code> also works in place of the <code>have</code></p>",
        "id": 494645155,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737296184
    },
    {
        "content": "<p>Oh  year. Sometimes a smile is effective to make Lean faster :)</p>",
        "id": 494752868,
        "sender_full_name": "pandaman",
        "timestamp": 1737363715
    }
]