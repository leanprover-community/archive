[
    {
        "content": "<p>To be able to accurately explain it to others I’m looking for precise definitions/explanations of some technical terms that often appear in discussions about Lean/Mathlib internals:</p>\n<ul>\n<li>\n<p><strong>“defeq”</strong>: I’ve seen references to \"defeq abuse\", “defeq check”, “defeq problem”, “non-defeq instance”, “not defeq”, “non-defeq diamonds”, “leak defeq”, etc. What does “defeq” mean in these contexts?</p>\n</li>\n<li>\n<p><strong>“diamond”</strong>: I've seen phrases like “diamond problem”, “typeclass diamonds”, “recipe for diamonds”, “instance diamonds”, “good diamond”, “non-defeq diamonds”, etc. What does “diamond” mean in these contexts?</p>\n</li>\n<li>\n<p><strong>“β/δ/η/ζ reductions”</strong>: I’d like to understand the notions of <strong>beta</strong>, <strong>delta</strong>, <strong>eta</strong>, and <strong>zeta</strong> reduction. I also see references to <strong>kernel</strong>, <strong>native</strong>, and <strong>elaborator</strong> reduction. What are these, and how do they differ from each other?</p>\n</li>\n</ul>",
        "id": 508052319,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1742915621
    },
    {
        "content": "<p>Defeq means definitional equality. The Lean Language reference says <a href=\"https://lean-lang.org/doc/reference/latest/The-Type-System/\">a few words</a> on it as well as on reduction rules.</p>",
        "id": 508053184,
        "sender_full_name": "suhr",
        "timestamp": 1742915809
    },
    {
        "content": "<p>If I'm not mistaken, \"defeq\" means \"definitional equality\". So defeq abuse means relying on the current exact definition of something without considering that that definition might change in the future (and break your proof). The \"fix\" for defeq abuse is to use theorems (i.e. \"public API\") that were specifically intended to be used to unwrap that definition — and which don't expose implementation details that might change over time.</p>",
        "id": 508053708,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1742915923
    },
    {
        "content": "<p>It says a few words on diamonds as well: <a href=\"https://lean-lang.org/doc/reference/latest//Type-Classes/Instance-Synthesis/#--tech-term-Diamonds\">https://lean-lang.org/doc/reference/latest//Type-Classes/Instance-Synthesis/#--tech-term-Diamonds</a></p>",
        "id": 508053829,
        "sender_full_name": "suhr",
        "timestamp": 1742915948
    },
    {
        "content": "<p>While this isn't quite the same thing in Lean, for intuition, I think it <em>might</em> be helpful to look at the \"diamond problem\" in traditional OOP inheritance (<a href=\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\">https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem</a>). It's a much older term and doesn't originate in Lean.</p>",
        "id": 508054459,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1742916059
    },
    {
        "content": "<p>a follow up question on defeq abuse: how do I know when not to unfold the definition of something defined in mathlib? or never do it?</p>",
        "id": 508056093,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1742916438
    },
    {
        "content": "<p>As a rule of thumb, you should never do it, you should find the definition in mathlib and read the ten lemmas directly after the definition and use them instead. </p>\n<p>Note that this doesn't always work: nowadays you might be in the unlucky situation that the definition you want is in a file called <code>Foo/Defs.lean</code> with no API at all. In this case you want to look at the first 10 lemmas that mention the foo in the file <code>Foo/Basic.lean</code>.</p>",
        "id": 508066532,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1742918918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Definitions.20of.20.22defeq.22.2C.20.22diamond.22.20and.20.22.CE.B2.2F.CE.B4.2F.CE.B7.2F.CE.B6.20reductions.22/near/508053708\">said</a>:</p>\n<blockquote>\n<p>So defeq abuse means relying on the current exact definition of something without considering that that definition might change in the future (and break your proof).</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span>  I think that's not quite the definition of defeq <em>abuse</em> that I would give. Depending on the circumstance, I would call that either <em>convenient defeq use</em> or <em>sloppy defeq use</em> depending on how prone to breakage / change it is.</p>\n<p>I would contend that defeq <em>abuse</em> refers more specifically to the situation where we have an equality of types like <code>X : Type</code> and <code>def Y := X</code>, and then things are proven involving <code>Y</code> by using a theorem about <code>X</code>, especially if this causes Lean to infer the wrong type for other parts of the proof (and therefore breaks <code>simp</code> or <code>rw</code> calls). Note that this kind of abuse can still have negative effects even if the definition of <code>Y</code> is never altered.</p>\n<p>Of course, at the very beginning when constructing the API for <code>Y</code>, it is necessary to do this kind of thing, but after these abstraction layers are erected, there should be no further reason to \"look through\" this definitional equality, and doing so is what constitutes abuse.</p>",
        "id": 508091884,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1742925298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"683979\">@Isak Colboubrani</span> Some of these concepts are also explained in <a href=\"https://leanprover-community.github.io/glossary.html\">https://leanprover-community.github.io/glossary.html</a><br>\nThis page was written in the Lean 3 era. Unfortunately it hasn't been updated yet. But most of the info is still relevant.</p>",
        "id": 508109021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1742930439
    },
    {
        "content": "<p>Yes it's a shame that I let that stagnate :/ it was a good way for me myself to learn the answers to some of these questions, so getting it back up to date is definitely something I'd like to do as well. We also have (had? let's see if it still works): term#diamond</p>",
        "id": 508121897,
        "sender_full_name": "Julian Berman",
        "timestamp": 1742934861
    },
    {
        "content": "<p>Apparently not anymore. OK well if we get that page back in shape we can re-ask for it.</p>",
        "id": 508121928,
        "sender_full_name": "Julian Berman",
        "timestamp": 1742934878
    },
    {
        "content": "<p>Definitional equality and reduction are broken down in this book: <a href=\"https://ammkrn.github.io/type_checking_in_lean4/\">https://ammkrn.github.io/type_checking_in_lean4/</a></p>\n<p>And their theory is discussed in this thesis: <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>",
        "id": 508154539,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1742950202
    },
    {
        "content": "<p>The diamond and instance stuff, or at least the theory, is covered in the tabled typeclass resolution paper: <a href=\"https://arxiv.org/pdf/2001.04301.pdf\">https://arxiv.org/pdf/2001.04301.pdf</a></p>",
        "id": 508154703,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1742950302
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> also has a paragraph about diamonds if I remember correctly</p>",
        "id": 508211458,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1742978807
    }
]