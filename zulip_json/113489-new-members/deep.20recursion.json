[
    {
        "content": "<p>I get a \"(kernel) deep recursion detected\" error, in the last <code>def</code> in this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Int.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.NormNum</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prop0</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span>\n<span class=\"kd\">def</span> <span class=\"n\">prop1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">x.natAbs</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">Nat.size</span> <span class=\"o\">(</span><span class=\"n\">x.natAbs</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">24</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">Nat.size</span> <span class=\"o\">(</span><span class=\"n\">x.natAbs</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">24</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x.natAbs</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">float</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">normal</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">//</span> <span class=\"n\">prop0</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">prop1</span> <span class=\"n\">x</span><span class=\"o\">})</span>\n\n<span class=\"c1\">-- Can construct a `float` from the value `(2 ^ 23 : ℤ)`:</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">has_prop0</span> <span class=\"o\">:</span> <span class=\"n\">prop0</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prop0</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">has_prop1</span> <span class=\"o\">:</span> <span class=\"n\">prop1</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prop1</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">natAbs</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">)]</span>\n  <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">Nat.size_pow</span><span class=\"o\">]</span>\n  <span class=\"n\">norm_num</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x₀</span> <span class=\"o\">:</span> <span class=\"n\">float</span> <span class=\"o\">:=</span> <span class=\"n\">float.normal</span> <span class=\"o\">⟨</span><span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">,</span> <span class=\"n\">has_prop0</span><span class=\"o\">,</span> <span class=\"n\">has_prop1</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- Cannot construct from same value if the proof of `prop1 val` is inlined:</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x₁</span> <span class=\"o\">:</span> <span class=\"n\">float</span> <span class=\"o\">:=</span>\n<span class=\"c1\">--  ~~ error: \"(kernel) deep recursion detected\"</span>\n  <span class=\"k\">let</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">prop0</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">has_prop0</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">prop1</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">prop1</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">val.natAbs</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">)]</span>\n    <span class=\"n\">rewrite</span> <span class=\"o\">[</span><span class=\"n\">Nat.size_pow</span><span class=\"o\">]</span>\n    <span class=\"n\">norm_num</span>\n  <span class=\"n\">float.normal</span> <span class=\"o\">⟨</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">h₀</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Why does this happen? Is there a well-known way to avoid it? If not, can you give me any hints on how to get more details about the recursion from Lean, for debugging?</p>",
        "id": 386640022,
        "sender_full_name": "Richard Copley",
        "timestamp": 1692719229
    },
    {
        "content": "<p>Using <code>rfl</code> and large numbers is dangerous. Changing it to this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">rewrite</span> <span class=\"o\">[(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span> <span class=\"o\">:</span> <span class=\"n\">val.natAbs</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"mi\">23</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>works.</p>",
        "id": 386642702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692719976
    },
    {
        "content": "<p>Perfect, thanks.</p>",
        "id": 386644161,
        "sender_full_name": "Richard Copley",
        "timestamp": 1692720382
    }
]