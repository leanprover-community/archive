[
    {
        "content": "<p>A few examples of Lean exploits, allowing one to write compiling code which proves False, have been publicized recently, such as this one:<br>\n<span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566253027\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">FLT</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„¤</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">badNatUnsafe</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"n\">run_elab</span>\n<span class=\"w\">  </span><span class=\"n\">addDecl</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">defnDecl</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">name</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">anonymous</span><span class=\"w\"> </span><span class=\"s2\">\"badNat\"</span>\n<span class=\"w\">    </span><span class=\"n\">levelParams</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">type</span><span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">    </span><span class=\"n\">value</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"n\">badNatVal</span>\n<span class=\"w\">    </span><span class=\"n\">hints</span><span class=\"w\">       </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"kn\">opaque</span>\n<span class=\"w\">    </span><span class=\"n\">safety</span><span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">safe</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FermatLastTheorem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_le</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">FLT</span>\n<span class=\"c1\">-- 'FLT' depends on axioms: [propext]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Given that these exist, how would I convince outside people that such and such theorem has been formally proved using Lean? Clearly, 'I have code on my computer which complies' is not good enough. Is 'I have a code on my computer which compiles and never uses the keyword <code>unsafe</code>' obviously good enough? If so, why is Lean by default set up in such a way that writing an <code>unsafe</code> declaration does not immediately produce at least a warning that this file is potentially compomised and is there a way to change it? Is it the case, that, e.g. mathlib's CI would immediately disallow such a declaration?</p>",
        "id": 566596792,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767722948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Exploits.20in.20Lean/near/566596792\">said</a>:</p>\n<blockquote>\n<p>Is 'I have a code on my computer which compiles and never uses the keyword <code>unsafe</code>' obviously good enough?</p>\n</blockquote>\n<p>No, it's not.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">FLT</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Int_eq_Nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„¤</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">â„•</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badNatDefinitelySafe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">Int_eq_Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">4294967296</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„¤</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">by_elab</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">lit</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">natVal</span><span class=\"w\"> </span><span class=\"n\">badNatDefinitelySafe</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">FLT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FermatLastTheorem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775807</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">truly_marvelous_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">badNat</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"mi\">9223372036854775807</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_lt</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">FLT</span>\n<span class=\"c1\">-- 'FLT' depends on axioms: [propext, Classical.choice, Quot.sound]</span>\n</code></pre></div>",
        "id": 566600563,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767724551
    },
    {
        "content": "<blockquote>\n<p>Given that these exist, how would I convince outside people that such and such theorem has been formally proved using Lean?</p>\n</blockquote>\n<p>As the thread you are quoting this from says, the official tool provided for this purpose by the FRO, <a href=\"https://github.com/leanprover/comparator/\">comparator</a> has not been affected by issues like this so far. As I have explained in that thread, it is also systemically immune against this specific kind of attack.</p>\n<blockquote>\n<p>If so, why is Lean by default set up in such a way that writing anÂ <code>unsafe</code>Â declaration does not immediately produce at least a warning that this file is potentially compomised and is there a way to change it?</p>\n</blockquote>\n<p>The <code>unsafe</code> keyword here is a red herring, there are several ways to circumvent the use of <code>unsafe</code> to pull this off.</p>\n<blockquote>\n<p>Is it the case, that, e.g. mathlib's CI would immediately disallow such a declaration?</p>\n</blockquote>\n<p>We run mathlib against lean4checker and nanoda on a daily basis, if you were to commit this exploit into mathlib right now (and thus somehow make it past code review with this obviously very suspicious change) it would be noticed within 24 hours. We have plans to add even more defense in depth to this mechanism in the future. That being said we have so far not seen an exploit that would not at least cause suspicion during a mathlib code review. I'd argue the attack scenario of \"someone commits wrong code into mathlib\" based on these exploits is quite low. A much more likely scenario to me would be e.g. that someone commits a wrong definition as we have e.g. seen with the Navier Stokes conjecture in the formal conjectures repository (in this case wrong by accident but of course purposely introducing a wrong definition is conceivable).</p>",
        "id": 566601273,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767724843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik BÃ¶ving</span> <a href=\"#narrow/channel/113489-new-members/topic/Exploits.20in.20Lean/near/566601273\">said</a>:</p>\n<blockquote>\n<p>the Navier Stokes conjecture in the formal conjectures repository</p>\n</blockquote>\n<p>Do you mean lean-dojo? <a href=\"https://github.com/google-deepmind/formal-conjectures/pull/1457\">FC#1457</a> is still under review</p>",
        "id": 566601964,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1767725104
    },
    {
        "content": "<p>Yes lean-dojo sorry, I mix these two up sometiems</p>",
        "id": 566603247,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767725659
    },
    {
        "content": "<p>Can you give a layman explanation as to what the core reason behind this contradiction in Lean is? It seems like you can somehow replace the actual proof of equality of two numbers with executing code which then exhibits overflow?</p>",
        "id": 566604442,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767726130
    },
    {
        "content": "<p>I have already explained this in the original thread: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566258040\">#lean4 &gt; SafeVerify-passing kernel soundness exploit @ ðŸ’¬</a></p>",
        "id": 566604731,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767726249
    },
    {
        "content": "<p>And to be clear the example I posted here really is just a mildly obfuscated version of my original example.</p>",
        "id": 566604848,
        "sender_full_name": "James E Hanson",
        "timestamp": 1767726299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik BÃ¶ving</span> <a href=\"#narrow/channel/113489-new-members/topic/Exploits.20in.20Lean/near/566604731\">said</a>:</p>\n<blockquote>\n<p>I have already explained this in the original thread: <a class=\"message-link\" href=\"/#narrow/channel/270676-lean4/topic/SafeVerify-passing.20kernel.20soundness.20exploit/near/566258040\">#lean4 &gt; SafeVerify-passing kernel soundness exploit @ ðŸ’¬</a></p>\n</blockquote>\n<p>But whereâ€™s the bug actually at? Is it in the Lean kernel, the compiler which translated the tactics to Lean kernel language, the decide tactic, or all of them?</p>",
        "id": 566605579,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767726601
    },
    {
        "content": "<p>I find it extremly hard to pinpoint \"the bug\"in Lean here. The Lean kernel fundamentally assumes that all objects are built only from their constructors and this code just doesn't do that. One might reason that the bug is that the Lean frontend that people use on an everyday basis allows people to produce such declarations and pass them to the kernel but this is intended. The Lean frontend that you use on a daily basis assumes that you are a friendly user and if you aren't we know dozens of tricks like this to make it swallow a theorem. It makes this assumption because not having to defend against a malicious user all the time actually provides tremendous speedup benefits. If you are dealing with a malicious user and want to verify their claim you should use Comparator which successfully upholds the kernel invariant by design and indeed Comparator does not accept this declaration. So one might even argue there is no bug in Lean and/or Comparator here and it's all working as designed. There is of course a bug in SafeVerify here because it does not undertake the effort of comparator to uphold the kernel's fundamental invariant of its objects being built from constructors.</p>",
        "id": 566607931,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767727570
    },
    {
        "content": "<p>Here is maybe a more precise question (or maybe I'm terribly confused):<br>\n<code>unsafeCast</code> is defined by </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î²</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">PLift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"n\">lcProof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PLift</span><span class=\"bp\">.</span><span class=\"n\">up</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>where <code>lcProof</code> is an <code>unsafe axiom</code>. The proof of FLT uses this definition, therefore <code>#print_axioms</code>, if implemented correctly, should list <code>lcProof</code> as an axiom. Why does it not do that?</p>",
        "id": 566608753,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767727868
    },
    {
        "content": "<p>This is a general issue in people's understanding of how Lean works I think. What is happening is that we give a C program a piece of memory that does not fulfill the assumptions of this program and thus makes it do a weird thing. The <code>unsafeCast</code> is not part of the memory that we pass to the kernel, it is just used to aid the creation of this invalid piece of memory to begin with. It could've been built in dozens of other ways by e.g. loading an invalid olean file that was previously written to the disk using some program etc.</p>",
        "id": 566610751,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767728667
    },
    {
        "content": "<p>Which is to say you have to distinguish between the meta part and the non-meta part of this program, the <code>unsafeCast</code> only occurs in the meta program to produce a declaration that is already invalidated that can then be used in the non-meta part of the program.</p>",
        "id": 566610909,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767728735
    },
    {
        "content": "<p>How difficult would it be to specify a subset of Lean which is guaranteed to produce only correct declarations and covers all the things which we use in practice? In other words, does the average Lean user need to be concerned with accidentally creating such a declaration, which then might be a nightmare to debug?</p>",
        "id": 566611897,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1767729177
    },
    {
        "content": "<blockquote>\n<p>How difficult would it be to specify a subset of Lean which is guaranteed to produce only correct declarations and covers all the things which we use in practice?</p>\n</blockquote>\n<p>You would have to arguably forbid basically any meta programming, there is lots of ways to create this type of stuff witout unsafe as I have mentioned above.</p>\n<blockquote>\n<p>does the average Lean user need to be concerned with accidentally creating such a declaration</p>\n</blockquote>\n<p>it is almost impossible to do this unintentionally if you are not using unsafe casts, this has never happened in practice before. In general almost all of the bugs of the class that are being discussed here are not interesting if you are just doing Lean yourself. They are of interest to people because they might want to verify e.g. proofs generated by an AI.</p>",
        "id": 566614691,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1767730301
    }
]