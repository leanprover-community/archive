[
    {
        "content": "<p>I am trying to define the subspace of a vector space in this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Subspace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">V</span>\n<span class=\"w\">  </span><span class=\"n\">closed_under_add</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v₁</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v₂</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n<span class=\"w\">  </span><span class=\"n\">closed_under_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n</code></pre></div>\n<p>and this works just fine.</p>\n<p>But originally my <code>closed_under_smul</code> was defined like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">closed_under_smul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n</code></pre></div>\n<p>and this did not work (Lean does not like the <code>a ∈ ℝ</code> bit).</p>\n<p>Why is that?</p>",
        "id": 554998210,
        "sender_full_name": "Luiz Kazuo Takei",
        "timestamp": 1762896860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"966994\">@Luiz Kazuo Takei</span> because you're doing type theory, not set theory. The key difference of type theory is that everything you say has to live in a type. In set theory, when you say \"x ∈ ℝ\", the \"x\" there can mean anything. For example, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>+</mo><mn>4</mn><mi>i</mi><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">3+4i \\in \\Bbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord\">4</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> is a valid mathematical statement (and it is false), and you can also state the statement <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>∈</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb{R} \\in \\Bbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.728em;vertical-align:-0.0391em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> (which is also false)</p>\n<p>but in Lean (and type theory), every object you mention has to have a type. That means, when you say <code>x</code>, you already have to tell Lean what its type is. So you're not even <em>allowed</em> to write \"ℝ ∈ ℝ\".</p>\n<p>In other words, <code>a : ℝ</code> means \"the symbol \"a\" has type \"ℝ\" in the following\", and <code>a ∈ ℝ</code> means nothing</p>",
        "id": 554999272,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762897498
    },
    {
        "content": "<p>Thanks a lot <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>! It was very informative!</p>\n<p>I am still getting used to type theory (as opposed to set theory). Do you know any good (and short) reference for a mathematician to learn about type theory?</p>\n<p>Any (or all) of these would be appreciated:</p>\n<ol>\n<li>Motivation of the theory</li>\n<li>Brief history of type theory</li>\n<li>Basics of type theory and how it interacts with math in general (and set theory in particular)</li>\n</ol>",
        "id": 554999663,
        "sender_full_name": "Luiz Kazuo Takei",
        "timestamp": 1762897790
    },
    {
        "content": "<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> is usually recommended for beginners<br>\nthe motivation would be <a href=\"https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence\">Curry--Howard correspondence</a> which equates computer programs with proofs<br>\nand the basic fact you would need to know is that every expression <em>has</em> a <em>unique</em> type, with a rough correspondence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">math</span><span class=\"w\">                 </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">theory</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">proof</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">element</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>\n<p>uniqueness means that <code>2 : ℕ</code> and <code>2 : ℤ</code> are considered to be <strong>different</strong> expressions, in contrast with mathematics where <code>ℕ ⊆ ℤ ⊆ ℚ ⊆ ℝ ⊆ ℂ</code>; instead in Lean you get \"canonical functions\" going from left to right</p>",
        "id": 554999742,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1762897833
    },
    {
        "content": "<p><a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/</a> is also a nice read.</p>",
        "id": 555072477,
        "sender_full_name": "Julian Berman",
        "timestamp": 1762940759
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I don't think Lean has <em>unique</em> typing.</p>",
        "id": 555238336,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1762988421
    },
    {
        "content": "<p>But theorem 4.1 of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> does say Lean has unique typing</p>",
        "id": 555241277,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1762990048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113489-new-members/topic/Defining.20the.20subspace.20of.20a.20vector.20space/near/555238336\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> I don't think Lean has <em>unique</em> typing.</p>\n</blockquote>\n<p>Why do you think so? Can you elaborate?</p>",
        "id": 555242786,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1762990958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"734814\">Dexin Zhang</span> <a href=\"#narrow/channel/113489-new-members/topic/Defining.20the.20subspace.20of.20a.20vector.20space/near/555241277\">said</a>:</p>\n<blockquote>\n<p>But theorem 4.1 of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> does say Lean has unique typing</p>\n</blockquote>\n<p>Theorem 4.1 of <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">#leantt</a> has since come to be doubted by Mario but is hopefully fixable was my last update.</p>",
        "id": 555242988,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1762991092
    }
]