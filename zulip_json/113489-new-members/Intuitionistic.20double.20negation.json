[
    {
        "content": "<p>I am puzzled by the behavior of Lean with regards to double negation. I did not <code>open classical</code>, I just evaluated some expressions</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\">  </span><span class=\"c1\">-- yields:   ¬¬True : Prop</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\">   </span><span class=\"c1\">-- yields:   true</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"c1\">-- yields:   ¬¬False : Prop</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\">  </span><span class=\"c1\">-- yields:   false</span>\n</code></pre></div>\n<p>Note, that the evaluations yield terms of type Bool (in the universe Type aka Type 0 aka Sort 1) and not types in the universe Prop (aka Sort 0).<br>\nIntuitionistically a proposition of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>→</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg P\\rightarrow P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is not provable. Thus you get the <a href=\"https://commons.wikimedia.org/wiki/File:Rieger-Nishimura.svg\">Rieger–Nishimura lattice</a> .<br>\nBut the Lean Prop-s True and False are not variable proposition. Might it be true intuitionistcally that the special cases  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊤</mi><mo>→</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\top\\rightarrow \\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊥</mi><mo>→</mo><mi mathvariant=\"normal\">⊥</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\bot\\rightarrow \\bot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊥</span></span></span></span> hold?<br>\nAnd then there is the thing that in Lean Bool-s can be coerced to Prop-s, cf. <a href=\"https://lean-lang.org/theorem_proving_in_lean4/Type-Classes/#coercions-using-type-classes\">Theorem Proofing in Lean 4, Ch. 10.10</a> .<br>\nMaybe there is a backward mechanism, too? Maybe this is only invoked when evaluations take place?<br>\nIn any case, if somehow the propositional logic of Prop-s work the same way as propositional logic for Bool-s (which, afaik, behave classically) in Lean, this would also explain the evaluation of double negatives as above.</p>\n<p>Since I neither have a background in intuitionistic logic nor in Lean I am a bit lost of what to make of it. Any help and explanation are appreciated.<br>\nAlso: Is there a way to work with (a substantial version of) intuitionistic logic \"out of the box\" in Lean 4? I.e. without building customized types and such to emulate intuitionistic logic? If not, is there some \"preferred way\" to work with intuitionistic logic in Lean?</p>",
        "id": 534063811,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1755037786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"680252\">Thomas Preu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534063811\">said</a>:</p>\n<blockquote>\n<p>Might it be true intuitionistcally that the special cases  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊤</mi><mo>→</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\top\\rightarrow \\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊥</mi><mo>→</mo><mi mathvariant=\"normal\">⊥</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\bot\\rightarrow \\bot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊥</span></span></span></span> hold?</p>\n</blockquote>\n<p>Yes, this is correct</p>",
        "id": 534064409,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755038288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"680252\">Thomas Preu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534063811\">said</a>:</p>\n<blockquote>\n<p>And then there is the thing that in Lean Bool-s can be coerced to Prop-s, cf. <a href=\"https://lean-lang.org/theorem_proving_in_lean4/Type-Classes/#coercions-using-type-classes\">Theorem Proofing in Lean 4, Ch. 10.10</a> .<br>\nMaybe there is a backward mechanism, too? Maybe this is only invoked when evaluations take place?</p>\n</blockquote>\n<p>When you write <code>#eval P</code>, and <code>P</code> has type <code>Prop</code>, this is automatically converted into <code>#eval decide P</code></p>",
        "id": 534064492,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755038368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"680252\">@Thomas Preu</span> the general theorem <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>→</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">\\neg \\neg P \\to P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is not provable, but that doesn't mean it's not provable for every specific P</p>",
        "id": 534064628,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755038473
    },
    {
        "content": "<p>for example, it's provable for every <em>decidable</em> P</p>",
        "id": 534064663,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755038500
    },
    {
        "content": "<p>decidability is the link between intuitionalistic logic and classical logic</p>",
        "id": 534064698,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755038531
    },
    {
        "content": "<p>and true and false are decidable (they're true and false respectively)</p>",
        "id": 534064749,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755038575
    },
    {
        "content": "<p>It also hold intuitionistically that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg\\neg P \\to \\neg P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬¬¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></p>",
        "id": 534064788,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755038603
    },
    {
        "content": "<p>this is seen as the contrapositive of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P \\to \\neg\\neg P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></p>",
        "id": 534064860,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755038667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534064788\">said</a>:</p>\n<blockquote>\n<p>It also hold intuitionistically that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi>P</mi><mo>→</mo><mi mathvariant=\"normal\">¬</mi><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg\\neg P \\to \\neg P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬¬¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span></p>\n</blockquote>\n<p>This is basis of double-negation translation which embeds classical logic into intuitionistic logic.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"680252\">Thomas Preu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534063811\">said</a>:</p>\n<blockquote>\n<p>Also: Is there a way to work with (a substantial version of) intuitionistic logic \"out of the box\" in Lean 4?</p>\n</blockquote>\n<p>Lean is already constructive out of the box, you just need to guard against theorems that use <code>Classical</code> (you can write a lint for that). But I can't advice you to use Lean for constructive mathematics. For two reasons. First, you will have to fight against the rest of Lean world who do not care much about constructive math. Second, any kind of HoTT is probably better suited for constructive mathematics than the type theory of Lean.</p>",
        "id": 534068675,
        "sender_full_name": "suhr",
        "timestamp": 1755041534
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534064409\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"680252\">Thomas Preu</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534063811\">said</a>:</p>\n<blockquote>\n<p>Might it be true intuitionistcally that the special cases  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊤</mi><mo>→</mo><mi mathvariant=\"normal\">⊤</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\top\\rightarrow \\top</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊤</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">¬</mi><mi mathvariant=\"normal\">⊥</mi><mo>→</mo><mi mathvariant=\"normal\">⊥</mi></mrow><annotation encoding=\"application/x-tex\">\\neg\\neg \\bot\\rightarrow \\bot</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">¬¬⊥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">⊥</span></span></span></span> hold?</p>\n</blockquote>\n<p>Yes, this is correct</p>\n</blockquote>\n<p>Thanks a lot! That affirmation set me on the right tracks. Of course you can proof those assertion \"trivially\", but that feels like cheating to me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_false_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_true_trivial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>\n<p>I as a beginner was unsure what's behind it, like magic that you don't understand (reminds me of the White Stripes song <a href=\"https://www.youtube.com/watch?v=HzjNAnEfvxc\">Black Math</a>). </p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"HzjNAnEfvxc\" href=\"https://www.youtube.com/watch?v=HzjNAnEfvxc\"><img src=\"https://uploads.zulipusercontent.net/83bd27d98a93d7fff69dd1519302d143b991a60d/68747470733a2f2f692e7974696d672e636f6d2f76692f487a6a4e416e45667678632f6d7164656661756c742e6a7067\"></a></div><p>With confidence that there is no \"classical magic\" or \"coercion magic\" but only \"intuitionistic inference\" I could find proofs that I have the confidence of understanding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_false_equi_true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_true_equi_false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h3</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_false_equi_true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_true_equi_false</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_true_equi_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_false_equi_true</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 534189610,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1755076564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113489-new-members/topic/Intuitionistic.20double.20negation/near/534068675\">said</a>:</p>\n<blockquote>\n<p>Lean is already constructive out of the box, you just need to guard against theorems that use <code>Classical</code> (you can write a lint for that). But I can't advice you to use Lean for constructive mathematics. For two reasons. First, you will have to fight against the rest of Lean world who do not care much about constructive math. Second, any kind of HoTT is probably better suited for constructive mathematics than the type theory of Lean.</p>\n</blockquote>\n<p>OK, good to know that it is intuitionistic out of the box.</p>\n<p>I accept excluded middle and choice. It's more a matter of understanding what's going on, about learning the principles behind Lean from the ground up.</p>",
        "id": 534190072,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1755076767
    },
    {
        "content": "<p>if you want to get into \"details\" you should use term mode more</p>",
        "id": 534192493,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755077647
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_false_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¬</span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"bp\">.</span><span class=\"n\">not_not</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_true_trivial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¬</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"bp\">.</span><span class=\"n\">not_not</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">double_neg_false_decide</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">double_neg_true_trivial</span>\n</code></pre></div>",
        "id": 534192581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755077684
    },
    {
        "content": "<p>more cheating</p>",
        "id": 534192589,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755077687
    },
    {
        "content": "<p>slightly less cheating:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_false_decide</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¬</span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not_intro</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">double_neg_true_trivial</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬¬</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not_intro</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">double_neg_false_decide</span>\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">double_neg_true_trivial</span>\n</code></pre></div>",
        "id": 534192751,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755077748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <br>\nUsing tactics as I did in my derivation felt a lot like using rules of natural deduction (cf. e.g. <a href=\"https://math.stackexchange.com/q/1636703/1011882\">here in the table at the end</a>).<br>\nIn which sense do I get \"more details\" when using term mode?</p>",
        "id": 534205834,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1755082682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"680252\">@Thomas Preu</span> in the sense that it's closer to Lean, because tactics generate terms</p>",
        "id": 534206284,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755082862
    },
    {
        "content": "<p>if you do <code>#print</code> on a tactic proof you can see the actual term that the tactic generates</p>",
        "id": 534206351,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755082883
    }
]