[
    {
        "content": "<p>Hello, I am tinkering around with PMFs and proving my definition of binomial is the PMF.binomial, I came across this problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">+</span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">X</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">my_binom_is_binom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">binomial</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">binom_do_rec</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">fin_one_eq_zero</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">binomial_apply_self</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- does not find instance of (PMF.binomial p h ?n) ↑?n</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"n\">pow_zero</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The proof state is <code>1 = (PMF.binomial p h 0) 0</code>. I got that the casting of the 0 is not trivial and AI pointed me to the workaround:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>before the rewrite in question works but I still wonder why the casting is not done by lean? Are there stronger tactics that manage this (<code>simp only</code> did not work in my case). How can I figure out if the problem is lean not casting/converting or maybe just not the correct theorem in the general case?<br>\nMany thanks!</p>",
        "id": 525499143,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750765510
    },
    {
        "content": "<p>note: the beginning also feels kind of sketchy - happy for any suggestion :)</p>",
        "id": 525499526,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750765650
    },
    {
        "content": "<p>why are you using <code>do</code> in definitions...</p>",
        "id": 525500775,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766142
    },
    {
        "content": "<p>Also I would recommend that you define it directly rather than recursively.</p>",
        "id": 525500850,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766173
    },
    {
        "content": "<p>I see, you also referenced the already-defined <code>PMF.binomial</code>.</p>",
        "id": 525500982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766217
    },
    {
        "content": "<p>you can refer to how the <a href=\"https://github.com/leanprover-community/mathlib4/blob/edf2cbec036cbc703268107faad1b6b16f216c3f/Mathlib/Probability/ProbabilityMassFunction/Binomial.lean#L23-L38\">source code</a> defines it directly, as I predicted</p>",
        "id": 525501048,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"588691\">@Jasper Ganten</span> here's the correct code, note the first part as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Head</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">castSucc</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">my_binom_is_binom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">binom_do_rec</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">binomial</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">DFunLike</span><span class=\"bp\">.</span><span class=\"n\">congr</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">binom_do_rec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">fin_one_eq_zero</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 525502484,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766704
    },
    {
        "content": "<p>you need <code>succ</code> and <code>castSucc</code> instead of +1</p>",
        "id": 525502530,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766723
    },
    {
        "content": "<p>and <code>simp</code> is quite powerful if you just supply it with the relevant lemmas</p>",
        "id": 525502688,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750766778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525500775\">said</a>:</p>\n<blockquote>\n<p>why are you using <code>do</code> in definitions...</p>\n</blockquote>\n<p>more or less as an exercise... if done more beautifully I think (especially for the discrete PMFs) the code becomes more like the intuitive definition. thats the motivation</p>",
        "id": 525516342,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750770960
    },
    {
        "content": "<p>I think my error was to only try <code>simp only</code>, which then doesnt do the necessary simplifications!</p>",
        "id": 525517499,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750771299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525502530\">said</a>:</p>\n<blockquote>\n<p>you need <code>succ</code> and <code>castSucc</code> instead of +1</p>\n</blockquote>\n<p>I get why this is much 'cleaner' but shouldnt the return automatically try to convert?<br>\nIf the defintion is not correct then this should throw an error, or not?<br>\nThanks for your answers :)</p>",
        "id": 525517985,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750771437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"588691\">Jasper Ganten</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525517985\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525502530\">said</a>:</p>\n<blockquote>\n<p>you need <code>succ</code> and <code>castSucc</code> instead of +1</p>\n</blockquote>\n<p>I get why this is much 'cleaner' but shouldnt the return automatically try to convert?<br>\nIf the defintion is not correct then this should throw an error, or not?<br>\nThanks for your answers :)</p>\n</blockquote>\n<p>It converts to a <code>Nat</code>, and then to a <code>Fin</code>, which introduces a mod n in the value</p>",
        "id": 525518842,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750771650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"588691\">Jasper Ganten</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525517985\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525502530\">said</a>:</p>\n<blockquote>\n<p>you need <code>succ</code> and <code>castSucc</code> instead of +1</p>\n</blockquote>\n<p>I get why this is much 'cleaner' but shouldnt the return automatically try to convert?<br>\nIf the defintion is not correct then this should throw an error, or not?<br>\nThanks for your answers :)</p>\n</blockquote>\n<p>It does throw and error if you click on the code itself (the top right corner of every code block has a little button that allows you to run it online)</p>",
        "id": 525521018,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750772235
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/G0OvL4iPhiaukiZmIW759Eqc/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/G0OvL4iPhiaukiZmIW759Eqc/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"971x195\" src=\"/user_uploads/thumbnail/3121/G0OvL4iPhiaukiZmIW759Eqc/image.png/840x560.webp\"></a></div>",
        "id": 525521069,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750772250
    },
    {
        "content": "<p>Did they get rid of the Fin -&gt; Nat -&gt; Fin shenanigans?</p>",
        "id": 525521250,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750772296
    },
    {
        "content": "<p>it could be possible</p>",
        "id": 525521644,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750772407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525500775\">said</a>:</p>\n<blockquote>\n<p>why are you using <code>do</code> in definitions...</p>\n</blockquote>\n<p>It's the Giry monad!</p>\n<p>I thought I remembered that there was a <code>do</code> in the definition of product measures at some point, but I can't find it. Maybe it it got generalized because of the universe level constraints with <code>do</code>.</p>",
        "id": 525538431,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750777153
    },
    {
        "content": "<p>how should I think about the limitations of do notation?<br>\nI was given the task to explore discrete PMFs and write them down using do but I am not even sure if bernoulli can be written from the dirac PMFs in do notation...</p>",
        "id": 525601051,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750801828
    },
    {
        "content": "<p>The universe limitation is that <code>Bind.bind</code> requires both the source and target to be in the same universe. If all of your types are in Type for example, then <code>do</code> is ok. Otherwise, you can use <code>PMF.bind</code> manually.</p>",
        "id": 525604638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750803814
    },
    {
        "content": "<p>I think you're right that Bernoulli is basic (in the sense that it can't be defined with <code>do</code> alone and uniform PMFs), without some sort of operation to re-weight things.</p>",
        "id": 525604964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750803994
    },
    {
        "content": "<p>A kind of fun definition of the binomial distribution is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">choices</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">choices</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>It's very clearly \"take a sequence of n weighted coin flips and count the number of heads\".</p>\n<p>Proving the support of this is what I thought it was took some doing though... The proof I came up with is really not good. It's clear though that there's some missing theory for dealing with <code>do</code>/monads and PMFs.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">binom_support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Iic</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">choices</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF.bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">choices.count</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_pure_eq_pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pure.pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">PMF.pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">List.sequence_nil</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Applicative</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"o\">([]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">List.sequence_cons</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Applicative</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List.cons</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;*&gt;</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">binom_support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h1.le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set.Iic</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">tsub_pos_of_lt</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ne_of_lt</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h0'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h0.ne.symm</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">binom₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_map_eq_map</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">contrapose</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.sequence_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_pure_eq_pure</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.replicate</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.sequence_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_map_eq_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_seq_eq_seq</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h0'</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">or_iff_not_imp_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_and_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_not</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">omega</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">omega</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.count_replicate</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.sequence_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_pure_eq_pure</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">omega</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.replicate</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.sequence_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_map_eq_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_seq_eq_seq</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h0'</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat.le_add_one_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List.cons</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">        </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat.sub_add_comm</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List.cons</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">        </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.replicate</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n<span class=\"w\">        </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.sequence_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_pure_eq_pure</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">          </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List.replicate</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List.sequence_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_map_eq_map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PMF.monad_seq_eq_seq</span><span class=\"o\">]</span>\n<span class=\"w\">          </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List.cons</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">          </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">List.replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">          </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h0'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"o\">]</span>\n</code></pre></div>\n</div></div>",
        "id": 525610552,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750807767
    },
    {
        "content": "<p>oh, the repeat function is called List.replicate!!!!! I was searching for that for so long, because I expected <code>List.repeat</code> (sorry off topic)</p>",
        "id": 525655746,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750838664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  That's amazing, thanks! <br>\nWhy is the List converted to a sequence in your definition? <br>\nIs there no <code>.count</code> for lists (if yes, why)?<br>\nupdate: got it more or less - for flattening / evaluating the List</p>",
        "id": 525667667,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750842575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  The other question would be the motivation for using <code>Set.Iic n</code> as the support. Is this in general more elegant since going for some more explicit statement would result in proving the less-equal statement and show it from there?</p>",
        "id": 525668439,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1750842848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"588691\">Jasper Ganten</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525667667\">said</a>:</p>\n<blockquote>\n<p>update: got it more or less - for flattening / evaluating the List</p>\n</blockquote>\n<p>Yeah, the sequence function takes a list of PMFs and yields a PMF of lists.</p>\n<p>The function is generic too, it works for any Traversable type.</p>",
        "id": 525726638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750861862
    },
    {
        "content": "<p>Don't read much into the choice of Set.Iic -- it was just convenient when writing the theorem statement!</p>",
        "id": 525726882,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1750861932
    },
    {
        "content": "<p>Why is the step in between <code>return a</code> -&gt; <code>Pure.pure a</code> -&gt; <code>PMF.pure a</code> necessary? Is there a case when you don't want to apply the PMF.pure definition? Since <code>simp</code> handles the <code>Pure.pure</code> conversion this is not such a big thing but I wonder whats the reasoning behind this extra step in the interpretation of the do notation...</p>",
        "id": 526571852,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1751364317
    },
    {
        "content": "<p>It's the same thing as <code>3 + 4</code> not being elaborated to <code>Nat.add 3 4</code>. The idea is that the \"notation\" <code>pure</code>  should rather be used by lemmas, unless that's unwanted in which case there should a <code>simp</code> lemma converting it into the underlying operation (e.g. <code>PMF.pure</code>).</p>",
        "id": 526581261,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1751367573
    },
    {
        "content": "<p>I get that in a general case. But using do notation to my understanding already requires the Monad I am in to be specified. So if I say sth like (3+4 : Nat) should be elaborated.<br>\nA simpler case of my confusion is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pureDo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pureDo'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>So why should the do notation in this case return a not be elaborated to <code>PMF.pure</code>?<br>\nTo be honest I did not really understand what you wanted to say with 'unless thats unwanted'. <br>\nThe main point is that the proofs for requires the additional step from <code>Pure.pure</code>to <code>PMF.pure</code> (a problem that is none if you use simp, but I am asking to undestand the elaboration).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pureDo</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pureDo'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pureDo_eval</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pureDo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pureDo</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- extra needed only with the do notation</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">pureDo_eval'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pureDo'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pureDo'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure_apply</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 526586380,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1751369335
    },
    {
        "content": "<p>It's the same reason we don't elaborate <code>(3 + 4 : Real)</code> to <code>Real.add 3 4</code> and <code>(3 + 4 : Rat)</code> to <code>Rat.add 3 4</code> and <code>(3 + 4 : Int)</code> to <code>Int.add 3 4</code> and <code>(3 + 4 : Nat)</code> to <code>Nat.add 3 4</code>. It's so you can use the same lemmas (like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=add_comm#doc\">docs#add_comm</a>) for all these cases. In the case of monads we have stuff like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=bind_pure#doc\">docs#bind_pure</a>.</p>",
        "id": 526590097,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751370642
    },
    {
        "content": "<p>You're running into the \"multiple languages for the same thing\" problem <span class=\"user-mention\" data-user-id=\"588691\">@Jasper Ganten</span>. The PMF library seems to be written primarily in terms of <code>PMF</code> functions directly, and there's not much in the way of theory about monads. Yes, <code>Pure.pure</code> for <code>PMF</code> is defined to be <code>PMF.pure</code>, but the first is in the \"monad language\" and the second is in the \"PMF language\". It's best not to think of these two ways of expressing things as being exactly the same. You should think \"these are (slightly) different languages, and it will take translation\".</p>\n<p>It would be worth writing some translation lemmas, like I did with <code>PMF.monad_pure_eq_pure</code>, and then possibly make a simp set, so that way you can write <code>simp [pmf_of_do]</code> and turn all the \"do language\" into \"PMF language\".</p>",
        "id": 526591907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1751371302
    },
    {
        "content": "<p>Thanks to the both of you, this makes lots of sense. My confusion is probably the symptom of trying to learn lean and category theory/monads at the same time <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> ...  The suggestion to make a simp set is great, since there is not much I will do on the monad level (although it's intriguing to expand on this in the future maybe) :)</p>",
        "id": 526601623,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1751374454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/need.20for.20'explicit'.20type.20conversion.20using.20rw/near/525610552\">schrieb</a>:</p>\n<blockquote>\n<p>A kind of fun definition of the binomial distribution is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">choices</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">sequence</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">bernoulli</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">choices</span><span class=\"bp\">.</span><span class=\"n\">count</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>It's very clearly \"take a sequence of n weighted coin flips and count the number of heads\".</p>\n<p>Proving the support of this is what I thought it was took some doing though... The proof I came up with is really not good. It's clear though that there's some missing theory for dealing with <code>do</code>/monads and PMFs.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">binom_support</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ENNReal</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">binom₀</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Iic</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Thanks for this piece of code you wrote some months ago! Actually, I am not sure your conclusion (missing theory for dealing with monads for <code>PMF</code>) is correct. I am done writing a similar proof, and when I </p>\n<ul>\n<li>exchange the use of <code>List</code> by <code>List.Vector _ n</code> (i.e. <code>sequence &lt;| List.Vector replicate (t := flip List.Vector n) n (PMF.bernoulli p h)</code> knows that it has length <code>n</code> and</li>\n<li>exchange <code>List.count</code> by (a proper definition of) <code>List.Vector.count _ _ : Fin (n + 1)</code>, <br>\nI get for free a <code>PMF (Fin (n + 1))</code>, in particular I have the correct support. </li>\n</ul>\n<p>My conclusion is that in this case, <code>List.Vector</code> has a good use, since I can carry around the length of the list, which leads to the correct support of the resulting <code>PMF</code>. Would you agree?</p>",
        "id": 572397971,
        "sender_full_name": "Peter Pfaffelhuber",
        "timestamp": 1770389938
    }
]