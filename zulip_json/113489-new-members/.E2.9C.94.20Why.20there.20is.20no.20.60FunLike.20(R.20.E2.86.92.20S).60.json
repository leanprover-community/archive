[
    {
        "content": "<p>Hi everyone,</p>\n<p>Why is there no instance for  <code>FunLike (R → S) R S</code>? I guess there is some special design behind it, but I didn't find out. Thank you!</p>",
        "id": 477000413,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1729001822
    },
    {
        "content": "<p>That seems like it would probably cause headaches. Because then every time you had a function <code>f : R → S</code>, you could either treat it as <code>f</code> or <code>⇑f</code>, which are defeq but not reducibly defeq, and which one might be affected by elaboration order.</p>",
        "id": 477014722,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1729005975
    },
    {
        "content": "<p>But the instances of <code>MonoidHomClass (R →* S) R S</code> and <code>RingHomClass (R →+* S) R S</code> do exist. So is this <code>⇑f</code> a special design for functions?</p>",
        "id": 477015304,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1729006150
    },
    {
        "content": "<p><code>R →* S</code> is <em>not</em> a function, it's a structure and one of its fields <em>is</em> a function. The <code>FunLike (R →* S) R S</code> instance allows Lean to automatically coerce <code>f : R →* S</code> to a function <code>⇑f : R → S</code>.</p>",
        "id": 477018356,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1729006999
    },
    {
        "content": "<p>This coercion happens when <code>f</code> is applied to an argument <code>r : R</code>. Basically, when Lean has <code>f : R →* S</code> and we write <code>f r</code>, Lean thinks to itself: \"oh, it seems <code>f</code> is a function with domain <code>R</code>, how can I interpret it as such?\" Then it goes looking for a <code>CoeFun</code> instance, which it ultimately gets from the <code>FunLike</code> instance I mentioned.</p>",
        "id": 477018763,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1729007141
    },
    {
        "content": "<p>Thank you for your explanation! </p>\n<p>Now I see that for <code>MonoidHomClass</code> and <code>RingHomClass</code>, their coercion only happens when they are arguments, i.e. when <code>p</code> is some function that takes a <code>RingHom</code> as input, and one writes <code>p f</code>, Lean will search for the instance <code>RingHomClass</code>. But <code>FunLike</code> is indeed different, when <code>f</code> is in the function's place (not only arguments' place), Lean will search for the <code>FunLike</code> instance. I guess that causes the difference.</p>",
        "id": 477020196,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1729007551
    },
    {
        "content": "<p>No, I don't think you're quite there yet (but maybe I misinterpreted what you said). <code>MonoidHomClass F R S</code> is for when <code>F</code> is a type which whose <em>terms</em> are monoid homomorphisms. This is trivially satisfied by <code>F := R →* S</code>, but it is also true for <code>F := R →+* S</code>, which is why <code>#synth MonoidHomClass (R →+* S) R S</code> succeeds.</p>",
        "id": 477020954,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1729007777
    },
    {
        "content": "<p>Sorry, maybe I missed your point here. I was trying to compare the difference between the following two triples</p>\n<ol>\n<li><code>(R → S)</code>, <code>FunLike</code> and <code>#synth FunLike (R → S) R S -- failed</code></li>\n<li><code>(R →* S)</code>, <code>MonoidHomClass</code> and <code>#synth MonoidHomClass (R →* S) R S -- succeeded</code></li>\n</ol>\n<p>I think the same logic applies to these two triples, which is whenever a coercion from an arbitrary type to <code>(R → S)</code> (resp. <code>(R →* S)</code>) is needed, Lean will search for <code>FunLike</code> (resp. <code>MonoidHomClass</code>) instance. However, <code>#synth</code> gives different results when the identity coercion is needed. This causes confusion to me.</p>",
        "id": 477023377,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1729008459
    },
    {
        "content": "<p><code>MonoidHomClass</code> serves two related purposes:</p>\n<ol>\n<li>it provides access to lemmas which apply to any morphism that satisfies the properties of a <code>MonoidHom</code> (e.g., <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_one#doc\">docs#map_one</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_mul#doc\">docs#map_mul</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=map_list_prod#doc\">docs#map_list_prod</a>, etc.)</li>\n<li>it provides a coercion from those morphisms into <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom#doc\">docs#MonoidHom</a> via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHomClass.toMonoidHom#doc\">docs#MonoidHomClass.toMonoidHom</a>.</li>\n</ol>\n<p>We need to implement an instance of <code>MonoidHomClass (R →* S) R S</code> in order make sure that the lemmas in (1) apply to <code>MonoidHom</code>s themselves. This also means, somewhat unfortunately as the case may be, that there is a coercion from <code>R →* S</code> <em>to itself</em> via (2). This is a bit annoying, but doesn't come up in practice too often.</p>\n<p>The situation for <code>FunLike</code> is a bit different, because it's really <em>only</em> (2) that we care about (this is not <em>strictly</em> true, as there are some lemmas that apply to all <code>FunLike</code> instances, like <code>DFunLike.ext_iff</code>, but we have these same lemmas for functions). As such, there is no real need to create a <code>FunLike (R → S) R S</code> instance (because we don't really need (1)), and it would only cause headaches (because (2) would apply to give us a coercion from functions to themselves).</p>",
        "id": 477052429,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1729018635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20there.20is.20no.20.60FunLike.20.28R.20.E2.86.92.20S.29.60/near/477052429\">said</a>:</p>\n<blockquote>\n<p>The situation for <code>FunLike</code> is a bit different, because it's really <em>only</em> (2) that we care about (this is not <em>strictly</em> true, as there are some lemmas that apply to all <code>FunLike</code> instances, like <code>DFunLike.ext_iff</code>, but we have these same lemmas for functions). As such, there is no real need to create a <code>FunLike (R → S) R S</code> instance (because we don't really need (1)), and it would only cause headaches (because (2) would apply to give us a coercion from functions to themselves).</p>\n</blockquote>\n<p>This is super clear! Thank you very much!</p>",
        "id": 477053220,
        "sender_full_name": "Jiang Jiedong",
        "timestamp": 1729018916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"611077\">Jiang Jiedong</span> has marked this topic as resolved.</p>",
        "id": 477053315,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729018943
    }
]