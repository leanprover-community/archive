[
    {
        "content": "<p>Hey all,</p>\n<p>I am new to dependent type theory, and i am a bit confused what 'Prop' does.</p>\n<p>Firstly, ive read that if a specific 'Prop' is not inhabited this means it is false; but doesn't<br>\nit mean its not true or false yet? A proposition being false seems like a stronger result.</p>\n<p>Also, say there is </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"n\">q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>-- is b a term of type q? What type is q? I am just confused how it can tell the difference between two terms of type Prop.</p>\n<p>Does a Prop term exist as some sort of dependent arrow construction ? Like if it is a Prop about</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>the Prop term itself is a dependent product?</p>",
        "id": 480888031,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1730888741
    },
    {
        "content": "<p>Hi and welcome! A \"stylistic\" comment: can you use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> (single in this case) in your messages? It makes everything more readable. Thanks!</p>",
        "id": 480890404,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730889557
    },
    {
        "content": "<p>Concerning your questions: a proposition <code>p : Prop</code> can be thought as the \"set\" (here in an informal sense) of all of its proofs. This can look a little weird a first sight, but it works well in type theory. So, a proposition that is empy has no proofs, and in this sense it is false.</p>",
        "id": 480890604,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730889626
    },
    {
        "content": "<p>The first thing you need to realize is that types also have types in Lean because indeed everything has a type. There is <code>Type</code> (more specifically <code>Type u</code> but don't think too much about the <code>u</code> yet) which is the type of types that have actual relevant data content. For example <code>Nat : Type</code>, <code>List Nat : Type</code>, <code>Real : Type</code> and so on. On the other hand there is the type of mathematical properties <code>Prop</code>. So for example you have <code>A ∧ B : Prop</code>, <code>∀ (n : Nat), n &lt; n + 1 : Prop</code> and so on.</p>\n<p>Now let's consider for example <code>h1 : A ∧ B</code> this means that you have a proof <code>h1</code> of the property <code>A ∧ B</code> and if you have <code>h2 : ∀ (n : Nat), n &lt; n + 1</code> you have <code>h2</code> being a proof of the property <code>∀ (n : Nat), n &lt; n + 1</code>. Lean's type theory additionally says that there is in fact no difference between two proofs of the same property so if you have <code>h1 :  A ∧ B</code> and <code>h3 :  A ∧ B</code> then you can always prove <code>h1 = h3</code>. Thus we can always show that if a property is provable it has exactly one inhabitant (aka proof) as all other inhabitants would be equivalent to that single inhabitant. If on the other hand we can prove that the property has no inhabitant it is false. We can show this with a simple proof. Let's assume that you had a proof of the property for a moment. That would mean you have an inhabitant of a type without inhabitants, clearly that is a contradiction. The state where \"a proof is not yet found\" is the state where we do not yet know whether the property is inhabited or not.</p>",
        "id": 480890649,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1730889645
    },
    {
        "content": "<p>Note that there is the \"philosophical\" notion of being false and the actual proposition <code>False : Prop</code>. I like to think as the first one as the fact that there are no proofs, so I say that <code>p</code> is false if in practice one cannot prove it.</p>",
        "id": 480890941,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730889747
    },
    {
        "content": "<p>Of course (if we believe that Lean's axiomatic system is OK), <code>False</code> is false, so we cannot prove it.</p>",
        "id": 480891071,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730889788
    },
    {
        "content": "<p>Now, a proposition is true if we can prove it, so <code>1+1=2</code> is a true statement, because one can find a proof. And of course <code>True : Prop</code> is true.</p>",
        "id": 480891189,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730889832
    },
    {
        "content": "<p>Concerning your last question, a proposition like <code>∀ n, n+0=0</code> is just another  <code>Prop</code>. A <em>proof</em> of such a proposition is a dependent function <code>f : (n : ℕ) → (n+0=n)</code>, meaning that the type of <code>f n</code> is <code>n+0=n</code>, so <code>f n</code> is a proof that <code>n+0=n</code>, and if you are able to construct <code>f</code> (so to specify its value everywhere) you are able to construct a proof that <code>n+0=n</code> for all <code>n</code>, and in practice you have proved that <code>∀ n, n+0=0</code>.</p>",
        "id": 480891813,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730890019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>  <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> </p>\n<p>Thank you so much, i think i understand more now.  <br>\nEssentially you can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">≥</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>but not</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">≥</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I am still trying to wrap my head around this, so i might not close this as resolved yet -- not sure what the norm is.</p>",
        "id": 480892731,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1730890325
    },
    {
        "content": "<p>The second example cannot work because after the second <code>:</code> you write <code>n ≥ 1</code>, that is your are saying to Lean that the type of the term you are defining is <code>n ≥ 1</code> (in this case in practice it means that you are proving this results, but it doesn't matter, after the <code>:</code> you specify the type of the term written after the <code>:=</code>).</p>",
        "id": 480893269,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730890522
    },
    {
        "content": "<p>Now, after the <code>:=</code> you write <code>Prop</code>. Lean's job is to check that the term written after the <code>:=</code> has the type written after the <code>:</code>. In this case it has to check if the type of <code>Prop</code> is <code>n ≥ 1</code>, and this is not the case, so it complains.</p>",
        "id": 480893439,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730890579
    },
    {
        "content": "<p>This \"checking the type\" is called type-checking, and mathematically it corresponds to \"check the proof is correct\". Here you are saying \"n is greater of equal than <code>1</code> and the proof is: the collection of all mathematical statements\"</p>",
        "id": 480893617,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730890648
    },
    {
        "content": "<p>For Lean this is en error similar to say \"n ≥ 1 because n ≥ 0\", even if from a human point of view it's clear that the error in the first case is not mathematical but rather in how to write things in Lean</p>",
        "id": 480893969,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1730890765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20does.20'Prop'.20check.20its.20type.3F/near/480893269\">said</a>:</p>\n<blockquote>\n<p>The second example cannot work because after the second <code>:</code> you write <code>n ≥ 1</code>, that is your are saying to Lean that the type of the term you are defining is <code>n ≥ 1</code> (in this case in practice it means that you are proving this results, but it doesn't matter, after the <code>:</code> you specify the type of the term written after the <code>:=</code>).</p>\n</blockquote>\n<p>Understood, i guess it was just confusing me that you can define it as Prop, but it ends up as a Prop (that  is directly tied to the statement <code>n≥1</code> for a specific n)  . And then you basically can define another Prop that you can follow rules to turn into the same Prop, but its all Prop <span aria-label=\"face with spiral eyes\" class=\"emoji emoji-1f635-200d-1f4ab\" role=\"img\" title=\"face with spiral eyes\">:face_with_spiral_eyes:</span></p>",
        "id": 480894320,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1730890874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> has marked this topic as resolved.</p>",
        "id": 480906350,
        "sender_full_name": "Notification Bot",
        "timestamp": 1730895040
    }
]