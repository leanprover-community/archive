[
    {
        "content": "<p>Is there the Riesz representation theorem in mathlib? Maybe just the simple case, like saying that any linear functional <code>l : (n → ℝ) →L[ℝ] ℝ</code> may be interpreted as a vector <code>n → ℝ</code>. In this case it's easy to do manually, but in other similar situations some theorem would be nice.</p>",
        "id": 463765850,
        "sender_full_name": "jsodd",
        "timestamp": 1724175115
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InnerProductSpace.toDual#doc\">docs#InnerProductSpace.toDual</a></p>",
        "id": 463766337,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724175267
    },
    {
        "content": "<p>Thanks. For some reason it fails to synthesize <code>InnerProductSpace ℝ (n → ℝ)</code></p>",
        "id": 463767096,
        "sender_full_name": "jsodd",
        "timestamp": 1724175545
    },
    {
        "content": "<p>I think this is because (n \\to \\R) is endowed with infinite norm rather than the euclidean one. You should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp#doc\">docs#PiLp</a> 2 instead I think</p>",
        "id": 463768953,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724176156
    },
    {
        "content": "<p>I see... Is there a standard way to switch? That is, if I didn't need the $L^2$ structure up to some point and I don't want to rewrite everything before that, is there a way to use it ad hoc?</p>",
        "id": 463769786,
        "sender_full_name": "jsodd",
        "timestamp": 1724176436
    },
    {
        "content": "<p>I’ve never used it so I don’t know if it is convenient, but the switch is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WithLp.equiv#doc\">docs#WithLp.equiv</a></p>",
        "id": 463770828,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724176776
    },
    {
        "content": "<p>Also we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=EuclideanSpace#doc\">docs#EuclideanSpace</a>, which is just a wrapper over PiLp, but it looks nicer</p>",
        "id": 463771195,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1724176873
    },
    {
        "content": "<p>This is great! I still have troubles making <code>n → ℝ</code> out of <code>l : (n → ℝ) →L[ℝ] ℝ</code>, but I guess I'll figure it out. Thank you very much</p>",
        "id": 463773971,
        "sender_full_name": "jsodd",
        "timestamp": 1724177567
    },
    {
        "content": "<p>In this case I could just take a basis <code>let e := fun (i j : n) \\map if i = j then (1 : \\R) else (0 : \\R)</code> and define <code>let l' := fun (i : n) \\map l (e i)</code>. I guess it's just easier than going through the all this machinery</p>",
        "id": 463775562,
        "sender_full_name": "jsodd",
        "timestamp": 1724178008
    },
    {
        "content": "<p>This is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Basis.toDualEquiv#doc\">docs#Basis.toDualEquiv</a></p>",
        "id": 463777943,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724178477
    },
    {
        "content": "<p>I've tried this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">toDualMap</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but now Lean cannot synthesize <code>NormedAddCommGroup (WithLp 2 (n → ℝ) → ℝ)</code>.</p>",
        "id": 463793017,
        "sender_full_name": "jsodd",
        "timestamp": 1724182327
    },
    {
        "content": "<p>It would be better probably if you try to give more context for what you want to do</p>",
        "id": 463799653,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1724184220
    },
    {
        "content": "<p>Well, in the simplest case I'd like to be able to find a unique vector <code>x : n → ℝ</code> representing <code>l : (n → ℝ) →L[ℝ] ℝ</code> relative to the standard scalar product</p>",
        "id": 463800773,
        "sender_full_name": "jsodd",
        "timestamp": 1724184404
    },
    {
        "content": "<p>And I'd also like to understand how to do this in the general Hilbert space context. But first just the finite dimensional case, as simple as possible</p>",
        "id": 463801496,
        "sender_full_name": "jsodd",
        "timestamp": 1724184536
    },
    {
        "content": "<p>I'm not yet sure, but this seems to be close to what I'm looking for:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">toDual</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 463805543,
        "sender_full_name": "jsodd",
        "timestamp": 1724185562
    },
    {
        "content": "<p>Maybe this belongs somewhere near <code>InnerProductSpace.toDual</code>? Taking linear functional representatives is a very common thing...</p>",
        "id": 463806223,
        "sender_full_name": "jsodd",
        "timestamp": 1724185753
    },
    {
        "content": "<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=InnerProductSpace.toDual_symm_apply#doc\">docs#InnerProductSpace.toDual_symm_apply</a> what you're looking for?</p>",
        "id": 463806689,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724185879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"743246\">jsodd</span> <a href=\"#narrow/stream/113489-new-members/topic/Riesz.20theorem/near/463805543\">said</a>:</p>\n<blockquote>\n<p><code>#check (InnerProductSpace.toDual ℝ (WithLp 2 (n → ℝ))).invFun x</code></p>\n</blockquote>\n<p>You should use <code>.symm</code> instead of <code>.invFun</code> to keep a linear equiv</p>",
        "id": 463806839,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724185910
    },
    {
        "content": "<p>I want the representative itself, not some lemma about it</p>",
        "id": 463806866,
        "sender_full_name": "jsodd",
        "timestamp": 1724185917
    },
    {
        "content": "<p>Yes I understand but you already have it, it is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">toDual</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WithLp</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 463806996,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724185955
    },
    {
        "content": "<p>Isn't it?</p>",
        "id": 463807065,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724185980
    },
    {
        "content": "<p>Yes. I'm just saying that maybe this operation deserves its own <code>def</code>.</p>",
        "id": 463807082,
        "sender_full_name": "jsodd",
        "timestamp": 1724185987
    },
    {
        "content": "<p>Just because it's so common to prove something by first proving linearity and then taking representatives</p>",
        "id": 463807150,
        "sender_full_name": "jsodd",
        "timestamp": 1724186010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/stream/113489-new-members/topic/Riesz.20theorem/near/463806839\">said</a>:</p>\n<blockquote>\n<p>You should use <code>.symm</code> instead of <code>.invFun</code> to keep a linear equiv</p>\n</blockquote>\n<p>But the fact that it's linear equivalence is gone as soon as I apply it to <code>x</code>, no?</p>",
        "id": 463807519,
        "sender_full_name": "jsodd",
        "timestamp": 1724186152
    },
    {
        "content": "<p>Well here it does not matter I think, but generally when you need the inverse of an equiv, you use <code>symm</code> to also have an equiv</p>",
        "id": 463807758,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1724186235
    },
    {
        "content": "<p>Okay, thanks for the advice!</p>",
        "id": 463807808,
        "sender_full_name": "jsodd",
        "timestamp": 1724186261
    },
    {
        "content": "<p>One more question on the same subject. Let's say I have defined a function <code>m : (n → ℝ) → ℝ</code>. What do I have to do, after proving <code>h : IsLinearMap m</code>, to reinterpret <code>m</code> as  <code>m : (n → ℝ) →L[ℝ] ℝ</code>? What's the proper way to use <code>h</code>?</p>",
        "id": 463970765,
        "sender_full_name": "jsodd",
        "timestamp": 1724226090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> IsLinearMap, LinearMap</p>",
        "id": 463971102,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724226178
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/LinearMap/Defs.html#IsLinearMap.mk%27\">IsLinearMap.mk'</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Module/LinearMap/Defs.html#LinearMap.isLinear\">LinearMap.isLinear</a>, and <a href=\"https://loogle.lean-lang.org/?q=IsLinearMap%2C%20LinearMap\">2 more</a></p>",
        "id": 463971103,
        "sender_full_name": "loogle",
        "timestamp": 1724226179
    },
    {
        "content": "<p>Presumably <code>h.mk' m</code> will work</p>",
        "id": 463971172,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724226208
    },
    {
        "content": "<p>Just <code>h.mk'</code> did the trick, thanks! So it's always through <code>.mk</code> constructors? I mean in similar circumstances</p>",
        "id": 463971539,
        "sender_full_name": "jsodd",
        "timestamp": 1724226313
    },
    {
        "content": "<p>In similar circumstances, I would also look at what loogle finds :)</p>",
        "id": 463971929,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724226476
    },
    {
        "content": "<p>The problem with loogle and the official documentation (which for me is easier to use) is to know how things are called.</p>",
        "id": 463972091,
        "sender_full_name": "jsodd",
        "timestamp": 1724226527
    },
    {
        "content": "<p>For example, I know what a Riesz representation theorem is, but there seems to be no way to find it in lean by this name</p>",
        "id": 463972212,
        "sender_full_name": "jsodd",
        "timestamp": 1724226579
    },
    {
        "content": "<p>It would be so nice to have a more user-friendly search</p>",
        "id": 463972538,
        "sender_full_name": "jsodd",
        "timestamp": 1724226683
    },
    {
        "content": "<p>And something like <code>fzf</code> on linux would also be great. Just to be less punished by the search for not knowing the precise name. Maybe I'll try writing something like this for myself...</p>",
        "id": 463973483,
        "sender_full_name": "jsodd",
        "timestamp": 1724226980
    },
    {
        "content": "<p>If you know the name of the theorem, use <a href=\"http://moogle.ai\">moogle.ai</a></p>",
        "id": 463973670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1724227024
    },
    {
        "content": "<p>I just tried to find Riesz representation theorem, but it couldn't.</p>",
        "id": 463974554,
        "sender_full_name": "jsodd",
        "timestamp": 1724227181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"743246\">jsodd</span> <a href=\"#narrow/stream/113489-new-members/topic/Riesz.20theorem/near/463972212\">said</a>:</p>\n<blockquote>\n<p>For example, I know what a Riesz representation theorem is, but there seems to be no way to find it in lean by this name</p>\n</blockquote>\n<p>You can search the repository on Github for \"Riesz representation\". The name is in the comments (as it should be).</p>",
        "id": 463975330,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724227317
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/NLEscynIHDaUb9XpwAMHxyYw/image.png\">image.png</a><br>\nI found it in the end by clicking on \"Google site search\" here</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/NLEscynIHDaUb9XpwAMHxyYw/image.png\" title=\"image.png\"><img data-original-dimensions=\"750x238\" src=\"/user_uploads/thumbnail/3121/NLEscynIHDaUb9XpwAMHxyYw/image.png/840x560.webp\"></a></div>",
        "id": 463975707,
        "sender_full_name": "jsodd",
        "timestamp": 1724227392
    },
    {
        "content": "<p>It also appears in the library overiew on the community webpage <a href=\"https://leanprover-community.github.io/mathlib-overview.html\">https://leanprover-community.github.io/mathlib-overview.html</a></p>",
        "id": 463975841,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724227424
    },
    {
        "content": "<p>I just hope the search will get easier in the future <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 463976918,
        "sender_full_name": "jsodd",
        "timestamp": 1724227645
    },
    {
        "content": "<p>I know it's far from the current project goals, but it's just so easy to imagine how a more user-friendly search may function.</p>",
        "id": 463976951,
        "sender_full_name": "jsodd",
        "timestamp": 1724227655
    },
    {
        "content": "<p>I agree that search can be difficult</p>",
        "id": 463977062,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1724227681
    },
    {
        "content": "<p>This google search feature seems to be quite good, just found \"second dual\" theorems with it. In lean it's called \"double dual\" with no second duals mentioned, but Google knows that double and second are the same thing.</p>",
        "id": 463978747,
        "sender_full_name": "jsodd",
        "timestamp": 1724228036
    }
]