[
    {
        "content": "<p>I've defined this data type which represents an infinite function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">StreamF</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">mk</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span><span class=\"o\">)))</span> <span class=\"bp\">→</span> <span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span>\n</code></pre></div>\n<p>And a function for creating a 'delayed' function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">liftSF</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">o</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">i</span><span class=\"o\">):</span> <span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"o\">:=</span> <span class=\"n\">StreamF.mk</span> <span class=\"bp\">λ</span><span class=\"n\">x'</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">liftSF</span> <span class=\"n\">f</span> <span class=\"n\">x'</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>How can I prove that <code>liftSF</code> terminates? Or does this function not terminate by lean's definition of termination?</p>",
        "id": 396551134,
        "sender_full_name": "Antonio Ponce",
        "timestamp": 1697220351
    },
    {
        "content": "<p>your definition of <code>StreamF</code> doesn't work. In particular, you can prove that your type is inhabited IFF <code>i</code> isn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">i</span><span class=\"o\">]:</span> <span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"bp\">→</span> <span class=\"n\">False</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">StreamF.rec</span> <span class=\"o\">(</span><span class=\"n\">motive_1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">motive_2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span><span class=\"o\">)</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">default</span>\n  <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">id</span>\n</code></pre></div>\n<p>This also means that your <code>liftSF</code> definition cannot be accepted by lean. Streams should be implemented using co-inductive types. They are, however, not a part of Lean's type theory. If you wish to implement this, your best bet currently would be to define this in Coq instead.</p>",
        "id": 396569293,
        "sender_full_name": "Arthur Adjedj",
        "timestamp": 1697230258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658849\">Antonio Ponce</span> has marked this topic as resolved.</p>",
        "id": 396572822,
        "sender_full_name": "Notification Bot",
        "timestamp": 1697232214
    },
    {
        "content": "<p>I think it's possible to create streams as function types without a co-inductive types feature. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream#doc\">docs#Stream</a> for example</p>",
        "id": 396585348,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697241607
    },
    {
        "content": "<p>I wonder if <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MLList#doc\">docs#MLList</a> would be useful as well</p>",
        "id": 396585482,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697241717
    },
    {
        "content": "<p>Maybe you could use an MLList where the monad is a reader monad of <code>i</code></p>",
        "id": 396585555,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697241751
    },
    {
        "content": "<p>Oops, I meant to link <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream%27#doc\">docs#Stream'</a>, which is defined as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Stream'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>This is nice for reasoning, but not always nice for computation, because every time you ask for the <code>n</code>th item in the stream, it has to recompute everything and can't reuse its result from the <code>n-1</code>th item.</p>\n<p>If you wanted to copy the purity of that approach and add your notion of inputs. I suppose the analog would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Given the inputs so far (at least one), produce the next output</span>\n<span class=\"kd\">def</span> <span class=\"n\">StreamF</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">o</span>\n</code></pre></div>",
        "id": 396588440,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697243729
    },
    {
        "content": "<p>The approach of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Stream#doc\">docs#Stream</a> is to use a <code>class</code> instead of an <code>inductive</code>. Rather than requiring that <code>StreamF</code> is the <em>smallest</em> type that can be constructed from an \"uncons\" function, which is what <code>inductive</code> means, you can use a typeclass to require that it's possible to define such a function on the type.</p>",
        "id": 396589005,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697244011
    },
    {
        "content": "<p>I was curious what it would look like, so I made a longer example using the \"purer\" option above</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">StreamF</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">o</span>\n\n<span class=\"c1\">-- We can define a `StreamF.mk` using a type `σ` to represent the stream state.</span>\n<span class=\"kd\">def</span> <span class=\"n\">StreamF.mk</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"bp\">×</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span>\n<span class=\"bp\">|</span> <span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">i1</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">acc</span> <span class=\"n\">i1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span>\n<span class=\"bp\">|</span> <span class=\"n\">acc</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">i1</span><span class=\"o\">,</span> <span class=\"n\">i2</span> <span class=\"o\">::</span> <span class=\"n\">is</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">StreamF.mk</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">acc</span> <span class=\"n\">i1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"n\">s</span> <span class=\"n\">i2</span> <span class=\"n\">is</span>\n\n<span class=\"c1\">-- Produces the first output from the stream given the first input.</span>\n<span class=\"kd\">def</span> <span class=\"n\">StreamF.uncons</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">StreamF</span> <span class=\"n\">i</span> <span class=\"n\">o</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i1</span> <span class=\"o\">[],</span> <span class=\"k\">fun</span> <span class=\"n\">i2</span> <span class=\"n\">is</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">s</span> <span class=\"n\">i1</span> <span class=\"o\">(</span><span class=\"n\">i2</span> <span class=\"o\">::</span> <span class=\"n\">is</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Example: Stream that maintains a `Nat` state, adding each input to it and outputting it.</span>\n<span class=\"kd\">def</span> <span class=\"n\">addToState</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StreamF</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">StreamF.mk</span> <span class=\"n\">start</span>\n    <span class=\"k\">fun</span> <span class=\"n\">acc</span> <span class=\"n\">i</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">addToState</span> <span class=\"mi\">2</span> <span class=\"mi\">5</span> <span class=\"o\">[]</span> <span class=\"c1\">-- 7</span>\n<span class=\"k\">#eval</span> <span class=\"n\">addToState</span> <span class=\"mi\">2</span> <span class=\"mi\">5</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"c1\">-- 8</span>\n<span class=\"k\">#eval</span> <span class=\"n\">addToState</span> <span class=\"mi\">2</span> <span class=\"mi\">5</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"c1\">-- 11</span>\n\n<span class=\"k\">#eval</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">addToState</span> <span class=\"mi\">2</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s.uncons</span> <span class=\"mi\">5</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">o2</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s.uncons</span> <span class=\"mi\">1</span>\n  <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">o3</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">s.uncons</span> <span class=\"mi\">3</span>\n  <span class=\"o\">[</span><span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">o2</span><span class=\"o\">,</span> <span class=\"n\">o3</span><span class=\"o\">]</span> <span class=\"c1\">-- [7, 8, 11]</span>\n\n<span class=\"c1\">-- A direct definition in comparison to using `Stream.mk`</span>\n<span class=\"kd\">def</span> <span class=\"n\">addToState'</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">StreamF</span> <span class=\"n\">Nat</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">i1</span>\n<span class=\"bp\">|</span> <span class=\"n\">i1</span><span class=\"o\">,</span> <span class=\"n\">i2</span> <span class=\"o\">::</span> <span class=\"n\">is</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">addToState</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"bp\">+</span> <span class=\"n\">i1</span><span class=\"o\">)</span> <span class=\"n\">i2</span> <span class=\"n\">is</span>\n</code></pre></div>",
        "id": 396596205,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1697248027
    }
]