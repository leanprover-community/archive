[
    {
        "content": "<p>Hi! Some background before my question:<br>\nThis is my first stab at Lean. I have a very minimal experience with Coq in the past, but I wanted to try out alternative theorem provers to see if there were others I liked more. And Lean is a lot more user-friendly (esp around induction and recursion!)<br>\nI'm trying to create a general framework for proving numbers are prime from first principles to get a handle on how to prove things in Lean . <br>\nI know this is probably not how you would normally use Lean, but I'm new to theorem proving in general so it seems like a natural place to start.</p>\n<p>NOTE: I've defined natural numbers like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">nat</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span>\n  <span class=\"bp\">|</span> <span class=\"n\">inc</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">nat</span>\n</code></pre></div>\n<p>I've gotten to the point where I have a function to check if a number is prime or not</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nat.check_prime</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>This is implemented and it works well, the following gives the result</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">nat.check_prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">isTrue</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>Nice! Now I have a problem, I want to use this function to prove that 2 is prime<br>\nHowever, I can't figure out how to ignore to <code>isFalse</code> case automatically since that's impossible, and Lean seems to know that it's impossible given the eval seen above. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">two_is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>How would I automatically ignore the <code>isFalse</code> case given this is a very concrete term</p>",
        "id": 350239893,
        "sender_full_name": "RustyYato",
        "timestamp": 1681611013
    },
    {
        "content": "<p>Here's as far as I was able to get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">two_is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">nat.check_prime</span> <span class=\"n\">nat.zero.inc.inc</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Decidable.isTrue</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">d</span>\n   <span class=\"c1\">-- no idea what to do here, and Lean doesn't let me ignore it like in other cases where a match branch is impossible</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Decidable.isFalse</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">admit</span>\n</code></pre></div>",
        "id": 350239961,
        "sender_full_name": "RustyYato",
        "timestamp": 1681611085
    },
    {
        "content": "<p>I was able to prove that two is prime without using this more general <code>check_prime</code> function, however I thought it should be possible to automatically detect if a number is prime, which led me down this rabbit hole</p>",
        "id": 350240089,
        "sender_full_name": "RustyYato",
        "timestamp": 1681611191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"610303\">RustyYato</span> <a href=\"#narrow/stream/113489-new-members/topic/force.20decidability/near/350239893\">said</a>:</p>\n<blockquote>\n<p>I know this is probably not how you would normally use Lean, but I'm new to theorem proving in general so it seems like a natural place to start.</p>\n</blockquote>\n<p>I take it you haven't seen <a href=\"https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\">#nng</a> then. :) Reinventing the natural numbers is such a common way to start that it's now a popular pastime</p>",
        "id": 350240602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681611624
    },
    {
        "content": "<p>The idiomatic way to use <code>Decidable</code> instances to prove things is <code>by decide</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">two_is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 350240728,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681611749
    },
    {
        "content": "<p>The way it works is to use an auxiliary definition which forces the <code>check_prime</code> function to be evaluated for the term to typecheck</p>",
        "id": 350240842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681611876
    },
    {
        "content": "<p>Here's an implementation of the proof strategy from scratch:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">AsTrue</span> <span class=\"o\">(</span><span class=\"n\">dec</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">dec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">d</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">of_asTrue</span> <span class=\"o\">(</span><span class=\"n\">dec</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">AsTrue</span> <span class=\"n\">dec</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">dec</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isTrue</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">isFalse</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">False.elim</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">two_is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"n\">of_asTrue</span> <span class=\"o\">(</span><span class=\"n\">nat.check_prime</span> <span class=\"n\">nat.zero.inc.inc</span><span class=\"o\">)</span> <span class=\"n\">trivial</span>\n</code></pre></div>\n<p>The trick is in the <code>trivial</code> at the end. <code>trivial</code> is a proof of <code>True</code>, but the type that is expected is <code>AsTrue (nat.check_prime nat.zero.inc.inc)</code>, so to make this typecheck lean will first unfold <code>AsTrue</code>, then see the match, then unfold <code>nat.check_prime</code> to get it to evaluate to <code>isTrue</code> of something.</p>",
        "id": 350241314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681612411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"610303\">@RustyYato</span></p>",
        "id": 350241375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1681612448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/force.20decidability/near/350240602\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"610303\">RustyYato</span> <a href=\"#narrow/stream/113489-new-members/topic/force.20decidability/near/350239893\">said</a>:</p>\n<blockquote>\n<p>I know this is probably not how you would normally use Lean, but I'm new to theorem proving in general so it seems like a natural place to start.</p>\n</blockquote>\n<p>I take it you haven't seen <a href=\"https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\">#nng</a> then. :) Reinventing the natural numbers is such a common way to start that it's now a popular pastime</p>\n</blockquote>\n<p>Oh wow, that's great! I'll definitely have to take a look at that.</p>",
        "id": 350249554,
        "sender_full_name": "RustyYato",
        "timestamp": 1681619631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/force.20decidability/near/350240728\">said</a>:</p>\n<blockquote>\n<p>The idiomatic way to use <code>Decidable</code> instances to prove things is <code>by decide</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">two_is_prime</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">decide</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I see, this was the missing piece for me, thanks! And the manual implementation is super helpful, using <code>AsTrue</code> to force evaluation wasn't something I thought about. Seems like a nice tool for other similar situations.</p>\n<p>Thanks a lot for the help!</p>",
        "id": 350249663,
        "sender_full_name": "RustyYato",
        "timestamp": 1681619732
    },
    {
        "content": "<p>So I tried  this out, but I ran into this problem</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">reduce</span> <span class=\"n\">to</span> <span class=\"bp\">'</span><span class=\"n\">true'</span>\n  <span class=\"n\">Decidable.rec</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">false</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">prime_is_decidable</span>\n</code></pre></div>\n<p>with this <code>instance</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">prime_is_decidable</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">nat.check_prime</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>So I tried out the manual approach you showed and got</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">of_asTrue</span> <span class=\"o\">(</span><span class=\"n\">nat.check_prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">)))</span> <span class=\"n\">trivial</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">trivial</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">True</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">AsTrue</span> <span class=\"o\">(</span><span class=\"n\">nat.check_prime</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"o\">(</span><span class=\"n\">nat.inc</span> <span class=\"n\">nat.zero</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Which looks like lean isn't able to reduce check_prime for some reason. At first I thought it was because I used well-founded recursion in by implementation of division, because of the docs for the <code>decide</code> tactic say that it may not work in the presence of well-founded recursion. So I went ahead and reimplemented it without well-founded recursion, and <code>decide</code> still doesn't work. I've tried everything I could think of and I still don't know why it's not evaluating. </p>\n<p>Here's the entire project so far: <a href=\"https://github.com/RustyYato/lean-root2\">https://github.com/RustyYato/lean-root2</a><br>\nHere's the definition of two is prime: <a href=\"https://github.com/RustyYato/lean-root2/blob/71e8179556aef1635301df3d721d72b7d89584c3/Root2/Prime/Concrete.lean#L15-L16\">https://github.com/RustyYato/lean-root2/blob/71e8179556aef1635301df3d721d72b7d89584c3/Root2/Prime/Concrete.lean#L15-L16</a></p>",
        "id": 350544276,
        "sender_full_name": "RustyYato",
        "timestamp": 1681744064
    },
    {
        "content": "<p>Wow, that took a while, but the reason why it wasn't reducing was because of how I was comparing equality of my natural numbers<br>\nAfter copying the implementation from the std lib, it worked.<br>\nNow to understand why</p>",
        "id": 355244841,
        "sender_full_name": "RustyYato",
        "timestamp": 1683054775
    },
    {
        "content": "<p>before I had equality defined like so</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">nat.compare_eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Decidable</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n\n  <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isTrue</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nat.inc</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span><span class=\"o\">)</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nat.inc</span> <span class=\"n\">a₀</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">b</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nat.zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Decidable.isFalse</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">intro</span><span class=\"bp\">;</span> <span class=\"n\">contradiction</span><span class=\"o\">)</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nat.inc</span> <span class=\"n\">b₀</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">nat.eq_inc_irr</span> <span class=\"n\">a₀</span> <span class=\"n\">b₀</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat.compare_eq</span> <span class=\"n\">a₀</span> <span class=\"n\">b₀</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where <code>eq_inc_irr : (inc a = inc b) = (a = b)</code>. I guess that lean doesn't like wrapping and unwrapping <code>Decidable</code> and gives up</p>",
        "id": 355248956,
        "sender_full_name": "RustyYato",
        "timestamp": 1683056035
    },
    {
        "content": "<p>But I have less than and less or equal comparisons defined in a similar way, and they get evaluated just fine. So I'm not sure why this one change made the difference</p>",
        "id": 355249857,
        "sender_full_name": "RustyYato",
        "timestamp": 1683056320
    }
]