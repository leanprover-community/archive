[
    {
        "content": "<p>Hello, I am relatively new to lean and could use some help. Currently I am trying to write prove that the (incl_fun) function defined, mapping a power series in a set of variables to a power series in variables corresponding to the disjoint union of the first set with another set in the natural way, gives a morphism of rings.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.quotient</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_power_series</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">τ</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incl_fun</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">finsupp.sum_finsupp_equiv_prod_finsupp</span> <span class=\"n\">m</span> <span class=\"k\">in</span>\n  <span class=\"k\">if</span> <span class=\"n\">n.2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">n.1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">mv_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">incl_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span>  <span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">incl_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">coeff_one</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">incl_fun</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Above is what I have so far. Below is the tactic state after the split_ifs tactic in map_one'. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">σ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">τ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n<span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">finsupp.comap_domain</span> <span class=\"n\">sum.inr</span> <span class=\"n\">m</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">finsupp.comap_domain</span> <span class=\"n\">sum.inl</span> <span class=\"n\">m</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">σ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">τ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n<span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"n\">R</span>\n<span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">⊕</span> <span class=\"n\">τ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">finsupp.comap_domain</span> <span class=\"n\">sum.inr</span> <span class=\"n\">m</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">finsupp.comap_domain</span> <span class=\"n\">sum.inl</span> <span class=\"n\">m</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>It seems as though the way to proceed would be to \"evaluate\" the lambda at our n and then split_ifs again to deal with all possibilities, however, I have not been able to figure out how I should go about doing this.</p>",
        "id": 342866985,
        "sender_full_name": "Coleton Kotch",
        "timestamp": 1679193491
    },
    {
        "content": "<p>Am I correct that your definition would be the same as <code>mv_polynomial.eval₂_hom mv_polynomial.C or.inl</code>?</p>",
        "id": 342868816,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1679195120
    },
    {
        "content": "<p>I believe that my definition would be the same as that yes, other than for power series of course and using <code>sum.inl</code> instead of <code>or.inl</code>.</p>",
        "id": 342872458,
        "sender_full_name": "Coleton Kotch",
        "timestamp": 1679198008
    },
    {
        "content": "<p>Ah, yes, I meant <code>sum.inl</code></p>",
        "id": 342872603,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1679198100
    },
    {
        "content": "<p>So you could prove it by using extensionality to verify that your map is the same as the ring homomorphism which already exists, and then deducing that your map is also a ring homomorphism :-)</p>",
        "id": 342903111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679218648
    },
    {
        "content": "<p>These internal definitions of things like polynomial multiplication are very delicate. If you're doing this as a learning exercise then you've certainly jumped in at the deep end and you might want to look at how things like eval2hom are constructed. If you're doing it because you need it for something else then just breathe a sigh of relief because it's done already. Even single variable polynomials are quite messy when dealing with multiplication.</p>",
        "id": 342903348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679218767
    },
    {
        "content": "<p>My goal is to use it in defining formal group laws so I don't need to do everything from scratch. However, though I do now know how to get the morphism for polynomials thanks to Yakov Pechersky's help, I don't see how to construct the analogous morphism for power series.</p>",
        "id": 342983844,
        "sender_full_name": "Coleton Kotch",
        "timestamp": 1679256027
    },
    {
        "content": "<p>The power series API might be less complete than the polynomial API -- probably power series have had less love than polynomials. So what's the set-up: a power series ring in finitely many variables over a commutative base ring? My feeling is that the correct way to set this up is to first show that power series rings are uniform space completions of polynomial rings and then use the polynomial API and argue by continuity to develop the corresponding power series API. The first step (although it would be worth checking to see nobody did it already) would be to put the uniform space structure on a polynomial ring coming from the ideal generated by the coefficients and prove that the inclusion to the power series ring identifies the power series ring with the completion (at least in the case of finitely many variables; I'd have to think a little more to be sure it worked in the case of infinite variables)</p>",
        "id": 342985450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1679257133
    }
]