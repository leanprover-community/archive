[
    {
        "content": "<p>In Section 3.4 of Mathematics in Lean (<a href=\"https://leanprover-community.github.io/mathematics_in_lean/mathematics_in_lean.pdf\">https://leanprover-community.github.io/mathematics_in_lean/mathematics_in_lean.pdf</a>), there is this exercise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>and the book says: \"Beyond logical operations, you do not need anything more than <code>le_refl</code> and <code>le_trans</code>.\" However, the official solution uses <code>le_antisymm</code>. Is there a way to solve this exercise without <code>le_antisymm</code>? Or is this just a typo in the book?</p>",
        "id": 490943630,
        "sender_full_name": "Noble Mushtak (he/him)",
        "timestamp": 1735271385
    },
    {
        "content": "<p>This works and is maybe not cheating :). I had to use <code>gt_irrefl</code> to show that <code>a &lt; a</code> is <code>False</code>. But I dug down through the the layers of its definition and found <code>le_refl</code> (or <code>le_rfl</code>) and <code>le_trans</code>.  Maybe the same is true for <code>le_antisymm</code> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"c1\">-- le_refl and le_trans.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">lt_iff_le_not_le</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">      </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">constructor</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_lt_or_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha₁</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb₁</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₁</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha₂</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exfalso</span>\n<span class=\"w\">        </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">        </span><span class=\"k\">calc</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">          </span><span class=\"bp\">_&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha₁</span>\n<span class=\"w\">          </span><span class=\"bp\">_&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha₂</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">gt_irrefl</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hb₂</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hb₁</span>\n</code></pre></div>",
        "id": 490949663,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1735276694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"815129\">Noble Mushtak (he/him)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20do.20exercise.20without.20le_antisymm.3F/near/490943630\">said</a>:</p>\n<blockquote>\n<p>In Section 3.4 of Mathematics in Lean (<a href=\"https://leanprover-community.github.io/mathematics_in_lean/mathematics_in_lean.pdf\">https://leanprover-community.github.io/mathematics_in_lean/mathematics_in_lean.pdf</a>), there is this exercise:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>and the book says: \"Beyond logical operations, you do not need anything more than <code>le_refl</code> and <code>le_trans</code>.\" However, the official solution uses <code>le_antisymm</code>. Is there a way to solve this exercise without <code>le_antisymm</code>? Or is this just a typo in the book?</p>\n</blockquote>\n<p>I don't think this is possible — <code>le_refl</code> and <code>le_trans</code> are satisfied by preorders (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preorder#doc\">docs#Preorder</a>), but this theorem isn't true for preorders</p>",
        "id": 490951314,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735278195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317929\">@Derek Rhodes</span> Your proof uses <code>le_iff_lt_or_eq</code>, which uses <code>le_antisymm</code> in its definition, so your proof still depends on <code>le_antisymm</code></p>\n<p><span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> Makes sense, who should I contact about this error in the book to have it corrected?</p>",
        "id": 490953692,
        "sender_full_name": "Noble Mushtak (he/him)",
        "timestamp": 1735280216
    },
    {
        "content": "<p>You can make a pull request or open an issue in the github repository: <a href=\"https://github.com/avigad/mathematics_in_lean_source\">https://github.com/avigad/mathematics_in_lean_source</a></p>",
        "id": 490958362,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735283721
    }
]