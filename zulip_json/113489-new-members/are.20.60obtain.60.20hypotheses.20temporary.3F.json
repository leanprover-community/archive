[
    {
        "content": "<p>The following is a simple example of using <code>obtain</code> to split a disjunctive hypothesis into cases:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>\n<p><strong>Question</strong>: Are the obtained hypotheses <code>ha</code> and <code>hb</code> temporary? That is, they only exist in the scope of the subproofs (inside the <code>\\.</code>) or do they replace <code>h</code> and exist until the end of the program?</p>\n<p>Infoview suggests <code>h</code> is deleted and replaced by <code>ha</code> and <code>hb</code>. But since I don't have more code after the cases, I don't know what happens after these goals are met.</p>",
        "id": 467181051,
        "sender_full_name": "rzeta0",
        "timestamp": 1725354484
    },
    {
        "content": "<p>Internally, Lean creates <em>lots</em> of metavariable, each one representing a goal.  Roughly, you can imagine that any tactic that modifies the goal is very likely \"resolving completely\" the goal before that tactic application and replacing it with one or more new metavariables (possibly very similar to the one that you started with) or possibly finishing a proof.</p>\n<p>Lean keeps track of these \"implications\" and knows how to solve the original goal, if you solve all the later goals and this happens in the background.</p>",
        "id": 467183747,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355137
    },
    {
        "content": "<p>Without knowing the exact details of <code>obtain</code>, my guess is that after the <code>obtain</code>, the original goal is considered \"solved\" and two more \"dependent\" goals are created, each with its context (the local hypotheses).  Lean knows what the resolved goals are, but is not showing them to you (and typically there are <em>many</em> more side-goals than the ones that you ever see, since Lean is constantly solving lots of unification, typeclass and similar such goals in the background.</p>",
        "id": 467184214,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355264
    },
    {
        "content": "<p>Here is a quick test that you can do: the new tactic <code>show_mvar_names</code> simply prints the internal names that Lean has for the goals.  These names are <em>unique</em>, so a different name means a different goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"sd\">/-- prints the internal names of all the metavariables -/</span>\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"show_mvar_names\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{(← getGoals).map (·.name)}\"</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">show_mvar_names</span><span class=\"w\"> </span><span class=\"c1\">-- [_uniq.934]</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">show_mvar_names</span><span class=\"w\"> </span><span class=\"c1\">-- [_uniq.958, _uniq.963]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 467184967,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355440
    },
    {
        "content": "<p>Hi Damiano</p>\n<p>If I add <code>show_mvar_names</code> to the end to see if the obtained hypothesis exist after the cases, then it shows me a <code>[]</code>. </p>\n<p>I can understand deleting <strong>goals</strong> once they are proven, but deleting <strong>hypotheses</strong> seems wrong as they may be used again further down the proof.</p>\n<hr>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"show_mvar_names\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">gs</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">getGoals</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">m!</span><span class=\"s2\">\"{gs.map (·.name)}\"</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">show_mvar_names</span><span class=\"w\"> </span><span class=\"c1\">-- [_uniq.934]</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">show_mvar_names</span><span class=\"w\"> </span><span class=\"c1\">-- [_uniq.958, _uniq.963]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"n\">show_mvar_names</span>\n</code></pre></div>",
        "id": 467185689,
        "sender_full_name": "rzeta0",
        "timestamp": 1725355643
    },
    {
        "content": "<p>The tactic is showing metavariables.  Each metavariable has a goal and a <em>context</em> that contains all the hypotheses relevant to that mvar.</p>",
        "id": 467185953,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355712
    },
    {
        "content": "<p>At the end of a proof, there are no metavariables left, so no hypotheses either.</p>",
        "id": 467186028,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355730
    },
    {
        "content": "<p>Roughly, a metavariable is a unique name for each one of the things that you can focus on using <code>·</code>: goal, hypothesis, everything.</p>",
        "id": 467186692,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725355866
    },
    {
        "content": "<p>But also, it would be incorrect to assume ha : x = 3 outside of the scope where we're no longer in the left case of the disjunction. We can't assume x = 3 anymore once we're outside that case. So Lean helps us by keeping track of the hypotheses that still hold.</p>",
        "id": 467242492,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1725367599
    },
    {
        "content": "<p>A \"goal\" consists of a \"local context\" (a list of hypotheses/local variables) and a \"target\" (the type that comes after the turnstile <code>⊢</code>). While \"goal\" should refer to the goal itself, colloquially people tend to use it to refer to the target via a figure of speech (synecdoche). Goals and metavariables are nearly the same thing, but a goal is a metavariable that appears in the tactic state's goal list.</p>\n<p>The local context is <em>essential</em> to a goal since it's necessary for interpreting the target. In your case, it answers what <code>x</code> is.</p>\n<p>Your <code>obtain</code> creates two goals. Each focusing dot focuses on each goal one at a time. Here's how you can think of it:</p>\n<ul>\n<li>the goal (let's call it <code>?m.1</code>) before <code>obtain</code> is used to create two new goals (let's call them <code>?m.2</code> and <code>?m.3</code>) with the same local contexts but with <code>h</code> deleted, and furthermore <code>?m.2</code> has <code>ha : x = 3</code> and <code>?m.3</code> has <code>hb : x = -3</code></li>\n<li>internal detail: the <code>obtain</code> tactic does the assignment <code>?m.1 := Or.casesOn h (fun ha =&gt; ?m.2) (fun hb =&gt; ?m.3)</code> (or something similar), which solves the goal <code>?m.1</code> assuming <code>?m.2</code> and <code>?m.3</code> are solved. This expression makes sense because <code>?m.2</code> has <code>ha</code> in its local context and <code>?m.3</code> has <code>hb</code> in its local context.</li>\n<li><code>obtain</code> adds <code>?m.2</code> and <code>?m.3</code> to the front of the goal list in the current tactic state.</li>\n</ul>\n<p>There is no adding or deleting local variables to the goals here. The two goals after <code>obtain</code> are derived from the original goal, but are otherwise independent of it, and each are independently solved by your focus tactics.</p>",
        "id": 467277678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725375008
    },
    {
        "content": "<p>Thanks Kyle - your reply is helpful.</p>\n<p>I have some follow on questions:</p>\n<ol>\n<li>\n<p>How does Lean know which scope which lean code corresponds to after an <code>obtain</code>? The above discussion mentions focussing dots, but as far as I can tell (based on  Heather macBeth's course) they seem optional good style. Does lean use the point at which the sub-goal is proved to then destroy the \"context\" and with it the <code>ha</code> hypothesis?</p>\n</li>\n<li>\n<p>Is / was there any discussion to further develop the lean syntax to make this clearer for readers, or to signal to lean where the scope was intended by the code writer? In the manner we use brackets or indents in some languages to denote function/loop/other scope?</p>\n</li>\n<li>\n<p>Can I confirm my understanding: A yes/no would be incredibly helpful:</p>\n</li>\n</ol>\n<ul>\n<li>\n<ol start=\"4\">\n<li>The goal <code>h</code> exists before <code>obtain</code> and exists again after the sub-goals created by <code>obtain</code> are completed ?</li>\n</ol>\n</li>\n<li>\n<ol start=\"5\">\n<li>The goals <code>ha</code> and <code>hb</code> only exist in the scope of the sub-goals, and once proven, they no longer exist, eg if I add additional code after the my example at the top of this thread, then <code>ha</code> doesn't exist any more ?</li>\n</ol>\n</li>\n</ul>",
        "id": 467330197,
        "sender_full_name": "rzeta0",
        "timestamp": 1725387044
    },
    {
        "content": "<p>Tactic scripts don't have scopes per se. It's all an illusion, and using good style is a way to make the scopes more real. All that really exist are the tactic states before and after each tactic, which consist of (1) the current list of goals and (2) other elaboration state, like metavariable assignments.</p>\n<p>Each individual tactic consumes the current list of goals and outputs a new list of goals, some of which may be the same. Most tactics only operate on the first goal in the list. The focus dot <code>· T</code> for example is a tactic that has a tactic T as an operand. The way it works is it takes the current goal list <code>[g1, g2, ..., gn]</code>, runs <code>T</code> using the goal list <code>[g1]</code>, checks that the result of running <code>T</code> is the empty goal list <code>[]</code>, and then afterwords sets the goal list to <code>[g2, ..., gn]</code>.</p>",
        "id": 467331028,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725387303
    },
    {
        "content": "<ol start=\"4\">\n<li>\n<p><code>h</code> is not a goal. It is a local hypothesis in the goal. Changing this to \"local hypothesis\", the answer is that <code>h</code> exists in the goal that <code>obtain</code> operates on. After that <code>obtain</code>, the goal no longer exists. The goal does not exist anymore even after the sub-goals are complete.</p>\n</li>\n<li>\n<p><code>ha</code> and <code>hb</code> exist in the local contexts of the subgoals, so they are \"in scope\" for the tactics that operate on them. Once these goals are done, <code>ha</code> and <code>hb</code> cannot be referred to anymore, they no longer exist.</p>\n</li>\n</ol>",
        "id": 467331480,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725387458
    },
    {
        "content": "<p>I'm trying to be careful here with the word \"scope\", because it's not very well defined here. We <em>could</em> equate \"scope\" with \"local context of the goal the tactic is operating on\", and that's basically how it seems to work, but using the word \"scope\" may lead you to think that tactic scripts use something like lexical scope, which there are no guarantees here.  Individual goals have \"scopes\" is the best I can say, it's a dynamic not lexical concept.</p>",
        "id": 467332007,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725387640
    },
    {
        "content": "<blockquote>\n<p>In the manner we use brackets or indents in some languages to denote function/loop/other scope?</p>\n</blockquote>\n<p>Yes, we use focusing dots. They are not enforced by the language, but in projects like mathlib, we require structure that eludicates the scopes.</p>\n<p>Some tactics, like <code>induction</code> and <code>cases</code>, have special syntax to create structured proofs, which is more directly in the direction you are wanting.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">calc</span>\n<span class=\"w\">      </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 467332411,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725387781
    },
    {
        "content": "<p>By the way, if you are familiar with a stack-based language like Forth, you can think of tactic scripts as being similar to Forth programs. The goal list is a stack.</p>",
        "id": 467333107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725388002
    },
    {
        "content": "<p>Just like Forth, there's no scope other than the global scope. Unlike Forth, each \"value\" (each goal) comes with a local context to keep track of the local variables that can be used in that context.</p>",
        "id": 467333412,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725388112
    },
    {
        "content": "<p>Your explanation as a \"stack\" of contexts, comparing to Forth, and the internal mechanism of working through linear list of goals <code>[g1, g2, .. gn]</code> is <strong>extremely</strong> helpful.</p>\n<p>The most illuminating and helpful reply in a long time - thank you :)</p>",
        "id": 467338351,
        "sender_full_name": "rzeta0",
        "timestamp": 1725389657
    },
    {
        "content": "<p>( which still makes me worry that in the real world, proofs are more like trees, and a linear list then leads to ambiguous syntax ... but that's a discussion for another day )</p>",
        "id": 467338501,
        "sender_full_name": "rzeta0",
        "timestamp": 1725389708
    },
    {
        "content": "<p>There's always a question about what \"is\" a proof. For a low-level point of view, a tactic script is just a metaprogram that constructs the actual proof. You can see the tree-like proof term when you use <code>by? ...</code> (short for <code>show_term by ...</code>).</p>\n<p>Lean tactic proofs are meant to be followable with editor aid, not readable on their own, but when they're written in particular ways it can be easier to read without aid (hence demanding focus dots for example). There's no harm in ambiguity to a human reader since everything is machine checked. At least when it comes to truth. When it comes to maintainability, we like things to be more readable, but not so verbose that it gets in the way of making fixes.</p>",
        "id": 467339374,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725389954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/are.20.60obtain.60.20hypotheses.20temporary.3F/near/467339374\">said</a>:</p>\n<blockquote>\n<p>Lean tactic proofs are meant to be followable with editor aid, not readable on their own</p>\n</blockquote>\n<p>This again is very reassuring for beginners like me - thank you.</p>\n<p>PS - some may find it interesting that LaTeX was never intended to be written by humans, but rather generated by tools ... I think the parallels are interesting.</p>",
        "id": 467379550,
        "sender_full_name": "rzeta0",
        "timestamp": 1725408283
    }
]