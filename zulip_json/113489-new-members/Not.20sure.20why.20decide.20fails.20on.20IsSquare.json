[
    {
        "content": "<p>I am not sure why the first example below throws an error since the documentation shows that <code>Nat.instDecidablePredIsSquare</code> exists:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- Why doesn't the following work?</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- throws error</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- this works</span>\n</code></pre></div>\n<p>Here is the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">decide'</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">proposition</span>\n<span class=\"w\">  </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"n\">since</span><span class=\"w\"> </span><span class=\"n\">its</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Decidable'</span><span class=\"w\"> </span><span class=\"kn\">instance</span>\n<span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">instDecidablePredIsSquare</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"n\">did</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">isTrue'</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">isFalse'</span><span class=\"bp\">.</span>\n\n<span class=\"n\">After</span><span class=\"w\"> </span><span class=\"n\">unfolding</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">decidable_of_decidable_of_iff'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">decidable_of_iff''</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">instDecidableEqBool'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">instDecidableEqNat'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">decEq'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">decEq'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">decLe'</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">instDecidablePredIsSquare'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">reduction</span><span class=\"w\"> </span><span class=\"n\">got</span><span class=\"w\"> </span><span class=\"n\">stuck</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">Decidable'</span><span class=\"w\"> </span><span class=\"kn\">instance</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">beq</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">⋯</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"bp\">⋯</span>\n</code></pre></div>",
        "id": 504145364,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741368162
    },
    {
        "content": "<p>Using <code>with_unfolding_all decide</code> works.</p>",
        "id": 504146585,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741368565
    },
    {
        "content": "<p>Could you explain why that is necessary here?</p>",
        "id": 504146665,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741368591
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sqrt.iter#doc\">docs#Nat.sqrt.iter</a> is irreducible</p>",
        "id": 504147607,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741368916
    },
    {
        "content": "<p>So, you could also do a more \"aimed\" unfolding and use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 504147785,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741368969
    },
    {
        "content": "<p>Interesting. Is there a good reason why it is irreducible?</p>",
        "id": 504147794,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741368973
    },
    {
        "content": "<p>Functions defined using well-founded recursion are automatically marked irreducible.</p>",
        "id": 504148640,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741369257
    },
    {
        "content": "<p>I see. I find it quite counterintuitive that <code>decide</code> doesn't automatically work on a decidable proposition.</p>",
        "id": 504148861,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741369323
    },
    {
        "content": "<p>see <a href=\"https://github.com/leanprover/lean4/pull/4061\">lean4#4061</a></p>",
        "id": 504148877,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741369329
    },
    {
        "content": "<p>You can also do <code>decide +kernel</code> to skip elaboration and go straight to the kernel, which ignores definition transparency.</p>",
        "id": 504149061,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741369401
    },
    {
        "content": "<p>Does that mean <code>decide +kernel</code> and <code>with_unfolding_all decide</code> are practically the same?</p>",
        "id": 504149247,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741369462
    },
    {
        "content": "<p>Hmm. <code>decide +kernel</code> doesn't work. Do I need to upgrade to the latest Lean? I'm on 4.13.</p>",
        "id": 504149690,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741369618
    },
    {
        "content": "<p>Looks like the last question is answered by <a href=\"https://lean-lang.org/blog/2024-12-9-lean-4140/\">https://lean-lang.org/blog/2024-12-9-lean-4140/</a></p>",
        "id": 504149962,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741369702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/channel/113489-new-members/topic/Not.20sure.20why.20decide.20fails.20on.20IsSquare/near/504149247\">said</a>:</p>\n<blockquote>\n<p>Does that mean <code>decide +kernel</code> and <code>with_unfolding_all decide</code> are practically the same?</p>\n</blockquote>\n<p>These are not the same.<br>\n<code>decide +kernel</code> instructs <code>decide</code> to skip checking if the <code>Decidable</code> instance reduces to <code>isTrue</code>, and just let the kernel check.<br>\n<code>with_unfolding_all decide</code> instructs <code>decide</code> to try harder to unfold the <code>Decidable</code> instance into <code>isTrue</code>, and then the kernel will check it again.</p>\n<p>Both stop <code>decide</code> from getting stuck in reduction.</p>",
        "id": 504153467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741370799
    },
    {
        "content": "<p>Does that mean plain <code>decide</code> is just elaboration?</p>",
        "id": 504153726,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741370893
    },
    {
        "content": "<p>Plain <code>decide</code> will first check if the <code>Decidable</code> instance reduces to <code>isTrue</code> (this is during elaboration). If it succeeds, then it will insert a proof term, and then during kernel typechecking, the kernel will also reduce the <code>Decidable</code> instance to <code>isTrue</code>.</p>",
        "id": 504154323,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741371104
    },
    {
        "content": "<p>The code for <code>decide</code> is at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Elab.Tactic.evalDecideCore#doc\">docs#Lean.Elab.Tactic.evalDecideCore</a>.</p>",
        "id": 504154352,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741371115
    },
    {
        "content": "<p>I see. Thank you.</p>",
        "id": 504154491,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741371150
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Not.20sure.20why.20decide.20fails.20on.20IsSquare/near/504148640\">said</a>:</p>\n<blockquote>\n<p>Functions defined using well-founded recursion are automatically marked irreducible.</p>\n</blockquote>\n<p>I think we could override it for <code>Nat.sqrt</code>?</p>",
        "id": 504159462,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741372651
    },
    {
        "content": "<p>Is that a good idea?</p>",
        "id": 504159762,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741372743
    },
    {
        "content": "<blockquote>\n<p>If these definitions are used to define instances of this class <em>and</em> this class is an argument to some other type-class so that type-class inference will have to unfold these instances to check for definitional equality, then these definitions should be marked <code>@[reducible]</code>.</p>\n</blockquote>\n<p>is already in a library note. This seems very much in that vein. </p>\n<p>If someone wants to make a PR to batteries to test the impact on mathlib, please ping me</p>",
        "id": 504160491,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1741372979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Not.20sure.20why.20decide.20fails.20on.20IsSquare/near/504159462\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Not.20sure.20why.20decide.20fails.20on.20IsSquare/near/504148640\">said</a>:</p>\n<blockquote>\n<p>Functions defined using well-founded recursion are automatically marked irreducible.</p>\n</blockquote>\n<p>I think we could override it for <code>Nat.sqrt</code>?</p>\n</blockquote>\n<p>I don’t think it's a good idea to let the kernel try to reduce the proofs in well-founded definitions. This blows  up easily and is hard to debug – just today someone on our team spent far too much time trying to understand a kernel reduction timeout that would have been much easier to diagnose if wf definitions were not reducible. It may work for small numbers as in the example above, but isn’t robust.</p>",
        "id": 504166864,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741375002
    },
    {
        "content": "<p>In fact we might actually make wf definitions never ever reducible for that reason (<a href=\"https://github.com/leanprover/lean4/pull/5182\">https://github.com/leanprover/lean4/pull/5182</a>).</p>",
        "id": 504166897,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741375011
    },
    {
        "content": "<p>Most definitions by wf recursion that people want to reduce in the kernel, like <code>sqrt.iter</code>, can be rewritten to use structural recursion using <code>fuel</code>, for example like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Auxiliary for `sqrt`. If `guess` is greater than the integer square root of `n`,</span>\n<span class=\"sd\">  returns the integer square root of `n`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">next</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">guess</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">guess</span>\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">guess</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sqrt</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">split</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt'_eq_sqrt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">sqrt'</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span>\n\n\n<span class=\"c1\">-- Or even</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">fuel</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">guess</span>\n\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">guess</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sqrt</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"bp\">.</span><span class=\"n\">iter</span><span class=\"bp\">.</span><span class=\"n\">eq_def</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">split</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">contradiction</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span>\n<span class=\"w\">      </span><span class=\"n\">omega</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">sqrt''_eq_sqrt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span>\n<span class=\"w\">  </span><span class=\"n\">congr</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">sqrt''</span><span class=\"bp\">.</span><span class=\"n\">iter_eq_iter</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>So if you care about kernel reduction, I suggest to use something like this .</p>",
        "id": 504166902,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741375012
    },
    {
        "content": "<p>Is the fuel elided in the runtime version?</p>",
        "id": 504167046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741375070
    },
    {
        "content": "<p>Or do we need both the wf and fuel versions with a <code>csimp</code> lemma?</p>",
        "id": 504167134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741375085
    },
    {
        "content": "<p>In this case, the latter, I fear. (I never got it to work with some form of <code>Prop</code>-valued fuel or something like that, even though the zero-match is not reachable)</p>",
        "id": 504168437,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741375542
    },
    {
        "content": "<p>There are also variants where you “boost” the accessibility proof to have many <code>Acc.intro</code> constructors, so that reduction works nice for a while. But that leads to large proof terms in the kernel, I believe.</p>",
        "id": 504168805,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741375673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/channel/113489-new-members/topic/Not.20sure.20why.20decide.20fails.20on.20IsSquare/near/504149247\">said</a>:</p>\n<blockquote>\n<p>Does that mean <code>decide +kernel</code> and <code>with_unfolding_all decide</code> are practically the same?</p>\n</blockquote>\n<p>From a user's point of view, you could think of these as being more-or-less the same. Aaron mentioned that <code>+kernel</code> skips using elaborator reduction, letting the kernel handle everything instead. The kernel doesn't know about irreducibility, so it's as if everything is unfoldable.</p>\n<p>However: the kernel type checker and the elaborator type checker are different, and there are small differences here and there. The elaborator is designed to be at least as strict as the kernel, so some other things might be accepted by <code>decide +kernel</code>. One example that comes to mind is smart unfolding, which is an elaborator feature and not a kernel feature, and which sometimes causes people's <code>rfl</code>s to fail. I'm not sure it affects \"ground terms\", which is what <code>decide</code> requires (goals without free variables or metavariables).</p>\n<p>If you know <code>decide</code> will succeed, then <code>decide +kernel</code> is also more efficient (it saves almost 50% of the evaluation time). We don't use <code>+kernel</code> mode by default because <code>decide</code> is supposed to fail fast. Tactics might tentatively try <code>decide</code> to close goals, and in that application reducibility should be respected.</p>",
        "id": 504170094,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741376078
    },
    {
        "content": "<p>I hope that there is a good solution. It's just weird that <code>decide Prime</code> works right out of the box but <code>decide IsSquare</code>requires jumping through hoops. Students could be confused (as I was).</p>",
        "id": 504171196,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1741376495
    },
    {
        "content": "<p>Maybe the fundamental issue is that we have a way to indicate how to efficiently calculate a proposition (the <code>Decidable</code> instance), allowing us to decouple algorithms from definitions, but we don't have something like that for definitions. (And maybe we should have separate ones for kernel reduction and compiled evaluations, although there <code>csimp</code> maybe enough)</p>",
        "id": 504172606,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1741376992
    },
    {
        "content": "<p>I think you end up here writing a <code>norm_num</code> extension</p>",
        "id": 504185437,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1741382049
    }
]