[
    {
        "content": "<p>I want to check I understand (well enough) the Curry-Howard Correspondence and how it enables systems like Lean+Mathlib to check proofs.</p>\n<p>I drew the following diagram to help me think about it - it is based on blogs I have read and some YouTube  videos I watched on the subject.</p>\n<p><a href=\"/user_uploads/3121/-MJKa0e37ithZlBBG7PbGc0y/Screenshot-2025-01-23-at-01.03.47.png\">Screenshot 2025-01-23 at 01.03.47.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/-MJKa0e37ithZlBBG7PbGc0y/Screenshot-2025-01-23-at-01.03.47.png\" title=\"Screenshot 2025-01-23 at 01.03.47.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1548x1085\" src=\"/user_uploads/thumbnail/3121/-MJKa0e37ithZlBBG7PbGc0y/Screenshot-2025-01-23-at-01.03.47.png/840x560.webp\"></a></div><p>I think the following is correct but tell me if I'm wrong:</p>\n<ul>\n<li>The Curry-Howard Correspondence says there is a correspondence between logical propositions and function types, and between proofs of those logical propositions and the function themselves. </li>\n<li>Example, logical conjunction corresponds to a product type</li>\n<li>Example, logical implication corresponds to function application</li>\n<li>A program that is of a given type, is a proof of the logical proposition corresponding to that function type.</li>\n<li>In addition, the mechanical process of simplifying proofs corresponds to the process of evaluating program functions</li>\n<li>For example, (A → B) ∧ A can be simplified to B, and in the code a function of type A→B can be evaluated if we have an \"inhabited\" A, to give us a B.</li>\n<li>All of the above is only true for programming languages that are (1) well-typed, and (2) purely functional - otherwise the can't depend on the functions/programs to behave in the way we expect logical propositions and operations do.</li>\n</ul>",
        "id": 495403391,
        "sender_full_name": "rzeta0",
        "timestamp": 1737594908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20Curry-Howard.20Correspondence/near/495403391\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The Curry-Howard Correspondence says there is a correspondence between logical propositions and function types, and between proofs of those logical propositions and the function themselves. </li>\n</ul>\n</blockquote>\n<p>Sort of? If you restrict the meaning of \"logical proposition\" or you extend the meaning of \"function type\".</p>\n<p>The Curry-Howard correspondence came about because someone thought that some rules for typing and some rules for logical deduction were similar.</p>\n<p>If you only look at function types and you only look at the logical formulas constructed by \"implication\", then there is a direct correspondence between \"logical statements\" and \"function types\" - just replace the implication symbol with the function arrow everywhere! Since both structures are syntactically a binary tree, it doesn't matter what you label the operation as.</p>\n<p>What is more interesting is that there is also the correspondence between (intuitionistic) proofs of an implicational formula and inhabitants of a function type. Here's an example:</p>\n<p>Theorem. For all propositions <code>P</code> and <code>Q</code>,<br>\n<code>(P implies (P implies Q)) implies (P implies Q)</code>.<br>\nProof.</p>\n<blockquote>\n<p>Suppose <code>P implies (P implies Q)</code>. Then</p>\n<blockquote>\n<p>Suppose <code>P</code>. Then</p>\n<blockquote>\n<p>Since both <code>P</code> and <code>P implies (P implies Q)</code>, then <code>P implies Q</code>.<br>\nSince both <code>P</code> and <code>P implies Q</code>, then <code>Q</code>.</p>\n</blockquote>\n<p>Since by assuming <code>P</code> we arrived at <code>Q</code>, then <code>P implies Q</code>.</p>\n</blockquote>\n<p>Since by assuming <code>P implies (P implies Q)</code> we arrived at <code>P implies Q</code>, then<br>\n<code>(P implies (P implies Q)) implies (P implies Q)</code>.</p>\n</blockquote>\n<p>Claim. Forall types <code>P</code> and <code>Q</code>, the function type <code>(P → P → Q) → P → Q</code> is always inhabited.<br>\nProof. We have the inhabitant</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>fun (two_p_get_q : P → P → Q) =&gt;\n  let p_get_q : P → Q := fun (p_object : P) =&gt;\n    let p_get_q : P → Q := two_p_get_q p_object\n    let q_object : Q := p_get_q p_object\n    q_object\n  p_get_q\n</code></pre></div>\n<p>Do you see the similarities between these two? The <code>Suppose</code> in the proof has turned into <code>fun</code> in the type theory interpretation. Similarly, the modus ponens rule of inference has turned into function application.<br>\nIt turns out we can extend this correspondence beyond just reasoning with implication being like function types. Logical conjunction (<code>∧</code> statements) can be modeled as product types, disjunction (<code>∨</code> statements) can be modeled as sum types, falsehood can be modeled as an Empty type, etc.</p>",
        "id": 495407567,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737597273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20Curry-Howard.20Correspondence/near/495403391\">said</a>:</p>\n<blockquote>\n<p>I want to check I understand (well enough) the Curry-Howard Correspondence and how it enables systems like Lean+Mathlib to check proofs.</p>\n<p>I drew the following diagram to help me think about it - it is based on blogs I have read and some YouTube  videos I watched on the subject.</p>\n<p><a href=\"/user_uploads/3121/-MJKa0e37ithZlBBG7PbGc0y/Screenshot-2025-01-23-at-01.03.47.png\">Screenshot 2025-01-23 at 01.03.47.png</a></p>\n<p>I think the following is correct but tell me if I'm wrong:</p>\n<ul>\n<li>The Curry-Howard Correspondence says there is a correspondence between logical propositions and function types, and between proofs of those logical propositions and the function themselves. </li>\n<li>Example, logical conjunction corresponds to a product type</li>\n<li>Example, logical implication corresponds to function application</li>\n<li>A program that is of a given type, is a proof of the logical proposition corresponding to that function type.</li>\n<li>In addition, the mechanical process of simplifying proofs corresponds to the process of evaluating program functions</li>\n<li>For example, (A → B) ∧ A can be simplified to B, and in the code a function of type A→B can be evaluated if we have an \"inhabited\" A, to give us a B.</li>\n<li>All of the above is only true for programming languages that are (1) well-typed, and (2) purely functional - otherwise the can't depend on the functions/programs to behave in the way we expect logical propositions and operations do.</li>\n</ul>\n</blockquote>\n<p>For clarity sake, whilst that is generally of CHC -- in lean #eval is not always that, pretty sure it corresponds more to #reduce(in the diagram).</p>",
        "id": 495412404,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737600205
    },
    {
        "content": "<p>Thanks both, and Aaron I will print out your <code>two_p_get_q</code> example to read more deeply on the train today.</p>",
        "id": 495477141,
        "sender_full_name": "rzeta0",
        "timestamp": 1737630324
    }
]