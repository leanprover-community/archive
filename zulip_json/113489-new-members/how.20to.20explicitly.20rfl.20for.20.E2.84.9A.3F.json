[
    {
        "content": "<p>Let's say you want to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>without any tactics. Now, the tactic <code>by rfl</code> works and expands using <code>by?</code> to <code>Eq.refl (1 / 3 + 2 / 3)</code> but unfortunately this does not type check in Lean.<br>\nOf course, <code>1/3 + 2/3</code> as output by the pretty printer is not the right expression, because those literals being interpreted in the world of naturals, so I tried <code>Eq.refl ((1 / 3 : ℚ) + 2 / 3)</code> instead. Still nope.</p>\n<p><code>by linarith</code> and <code>by norm_num</code> expand to horrible messes which, unfortunately, suffer from the same <code>Eq.refl</code> issues as above.</p>",
        "id": 406961128,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702146180
    },
    {
        "content": "<p>Interestingly, <code>by decide</code> does not work here. Must be a recent breakage, or am I dreaming?</p>",
        "id": 406961289,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702146328
    },
    {
        "content": "<p>I assume your question is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Rat.Basic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">show_term</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.refl</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"c1\">-- fails: why?</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails: why?</span>\n</code></pre></div>",
        "id": 406961531,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702146516
    },
    {
        "content": "<p>That is, why <code>by rfl</code> succeeds but seems to generate a term that fails on its own</p>",
        "id": 406961547,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702146531
    },
    {
        "content": "<p>Well, kind of. As in, I'm familiar with the terms generated by <code>show_term</code> often failing, and that might be a whole (already known) question on its own, but my specific question here is how to actually prove the equality with a term.</p>",
        "id": 406961601,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702146589
    },
    {
        "content": "<p><code>example : (1 / 3 : ℚ) + 2 / 3 = 1 := by with_unfolding_all exact rfl</code> works</p>",
        "id": 406961747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702146695
    },
    {
        "content": "<p>Apparently that just <code>show_term</code>s to <code>rfl</code> which does not work, sadly.</p>",
        "id": 406961815,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702146743
    },
    {
        "content": "<p>Right, the point is that the term is valid from the kernel's point of view, but the elaborator has to be tricked via <code>with_unfolding_all</code></p>",
        "id": 406961843,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702146776
    },
    {
        "content": "<p>Oh, I see. So <code>rfl</code> technically is valid but doesn't compile because something was marked as <code>irreducible</code>? So I guess there is no reasonable (without going into tactic mode) term that can prove that 1/3 + 2/3 = 1?</p>",
        "id": 406961972,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702146880
    },
    {
        "content": "<p>It seems like you have to go into tactic mode, turn off irreducibility checking, then go back into term mode; the <code>rfl</code> in my proof is the term-mode rfl</p>",
        "id": 406962497,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702147455
    },
    {
        "content": "<p>Though something very strange does seem to be happening here; I can't work out where Lean is recording the decision to ignore reducibility</p>",
        "id": 406962573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702147554
    },
    {
        "content": "<p>I couldn't get this to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">elab</span> <span class=\"s2\">\"with_unfolding_all% \"</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">term</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">expectedType</span> <span class=\"bp\">=&gt;</span>\n  <span class=\"n\">withTransparency</span> <span class=\"n\">TransparencyMode.all</span> <span class=\"bp\">&lt;|</span> <span class=\"o\">(</span><span class=\"n\">Lean.Elab.Term.elabTerm</span> <span class=\"n\">y</span> <span class=\"n\">expectedType</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">with_unfolding_all</span><span class=\"bp\">%</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 406962623,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702147574
    },
    {
        "content": "<p>If your goal has no free variables, the <code>eq_refl</code> tactic uses the kernel checker rather than the elaborator's:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">eq_refl</span>\n</code></pre></div>",
        "id": 406970355,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702155376
    },
    {
        "content": "<p>That's basically what <code>rfl</code> calls, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">macro</span> <span class=\"s2\">\"rfl\"</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span> <span class=\"n\">eq_refl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 406970403,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702155454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I'm guessing with your example that the <code>example</code> command is itself ensuring that the term has the right type. You can insert a type hint:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">with_unfolding_all</span><span class=\"bp\">%</span> <span class=\"n\">id</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>(You can also get your elaborator to insert a type hint, via an <code>id</code>, with <code>mkExpectedTypeHint</code>)</p>",
        "id": 406970478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702155517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"582393\">@Yongyi Chen</span> I forgot that <code>rfl</code> was different from <code>exact rfl</code>. I think I learned about <code>eq_refl</code> from a thread where I learned and immediately forgot that.</p>",
        "id": 406970512,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702155589
    },
    {
        "content": "<p>So after thinking about this, I think that Rat.add and siblings should not be marked as irreducible, so that <code>simp</code> and <code>decide</code> and <code>rfl</code> can work properly. (Currently <code>simp</code> won't even simplify rational expressions.)</p>",
        "id": 406980994,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702162459
    },
    {
        "content": "<p>Note that <code>norm_num</code> works fine here, though that isn't necessarily an argument for keeping the irreducibility</p>",
        "id": 406981224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702162720
    },
    {
        "content": "<p>(simp can't reasonably be expected to work here, it's not possible to write a lemma that matches arbitrary pairs of digits)</p>",
        "id": 406981254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702162775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/406981254\">said</a>:</p>\n<blockquote>\n<p>(simp can't reasonably be expected to work here, it's not possible to write a lemma that matches arbitrary pairs of digits)</p>\n</blockquote>\n<p>I guess so, since <code>simp</code> doesn't simplify <code>(1 : ℤ) + (2 : ℤ)</code> either.</p>",
        "id": 406981603,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702162953
    },
    {
        "content": "<p>decide should work regardless of irreducibility I thought</p>",
        "id": 406981871,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1702163163
    },
    {
        "content": "<p>Doesn't! But if I make a local copy of the <code>Rat</code> file and remove the <code>irreducible</code> modifiers on <code>mul</code> and <code>inv</code>, then it does.</p>",
        "id": 406981943,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702163242
    },
    {
        "content": "<p>By the way, I solved the original task!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ddd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Rat.div_def</span> <span class=\"mi\">1</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">Rat.div_def</span> <span class=\"mi\">2</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">Rat.inv_def</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">Rat.mul_def</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">Rat.mul_def</span> <span class=\"mi\">2</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">Rat.add_def'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 406982627,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702163964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/406981871\">said</a>:</p>\n<blockquote>\n<p>decide should work regardless of irreducibility I thought</p>\n</blockquote>\n<p><code>decide</code> relies on the decidability instance being sufficiently reducible in some way</p>",
        "id": 406982846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702164197
    },
    {
        "content": "<p>I don't see the logic in changing reducibility settings just so rfl can do a job which <code>norm_num</code>  was designed to do...</p>",
        "id": 407056198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1702208116
    },
    {
        "content": "<p>But nor do I think that \"<code>norm_num</code> doesn't care\" is a good answer to \"why are Rat operations irreducible?\"</p>",
        "id": 407065478,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1702212426
    },
    {
        "content": "<p>I see <code>linarith</code> and <code>norm_num</code> as sledgehammers for the purpose of deciding equality of easily decidable things like integers and rationals, mainly because they produce very long (and slow) code under the hood.</p>",
        "id": 407085270,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702226695
    },
    {
        "content": "<p><code>norm_num</code> is the minimal supported approach to proving things about concrete numbers</p>",
        "id": 407088877,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702229310
    },
    {
        "content": "<p>If there's ways in which it's suboptimal, it's better to improve it rather than trying to work around it</p>",
        "id": 407089083,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1702229402
    },
    {
        "content": "<p>I don't think this is an argument for why <code>decide</code> should <em>fail</em> to decide that two rational numbers are equal.</p>",
        "id": 407091177,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702230367
    },
    {
        "content": "<p><code>norm_num</code> isn't a sledgehammer tactic though -- it just evaluates numeric expressions, and its aim is to generate efficient proofs of the correctness of the evaluation.</p>",
        "id": 407092022,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702230770
    },
    {
        "content": "<p>There are cases where <code>norm_num</code> is faster than <code>rfl</code> because it knows a better way to compute a function than by appealing to its definition.</p>",
        "id": 407092107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702230838
    },
    {
        "content": "<p>(I know that it used to be that because GCD is defined using well-founded recursion that you couldn't really prove anything about it by <code>rfl</code>, but it seems that examples like <code>example : Nat.gcd 15 25 = 5 := rfl</code> work now. I'm not sure what the status is for whether that being provable by <code>rfl</code> is meant to be supported.)</p>",
        "id": 407092516,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702231114
    },
    {
        "content": "<p>I agree that using <code>linarith</code> to prove equalities about concrete rationals is overkill.</p>",
        "id": 407092747,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702231300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/406981871\">said</a>:</p>\n<blockquote>\n<p>decide should work regardless of irreducibility I thought</p>\n</blockquote>\n<p>The <code>DecidableEq</code> instance for <code>Rat</code> is basically that to prove <code>p = q</code> then see if <code>(rfl : p.num = q.num)</code> and <code>(rfl : q.den = q.den)</code> typecheck. That means whatever is going on in <code>p</code> and <code>q</code> have to be reducible enough.</p>",
        "id": 407093113,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702231516
    },
    {
        "content": "<p>I'm pretty sure that for equalities of naturals, integers, and rationals that <code>decide</code> has no special powers that <code>rfl</code> doesn't already have...</p>",
        "id": 407093233,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702231621
    },
    {
        "content": "<p>So <code>Rat</code> derives from <code>DecidableEq</code>but yet...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  failed to reduce to 'true'</span>\n<span class=\"cm\">    Decidable.rec (fun h =&gt; (fun x =&gt; false) h) (fun h =&gt; (fun x =&gt; true) h) (instDecidableEqRat (4 / 2) 2)</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 407093598,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702231903
    },
    {
        "content": "<p>This contradicts what the docs say on <code>Decidable</code>:</p>\n<blockquote>\n<p>If a proposition p is Decidable, then (by decide : p) will prove it by evaluating the decidability instance to isTrue h and returning h.</p>\n</blockquote>",
        "id": 407093781,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702232048
    },
    {
        "content": "<p>Right, like I said it depends on checking that <code>rfl</code> can prove that the numerators and denominators are equal.</p>",
        "id": 407094016,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702232257
    },
    {
        "content": "<p>This fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">num</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>so <code>decide</code> fails.</p>",
        "id": 407094093,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702232304
    },
    {
        "content": "<p>There's generally no point in using <code>decide</code> to prove equalities of naturals, integers, and rationals since it's a more roundabout <code>rfl</code>. I'm pretty sure there are no exceptions here.</p>",
        "id": 407094166,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702232375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"582393\">Yongyi Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407093781\">said</a>:</p>\n<blockquote>\n<p>This contradicts what the docs say on <code>Decidable</code>: [...]</p>\n</blockquote>\n<p>There's no contradiction. It failed to evaluate the decidable instance to <code>isTrue</code>. The word \"evaluate\" might not be good here though, since \"reduce\" is would be more precise.</p>",
        "id": 407094261,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702232437
    },
    {
        "content": "<p>When I hear \"evaluate\" I think about <code>#eval</code>. Decidable instances can always be evaluated that way, but they don't generate proofs in that case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#eval</span> <span class=\"n\">decide</span> <span class=\"o\">((</span><span class=\"mi\">4</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c1\">-- true</span>\n</code></pre></div>",
        "id": 407094435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702232615
    },
    {
        "content": "<p>So to summarize, for equalities of rational numbers involving literals,<br>\n<code>by rfl</code>, <code>by norm_num</code> work, while<br>\n<code>rfl</code> ( = <code>by exact rfl</code>), <code>by decide</code>, and <code>by aesop</code> don't work,<br>\nand everyone but me agrees this is how it should be?</p>",
        "id": 407095074,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702233171
    },
    {
        "content": "<p>I'd say <code>by rfl</code> accidentally works, since it's circumventing transparency settings by using the kernel defeq checker.</p>",
        "id": 407096637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702234836
    },
    {
        "content": "<p>And this is how it should be in the sense that the designers of Rat made the actual definitions of the arithmetic operations be behind the API.</p>",
        "id": 407096734,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702234901
    },
    {
        "content": "<p>Not sure why you would expect <code>aesop</code> to work here</p>",
        "id": 407096825,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702234936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407094261\">said</a>:</p>\n<blockquote>\n<p>There's no contradiction. It failed to evaluate the decidable instance to <code>isTrue</code>. The word \"evaluate\" might not be good here though, since \"reduce\" is would be more precise.</p>\n</blockquote>\n<p>OK, I think I thought too naively what Decidable means. So for example there is a term of type <code>Decidable (BB(9001) = 0)</code> as well (I think?)</p>",
        "id": 407096865,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702234964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407096825\">said</a>:</p>\n<blockquote>\n<p>Not sure why you would expect <code>aesop</code> to work here</p>\n</blockquote>\n<p>To me it seems more surprising a tool like <code>aesop</code>couldn't do this.</p>",
        "id": 407097026,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235045
    },
    {
        "content": "<p>aesop does logic puzzles. Computing is not a logic puzzle</p>",
        "id": 407097056,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702235080
    },
    {
        "content": "<p>If reducing <code>Nat.gcd</code> in the kernel is now reliable (which by my recollection it wasn't before) maybe the arithmetic operations' definitions could be made semireducible rather than irreducible. However, I do not know if <code>rfl</code> proofs for rationals are actually efficient. I wouldn't be surprised if the <code>norm_num</code> ones typecheck faster.</p>",
        "id": 407097089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Doesn't <code>aesop</code> use <code>simp</code>? Couldn't it use <code>norm_num</code>?</p>",
        "id": 407097115,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235161
    },
    {
        "content": "<p>(I actually don't know if <code>aesop</code> uses <code>simp</code> or not)</p>",
        "id": 407097165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235186
    },
    {
        "content": "<p>About <code>norm_num</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thirds_inefficient</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>\n<p>expands to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thirds_inefficient</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">of_eq_true</span>\n  <span class=\"o\">(</span><span class=\"n\">eq_true</span>\n    <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_eq_true</span>\n      <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsInt.to_isNat</span>\n        <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsRat.to_isInt</span>\n          <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_add</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_div</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_mul</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.to_isRat</span>\n                  <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_inv_pos</span>\n                  <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.to_isRat</span>\n                    <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">))))</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.mul</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">)))</span>\n            <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_div</span>\n              <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_mul</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.to_isRat</span>\n                  <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">2</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isRat_inv_pos</span>\n                  <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.IsNat.to_isRat</span>\n                    <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">))))</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.mul</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">)))</span>\n            <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">9</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">9</span><span class=\"o\">))))</span>\n      <span class=\"o\">(</span><span class=\"n\">Mathlib.Meta.NormNum.isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>with typecheck errors on two of the <code>(Eq.refl 3)</code> terms complaining of an application type mismatch.</p>",
        "id": 407097166,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235190
    },
    {
        "content": "<p><code>aesop</code> does use <code>simp</code> as a preprocessing step (every time a rule is applied!). I guess <code>norm_num</code> could be plugged in there too.</p>",
        "id": 407097207,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702235252
    },
    {
        "content": "<ol>\n<li>Pretty printing unfortunately fails to round-trip too often. That's the only thing you can infer from <code>Eq.refl 3</code> causing typechecking failures.</li>\n<li>The proof looks big, but that doesn't mean it's slow to typecheck. These <code>norm_num</code> proofs are set up so that defeq checks are trivial, except for places where it's doing <code>Nat</code> computations.</li>\n</ol>",
        "id": 407097285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235301
    },
    {
        "content": "<p>Yongyi, that doesn't mean much, really. It just means that \"pretty-printing doesn't round-trip\", namely you can't trust the printing of an expression to elaborate back to that expression.</p>",
        "id": 407097298,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702235330
    },
    {
        "content": "<p>It's also pretty big just because every lemma is prefixed with <code>Mathlib.Meta.NormNum</code>, so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 407097328,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1702235382
    },
    {
        "content": "<p>I think, as in the examples at the start of this conversation, there isn't an actual term similar to this that type-checks. Because I think the Eq.refl errors are the same seeing-through-irreducibility issues as earlier.</p>",
        "id": 407097337,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"582393\">Yongyi Chen</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407097337\">said</a>:</p>\n<blockquote>\n<p>I think the Eq.refl errors are the same seeing-through-irreducibility issues as earlier.</p>\n</blockquote>\n<p>This is false. These are Nat refls.</p>",
        "id": 407097403,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235437
    },
    {
        "content": "<p>Oh, OK. So for the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">argument</span>\n  <span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Nat.mul</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.mul</span> <span class=\"mi\">1</span> <span class=\"bp\">?</span><span class=\"n\">m.7106</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>what should go instead of <code>Eq.refl 3</code>?</p>",
        "id": 407097444,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235492
    },
    {
        "content": "<p>The problem is that the elaborator isn't able to elaborate the pretty printed term, and it could be because of any number of things, most likely missing implicit arguments.</p>",
        "id": 407097508,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235551
    },
    {
        "content": "<p>The pretty printing \"sledgehammer\" is setting <code>set_option pp.all true</code>. That one typechecks, I've verified it just now.</p>",
        "id": 407097546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235597
    },
    {
        "content": "<p>But to \"what should go instead of <code>Eq.refl 3</code>\", I'd say \"nothing, delete that whole proof term and use <code>norm_num</code>\"</p>",
        "id": 407097565,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407097546\">said</a>:</p>\n<blockquote>\n<p>The pretty printing \"sledgehammer\" is setting <code>set_option pp.all true</code>. That one typechecks, I've verified it just now.</p>\n</blockquote>\n<p>Oh! That's useful. Also verified it on my end.</p>",
        "id": 407097612,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/how.20to.20explicitly.20rfl.20for.20.E2.84.9A.3F/near/407097328\">said</a>:</p>\n<blockquote>\n<p>It's also pretty big just because every lemma is prefixed with <code>Mathlib.Meta.NormNum</code>, so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</blockquote>\n<p>With <code>open Mathlib.Meta.NormNum</code> I guess it's not so bad anymore</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thirds_inefficient</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">of_eq_true</span>\n  <span class=\"o\">(</span><span class=\"n\">eq_true</span>\n    <span class=\"o\">(</span><span class=\"n\">isNat_eq_true</span>\n      <span class=\"o\">(</span><span class=\"n\">IsInt.to_isNat</span>\n        <span class=\"o\">(</span><span class=\"n\">IsRat.to_isInt</span>\n          <span class=\"o\">(</span><span class=\"n\">isRat_add</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HAdd.hAdd</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">isRat_div</span>\n              <span class=\"o\">(</span><span class=\"n\">isRat_mul</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">IsNat.to_isRat</span> <span class=\"o\">(</span><span class=\"n\">isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">1</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">isRat_inv_pos</span> <span class=\"o\">(</span><span class=\"n\">IsNat.to_isRat</span> <span class=\"o\">(</span><span class=\"n\">isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">))))</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.mul</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">)))</span>\n            <span class=\"o\">(</span><span class=\"n\">isRat_div</span>\n              <span class=\"o\">(</span><span class=\"n\">isRat_mul</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"n\">HMul.hMul</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">IsNat.to_isRat</span> <span class=\"o\">(</span><span class=\"n\">isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">2</span><span class=\"o\">)))</span>\n                <span class=\"o\">(</span><span class=\"n\">isRat_inv_pos</span> <span class=\"o\">(</span><span class=\"n\">IsNat.to_isRat</span> <span class=\"o\">(</span><span class=\"n\">isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">))))</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.mul</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">3</span><span class=\"o\">)))</span>\n            <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">Int.ofNat</span> <span class=\"mi\">9</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">9</span><span class=\"o\">))))</span>\n      <span class=\"o\">(</span><span class=\"n\">isNat_ofNat</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"mi\">1</span><span class=\"o\">))))</span>\n</code></pre></div>\n<p>which I guess has similar structure to my hand-crafted</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">thirds</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">div_def</span> <span class=\"mi\">1</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">div_def</span> <span class=\"mi\">2</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">inv_def</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">mul_def</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">mul_def</span> <span class=\"mi\">2</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">add_def'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 407097696,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235755
    },
    {
        "content": "<p>And it might elaborate faster than yours, since <code>▸</code> is hiding some automation.</p>",
        "id": 407097774,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235824
    },
    {
        "content": "<p>So it does. 35 ms for mine and 20 ms for <code>norm_num</code>. Wow!</p>",
        "id": 407097794,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702235865
    },
    {
        "content": "<p>So make sure to profile things before assuming they're inefficient <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 407097857,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702235906
    },
    {
        "content": "<p>(That's still really slow for just adding two rational numbers of course, but adding rationals usually isn't in the hot path for theorem proving)</p>",
        "id": 407097986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236047
    },
    {
        "content": "<p>True, <code>by rfl</code> or <code>by eq_refl</code> is a 5 ms typecheck</p>",
        "id": 407098001,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702236068
    },
    {
        "content": "<p>For larger examples, the difference between <code>by rfl</code> and <code>by norm_num</code> goes down.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- 0.0138 s</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10001</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10002</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10003</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10004</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10005</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2781112528027793</span><span class=\"bp\">/</span><span class=\"mi\">5563893612361263340</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rfl</span>\n<span class=\"c1\">-- 0.0185 s</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10001</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10002</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10003</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10004</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">10005</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2781112528027793</span><span class=\"bp\">/</span><span class=\"mi\">5563893612361263340</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 407098303,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236396
    },
    {
        "content": "<p>How long does a <code>sorry</code> take there?</p>",
        "id": 407098447,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702236549
    },
    {
        "content": "<p>Too little time for <code>set_option trace.profiler true</code> to report it</p>",
        "id": 407098536,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236650
    },
    {
        "content": "<p>Oh very interesting! <code>sorry</code>there takes over 100 ms to elaborate on my Windows machine. Let me dual-boot and see if it's a Windows issue.</p>",
        "id": 407098570,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702236702
    },
    {
        "content": "<p>There's a lot of noise in these measurements, so my method is to set up the three <code>examples</code> and then insert some whitespace before the first <code>example</code> to get them to all re-elaborate</p>",
        "id": 407098639,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236767
    },
    {
        "content": "<p>When I first created the <code>sorry</code> example it was measureable on its own (at 300ms or so), but then after that it stopped being measurable.</p>",
        "id": 407098678,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236823
    },
    {
        "content": "<p>Maybe it's something with the process of typing out <code>sorry</code> putting a lot of pressure on the elaborator due to repeated re-elaboration on each keystroke?</p>",
        "id": 407098757,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702236897
    },
    {
        "content": "<p>Haha it was something stupid on my part. The section I was working in had variables for modules and other high-complexity objects. Going into a fresh file and using #time shows a timing of around 13ms for sorrys</p>",
        "id": 407098984,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702237133
    },
    {
        "content": "<p>Oh, yeah, <code>variable</code> bindings get re-elaborated for every declaration from scratch</p>",
        "id": 407099123,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1702237293
    },
    {
        "content": "<p>Results: 13 ms for <code>sorry</code>, 20 ms for <code>rfl</code>, and 29 ms for <code>norm_num</code></p>",
        "id": 407099133,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1702237319
    }
]