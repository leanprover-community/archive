[
    {
        "content": "<p>So I have observed that:</p>\n<ul>\n<li>The similarity between the induction <strong>process</strong> and the <strong>evaluation</strong> of a recursively defined function.</li>\n<li>The similarity between an induction <strong>proof</strong> and the <strong>definition</strong> of a recursively defined function.</li>\n</ul>\n<p>So clearly there are deeper connections between induction and recursion.</p>\n<p>I'm definitely not an expert so my naive view is that the inductive process (by which inductive proofs happen) are recursive by nature.</p>\n<p>Is that wording a correct summary of the connection?</p>\n<p>Or is my summarisation of the connection actually wrong, and just based on outward observations?</p>\n<p>(And separately, I think I read that inside Lean induction and recursion are not separate but implemented in a unified manner).</p>",
        "id": 497269697,
        "sender_full_name": "rzeta0",
        "timestamp": 1738512829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/checking.20my.20understanding.20of.20recursion.20and.20induction/near/497269697\">said</a>:</p>\n<blockquote>\n<p>Is that wording a correct summary of the connection?</p>\n</blockquote>\n<p>I'm not a mathematician but what you want to check out is <a href=\"https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence\">Curryâ€“Howard correspondence</a>.</p>",
        "id": 497270410,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1738513495
    },
    {
        "content": "<p>That's interesting .</p>\n<p>I had previously read a bit about C-H and understood it to mean there is a correspondence between simple logical operations (conjunction, implication, etc) and certain computable functions in a constrained language.</p>\n<p>I didn't think that correspondence extended to the mathematical process of induction.</p>\n<p>So we're saying that the mathematical process of induction corresponds - by C-H - to computable recursive functions?</p>",
        "id": 497271439,
        "sender_full_name": "rzeta0",
        "timestamp": 1738514411
    },
    {
        "content": "<p>Yes, induction and recursion are the same concept. In Lean, each recursor for inductive types gives both principles simultaneously.</p>",
        "id": 497271649,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738514615
    },
    {
        "content": "<p>Yes, that seems correct</p>",
        "id": 497271651,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738514619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/checking.20my.20understanding.20of.20recursion.20and.20induction/near/497271439\">said</a>:</p>\n<blockquote>\n<p>So we're saying that the mathematical process of induction corresponds - by C-H - to computable recursive functions?</p>\n</blockquote>\n<p>I see others answered before me so I'll ask this finer point. To be provable the function has to be total?</p>",
        "id": 497271714,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1738514665
    },
    {
        "content": "<p>When people sometimes ask \"is this proof done by recursion or by induction\" in Lean, the answer is \"both\" as there's no distinction to be drawn. However, you can write proofs explicitly recursively, or you can use the <code>induction</code> tactic, which hides the recursion. However, <code>induction</code> uses recursors more directly.</p>",
        "id": 497271955,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738514886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366057\">@Eric Taucher</span> What does total mean to you? The answer depends on that.</p>\n<p>Every Lean function is total.</p>\n<p>Maybe you mean \"a recursive function that Lean accepts\"? In that case it's about whether the def elabrator can eliminate the explicit recursion, either by recognizing structural recursion or well-founded recursion. This is a form a totality proving, but it's a bit more specific.</p>",
        "id": 497272152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738515065
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/checking.20my.20understanding.20of.20recursion.20and.20induction/near/497272152\">said</a>:</p>\n<blockquote>\n<p>What does total mean to you?</p>\n</blockquote>\n<p>As a programmer it means I don't pay attention to <a href=\"https://en.wikipedia.org/wiki/Partial_function\">injective</a> and such I just get the code to work. When programming with functions and working to get code that is bullet proof then with other programmers I would note <a href=\"https://en.wikipedia.org/wiki/Total_functional_programming\">Total functional programming</a>. However for me that is still not good enough and thus why Lean 4 is on my short list of two programming languages I prefer to use, Prolog and Lean.</p>",
        "id": 497273085,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1738515828
    },
    {
        "content": "<p>The problem is that recursive proofs fail to even compile unless the function is, in some sense, total. (In the sense of it being some sort of recursion scheme that the compiler (read: elaborator) recognizes.)</p>",
        "id": 497273853,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738516482
    },
    {
        "content": "<p>(Read the wikipedia article, yes Lean requires totality in that sense for every proof, and in general every non-<code>unsafe</code> declaration. I'm ignoring <code>partial</code> here since that's a way to use <code>unsafe</code> declarations in a convenient way.)</p>",
        "id": 497274097,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738516702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/checking.20my.20understanding.20of.20recursion.20and.20induction/near/497273853\">said</a>:</p>\n<blockquote>\n<p>The problem is that recursive proofs fail to even compile unless the function is, in some sense, total.</p>\n</blockquote>\n<p>Yes.</p>\n<p>As a programmer coming to Lean and other programming that carries proofs one has to be attentive to total functions. As a programmer years ago in general I did not know or even care about a function being total, so for me when working with Lean I have to always think total functions. Small point but one that bites hard if you don't know about it.</p>",
        "id": 497274143,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1738516762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366057\">Eric Taucher</span> <a href=\"#narrow/channel/113489-new-members/topic/checking.20my.20understanding.20of.20recursion.20and.20induction/near/497271714\">said</a>:</p>\n<blockquote>\n<p>I see others answered before me so I'll ask this finer point. To be provable the function has to be total?</p>\n</blockquote>\n<p>The finer point to the finer point is that this is not something that the user has to check themselves, since the way Lean is constructed it's <em>impossible</em> to create non-total functions, unless you specifically opt out of kernel typechecking with <code>unsafe</code>. But <code>unsafe</code> theorems/definitions are not admissible in non-<code>unsafe</code> proofs.</p>",
        "id": 497274404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738516954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> has marked this topic as resolved.</p>",
        "id": 497278563,
        "sender_full_name": "Notification Bot",
        "timestamp": 1738520353
    }
]