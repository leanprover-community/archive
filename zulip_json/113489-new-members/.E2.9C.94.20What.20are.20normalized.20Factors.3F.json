[
    {
        "content": "<p>Are they some mathematical concept I can't find on google easily or some detail about implementation? </p>\n<p>In particular I am trying to understand, what does UniqueFactorizationMonoid.normalizedFactors_one do? Link to the documentation is below. I couldn't dechyper what is going on with this theorem. </p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/UniqueFactorizationDomain.html#UniqueFactorizationMonoid.normalizedFactors_one\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/UniqueFactorizationDomain.html#UniqueFactorizationMonoid.normalizedFactors_one</a></p>",
        "id": 474306875,
        "sender_full_name": "Baran Zadeoglu",
        "timestamp": 1727878030
    },
    {
        "content": "<p>Here is a good motivating example: What are the prime factors of <code>-2 : ℤ</code>?</p>",
        "id": 474311802,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727878825
    },
    {
        "content": "<p>You might be tempted to say \"<code>2</code> and that's it\", but \"<code>-2</code> and that's it\" would also have been a valid answer. You don't want to say \"<code>2</code> and <code>-2</code>\" because their product is definitely not <code>-2</code>.</p>",
        "id": 474312067,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727878896
    },
    {
        "content": "<p>In <code>ℤ</code>, there is pretty clearly a convention that one should take the positive factors and not the negative ones. Namely there is a convention that we should <em>normalise</em> the factors to be positive.</p>",
        "id": 474312376,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727878961
    },
    {
        "content": "<p>You can do this in general. For all equivalence classes of elements of your monoid under \"association\" (the property of being equal up to multiplication by a unit element, eg +-1 in <code>ℤ</code>, or +-1, +-i in the gaussian integers), you pick one out to be the \"normalisation\" of all its equivalence class</p>",
        "id": 474312808,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727879075
    },
    {
        "content": "<p><code>normalizedFactors a</code> is then the result of applying this normalisation, with multiplicity (whence the <code>Multiset</code>), to an arbitrary (because one could multiply the factors by a unit) prime factorisation of <code>a</code></p>",
        "id": 474313351,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727879205
    },
    {
        "content": "<p>Eg <code>1</code> has no prime factors. Hence it has no normalised factors. Hence its multiset of normalised factors is the empty multiset, namely <code>0</code></p>",
        "id": 474313562,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1727879253
    },
    {
        "content": "<p>If you are familiar with Dedekind domains, they are similar (but not exactly the same) as the prime ideals that divide the ideal generated by the element. The main point of ideal factorization is to solve non uniqueness of the factorization itself, but it also solve the ambiguity of the units. Here we realized that sometimes (in practice for <code>ℕ</code>, <code>ℤ</code> and <code>K[X]</code>) there is \"canonical\" generator (no choice for <code>ℕ</code>, the positive one for <code>ℤ</code> and the monic one for <code>K[X]</code>).</p>",
        "id": 474315308,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1727879727
    },
    {
        "content": "<p>thank you to both of you</p>",
        "id": 474595394,
        "sender_full_name": "Baran Zadeoglu",
        "timestamp": 1727963401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"677650\">Baran Zadeoglu</span> has marked this topic as resolved.</p>",
        "id": 474595449,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727963406
    }
]