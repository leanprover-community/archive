[
    {
        "content": "<p>I'm trying to take lsub of ordinals over a list. I could use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iSub#doc\">docs#iSub</a> because it has syntax for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a>. Is there a syntax for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Membership#doc\">docs#Membership</a> for anonymous functions so I can use it with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.lsub%3F#doc\">docs#Ordinal.lsub?</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">os</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">‚®Ü</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">os</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">o</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">lsub</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"bp\">‚àà</span><span class=\"w\"> </span><span class=\"n\">os</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>The second <code>#check</code> doesn't work, and I don't understand why.</p>",
        "id": 561261604,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1764618778
    },
    {
        "content": "<p>It's a universe problem, <code>lsub</code> has the weird type of <code>def lsub {Œπ : Type u} (f : Œπ ‚Üí Ordinal.{max u v}) : Ordinal.{max u v}</code> (for some reason...). There are also comments in the code suggesting that <code>lsub</code> should be deprecated; I guess you're supposed to use <code>‚®Ü o ‚àà os, Order.succ o</code> instead?</p>",
        "id": 561265445,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1764620078
    },
    {
        "content": "<p>You should not be using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Ordinal.lsub#doc\">docs#Ordinal.lsub</a>.</p>",
        "id": 561265483,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764620093
    },
    {
        "content": "<p>I haven't been able to deprecate it, but you should treat it as morally deprecated</p>",
        "id": 561265567,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764620119
    },
    {
        "content": "<p>yeah weren't we gonna remove it</p>",
        "id": 561265577,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764620123
    },
    {
        "content": "<p>To do what you want you could do <code>(os.map (fun x ‚Ü¶ x + 1)).max</code></p>",
        "id": 561265753,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764620191
    },
    {
        "content": "<p>To take the least strict upper bound of a set <code>s</code>, use <code>sSup ((fun x ‚Ü¶ x + 1) '' s)</code></p>",
        "id": 561265817,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764620214
    },
    {
        "content": "<p><code>lsub</code> inevitably leads to universe issues like the one you just came across</p>",
        "id": 561265860,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764620227
    },
    {
        "content": "<p>Oh, sorry, my bad</p>",
        "id": 561282846,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764626020
    },
    {
        "content": "<p>It seemed universe-wise reasonable to me for the purpose in <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Showing.20termination.20with.20high-order.20inductive/near/561141667\">#new members &gt; Showing termination with high-order inductive @ üí¨</a></p>",
        "id": 561283271,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764626217
    },
    {
        "content": "<p>I thought this universe constraint makes a lot of sense -- exactly because of the smaller universe, you know there is an ordinal above. If you took arbitrary set of ordinals, such as the set of all the ordinals, you would not have this guarantee.</p>",
        "id": 561283767,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764626445
    },
    {
        "content": "<p>The actual constraint you'd want is not a universe constraint, but rather a constraint that your set be <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Small#doc\">docs#Small</a></p>",
        "id": 561284140,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764626595
    },
    {
        "content": "<p>For instance, one can always take the supremum of the range of a function <code>Iio x ‚Üí Ordinal.{u}</code> for some <code>x : Ordinal.{u}</code>, even though the domain is in <code>Type (u + 1)</code></p>",
        "id": 561284301,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764626658
    },
    {
        "content": "<p>I think in Jakub's case, writing</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"n\">lsub</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">os</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">‚Ü¶</span><span class=\"w\"> </span><span class=\"n\">os</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ordinal</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span>\n</code></pre></div>\n<p>would be reasonable. But if you want to deprecate it...</p>",
        "id": 561284777,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764626806
    },
    {
        "content": "<p>Yes, <code>lsub</code> was added by me back in 2021 or so, before the <code>Ordinal</code> API was even linked to the much more expansive API on conditionally complete orders.</p>",
        "id": 561285097,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764626925
    },
    {
        "content": "<p>For that and other reasons I'd suggest just using <code>sSup</code> / <code>iSup</code></p>",
        "id": 561285148,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764626947
    },
    {
        "content": "<p>But supremum is a little different operation from smallest strict upper bound. Isn't the latter often more practical for ordinals?</p>",
        "id": 561285455,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764627073
    },
    {
        "content": "<p>Even if you change it to an operation on <code>Set Ordinal</code> which are <code>Small</code>...</p>",
        "id": 561285766,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764627205
    },
    {
        "content": "<p>Well, to be more precise, my suggestion is using <code>sSup</code> / <code>iSup</code> composed with <code>(¬∑ + 1)</code></p>",
        "id": 561285871,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764627255
    },
    {
        "content": "<p>We could in theory redefine <code>lsub</code> for a conditionally complete lattice with a successor function, but that seems like unnecessary cruft</p>",
        "id": 561286043,
        "sender_full_name": "Violeta Hern√°ndez",
        "timestamp": 1764627343
    },
    {
        "content": "<p>It makes the proofs in my example of a well-founded recursion a little more complicated but what can I do...</p>",
        "id": 561287003,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764627802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133339\">Mirek Ol≈°√°k</span> <a href=\"#narrow/channel/113489-new-members/topic/Membership.20syntax.20for.20anonymous.20function/near/561283271\">said</a>:</p>\n<blockquote>\n<p>It seemed universe-wise reasonable to me for the purpose in <a class=\"message-link\" href=\"/#narrow/channel/113489-new-members/topic/Showing.20termination.20with.20high-order.20inductive/near/561141667\">#new members &gt; Showing termination with high-order inductive @ üí¨</a></p>\n</blockquote>\n<p>I updated the code here, so check if it contains some any other deprecated recommendations...</p>",
        "id": 561289127,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764628774
    },
    {
        "content": "<p>On the other hand, <span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> , I think you should be realizing what you are doing. I am not sure how much set theory you know, so sorry if I am saying trivialities.</p>\n<p>Most mathematicians consider mathematics is done in ZFC -- that is an axiomatic framework (a little different from Lean but comparable). The world of ZFC is rich enough for almost all of mathematics in the world.</p>\n<p>Defining an inductive datatype of type <code>Type 1</code>, is quite extraordinary, and on par with how Lean defines the entire ZFC universe (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PSet#doc\">docs#PSet</a>). When you have an inductive</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ±</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Œ±</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListSchema</span><span class=\"w\"> </span><span class=\"n\">Œ≤</span>\n</code></pre></div>\n<p>it means that in <code>fmap</code>, you \"store\" a node for each element \"x : Œ±\" , where \"Œ±\" can be arbitrarily large, infinite, uncountable, or way way bigger ...</p>\n<p>And it is not only the width that can explode. Although every single branch in the tree will be finite, there is no bound on how \"high\" a node can be either. If you have an infinitely branching tree with branches of lengths 0, 1, 2, ..., you have to give the main node the level <code>œâ</code>, if you put such node into a tree, that tree will have height <code>œâ+1</code>, <code>œâ+2</code>, etc. But there are much more ordinals, some ordinals are uncountable. Actually for arbitrary large set / type, there is an ordinal which has as many nodes below itself. So ordinals are again spanning the entire ZFC universe (they have the same cardinality as all the ZFC-sets)...</p>\n<p>So in standard mathematics, you would be already hitting its limits. In particular, if you consider all the heights of all the <code>ListSchema</code>, you will fill all the standard ordinals, there is no <code>Ordinal.{0}</code> which would be above all such heights. Are you sure it is what you intend?</p>\n<p>Lean can do a little more, it has infinitely many such universes above each other (called <code>Type 0</code>, <code>Type 1</code>, <code>Type 2</code> ...), similarly it has also <code>Ordinal.{1}</code>, <code>Ordinal.{2}</code> and that is the limit of Lean. You cannot build the sigma type <code>Œ£ n : ‚Ñï, Type n</code>, you cannot even take <code>Type (10^100)</code>. Because universes are the limit of Lean, it can get a bit confusing if you don't know precisely how you are using them.</p>",
        "id": 561295591,
        "sender_full_name": "Mirek Ol≈°√°k",
        "timestamp": 1764632289
    }
]