[
    {
        "content": "<p>There is a structure called Irreducible (<a href=\"https://github.com/leanprover-community/mathlib4/blob/0d1fc2182203e994dddc69190f494eb361b18963/Mathlib/Algebra/Prime/Defs.lean#L99\">https://github.com/leanprover-community/mathlib4/blob/0d1fc2182203e994dddc69190f494eb361b18963/Mathlib/Algebra/Prime/Defs.lean#L99</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- `p` is not a unit -/</span>\n<span class=\"w\">  </span><span class=\"n\">not_unit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- if `p` factors then one factor is a unit -/</span>\n<span class=\"w\">  </span><span class=\"n\">isUnit_or_isUnit'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Currently my code assumes a specific polynomial to be NOT Irreducible, the assumption is like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">h_neg_irreducible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But now I want to convert this assumption of non-existence of an instance of <strong>Irreducible</strong> into propositions about its properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">poly</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Could you give me some ideas on which tactics can I use to achieve this goal? I really appreciate any help from you. Thank you.</p>",
        "id": 504488589,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741590389
    },
    {
        "content": "<p>You can use <code>by_contra h</code> and then  <code>apply</code> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=irreducible_iff#doc\">docs#irreducible_iff</a>. You will get better answers if you post an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> to fill-in.</p>",
        "id": 504491798,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741591648
    },
    {
        "content": "<p>ah I see now that you specified it's a hypothesis, <code>simp [irreducible_iff] at h</code> should do it.</p>",
        "id": 504493744,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741592321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20extract.20propositions.20from.20instance's.20non-existence.3F/near/504493744\">said</a>:</p>\n<blockquote>\n<p>ah I see now that you specified it's a hypothesis, <code>simp [irreducible_iff] at h</code> should do it.</p>\n</blockquote>\n<p>Thank you so much <span class=\"user-mention\" data-user-id=\"761203\">@Vlad Tsyrklevich</span>. This is the final working <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> using <code>apply</code> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=irreducible_iff#doc\">docs#irreducible_iff</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Units</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Span</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">poly</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">polyIrreducible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">irreducible_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"c1\">-- split h_neg_irreducible into two cases and derive contradiction in both cases</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">imp_iff_not_or</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"c1\">-- consider cases and prove both cases lead to contradiction</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">left_case</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"c1\">-- left_case : ¬¬IsUnit poly</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">right_case</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"c1\">-- right_case : ∃ x x_1, poly = x * x_1 ∧ ¬IsUnit x ∧ ¬IsUnit x_1</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 504497209,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741593457
    },
    {
        "content": "<p>(That's not a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, if only because it doesn't have imports)</p>",
        "id": 504501752,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1741594783
    },
    {
        "content": "<p>(hover over the code and press the button in the top-right to see)</p>",
        "id": 504502786,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1741595060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20extract.20propositions.20from.20instance's.20non-existence.3F/near/504501752\">said</a>:</p>\n<blockquote>\n<p>(That's not a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, if only because it doesn't have imports)</p>\n</blockquote>\n<p>Thank you for your feedback. I will post a full <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> soon.</p>",
        "id": 504769499,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741681269
    },
    {
        "content": "<p>I've updated the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. Thank you you all.</p>",
        "id": 504784694,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741685454
    },
    {
        "content": "<p>But now what exactly is the question? I don't see <code>IsUnit (poly) ∨ ∃ a b, poly = a * b ∧ ¬IsUnit a ∧ ¬IsUnit b</code> in the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. Can you write down the Lean code for the exact theorem you want to prove?</p>",
        "id": 504789469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741686639
    },
    {
        "content": "<p>Is this the question?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Units</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Span</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">poly</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_neg_irreducible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">poly</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Your mwe seems unrelated to your question.</p>",
        "id": 504789902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741686747
    },
    {
        "content": "<p>I've just added comments the <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, with <strong>cases</strong> we can prove each case separately. That's what I needed.</p>",
        "id": 504790105,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741686803
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Polynomial</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Units</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Algebra</span><span class=\"bp\">.</span><span class=\"n\">Field</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">Ideal</span><span class=\"bp\">.</span><span class=\"n\">Span</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">poly</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">F3</span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_neg_irreducible</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Irreducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">poly</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">poly</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsUnit</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">irreducible_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"n\">push_neg</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_neg_irreducible</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 504790413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741686876
    },
    {
        "content": "<p>Great. Thank you for this very clean approach. <strong>push_neg</strong> looks really useful.</p>",
        "id": 504791317,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741687085
    },
    {
        "content": "<p>btw do you think that the way we have to use a supporting theorem like <strong>irreducible_iff</strong> to decompose a structure is a bit repetitive? Because we will have to create such a theorem for every structure? Especially for structures that extend other structures and more (nested extension), it would be complex and long.</p>\n<p><code>So I'm looking for a way to get the proposition that represents the existence/non-existence of an instance of a structure in the most clean way. Do you have any ideas?</code></p>",
        "id": 504796311,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741688365
    },
    {
        "content": "<p>Using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Prime/Defs.html#irreducible_iff\">irreducible_iff</a> instead of unfolding a definition makes a proof more robust. Imagine that tomorrow for some reason someone changes the definition of <code>Irreducible</code>, to something mathematically equivalent but expressed in a different way, maybe more convenient for formalization. Of course the proof of <code>irreducible_iff</code> would need to be fixed, but all the other proofs will work automatically. On the other hand proofs unfolding the definition will break.</p>",
        "id": 504799838,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741689259
    },
    {
        "content": "<p>In an ideal world all definitions should have a good API, and after the API is developed nobody should never unfold the definition. For example you really don't want to know how <code>ℤ</code> is defined in mathlib (at least if you are a mathematician), but the point is that you don't need to know it.</p>",
        "id": 504800280,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741689382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20extract.20propositions.20from.20instance's.20.28non-.29existence.3F/near/504799838\">said</a>:</p>\n<blockquote>\n<p>Using <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Prime/Defs.html#irreducible_iff\">irreducible_iff</a> instead of unfolding a definition makes a proof more robust. Imagine that tomorrow for some reason someone changes the definition of <code>Irreducible</code>, to something mathematically equivalent but expressed in a different way, maybe more convenient for formalization. Of course the proof of <code>irreducible_iff</code> would need to be fixed, but all the other proofs will work automatically. On the other hand proofs unfolding the definition will break.</p>\n</blockquote>\n<p>Yep I got your point.<br>\nMy concern is how can we unfold definitions that are abstract like this? Or do we have to trace back to all of the dependencies to gather the full definitions and put them into a theorem? Because I don't have the concrete propositions, I have to find a longer way around it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A domain is a nontrivial semiring such that multiplication by a non zero element</span>\n<span class=\"sd\">is cancellative on both sides. In other words, a nontrivial semiring `R` satisfying</span>\n<span class=\"sd\">`∀ {a b c : R}, a ≠ 0 → a * b = a * c → b = c` and</span>\n<span class=\"sd\">`∀ {a b c : R}, b ≠ 0 → a * b = c * b → a = c`.</span>\n\n<span class=\"sd\">This is implemented as a mixin for `Semiring α`.</span>\n<span class=\"sd\">To obtain an integral domain use `[CommRing α] [IsDomain α]`. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">stacks</span><span class=\"w\"> </span><span class=\"mi\">09</span><span class=\"n\">FE</span><span class=\"kd\">]</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">IsCancelMulZero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 504800835,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741689514
    },
    {
        "content": "<p>The short answer is: don't unfold the definition. If you find a missing lemma in the API add it, but in proofs of \"serious\" theorems you should never unfold.</p>",
        "id": 504804655,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741690475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20extract.20propositions.20from.20instance's.20.28non-.29existence.3F/near/504804655\">said</a>:</p>\n<blockquote>\n<p>The short answer is: don't unfold the definition. If you find a missing lemma in the API add it, but in proofs of \"serious\" theorems you should never unfold.</p>\n</blockquote>\n<p>Yep. Thank you for your answer.</p>",
        "id": 504804792,
        "sender_full_name": "Chung Thai Nguyen",
        "timestamp": 1741690512
    },
    {
        "content": "<p>the fact that <code>isDoman_iff</code> does not exist is probably because nobody wants it. We surely have that all the trivial stuff hold for a domain. And if you want to provide an instance of <code>IsDomain</code> is much better to use the <code>where</code> syntax.</p>",
        "id": 504805260,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741690642
    },
    {
        "content": "<p>The rationale is something like: \"<code>Prop</code> valued structures deserve an <code>iff</code> lemma, other structures don't\"</p>",
        "id": 504805725,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741690766
    }
]