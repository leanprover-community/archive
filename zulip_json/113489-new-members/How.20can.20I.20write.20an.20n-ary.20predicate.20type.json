[
    {
        "content": "<p>I need a function <code>f</code> such that for <code>n : Nat</code> and <code>\\alpha : Sort*</code>, it returns the n-ary predicate type <code>f n \\alpha := \\alpha -&gt; \\alpha -&gt; ... -&gt; \\alpha -&gt; Prop</code>. </p>\n<p>I tried to find such a function and got <code>Function.OfArity</code>. But <code>Function.OfArity</code> requires that the domain and codomain are on the same universe level, so if I use it, then I would have to lift <code>Prop</code> up to the same universe as alpha, which is undesired. I tried to find a version for predicates and failed. </p>\n<p>Do I have to implement it by myself?</p>",
        "id": 532436377,
        "sender_full_name": "nemo",
        "timestamp": 1754127138
    },
    {
        "content": "<p>Why not use <code>(Fin n -&gt; \\alpha) -&gt; Prop</code> or <code>Vector \\alpha n -&gt; Prop</code>?</p>",
        "id": 532436536,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754127238
    },
    {
        "content": "<p>Because I want it to be definitionally <code>\\alpha -&gt; Prop</code> and <code>\\alpha-&gt;\\alpha-&gt;Prop</code> for the cases where n = 1 or n = 2</p>",
        "id": 532436643,
        "sender_full_name": "nemo",
        "timestamp": 1754127348
    },
    {
        "content": "<p>What do you want to use it for?</p>",
        "id": 532437332,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754127833
    },
    {
        "content": "<p>You could use <code>OfArity a (a -&gt; Prop) (n - 1)</code></p>",
        "id": 532437698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1754128115
    },
    {
        "content": "<p>I want to defined a Kripke frame and I need to define the accessibility relation in the most general sence, which is an n-ary relation.</p>",
        "id": 532437742,
        "sender_full_name": "nemo",
        "timestamp": 1754128155
    },
    {
        "content": "<p>If I use OfArity a (a -&gt; Prop) (n-1), then it would fail at the case where n=0</p>",
        "id": 532437887,
        "sender_full_name": "nemo",
        "timestamp": 1754128290
    },
    {
        "content": "<p>The thing is that <code>Prop</code> lives in universe <code>Type</code> and <code>\\alpha -&gt; Prop</code> (where <code>alpha : Type u</code>) lives in <code>Type u</code>. But if you unify them under one <code>f</code> they need to have the same universe</p>",
        "id": 532437974,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754128371
    },
    {
        "content": "<p>You could use one of these though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">OfArity</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">OfArity</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PUnit</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 532438103,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754128494
    },
    {
        "content": "<p>Or the very weird and awkward to work with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ULift</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">OfArity</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">k</span>\n</code></pre></div>",
        "id": 532438298,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754128652
    },
    {
        "content": "<p>I have just found it necessary to leave out the case for 0-ary predicates, since Prop is in Type but \\alpha \\to prop is in a higher universe</p>",
        "id": 532438339,
        "sender_full_name": "nemo",
        "timestamp": 1754128695
    },
    {
        "content": "<p>So I think I'm going to take the OfArity  \\alpha (\\alpha \\to Prop) approach</p>",
        "id": 532438386,
        "sender_full_name": "nemo",
        "timestamp": 1754128742
    }
]