[
    {
        "content": "<p>Lean's typing behavior is driving me crazy.  Consider the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">hasSetPrefix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hasSetPrefix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">num_perms_set_prefix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">hasSetPrefix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"bp\">.</span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">factorial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Question 1: Why is the <code>(α := α)</code> necessary in the <code>#check</code>?  I found that if I drop it, Lean gets confused about the type of <code>p</code>.</p>\n<p>Question 2: Lean \"failed to synthesize   Fintype { p // hasSetPrefix α s p }\" on the subtype construction in the last theorem.  Why?  What is going on?</p>",
        "id": 495186779,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737514121
    },
    {
        "content": "<blockquote>\n<p>Question 1: Why is the <code>(α := α)</code> necessary in the <code>#check</code>?  I found that if I drop it, Lean gets confused about the type of <code>p</code>.</p>\n</blockquote>\n<p>Since you wrote <code>(α : Type*)</code> at the top, Lean is expecting <code>hasSetPrefix α s p</code>, so when you write <code>hasSetPrefix s p</code>, Lean tries to convert <code>s</code> to a type, and then gets confused when <code>p</code> is not a <code>Finset</code>.</p>",
        "id": 495187217,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737514411
    },
    {
        "content": "<p>That's a good point.  The (α := α) can be replaced by α.</p>",
        "id": 495187526,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737514606
    },
    {
        "content": "<p>I used the explicit (α : Type*) because of the issues discussed in <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/How.20to.20prove.20some.20simple.20combinatoric.20identities\">#new members &gt; How to prove some simple combinatoric identities</a></p>",
        "id": 495188215,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737514963
    },
    {
        "content": "<p>So my question 1 is solved.  Question 2 remains.</p>",
        "id": 495188414,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737515046
    },
    {
        "content": "<blockquote>\n<p>Question 2: Lean \"failed to synthesize   Fintype { p // hasSetPrefix α s p }\" on the subtype construction in the last theorem.  Why?  What is going on?</p>\n</blockquote>\n<p><code>Fintype</code> means \"I can list out all the elements of this type without duplication and without missing any (and I can prove my listing has these properties)\". \"Failed to synthesize\" means Lean's typeclass system was not able to automatically find a way to have a <code>Fintype</code> for your type.<br>\nThe problem is, when making a list of all the <code>{ p : Perm α // hasSetPrefix (α := α) s p }</code>, Lean has no way of knowing if a certain <code>Perm α</code> should go in the list or not.<br>\nOne way to fix this is by using <code>open Classical</code> to tell Lean to use the axiom of choice to figure out if a permuatation should be included.<br>\nAnother way to solve this is by writing a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Decidable#doc\">docs#Decidable</a> instance for your <code>hasSetPrefix</code> function, that gives an algorithm for deciding (I recommend this way).<br>\nAnother way is to not use <code>Fintype.card</code>, but instead something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.card#doc\">docs#Nat.card</a> which doesn't need a <code>Fintype</code> instance but cannot be evaluated either.</p>",
        "id": 495188416,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737515049
    },
    {
        "content": "<p>Here's an example <code>Decidable</code> instance for <code>hasSetPrefix</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hasSetPrefix</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decidable_of_iff'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iff_of_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">hasSetPrefix</span><span class=\"bp\">.</span><span class=\"n\">eq_def</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 495188682,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737515231
    },
    {
        "content": "<p>Alternatively, you can say <code>abbrev hasSetPrefix</code> instead of <code>def hasSetPrefix</code> and the typeclass system will unfold your definition and derive the decidability for the underlying forall statement.</p>",
        "id": 495188821,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737515315
    },
    {
        "content": "<p>Thanks for the explanations!  How is <code>abbrev</code> different from <code>def</code>?</p>",
        "id": 495189356,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737515694
    },
    {
        "content": "<p>It's more reducible (more parts of the system will unfold it)</p>",
        "id": 495217514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737532023
    },
    {
        "content": "<p><code>abbrev</code> is not mentioned in any of the documents listed in the \"Books\" section here:</p>\n<p><a href=\"https://leanprover-community.github.io/learn.html\">https://leanprover-community.github.io/learn.html</a></p>\n<p>It is described in \"Functional programming in Lean\", but I thought I was just doing theorem proving.</p>",
        "id": 495354340,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737572292
    },
    {
        "content": "<p>The elaborator has a concept called transparency. Every definition has a transparency associated with it, and the definition will only be unfolded if it is transparent enough.<br>\nThe four definition transparencies are:</p>\n<blockquote>\n<p><code>@[reducible] def</code><br>\n<code>@[instance] def</code><br>\n<code>def</code> and<br>\n<code>@[irreducible] def</code></p>\n</blockquote>\n<p>The four transparency modes are:</p>\n<blockquote>\n<p><code>reducible</code> : unfold reducible defs<br>\n<code>instances</code> : unfold reducible and instance defs<br>\n<code>default</code> : unfold everything except irreducible defs<br>\n<code>all</code> : unfold everything</p>\n</blockquote>\n<p><code>abbrev</code> is short for <code>@[reducible] def</code>, so typeclass inference will unfold it.<br>\n<a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/\">Metaprogramming in Lean</a> has a section on transparency <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/04_metam.html#transparency\">here</a>.</p>",
        "id": 495358435,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737573848
    },
    {
        "content": "<p>Thanks for the explanation!</p>",
        "id": 495376012,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737580925
    }
]