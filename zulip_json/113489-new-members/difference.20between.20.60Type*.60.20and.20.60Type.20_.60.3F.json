[
    {
        "content": "<p>Is there any difference between <code>Type*</code> and <code>Type _</code>? (besides <code>Type*</code> requires mathlib)</p>",
        "id": 450346638,
        "sender_full_name": "llllvvuu",
        "timestamp": 1720588385
    },
    {
        "content": "<p><code>Type*</code> creates a fresh universe level variable <code>u</code> and elaborates to <code>Type u</code>, and <code>Type _</code> creates a fresh universe level metavariable <code>?u</code> and elaborates to <code>Type ?u</code>.</p>",
        "id": 450346791,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720588494
    },
    {
        "content": "<p>If you have <code>(X Y : Type*)</code> then for example <code>X = Y</code> would be a type error (they have different universe level variables), but <code>(X Y : Type _)</code> would allow <code>X = Y</code> since the universe level metavariables can unify.</p>",
        "id": 450346859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720588557
    },
    {
        "content": "<p>(note that <code>(a b : ty)</code> elaborates as <code>(a : ty) (b : ty)</code>, with <code>ty</code> elaborated twice)</p>",
        "id": 450346972,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720588622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/difference.20between.20.60Type*.60.20and.20.60Type.20_.60.3F/near/450346859\">said</a>:</p>\n<blockquote>\n<p>If you have <code>(X Y : Type*)</code> then for example <code>X = Y</code> would be a type error (they have different universe level variables), but <code>(X Y : Type _)</code> would allow <code>X = Y</code> since the universe level metavariables can unify.</p>\n</blockquote>\n<p>Thanks for the explanation!</p>",
        "id": 450503373,
        "sender_full_name": "llllvvuu",
        "timestamp": 1720628916
    },
    {
        "content": "<p>(This may not be true anymore, or may be controversial, so I'll say it anyway so that someone disagrees if it isn't) but I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> told me to generally avoid <code>Type _</code> unless you're really sure you want that behavior, because it can cause Lean to do some expensive unification (in the way Kyle mentioned).</p>",
        "id": 450508783,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720630655
    },
    {
        "content": "<p>If <code>Type*</code> fails and <code>Type _</code> is ok, then you probably have secret universe constraints floating around</p>",
        "id": 450509109,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720630757
    },
    {
        "content": "<p>You will only see it for type synonyms now</p>",
        "id": 450509309,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720630818
    },
    {
        "content": "<p>But in the case that both work, <code>Type _</code> can end up being lots slower as Lean tries to find some potentially non-trivial minimal universes to satisfy all the holes right?</p>",
        "id": 450509549,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720630881
    },
    {
        "content": "<p>When <code>Type*</code> succeeds you should always use it over <code>Type _</code></p>",
        "id": 450509666,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720630913
    },
    {
        "content": "<p>It doesn't succeed on type synonym <code>def MyNat : Type* := Nat</code>, where <code>Type _</code> is ok.</p>",
        "id": 450509823,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720630954
    },
    {
        "content": "<p>Everywhere else, probably you should work out what the <code>_</code> is being inferred as and write that instead</p>",
        "id": 450509925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720630978
    },
    {
        "content": "<p>Yes, generally you should be explicit about levels anyway. They get introduced automatically (autoimplicit) still and can have a dramatic effect on the performance as Lean needs to do an additional solve for each step</p>",
        "id": 450509938,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720630981
    },
    {
        "content": "<p>Even though it probably yields no benefit peformance-wise, I would still try to avoid <code>Type _</code> in synonyms. That way everyone who reads the code knows where everything live explicitly. This is just my opinion though</p>",
        "id": 450510440,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631133
    },
    {
        "content": "<p>Can you (either of you) explain what's special about type synonyms?</p>",
        "id": 450510591,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631170
    },
    {
        "content": "<p>Is it because <code>Nat</code> itself is defined using <code>Type _</code>?</p>",
        "id": 450510606,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631178
    },
    {
        "content": "<p>API boundaries</p>",
        "id": 450510629,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631189
    },
    {
        "content": "<p>Oh wait. Sorry. I thought you meant their use.</p>",
        "id": 450510667,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631203
    },
    {
        "content": "<p>Ah I see, so you're saying \"use the one you find from the thing I'm aliasing\"?</p>",
        "id": 450510669,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631203
    },
    {
        "content": "<p>No I understand what they're for yeah, just not why <code>Type _</code> is then something needed</p>",
        "id": 450510721,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631221
    },
    {
        "content": "<p>Here you have a secret constraint. The level of the thing after <code>:=</code> better be the same as the level of the synonym</p>",
        "id": 450510807,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631243
    },
    {
        "content": "<p>Got it, right, makes sense, thanks.</p>",
        "id": 450510848,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631253
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/113489-new-members/topic/difference.20between.20.60Type*.60.20and.20.60Type.20_.60.3F/near/450510440\">said</a>:</p>\n<blockquote>\n<p>Even though it probably yields no benefit peformance-wise, I would still try to avoid <code>Type _</code> in synonyms. That way everyone who reads the code knows where everything live explicitly. This is just my opinion though</p>\n</blockquote>\n<p>I think the argument is probably that no one really cares about the universe; but people certainly want to see <code>def foo : Type _ := maybeAType</code> instead of <code>def foo := maybeAType</code></p>",
        "id": 450510949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720631281
    },
    {
        "content": "<p>I think that is also the reason why levels can be introduced implicitly still</p>",
        "id": 450511128,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631326
    },
    {
        "content": "<p>eg <code>[Category C]</code></p>",
        "id": 450511187,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span> Beyond performance, an additional concern with <code>Type _</code> is that your theorems might be more specialized than you think.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- \"All types are subsingletons\"</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"c1\">-- Oh, no they're not.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subsingleton</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Subsingleton</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>",
        "id": 450511203,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631342
    },
    {
        "content": "<p>This was the primary motivation for <code>Type*</code>/<code>Sort*</code></p>",
        "id": 450511327,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631370
    },
    {
        "content": "<p>After they got introduced, at least one thing was found to live in <code>Type 0</code> for example</p>",
        "id": 450511566,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631436
    },
    {
        "content": "<p>And what's happening there (and I'll butcher the terminology I'm sure, sorry), is that while Lean is elaborating the actual type after the <code>:</code>, it's doing that before it works out the <code>_</code> in the binder, and so once it gets to that it picks a narrower <code>_</code> than it \"should\"?</p>",
        "id": 450511710,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631472
    },
    {
        "content": "<p>If you change that <code>example</code> to a def and <code>#print</code> it you'll see</p>",
        "id": 450511807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631501
    },
    {
        "content": "<p>Or maybe even move your cursor right before <code>x = y</code> to see what instance it picked up in the local context</p>",
        "id": 450511926,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631532
    },
    {
        "content": "<p>Except I don't think there is a \"should\". It fills in what works without telling you what choices it makes do so</p>",
        "id": 450511979,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631550
    },
    {
        "content": "<p>There's a \"should\" in the sense that when you write <code>α : Sort _</code> you wrote it because you thought it would make it be more polymorphic than it ends up being</p>",
        "id": 450512180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631608
    },
    {
        "content": "<p>Right I meant in ^ sense that I still don't really understand when this behavior is so desirable.</p>",
        "id": 450512243,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631625
    },
    {
        "content": "<p>It seems like a footgun.</p>",
        "id": 450512305,
        "sender_full_name": "Julian Berman",
        "timestamp": 1720631641
    },
    {
        "content": "<p>Exactly, that's why we made <code>Type*</code>/<code>Sort*</code></p>",
        "id": 450512374,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631652
    },
    {
        "content": "<p>As Eric said, the counterpoint is that is it is a pain to write </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">a1</span><span class=\"w\"> </span><span class=\"n\">b1</span><span class=\"w\"> </span><span class=\"n\">c1</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 450512480,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1720631676
    },
    {
        "content": "<p>The desirability of <code>Type _</code> is that <code>_</code> is a plain old universe level placeholder (which elaborates to a fresh plain old universe level metavariable). That is, it's just a combination of basic features.</p>",
        "id": 450512492,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631679
    },
    {
        "content": "<p>and there's no mechanism in Lean to make a metavariable that isn't unifiable with a constant, or whatever the rule is supposed to be where it's not a footgun</p>",
        "id": 450512762,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1720631753
    }
]