[
    {
        "content": "<p>The following is a simple example of a recursively defined function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Initially I thought the recursive part <code>| n + 1 =&gt; 2 * n + 1 + f n</code> was <strong>required</strong> to map from <code>n + 1</code>. I thought this because that is what induction proofs must do in the inductive step. </p>\n<p>I was wrong, confirmed when I saw in MoP that some functions mapped from <code>n + 2</code>.</p>\n<p>So the question I ask myself is, what are the constraints on a recursively defined function. </p>\n<p>The only one I can guess at is that if <code>n</code> is a natural number, then no part of the definition can use subtraction.</p>\n<p>I assume Lean doesn't check for <strong>contradictory</strong> branches of the definition, eg:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- &lt; -- contradicts</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>or <strong>gaps</strong>, eg the follow doesn't define <code>f 3</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Am I right?</p>",
        "id": 491984880,
        "sender_full_name": "rzeta0",
        "timestamp": 1736099176
    },
    {
        "content": "<p>Did you try just typing those into Lean and seeing what happens?</p>",
        "id": 491985509,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736099781
    },
    {
        "content": "<p>e.g. the first one you can test with <code>#eval f 0</code></p>",
        "id": 491985520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1736099793
    },
    {
        "content": "<p>Both give an error when I try it - which is re-assuring.</p>\n<p>These are just my guesses at scenarios which are not allowed and checked for by Lean. </p>\n<p>There may be others?</p>",
        "id": 491986163,
        "sender_full_name": "rzeta0",
        "timestamp": 1736100288
    },
    {
        "content": "<p>You can just experiment yourself here, right?</p>",
        "id": 491987927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736101758
    },
    {
        "content": "<p>you will get a clearer idea of the lower-level definition here by replacing the pattern-matching with a <code>Nat.casesOn</code> (the definition must first produce a successful translation of the match into <code>Nat.casesOn</code> before recursion is elaborated)</p>",
        "id": 491990022,
        "sender_full_name": "nrs",
        "timestamp": 1736103608
    },
    {
        "content": "<p>to study this you may use <code>whatsnew in</code> over functions you are used to. the <code>Nat.brecOn</code> part of the resulting output arises after recursion is elaborated. the match statement contained within (within the <code>Nat.brecOn</code> function, in the <code>whatsnew in</code> output) is the statement as it is before recursion elaboration</p>",
        "id": 491990237,
        "sender_full_name": "nrs",
        "timestamp": 1736103791
    }
]