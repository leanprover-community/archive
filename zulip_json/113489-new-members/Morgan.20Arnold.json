[
    {
        "content": "<p>Howdy! My name is Morgan. I'm a master's student in pure mathematics. I am broadly interested in the rather disparate mathematical fields of (homotopy) type theory, constructive mathematics, and mathematical general relativity. I'm currently working on a thesis on the latter.</p>\n<p>I've been interested in type theory for a long time, which is at least partially motivated by my generally constructivist philosophical views. I have more experience with Coq than Lean, but have been trying to learn Lean, mostly due to the larger community working on the formalization of mathematics in Lean.</p>\n<p>I'm currently trying to cut my teeth on Lean my formalizing some parts of Bishop's <em>Constructive Analysis</em>. I can't say that it's the smoothest of sailing, but I'm learning!</p>",
        "id": 515556569,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746123712
    },
    {
        "content": "<p>Two questions I've run into in the work I'm doing so far:</p>\n<ol>\n<li>Following Bishop, I've defined a <code>RegularSeq</code> to be a</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RegularSeq</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">â„š</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">â‰¤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>but this doesn't have great ergonomics. For instance, I end up getting really messy-looking terms like <code>|(x.seq n - y.seq n) + (y.seq n - z.seq n)|</code> and such. I was hoping that I would be able to get around this by defining a coersion, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">RegularSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">â„•</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">â„š</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">seq</span>\n</code></pre></div>\n<p>but this simply doesn't seem to work. Maybe it would be more correct to define regular sequences based on a predicate <code>Regular (x : â„• â†’ â„š) : Prop</code> instead, but I want to define an equivalence relation on the type of regular sequences to form a quotient, and it's not clear to me how that would be done without defining regular sequences as a structure type like this.</p>\n<ol start=\"2\">\n<li>The second problem that I'm having is also to do with coersions, but in a different way this time! I'm working on defining the sum of two regular sequences, and running into some issues with the proof that it's regular. Given two sequences <code>x</code> and <code>y</code>, their sum is <code>Î» n â†¦ x (2 * n) + y (2 * n)</code>, but in proving that this is regular I have some issues. The proof is mostly routine, but once things are split up with the triangle inequality, I am left to prove that <code>|x (2 * m) - x (2 * n)| â‰¤ 1 / (2 * â†‘m) + 1 / (2 * â†‘n)</code>. This should follow immediately from the regularity of <code>x</code>, but the proposition that that ends up yielding me is instead <code>|x (2 * m) - x (2 * n)| â‰¤ 1 / â†‘(2 * m) + 1 / â†‘(2 * n)</code>. These are equivalent to the best of my understanding, but cannot be unified due to the different points at which the coersions occur. Presumably I could figure out how to prove that <code>(2 * â†‘m) = â†‘(2 * m)</code>, but having to do that seems like a bit of a smell to me, and I suspect that there is probably a way of doing this that allows me to avoid this mess.</li>\n</ol>",
        "id": 515575293,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746130900
    },
    {
        "content": "<p>Pardon my wall of text!</p>",
        "id": 515575325,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746130917
    },
    {
        "content": "<p>Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeFun#doc\">docs#CoeFun</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs#FunLike</a></p>",
        "id": 515575696,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131056
    },
    {
        "content": "<p>I suggest <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs#FunLike</a></p>",
        "id": 515575736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131071
    },
    {
        "content": "<p>For your second issue, I imagine the tactic <code>norm_cast</code> would be useful, a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for that situation would be helpful</p>",
        "id": 515576883,
        "sender_full_name": "Eric Paul",
        "timestamp": 1746131489
    },
    {
        "content": "<p>Keep in mind <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/.E2.9C.94.20Classical.20is.20now.20open.20by.20default.3F.20How.20to.20disable.20it.3F/with/505552828\">#general &gt; âœ” Classical is now open by default? How to disable it?</a></p>",
        "id": 515577177,
        "sender_full_name": "suhr",
        "timestamp": 1746131597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515577177\">said</a>:</p>\n<blockquote>\n<p>Keep in mind <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/.E2.9C.94.20Classical.20is.20now.20open.20by.20default.3F.20How.20to.20disable.20it.3F/with/505552828\">#general &gt; âœ” Classical is now open by default? How to disable it?</a></p>\n</blockquote>\n<p>Oh, that's absolutely bizarre. In fact, I just checked, and it seems like even in my definition of regular sequences classical choice is somehow being looped into the mix. According to <code>#print axioms RegularSeq</code>, <code>'RegularSeq' depends on axioms: [propext, Classical.choice, Quot.sound]</code>. <code>propext</code> makes sense, and <code>Quot.sound</code> makes sense because of the rationals being presumably defined as a quotient, but I can't for the life of me see why this definition requires <code>Classical.choice</code>!</p>",
        "id": 515673576,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746177826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"639473\">Morgan Arnold</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515673576\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515577177\">said</a>:</p>\n<blockquote>\n<p>Keep in mind <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/.E2.9C.94.20Classical.20is.20now.20open.20by.20default.3F.20How.20to.20disable.20it.3F/with/505552828\">#general &gt; âœ” Classical is now open by default? How to disable it?</a></p>\n</blockquote>\n<p>Oh, that's absolutely bizarre. In fact, I just checked, and it seems like even in my definition of regular sequences classical choice is somehow being looped into the mix. According to <code>#print axioms RegularSeq</code>, <code>'RegularSeq' depends on axioms: [propext, Classical.choice, Quot.sound]</code>. <code>propext</code> makes sense, and <code>Quot.sound</code> makes sense because of the rationals being presumably defined as a quotient, but I can't for the life of me see why this definition requires <code>Classical.choice</code>!</p>\n</blockquote>\n<p>Will need to see more of it i think to say for sure. Without more info i would say check the type signature of the | | there and also division of one.</p>",
        "id": 515674366,
        "sender_full_name": "Yan Yablonovskiy ðŸ‡ºðŸ‡¦",
        "timestamp": 1746178117
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.sub_def#doc\">docs#Rat.sub_def</a> already requires choice, so there doesn't seem to be much of a chance to avoid it</p>",
        "id": 515674935,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746178325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515674935\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.sub_def#doc\">docs#Rat.sub_def</a> already requires choice, so there doesn't seem to be much of a chance to avoid it</p>\n</blockquote>\n<p>Hm, is choice required here to select a representative of the equivalence class or something?</p>",
        "id": 515679716,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746180210
    },
    {
        "content": "<p>Isnâ€™t it simply the case that -- even if a result doesnâ€™t <em>theoretically</em> requireÂ <code>Classical.choice</code>-- Mathlib contributors typically make no special effort to avoid using it in practice?</p>",
        "id": 515680666,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746180576
    },
    {
        "content": "<p>In other words, seeing <code>'foo' depends on axioms: [â€¦, Classical.choice, â€¦]</code> should not be taken to mean that Mathlibâ€™s contributors couldnâ€™t find a way to proveÂ <code>foo</code>Â without usingÂ <code>Classical.choice</code>.</p>",
        "id": 515681189,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746180778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515680666\">said</a>:</p>\n<blockquote>\n<p>Isnâ€™t it simply the case that -- even if a result doesnâ€™t <em>theoretically</em> requireÂ <code>Classical.choice</code>-- Mathlib contributors typically make no special effort to avoid using it in practice?</p>\n</blockquote>\n<p>Certainly</p>",
        "id": 515683764,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746181753
    },
    {
        "content": "<p>(Though this is core lean, even)</p>",
        "id": 515683839,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746181792
    },
    {
        "content": "<p>Yeah, but this is not a mathlib issue. This is core lean.</p>",
        "id": 515683921,
        "sender_full_name": "suhr",
        "timestamp": 1746181803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515674935\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Rat.sub_def#doc\">docs#Rat.sub_def</a> already requires choice</p>\n</blockquote>\n<p>Thanks for saying that. So I will need to avoid <code>Batteries</code> as well in my project.</p>",
        "id": 515685194,
        "sender_full_name": "suhr",
        "timestamp": 1746182354
    },
    {
        "content": "<p>Following the rabbit hole even further, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.tdiv_eq_ediv#doc\">docs#Int.tdiv_eq_ediv</a> is one source of choice, and that's in core</p>",
        "id": 515685788,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746182595
    },
    {
        "content": "<p>I recommend asking yourself why you'd want to avoid choice</p>",
        "id": 515685838,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746182614
    },
    {
        "content": "<p>That's easy: I want to do both constructive and classical mathematics, while keeping the clear distinction between them.</p>",
        "id": 515686400,
        "sender_full_name": "suhr",
        "timestamp": 1746182822
    },
    {
        "content": "<p>I find myself in a similar camp. My interest in proof verification tools like Lean stems in large part from an interest in constructive mathematics. Indeed, I'm trying to learn Lean by formalizing theorems from a book on constructive analysis. That seems a bit moot if I can't prevent Lean from including non-constructive classical results willy-nilly. I was also hoping that it would be possible to maintain a clear distinction between constructive results and classical results.</p>",
        "id": 515686692,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746182945
    },
    {
        "content": "<p>It <em>is</em> possible with a certain hack: <a href=\"https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F\">https://lean-ja.github.io/lean-by-example/Diagnostic/Print.html#%E8%88%9E%E5%8F%B0%E8%A3%8F</a>.</p>\n<p>But it sucks when trivially constructive lemmas in the standard library implicitly depend on choice.</p>",
        "id": 515687183,
        "sender_full_name": "suhr",
        "timestamp": 1746183149
    },
    {
        "content": "<p>It does seem to make it a bit tricky to actually do explicitly constructive mathematics in Lean, which is a real shame.</p>",
        "id": 515689669,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746184129
    },
    {
        "content": "<p>Yeah. I still find Lean much nicer to work with than other proof assistants, so I would prefer using this hack and implementing things myself over using Rocq, for example.</p>",
        "id": 515690324,
        "sender_full_name": "suhr",
        "timestamp": 1746184387
    },
    {
        "content": "<p>Keep in mind that Lean maintains a distinction between constructive mathematics and computable mathematics, and while the former is hard to do given that nearly all of Mathlib depends on choice, the latter is definitely achievable.</p>",
        "id": 515757518,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746204951
    },
    {
        "content": "<p>Are you trying to do constructive mathematics so that you can run your code, or just because you don't like the law of the excludes middle?</p>",
        "id": 515757981,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746205078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> mostly because I don't like LEM. I'm also trying to formalize parts of a book on constructive mathematics, so I find it a bit aesthetically unpleasant if Lean implicitly pulls all of this non-constructive stuff. I'm trying to do constructive math, so I'd like Lean to offer the guarantee that it's constructive. That's all.</p>",
        "id": 515766579,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746207956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515757518\">said</a>:</p>\n<blockquote>\n<p>Keep in mind that Lean maintains a distinction between constructive mathematics and computable mathematics, and while the former is hard to do given that nearly all of Mathlib depends on choice, the latter is definitely achievable.</p>\n</blockquote>\n<p>For me it's both. I'd like to preserve the constructive meaning of <code>âˆƒ</code> and also like when things are computable.</p>",
        "id": 515768187,
        "sender_full_name": "suhr",
        "timestamp": 1746208548
    },
    {
        "content": "<p>Unfortunately, the more I read the more it seems like Lean is really not very well-suited to doing explicitly constructivist mathematics. At a minimum it seems like I would need to re-implement a ton of stuff from mathlib because of just how much of it depends on choice, plus be very vigilant to ensure that the built-in tactics don't introduce choice in my proofs. It's just unmanageable.</p>",
        "id": 515768781,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746208736
    },
    {
        "content": "<p>You can write metaprograms that detect whether choice is included in your proof. (I think the Lean ground zero project does something similar; maybe you should check it out). It's more of a question of how much work you want to do yourself</p>",
        "id": 515770813,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746209389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"639473\">Morgan Arnold</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515768781\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, the more I read the more it seems like Lean is really not very well-suited to doing explicitly constructivist mathematics. At a minimum it seems like I would need to re-implement a ton of stuff from mathlib because of just how much of it depends on choice, plus be very vigilant to ensure that the built-in tactics don't introduce choice in my proofs. It's just unmanageable.</p>\n</blockquote>\n<p>Right, I wanted to say this to you when I saw your post yesterday but didn't have time. You are much better off sticking to Coq if you want to do Bishop style math</p>",
        "id": 515778459,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1746212091
    },
    {
        "content": "<p>You will not be able to use most of mathlib (addition of polynomials depends on choice...) or even most  tactics (many of which introduce lem sneakily)</p>",
        "id": 515778506,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1746212110
    },
    {
        "content": "<p>While Coq already has some awfully sophistiacated libraries for constructive analysis, and a rich community interested in this line of work</p>",
        "id": 515778598,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1746212150
    },
    {
        "content": "<p>In open-source communities, forking a project and letting your version shine often beats trying to convince maintainers to reverse long-standing fundamental choices. Has anyone eager for a purely \"non-classical\" Lean or Mathlib ever actually given it a try, or has the effort stayed at just persuading maintainers?</p>",
        "id": 515783994,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746214184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/stream/113489-new-members/topic/Morgan.20Arnold/near/515783994\">said</a>:</p>\n<blockquote>\n<p>In open-source communities, forking a project and letting your version shine often beats trying to convince maintainers to reverse long-standing fundamental choices. Has anyone eager for a purely \"non-classical\" Lean or Mathlib ever actually given it a try, or has the effort stayed at just persuading maintainers?</p>\n</blockquote>\n<p>Forking Lean/mathlib is more or less discouraged by the mantainers</p>",
        "id": 515784947,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1746214533
    },
    {
        "content": "<p>The fact that it's all one huge construction is arguably one of mathlib's major strengths after all</p>",
        "id": 515785079,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1746214574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515783994\">said</a>:</p>\n<blockquote>\n<p>In open-source communities, forking a project and letting your version shine often beats trying to convince maintainers to reverse long-standing fundamental choices. Has anyone eager for a purely \"non-classical\" Lean or Mathlib ever actually given it a try, or has the effort stayed at just persuading maintainers?</p>\n</blockquote>\n<p>Classical reasoning is just so ingrained into the core of Lean that any attempt at building a non-classical mathlib would require modifying substantial parts of Lean. There is not many people that can and want to do this work. Additionally if such a fork wants to profit from the work that the Mathlib community and Lean FRO is putting into the two projects it would need lots of dedicated people to backport changes, otherwise it just gets left behind in a few months.</p>",
        "id": 515785641,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1746214810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik BÃ¶ving</span> I completely agree -- itâ€™s a massive undertaking (and personally, Iâ€™m not convinced itâ€™s even necessary -- Iâ€™m perfectly happy with classical logic). Iâ€™m just curious whether anyone committed to non-classical logic has taken concrete steps beyond simply appealing to the maintainers.</p>",
        "id": 515798402,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746219990
    },
    {
        "content": "<p>I'm not sure if this is constructive, but the ground zero project has an extra type checker bolted on to Lean to make sure that subsingleton elimination, which is inconsistent with univalence, is not used.</p>",
        "id": 515799387,
        "sender_full_name": "Niels Voss",
        "timestamp": 1746220400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515783994\">said</a>:</p>\n<blockquote>\n<p>In open-source communities, forking a project and letting your version shine often beats trying to convince maintainers to reverse long-standing fundamental choices. Has anyone eager for a purely \"non-classical\" Lean or Mathlib ever actually given it a try, or has the effort stayed at just persuading maintainers?</p>\n</blockquote>\n<p>I should probably clarify that I'm not making any effort to persuade anyone to do any work on this. It's entirely the prerogative of Lean's maintainers to focus on classical logic, and doing so probably makes sense given its primary status in actual mathematics. I was just asking if an effective means of segregating the classical and non-classical results in Lean and mathlib already existed. It seems like the answer is no. If I really want to ensure that I'm doing purely constructive mathematics, it probably makes more sense to either stick with Rocq or learn Agda or something.</p>",
        "id": 515800277,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746220765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515799387\">said</a>:</p>\n<blockquote>\n<p>I'm not sure if this is constructive, but the ground zero project has an extra type checker bolted on to Lean to make sure that subsingleton elimination, which is inconsistent with univalence, is not used.</p>\n</blockquote>\n<p>Is that <a href=\"https://github.com/forked-from-1kasper/ground_zero\">https://github.com/forked-from-1kasper/ground_zero</a>?</p>",
        "id": 515800675,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1746220950
    },
    {
        "content": "<p>I would say the effective means of segregating is assuming everything in mathlib is classical :)</p>",
        "id": 515809091,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1746225106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"683979\">Isak Colboubrani</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515783994\">said</a>:</p>\n<blockquote>\n<p>Has anyone eager for a purely \"non-classical\" Lean or Mathlib ever actually given it a try, or has the effort stayed at just persuading maintainers?</p>\n</blockquote>\n<p>Together with my book I will write my little \"mathlib at home\". No intent to compete with large mathlib though, just enough stuff to support the book.</p>\n<p>And no desire to persuade anyone either (it's useless).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik BÃ¶ving</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515785641\">said</a>:</p>\n<blockquote>\n<p>Classical reasoning is just so ingrained into the core of Lean</p>\n</blockquote>\n<p>Lean core as described in <a href=\"https://lean-lang.org/doc/reference/latest/The-Type-System/\">the reference</a> is pretty much constructive. So the only thing one needs to care about are tactics.</p>",
        "id": 515810007,
        "sender_full_name": "suhr",
        "timestamp": 1746225633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"639473\">Morgan Arnold</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515800277\">said</a>:</p>\n<blockquote>\n<p>it probably makes more sense to either stick with Rocq or learn Agda or something.</p>\n</blockquote>\n<p>Take a look at Cubical Agda.</p>",
        "id": 515810651,
        "sender_full_name": "suhr",
        "timestamp": 1746226014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515810007\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik BÃ¶ving</span> <a href=\"#narrow/channel/113489-new-members/topic/Morgan.20Arnold/near/515785641\">said</a>:</p>\n<blockquote>\n<p>Classical reasoning is just so ingrained into the core of Lean</p>\n</blockquote>\n<p>Lean core as described in <a href=\"https://lean-lang.org/doc/reference/latest/The-Type-System/\">the reference</a> is pretty much constructive. So the only thing one needs to care about are tactics.</p>\n</blockquote>\n<p>This amounts to the tactics and everything that is proven with them which is pretty much everything. If you want to do fully constructive things in Lean you will have to ignore basically everything that has been built.</p>",
        "id": 515811539,
        "sender_full_name": "Henrik BÃ¶ving",
        "timestamp": 1746226542
    },
    {
        "content": "<p>Yeah. But so far things are not that bad, and I can just guard against <code>Classical.choice</code> instead of reimplementing everything.</p>\n<p>If things are not going to become much worse quickly, I can just reimplement things by need.</p>",
        "id": 515813301,
        "sender_full_name": "suhr",
        "timestamp": 1746227527
    }
]