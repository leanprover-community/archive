[
    {
        "content": "<p>Howdy! My name is Morgan. I'm a master's student in pure mathematics. I am broadly interested in the rather disparate mathematical fields of (homotopy) type theory, constructive mathematics, and mathematical general relativity. I'm currently working on a thesis on the latter.</p>\n<p>I've been interested in type theory for a long time, which is at least partially motivated by my generally constructivist philosophical views. I have more experience with Coq than Lean, but have been trying to learn Lean, mostly due to the larger community working on the formalization of mathematics in Lean.</p>\n<p>I'm currently trying to cut my teeth on Lean my formalizing some parts of Bishop's <em>Constructive Analysis</em>. I can't say that it's the smoothest of sailing, but I'm learning!</p>",
        "id": 515556569,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746123712
    },
    {
        "content": "<p>Two questions I've run into in the work I'm doing so far:</p>\n<ol>\n<li>Following Bishop, I've defined a <code>RegularSeq</code> to be a</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">RegularSeq</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">seq</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>but this doesn't have great ergonomics. For instance, I end up getting really messy-looking terms like <code>|(x.seq n - y.seq n) + (y.seq n - z.seq n)|</code> and such. I was hoping that I would be able to get around this by defining a coersion, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">RegularSeq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">seq</span>\n</code></pre></div>\n<p>but this simply doesn't seem to work. Maybe it would be more correct to define regular sequences based on a predicate <code>Regular (x : ℕ → ℚ) : Prop</code> instead, but I want to define an equivalence relation on the type of regular sequences to form a quotient, and it's not clear to me how that would be done without defining regular sequences as a structure type like this.</p>\n<ol start=\"2\">\n<li>The second problem that I'm having is also to do with coersions, but in a different way this time! I'm working on defining the sum of two regular sequences, and running into some issues with the proof that it's regular. Given two sequences <code>x</code> and <code>y</code>, their sum is <code>λ n ↦ x (2 * n) + y (2 * n)</code>, but in proving that this is regular I have some issues. The proof is mostly routine, but once things are split up with the triangle inequality, I am left to prove that <code>|x (2 * m) - x (2 * n)| ≤ 1 / (2 * ↑m) + 1 / (2 * ↑n)</code>. This should follow immediately from the regularity of <code>x</code>, but the proposition that that ends up yielding me is instead <code>|x (2 * m) - x (2 * n)| ≤ 1 / ↑(2 * m) + 1 / ↑(2 * n)</code>. These are equivalent to the best of my understanding, but cannot be unified due to the different points at which the coersions occur. Presumably I could figure out how to prove that <code>(2 * ↑m) = ↑(2 * m)</code>, but having to do that seems like a bit of a smell to me, and I suspect that there is probably a way of doing this that allows me to avoid this mess.</li>\n</ol>",
        "id": 515575293,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746130900
    },
    {
        "content": "<p>Pardon my wall of text!</p>",
        "id": 515575325,
        "sender_full_name": "Morgan Arnold",
        "timestamp": 1746130917
    },
    {
        "content": "<p>Use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CoeFun#doc\">docs#CoeFun</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs#FunLike</a></p>",
        "id": 515575696,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131056
    },
    {
        "content": "<p>I suggest <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FunLike#doc\">docs#FunLike</a></p>",
        "id": 515575736,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746131071
    },
    {
        "content": "<p>For your second issue, I imagine the tactic <code>norm_cast</code> would be useful, a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for that situation would be helpful</p>",
        "id": 515576883,
        "sender_full_name": "Eric Paul",
        "timestamp": 1746131489
    },
    {
        "content": "<p>Keep in mind <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/.E2.9C.94.20Classical.20is.20now.20open.20by.20default.3F.20How.20to.20disable.20it.3F/with/505552828\">#general &gt; ✔ Classical is now open by default? How to disable it?</a></p>",
        "id": 515577177,
        "sender_full_name": "suhr",
        "timestamp": 1746131597
    }
]