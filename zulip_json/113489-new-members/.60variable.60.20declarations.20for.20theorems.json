[
    {
        "content": "<p>I declared some variables, then when using them in <code>def</code>/<code>structure</code>/<code>inductive</code> the definitions seem to pick them up correctly from the environment.<br>\nBut for a theorem, it only seems to work if the statement contains that variable.<br>\nWhy? Where is this documented? And how can I force the theorem to let me use that variable without changing the theorem statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Common</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mydef</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyStruct</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyInd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">myind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInd</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">theo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">MyInd</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>unknown identifier 'b'\n</code></pre></div>",
        "id": 530856990,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1753481955
    },
    {
        "content": "<p>You can use <code>include a b in</code> before the theorem to remind Lean to use them</p>",
        "id": 530857154,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482054
    },
    {
        "content": "<p>The difference in behavior is because <code>theorem</code> decides its type up front before looking at the proof</p>",
        "id": 530857253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482101
    },
    {
        "content": "<p>And the reason behind that is, Lean wants to prevent you from accidentally formalizing a wrong statement?</p>",
        "id": 530857347,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1753482155
    },
    {
        "content": "<p>Implicit undeclared variables are already a thing, and Lean's solution for that is to insert them faded out in vscode, so it can do that here too</p>",
        "id": 530857484,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1753482231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/.60variable.60.20declarations.20for.20theorems/near/530857253\">said</a>:</p>\n<blockquote>\n<p>The difference in behavior is because <code>theorem</code> decides its type up front before looking at the proof</p>\n</blockquote>\n<p>Thanks, is this documented somewhere? Both the behavior and the <code>include</code> feature. Because I couldn't find anything online</p>",
        "id": 530857535,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1753482268
    },
    {
        "content": "<p>I think once you type include, you can hover over it to see what it does</p>",
        "id": 530857577,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482293
    },
    {
        "content": "<p>That of course doesn't help with discovery</p>",
        "id": 530857582,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482302
    },
    {
        "content": "<p>is <code>include</code> mentioned in the help for <code>variable</code>?</p>",
        "id": 530857595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482308
    },
    {
        "content": "<p>Where's the help for <code>variable</code>? I couldn't find a Lean language reference online</p>",
        "id": 530857655,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1753482343
    },
    {
        "content": "<p>If you hover over the word <code>variable</code> you should get some help</p>",
        "id": 530858716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482919
    },
    {
        "content": "<p>But there is the same help and more online somewhere, probably</p>",
        "id": 530858743,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1753482934
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir</span> <a href=\"#narrow/stream/113489-new-members/topic/.60variable.60.20declarations.20for.20theorems/near/530857655\">said</a>:</p>\n<blockquote>\n<p>Where's the help for <code>variable</code>? I couldn't find a Lean language reference online</p>\n</blockquote>\n<p>It is documented <a href=\"https://lean-lang.org/doc/reference/latest//Namespaces-and-Sections/#section-variables\">right here</a> in case you need to look up something else.</p>",
        "id": 530875546,
        "sender_full_name": "Anthony Fernandes",
        "timestamp": 1753494279
    },
    {
        "content": "<p>If I understand correctly, there is no way to declare a number of (Prop-valued) assumptions and make them blankly available to all theorems in a section? You have to is an <code>include</code> for each new theorem? </p>\n<p>(I am asking because some assumptions may  have long statements; Coq/Rocq has a <code>Hypothesis</code> command that does what I am looking for, make some assumptions available for several future theorems)</p>",
        "id": 530928355,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1753526704
    },
    {
        "content": "<p>Bundle them if you really need so many</p>",
        "id": 530932161,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1753528739
    },
    {
        "content": "<p>there was parameter in lean 3</p>",
        "id": 530933055,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753529184
    },
    {
        "content": "<p>The term to search for is \"proof data pattern\": sphere eversion has used it, carleson also --- and quite possibly some other projects as well.</p>",
        "id": 530934286,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1753529830
    },
    {
        "content": "<p>Bundling all ambient data in a structure + declaring an instance of that structure as a variable + <code>export</code>ing the useful components of that structure works quite well in my opinion, as it then makes those components freely available for the rest of the namespace.  I did this for instance to implement Zermelo-Frankel set theory (with atoms) within Lean, see <a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_3_1.lean</a></p>",
        "id": 531162691,
        "sender_full_name": "Terence Tao",
        "timestamp": 1753630931
    }
]