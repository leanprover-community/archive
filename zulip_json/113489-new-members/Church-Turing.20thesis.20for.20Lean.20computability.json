[
    {
        "content": "<p>Let us call a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : \\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> computable in Lean, if there exists some compiling Lean code which I can put after </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n</code></pre></div>\n<p>Without having to say noncomputable def, such that for any natural number n, f n equals to the right number by rfl.<br>\nI apologize for the imprecision of this definition. I’m not an expert in logic, so there might be some subtleties which I’m missing. For example, I do not want to talk about whether we can prove in Lean whether two functions f and g are actually equal, just that for some set-theoretic function there exists a Lean code computing it in some platonic sense.<br>\nMy questions about this notion are:<br>\n1) Is it true that every function computable in Lean is a total recursive function?<br>\n2) Is it possible in principle to write a meta program which will automatically deduce that f is recursive from the fact that its definition is computable?</p>",
        "id": 560673466,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764279331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560673466\">said</a>:</p>\n<blockquote>\n<p>such that for any natural number n, f n equals to the right number by rfl.</p>\n</blockquote>\n<p>This part seems like it could be problematic, since how do you determine what is the \"right\" number and also it's not possible to check statements about \"any natural number n\" in a finite amount of time</p>",
        "id": 560674946,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764280191
    },
    {
        "content": "<p>Ok let me try to explain how I would imagine a more precise definition would go.<br>\nI assume (but do not know a precise reference in the literature for) that there is a notion of a set-theoretic model of Lean, which is a tuple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">M</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><mo separator=\"true\">,</mo><msub><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><mo separator=\"true\">,</mo><msub><mo>:</mo><mi mathvariant=\"fraktur\">M</mi></msub><mo separator=\"true\">,</mo><msub><mo>≡</mo><mi mathvariant=\"fraktur\">M</mi></msub><mo separator=\"true\">,</mo><mo>…</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{M}=(\\mathrm{Type}_{\\mathfrak{M}}, \\mathrm{Term}_{\\mathfrak{M}}, :_{\\mathfrak{M}}, \\equiv_{\\mathfrak{M}}, \\ldots)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Type</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2398em;\"><span style=\"top:-2.4559em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2441em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Term</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">:</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6582em;vertical-align:-0.1944em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≡</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mclose\">)</span></span></span></span> consisting of a set of terms, a set of types, a typing relation, a definitional equality relation, and some maps corresponding to constructing dependent product types, inductive types, quot types, function applications, abstractions, recursors, and quot makers.<br>\nFor any model <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">M</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{M}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">M</span></span></span></span> of Lean, there exists a distingushed element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> -- the naturals of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">M</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{M}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">M</span></span></span></span>, with two distinguished terms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">z</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">o</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><msub><mo>:</mo><mi mathvariant=\"fraktur\">M</mi></msub><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{zero}_{\\mathfrak{M}} :_{\\mathfrak{M}} \\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">zero</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">:</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">s</mi><mi mathvariant=\"normal\">u</mi><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">c</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><msub><mo>:</mo><mi mathvariant=\"fraktur\">M</mi></msub><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><msub><mo>→</mo><mi mathvariant=\"fraktur\">M</mi></msub><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{succ}_{\\mathfrak{M}} :_{\\mathfrak{M}} \\mathrm{Nat}_{\\mathfrak{M}} \\to_{\\mathfrak{M}} \\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">succ</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">:</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. This allows us to construct an embedding from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to the set of terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, the image of which I will call <em>standard naturals</em>.<br>\nNow, for any computable (which I assume means \"does not have Classical.choice anywhere\") term <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>∈</mo><msub><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">m</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">F \\in \\mathrm{Term}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Term</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub><msub><mo>→</mo><mi mathvariant=\"fraktur\">M</mi></msub><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat}_{\\mathfrak{M}} \\to_{\\mathfrak{M}} \\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. I can construct by application a function from the set of terms of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mi mathvariant=\"fraktur\">M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat}_{\\mathfrak{M}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.334em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathfrak mtight\">M</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to itself. Then one can ask the following questions:<br>\na) Is it true that for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> as above, the corresponding function preserves the set of standard naturals?<br>\nb) Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> be a computable Lean term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat} \\to \\mathrm{Nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span></span></span></span>, such that for any model of Lean, the corresponding function preserves the set of standard naturals. Is it true that the restriction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> to the set of standard naturals is independent of the model?<br>\nc) Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> be a computable Lean term of type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow><mo>→</mo><mrow><mi mathvariant=\"normal\">N</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">t</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Nat} \\to \\mathrm{Nat}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Nat</span></span></span></span></span>, such that for any model of Lean, the corresponding function preserves the set of standard naturals, and the restriction to standard naturals is independent of the model. Is it true that this restriction is a total recursive function?</p>",
        "id": 560685591,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764288243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560685591\">said</a>:</p>\n<blockquote>\n<p>a) Is it true that for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> as above, the corresponding function preserves the set of standard naturals?</p>\n</blockquote>\n<p>I'm assuming you mean up to definitional equality? (the answer is no)</p>",
        "id": 560686435,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764288592
    },
    {
        "content": "<p>This is assuming you're allowed axioms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.sound#doc\">docs#Quot.sound</a> even though choice is banned</p>",
        "id": 560686571,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764288670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560686571\">said</a>:</p>\n<blockquote>\n<p>This is assuming you're allowed axioms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.sound#doc\">docs#Quot.sound</a> even though choice is banned</p>\n</blockquote>\n<p>Can I use these axioms without having to mark the definition as noncomputable?</p>",
        "id": 560686649,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764288721
    },
    {
        "content": "<p>yes</p>",
        "id": 560686937,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764288837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560686435\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560685591\">said</a>:</p>\n<blockquote>\n<p>a) Is it true that for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> as above, the corresponding function preserves the set of standard naturals?</p>\n</blockquote>\n<p>I'm assuming you mean up to definitional equality? (the answer is no)</p>\n</blockquote>\n<p>So my assumption was that when I write computable definitions in Lean, then I really write a program and when I try to use rfl, Lean runs this program and see whether the results are the same. Like that’s how 2+2=4 ends up being rfl</p>",
        "id": 560686975,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764288851
    },
    {
        "content": "<p>you can also use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.choice#doc\">docs#Classical.choice</a> without having to mark it noncomputable</p>",
        "id": 560686989,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764288861
    },
    {
        "content": "<p>If my assumption is false, and the answer to a) is false, I’m happy to relax to propositional equality</p>",
        "id": 560687091,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764288913
    },
    {
        "content": "<p>it does become some sort of program</p>",
        "id": 560687170,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764288963
    },
    {
        "content": "<p>and you can still <code>#eval</code> it and get a number</p>",
        "id": 560687285,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289030
    },
    {
        "content": "<p>but defeq gets stuck sometimes</p>",
        "id": 560687297,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289042
    },
    {
        "content": "<p>Here is one issue that I assume arises:<br>\nIf <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a total recursive function which is not provably total in Lean, is it possible that I can computably define such an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>?</p>",
        "id": 560687336,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289061
    },
    {
        "content": "<p>I would assume no</p>",
        "id": 560687364,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289079
    },
    {
        "content": "<p>probably not</p>",
        "id": 560687391,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289097
    },
    {
        "content": "<p>But if yes, then my questions do kind of break down</p>",
        "id": 560687395,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289098
    },
    {
        "content": "<p>since defining it would amount to a proof that it's total</p>",
        "id": 560687413,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289119
    },
    {
        "content": "<p>But then I really asked for a blanket statement of the type “is every computably definable function recursive”</p>",
        "id": 560687468,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289155
    },
    {
        "content": "<p>That could still be true</p>",
        "id": 560687476,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289162
    },
    {
        "content": "<p>well I don't see why not</p>",
        "id": 560687523,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289199
    },
    {
        "content": "<p>But you are saying that if the program is sufficiently complicated, then rfl just gives up and doesn’t reduce the term fully?</p>",
        "id": 560687752,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764289345
    },
    {
        "content": "<p>well it does do that sometimes but that's not what I'm saying</p>",
        "id": 560687813,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764289377
    },
    {
        "content": "<p><code>noncomputable</code> has no theoretically relevant meaning, it just tells the compiler not to generate code for your function, either because you don't want to or because it can't for whatever reason. These reasons can be manifold and also arbitrary limitations of the current algorithm.</p>",
        "id": 560688370,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1764289839
    },
    {
        "content": "<p>Related thread: <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/channel/116395-maths/topic/.28Partial.29.20Church.27s.20thesis/with/519375836\">#maths &gt; (Partial) Church's thesis</a>. This thread seems to imply that the answer to your question 1) is no and 2) is yes for some large subset of the definable functions (although no one has actually implemented such a metaprogram).</p>",
        "id": 560688950,
        "sender_full_name": "Niels Voss",
        "timestamp": 1764290291
    },
    {
        "content": "<p>here we are</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quot</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Quot</span><span class=\"bp\">.</span><span class=\"n\">sound</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- fails</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- 1</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- ⋯ ▸ 1</span>\n</code></pre></div>",
        "id": 560689149,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1764290459
    },
    {
        "content": "<blockquote>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a total recursive function which is not provably total in Lean, is it possible that I can computably define such an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>?</p>\n</blockquote>\n<p>Not sure if this is what you are asking, but you might be interested in <a href=\"https://proofassistants.stackexchange.com/q/1840/6046\">https://proofassistants.stackexchange.com/q/1840/6046</a></p>",
        "id": 560689270,
        "sender_full_name": "Niels Voss",
        "timestamp": 1764290564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560687336\">said</a>:</p>\n<blockquote>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a total recursive function which is not provably total in Lean, is it possible that I can computably define such an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>?</p>\n</blockquote>\n<p>What do you mean by 'computably define'?</p>",
        "id": 560691923,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764292723
    },
    {
        "content": "<p>The standard way to do something like this would be to write w program that enumerates all of the functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> that Lean proves are total and then diagonalize against them.</p>",
        "id": 560691969,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764292769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560691923\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560687336\">said</a>:</p>\n<blockquote>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a total recursive function which is not provably total in Lean, is it possible that I can computably define such an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>?</p>\n</blockquote>\n<p>What do you mean by 'computably define'?</p>\n</blockquote>\n<p>being able to write some code<br>\n<code> def f : Nat -&gt; Nat := ...</code><br>\nwithout having to mark it as \"noncomputable\"</p>",
        "id": 560691982,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764292776
    },
    {
        "content": "<p>You wouldn't be able to do this within Lean itself, no.</p>",
        "id": 560691998,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764292793
    },
    {
        "content": "<p>You should, however, be able to do it in Lean together with an axiom asserting that Lean is arithmetically sound.</p>",
        "id": 560692051,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764292844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560691998\">said</a>:</p>\n<blockquote>\n<p>You wouldn't be able to do this within Lean itself, no.</p>\n</blockquote>\n<p>Well okay, this depends on what you mean by certain words.</p>",
        "id": 560692186,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764292995
    },
    {
        "content": "<p>You can write two computer programs <code>A</code> and <code>B</code> which compute the same function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> such that Lean proves <code>A</code> computes a total function but Lean does not prove <code>B</code> computes a total function.</p>",
        "id": 560692242,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293059
    },
    {
        "content": "<p>I'm not sure if that's the kind of thing you're looking for.</p>",
        "id": 560692250,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293067
    },
    {
        "content": "<p>All of these are subtleties which I'm really trying to avoid for the purposes of my main question:<br>\nis it possible in principle to write a metaprogram which proves automatically that any function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> whose definition does not involve the axiom of choice is recursive?</p>",
        "id": 560692333,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293188
    },
    {
        "content": "<p>What do you mean by 'doesn't involve the axiom of choice'? Do you mean 'is definable in Lean without <code>Classical.choice</code>?</p>",
        "id": 560692558,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560692558\">said</a>:</p>\n<blockquote>\n<p>What do you mean by 'doesn't involve the axiom of choice'? Do you mean 'is definable in Lean without <code>Classical.choice</code>?</p>\n</blockquote>\n<p>Something like that yes</p>",
        "id": 560692590,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293396
    },
    {
        "content": "<p>And what do you mean by your metaprogram 'proving' that these things are are recursive?</p>",
        "id": 560692609,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293412
    },
    {
        "content": "<p>Are there other things that trigger the error message \"consider marking the definition is noncomputable\", besides using choice?</p>",
        "id": 560692625,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293428
    },
    {
        "content": "<p>Are you saying you want a program that takes a Lean definition of a function and produces a Lean proof that that function agrees with some specific Turing machine?</p>",
        "id": 560692628,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560692628\">said</a>:</p>\n<blockquote>\n<p>Are you saying you want a program that takes a Lean definition of a function and produces a Lean proof that that function agrees with some specific Turing machine?</p>\n</blockquote>\n<p>Yes</p>",
        "id": 560692646,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293440
    },
    {
        "content": "<p>Ah okay. The core theory of Lean is a fairly basic constructive type theory, so this should be possible by a pretty standard realizability argument.</p>",
        "id": 560692746,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560686571\">said</a>:</p>\n<blockquote>\n<p>This is assuming you're allowed axioms <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.sound#doc\">docs#Quot.sound</a> even though choice is banned</p>\n</blockquote>\n<p>So is it true that propext and Quot.sound might break recursiveness in some way or are they subsumed by a realizability argument?</p>",
        "id": 560692882,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293628
    },
    {
        "content": "<p>I do not think those will keep these functions from being computable.</p>",
        "id": 560692991,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293706
    },
    {
        "content": "<p>There's a more direct argument for this but basically my thinking is that the standard construction of a model of MLTT/CIC with universes in IZF + universes will cover Lean with propositional extensionality and the quotient soundness axiom.</p>",
        "id": 560693060,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293756
    },
    {
        "content": "<p>And then IZF + universes has a realizer interpretation.</p>",
        "id": 560693085,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293784
    },
    {
        "content": "<p>And at the level of finitely many universes, this should all be internalizable in Lean.</p>",
        "id": 560693105,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293801
    },
    {
        "content": "<p>Again though, that's not going to be the right way to actually write such a program.</p>",
        "id": 560693123,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293818
    },
    {
        "content": "<p>That's just an argument that it should be possible.</p>",
        "id": 560693140,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293832
    },
    {
        "content": "<p>How do universes affect which functions are definable in Lean?</p>",
        "id": 560693145,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293839
    },
    {
        "content": "<p>I mean functions from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> specifically</p>",
        "id": 560693180,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293876
    },
    {
        "content": "<p>Well each universe increases the consistency strength of Lean considerably and leads to more provably total computable functions.</p>",
        "id": 560693197,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293890
    },
    {
        "content": "<p>Basically, Lean with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> universes can take the list of computable functions that Lean with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> universes can prove are total and uniformly prove that they're all computable.</p>",
        "id": 560693271,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764293951
    },
    {
        "content": "<p>So is it true that a function is definable in Lean using <br>\n<code>def f : Nat -&gt; Nat := ...</code><br>\niff it is recursive and provably total in Lean?</p>",
        "id": 560693277,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764293955
    },
    {
        "content": "<p>There might be a slight subtlety with Markov's principle. I'm not completely sure, but this is probably true.</p>",
        "id": 560693362,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764294010
    },
    {
        "content": "<p>Well okay, regarding Markov's principle, it's going to depend on what you mean by 'provably total', I guess. But with the strongest interpretation of that, the answer is going to be yes.</p>",
        "id": 560693404,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764294049
    },
    {
        "content": "<p>Ok then this answers my questions in the strongest possible form <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 560693449,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764294094
    },
    {
        "content": "<p>The strongest interpretation being the most direct: We say that Lean proves that the program <code>A</code> is total if it proves that for every <code>n : Nat</code>, there is a stage <code>s : Nat</code> at which <code>A</code> halts on input <code>n</code>.</p>",
        "id": 560693459,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764294108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560693404\">said</a>:</p>\n<blockquote>\n<p>Well okay, regarding Markov's principle, it's going to depend on what you mean by 'provably total', I guess. But with the strongest interpretation of that, the answer is going to be yes.</p>\n</blockquote>\n<p>I want to say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : \\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> is provably total if there exists an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">e \\in \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mi>e</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_e</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> computes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and Lean proves that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">N</mi><mo separator=\"true\">,</mo><msub><mi>U</mi><mi>e</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>↓</mo></mrow><annotation encoding=\"application/x-tex\">\\forall n \\in \\mathbb{N}, U_e(n) \\downarrow</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">e</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↓</span></span></span></span></p>",
        "id": 560693563,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1764294196
    },
    {
        "content": "<p>Yes that's basically what I'm saying.</p>",
        "id": 560693596,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764294229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407114\">@Stepan Nesterov</span> Regarding your second message in this thread: you really have two questions there, the first being \"will a Lean term <code>ℕ → ℕ</code> applied to a numeral compute to a numeral, perhaps up to propositional equality\", and the other is \"is every Lean-definable function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span>\" computable. IUUC, you're trying to use a positive answer to the first question in other to define what it even means to be Lean-definable for the second question to make sense, by saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span> is Lean-definable when there exists a Lean term <code>f_impl : ℕ → ℕ</code> such that <code>f_impl</code> applied to a numeral <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>n</mi><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">⌈n⌉</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">⌉</span></span></span></span> (i.e., <code>succ (succ (... zero ))</code> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> applications of <code>succ</code>) is the numeral <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌈</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">⌉</mo></mrow><annotation encoding=\"application/x-tex\">⌈f(n)⌉</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌈</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)⌉</span></span></span></span> up to either definitional or propositional equality. But you don't need this. You can just interpret a Lean term of type <code>ℕ → ℕ</code> into the standard model (aka set model or metacircular interpretation) of type theory and that gives you a bonafide function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span>.</p>\n<p>So you can say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span> is Lean-definable-without-choice iff there exists a Lean term <code>f_impl : ℕ → ℕ</code> not containing <code>Classical.choice</code> whose interpretation in the standard model is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. And then it's indeed true, by standard realizability arguments, that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is Lean-definable-without-choice then it is computable, and the proof of this is constructive so from a Lean term <code>ℕ → ℕ</code> without choice you can compute a Turing machine that computes the associated function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span>.</p>",
        "id": 560796643,
        "sender_full_name": "Jean Abou Samra",
        "timestamp": 1764339396
    },
    {
        "content": "<p>However, I do not see that it easily follows that for every Lean-without-choice term <code>f_impl : ℕ → ℕ</code>, calling <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span> the associated function, there is a Turing machine <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> such that <strong>Lean-without-choice proves that</strong> <code>∀ n, turing_machine_halts_on_input_and_returns_output U n (f n)</code> (this is what I understand from what you're saying about a \"meta program\"). In other words, <span class=\"user-mention\" data-user-id=\"904624\">@James E Hanson</span> I don't see how you get \"And at the level of finitely many universes, this should all be internalizable in Lean\" (unless I misunderstood what you mean by that).</p>",
        "id": 560798554,
        "sender_full_name": "Jean Abou Samra",
        "timestamp": 1764340021
    },
    {
        "content": "<p>(It is a statement of the same flavor as propositional canonicity, which would be \"every closed term of type <code>ℕ</code> in Lean-without-choice is propositionally equal to a numeral\" (although I don't actually see how to deduce propositional canonicity from your statement). Both have the form \"for every internal thing, there is a concrete external thing and an internal proof that they agree\". And propositional canonicity is hard to prove in general.)</p>",
        "id": 560802405,
        "sender_full_name": "Jean Abou Samra",
        "timestamp": 1764341288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"880066\">Jean Abou Samra</span> <a href=\"#narrow/channel/113489-new-members/topic/Church-Turing.20thesis.20for.20Lean.20computability/near/560798554\">said</a>:</p>\n<blockquote>\n<p>However, I do not see that it easily follows that for every Lean-without-choice term <code>f_impl : ℕ → ℕ</code>, calling <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"normal\">N</mi><mo>→</mo><mi mathvariant=\"normal\">N</mi></mrow><annotation encoding=\"application/x-tex\">f : ℕ → ℕ</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord amsrm\">N</span></span></span></span> the associated function, there is a Turing machine <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> such that <strong>Lean-without-choice proves that</strong> <code>∀ n, turing_machine_halts_on_input_and_returns_output U n (f n)</code> (this is what I understand from what you're saying about a \"meta program\"). In other words, <span class=\"user-mention silent\" data-user-id=\"904624\">James E Hanson</span> I don't see how you get \"And at the level of finitely many universes, this should all be internalizable in Lean\" (unless I misunderstood what you mean by that).</p>\n</blockquote>\n<p>It depends on what you mean by 'internalizable in Lean'. There is no function you can define from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>→</mo><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N} \\to \\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> that will give you a Turing index of a program that computes a given function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, but for a fixed universe level <code>u</code> you should be able to write a function that takes a syntactic representation of a term <code>t</code> that only uses universes up to <code>u</code> and produces the corresponding actual term <code>t</code>, a Turing index <code>e</code>, and a proof that the function computed by <code>e</code> is equal to <code>t</code>.</p>",
        "id": 560833385,
        "sender_full_name": "James E Hanson",
        "timestamp": 1764351370
    }
]