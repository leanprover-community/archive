[
    {
        "content": "<p>I'm trying to prove some basic results about finite dimensional complex representations of finite groups, hopefully with an eye to contributing this stuff to mathlib eventually since we need a bunch of facts which are not there to do more interesting things. FDRep k G is a type which depends on a field k and a group G. Because these results are specific to complex representations I'm taking k to be \\C.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">ComplexConjugate</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">comp_char_inv_conj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">conj</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This has a type error objection at G</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">application</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">G</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n</code></pre></div>\n<p>I suspect this is something fairly basic about how lean handles types that's showing a misunderstanding on my part. Why is not not legitimate and / or how would I modify what I wrote to make sense?</p>",
        "id": 535354991,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755708393
    },
    {
        "content": "<p>The issue is that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FDRep#doc\">docs#FDRep</a> is universe monomorphic</p>",
        "id": 535355503,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755708629
    },
    {
        "content": "<p>What does that mean? That the group and ring must be of the same level? Can we bump the level of one of them to match?</p>",
        "id": 535355811,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755708749
    },
    {
        "content": "<p>You can use <code>ULift</code></p>",
        "id": 535356467,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755709012
    },
    {
        "content": "<p>but the correct thing to do here would be to fix <code>FDRep</code></p>",
        "id": 535356499,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755709024
    },
    {
        "content": "<p>correct is a strong word, i think bundled things should be monomorphic and unbundled things should be polymorphic</p>",
        "id": 535356739,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755709118
    },
    {
        "content": "<p>Lots of bundled things are already polymorphic</p>",
        "id": 535356918,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755709200
    },
    {
        "content": "<p>Like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat#doc\">docs#ModuleCat</a></p>",
        "id": 535357048,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755709252
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Action#doc\">docs#Action</a></p>",
        "id": 535357260,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755709338
    },
    {
        "content": "<p>Is this a question of how things are organized in packages? This is over my head :). I don't mind if people want to refactor later, I'm just trying to figure out how to appease the type system to create complex representations</p>",
        "id": 535357464,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755709422
    },
    {
        "content": "<p>if you change it to <code>{G : Type}</code> it works</p>",
        "id": 535359288,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755710182
    },
    {
        "content": "<p>it's because it has to match the same type universe as <code>ℂ</code>, which is <code>Type</code></p>",
        "id": 535359474,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755710269
    },
    {
        "content": "<p>I guess since it's finite you can always shrink it</p>",
        "id": 535360586,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755710761
    },
    {
        "content": "<p>why would that be necessary? this seems like a very simple problem with a very simple solution: use <code>{G : Type}</code> instead of <code>{G : Type u}</code></p>",
        "id": 535360778,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755710856
    },
    {
        "content": "<p>I meant if you want to use this for a <code>Type u</code></p>",
        "id": 535360941,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755710937
    },
    {
        "content": "<p>I suspect <span class=\"user-mention\" data-user-id=\"130170\">@Ryan Smith</span> just wants his code to work and wrote <code>Type u</code> because that's often good practice... but yes, if he needs universe polymorphism then he'll have to do some extra work</p>",
        "id": 535361206,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755711062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535356739\">said</a>:</p>\n<blockquote>\n<p>correct is a strong word, i think bundled things should be monomorphic and unbundled things should be polymorphic</p>\n</blockquote>\n<p>Can I ask why?</p>",
        "id": 535361605,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755711217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535361605\">said</a>:</p>\n<blockquote>\n<p>Can I ask why?</p>\n</blockquote>\n<p>I think sometimes Lean has trouble with solving <code>max u v</code> stuff</p>",
        "id": 535369824,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755714767
    },
    {
        "content": "<p>but all your universes are coming from the types</p>",
        "id": 535370424,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755715045
    },
    {
        "content": "<p>you don't need to solve any <code>max u v</code> stuff</p>",
        "id": 535370448,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755715054
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MvPolynomial#doc\">docs#MvPolynomial</a> is polymorphic without causing any problems</p>",
        "id": 535370526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755715092
    },
    {
        "content": "<p>so is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat#doc\">docs#ModuleCat</a></p>",
        "id": 535370656,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755715146
    },
    {
        "content": "<p>This is enough to start fighting with lean over theorem specific issues :) </p>\n<p>How do you check for existing results in a library? Surely we must have a result for the trace of the power of a matrix but I'm just finding it for matrices over finite fields and Z/pZ. As an inexperienced user a find 70% of the time is just hunting for stuff already buried somewhere in mathlib that I can't find. So far I just use <a href=\"http://moogle.ai\">moogle.ai</a> and guess at keywords?</p>",
        "id": 535371229,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755715422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535371229\">said</a>:</p>\n<blockquote>\n<p>Surely we must have a result for the trace of the power of a matrix but I'm just finding it for matrices over finite fields and Z/pZ.</p>\n</blockquote>\n<p>Which result are you looking for?</p>",
        "id": 535371773,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755715647
    },
    {
        "content": "<p>Something which when I thought it over was not true in the general case and needed extra hypotheses :)</p>",
        "id": 535372587,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755716022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535371229\">said</a>:</p>\n<blockquote>\n<p>How do you check for existing results in a library?</p>\n</blockquote>\n<p>if you're starting out, leanexplore and leansearch allow you to search using natural language (i.e. english),</p>\n<p>and if you have more experience, you would want to gradually shift to loogle, which requires you to know about the names of the moving parts, or parts of the name of the theorem</p>",
        "id": 535375656,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755717279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535371229\">said</a>:</p>\n<blockquote>\n<p>the trace of the power of a matrix</p>\n</blockquote>\n<p>so for example here i see \"trace\" and \"power\", and in lean they are <code>Matrix.trace</code> (I guessed this one with experience, Lean names are by design very predictable) and <code>_ ^ _</code>, so I typed those to Loogle: <a href=\"https://loogle.lean-lang.org/?q=Matrix.trace%2C+_+%5E+_\">Matrix.trace, _ ^ _</a></p>",
        "id": 535375810,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755717351
    },
    {
        "content": "<p>and indeed we only have the charp result</p>",
        "id": 535375868,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755717373
    },
    {
        "content": "<p>Ok, a concrete example of trying to find stuff in mathlib: tr A = sum eigenvalues A for complex matrix A. Lots of searches involving \"eigenvalue\", \"trace\", \"algebraically closed\"  etc. I suppose in an ideal world it would be the trace of a linear map rather than picking a basis but this has to be somewhere right?</p>",
        "id": 535406293,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755734227
    },
    {
        "content": "<p>Using leansearch I got Matrix.trace_eq_sum_roots_charpoly, but I’m not sure if that’s what you want</p>",
        "id": 535407596,
        "sender_full_name": "Chase Norman",
        "timestamp": 1755735448
    },
    {
        "content": "<p>Searching for module endomorphism eigenvalues produces a wealth of useful stuff, thanks for the other search links.</p>\n<p>One tangible question though, it seems that Module.End.Eigenvalues is a type and not something concrete like a list of eigenvalues. If I need to prove something about all eigenvalues of a particular endomorphism what is the hypothesis which says \"let z \\in \\C be an eigenvalue of ___\" ?</p>",
        "id": 535430738,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755753017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535406293\">said</a>:</p>\n<blockquote>\n<p>tr A = sum eigenvalues A for complex matrix</p>\n</blockquote>\n<p>Please PR!</p>",
        "id": 535445388,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755761413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535430738\">said</a>:</p>\n<blockquote>\n<p>what is the hypothesis which says</p>\n</blockquote>\n<p>it's best to answer this question by looking at real life theorems using it</p>",
        "id": 535445495,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755761468
    },
    {
        "content": "<p>which, I would agree, is not a lot</p>",
        "id": 535445535,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755761480
    },
    {
        "content": "<p>Wasn't trying to be vague, just trying to avoid clutter.</p>\n<p>To be specific, I have <code>V : FDRep ℂ G</code> and from that we're accessing the representation <code>V.ρ : G →* ↑V.V →ₗ[ℂ] ↑V.V</code> (not sure why there is a type coercion since I don't think it needs one?). G is a finite group, and I need to prove multiple lemmas about each of the eigenvalues of <code>V.ρ g</code> in order to prove results about the character of V. For a warm up we are showing an arbitrary eigenvector has norm 1.  Easy math, but have to explain what we mean to lean. The plan is to say z is an eigenvalue, get the existence of a vector, then use an existing theorem in mathlib about the eigenvalues of a kth power.</p>\n<p>Where I'm failing is to write our hypothesis h here: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">z</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This doesn't work because</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Invalid</span><span class=\"w\"> </span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"ss\">`HasEigenvalue</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">environment</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">contain</span><span class=\"w\"> </span><span class=\"ss\">`LinearMap.HasEigenvalue</span><span class=\"bp\">`</span>\n<span class=\"w\">  </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">↑</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℂ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">V</span>\n</code></pre></div>\n<p>I'm surprised this fails because something like this from math in lean works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">eigenspace</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>And End K V is just an abbreviation for K linear maps V -&gt; V</p>",
        "id": 535534031,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755791713
    },
    {
        "content": "<p>here's one approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">tmp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">z</span><span class=\"bp\">‖</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>this uses the <code>show _ from _</code> pattern to cast the <code>LinearMap</code> to a <code>Module.End</code></p>",
        "id": 535536362,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755792508
    },
    {
        "content": "<p>You can do that in a declaration?  Interesting</p>",
        "id": 535536471,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755792539
    },
    {
        "content": "<p>It gives you an ugly <code>have this := V.ρ g; this</code></p>",
        "id": 535546629,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755796531
    },
    {
        "content": "<p>No doubt its ugly, is there a better way? Working with that hypothesis is going to be a bit challenging . Normal programming languages seem like that would be ok with <code>(V.ρ g).HasEigenvalue</code> but I guess thats invalid syntax here</p>",
        "id": 535547142,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755796742
    },
    {
        "content": "<p>it's invalid because <code>V.ρ g</code> has the wrong type... <code>HasEigenvalue</code> requires a value of type <code>Module.End</code></p>",
        "id": 535547597,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755796934
    },
    {
        "content": "<p>(also I wouldn't be surprised if there's a better way... I was just throwing out one possible solution)</p>",
        "id": 535547737,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755796978
    },
    {
        "content": "<p>You could write out <code>Module.End.HasEigenvalue (V.ρ g) z</code></p>",
        "id": 535551081,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755798243
    },
    {
        "content": "<p>oh yeah that's a much better idea lol</p>",
        "id": 535553869,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755799374
    },
    {
        "content": "<p>sorry I led you astray, <span class=\"user-mention\" data-user-id=\"130170\">@Ryan Smith</span> ... looks like the issue was just that using dot notation requires a strict type match</p>",
        "id": 535554350,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755799548
    },
    {
        "content": "<p>So does an abbreviation create a new type? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>Thank you both for help with this</p>",
        "id": 535555230,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755799896
    },
    {
        "content": "<p>there's some good information on what <code>abbrev</code> does in this part of the manual:</p>\n<p><a href=\"https://lean-lang.org/doc/reference/latest/Definitions/Definitions/\">https://lean-lang.org/doc/reference/latest/Definitions/Definitions/</a></p>",
        "id": 535557074,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755800708
    },
    {
        "content": "<p>you're defining a new type (in the sense that it's a new constant), though it's definitionally equal to the old one</p>",
        "id": 535557352,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755800838
    },
    {
        "content": "<p>also here's the section on generalized field notation:</p>\n<p><a href=\"http://lean-lang.org/doc/reference/latest/Terms/Function-Application/#generalized-field-notation\">http://lean-lang.org/doc/reference/latest/Terms/Function-Application/#generalized-field-notation</a></p>",
        "id": 535557473,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755800890
    },
    {
        "content": "<p>you can see that it looks up the function based on the name of the type... it can unfold the type if it doesn't find anything, but the problem here is that <code>LinearMap</code> doesn't unfold to <code>Module.End</code>, but rather the reverse, so unfolding can't help here</p>",
        "id": 535558040,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755801122
    },
    {
        "content": "<p>Kenny Lau: PR ?</p>",
        "id": 535559857,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1755801947
    },
    {
        "content": "<p>FYI you can tag <span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> using the <code>@</code> symbol (or you can tag without notifying with <code>@_</code>, which I just did)</p>",
        "id": 535564940,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1755804080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130170\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Basic.20type.20question.20when.20trying.20to.20do.20complex.20reps/near/535559857\">said</a>:</p>\n<blockquote>\n<p>Kenny Lau: PR ?</p>\n</blockquote>\n<p>it's the process of getting stuff into mathlib, see <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a> for more details</p>",
        "id": 535587030,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755814813
    }
]