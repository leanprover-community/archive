[
    {
        "content": "<p>Suppose I have two real intervals </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">J</span><span class=\"bp\">.</span><span class=\"n\">OrdConnected</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">OrdConnected</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>How do I write the type of bijective functions from J to I which are are also r times continuously differentiable and their inverse is also r times continuously differentiable?  I don't really understand the definition of a diffeomorphism in mathlib, in particular what is a ModelWithCorners, I tried to do the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">J</span><span class=\"bp\">.</span><span class=\"n\">OrdConnected</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">OrdConnected</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">WithTop</span><span class=\"w\"> </span><span class=\"n\">‚Ñï</span><span class=\"bp\">‚àû</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">œÜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">J</span><span class=\"w\"> </span><span class=\"bp\">‚âÉ‚Çò^</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">‚üÆ</span><span class=\"n\">‚Ñù</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"bp\">‚üØ</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but I get some error which I don't understand. I would appreciate if someone could explain me how to use the diffeomorphism definition, especially in my particular situation.</p>",
        "id": 560602883,
        "sender_full_name": "Michael Novak",
        "timestamp": 1764251598
    },
    {
        "content": "<p>Can you explain why you need to consider this type? </p>\n<p>If you just need to talk about one such diffeomorphism (instead of the type of all of them), the simplest situation would probably be to consider a <code>PartialEquiv</code> between <code>I</code> and <code>J</code> (seen as subsets of the real line) requiring that it is <code>ContDiffOn r I</code>, as well as its inverse. </p>\n<p>(Note that in general a real interval is not a one-dimensional manifold, because it could be reduced to a point, so there are subtleties -- the way to resolve them really depends on what you want to do)</p>",
        "id": 560605987,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764252367
    },
    {
        "content": "<p>I'm working on formalizing parametrized curves and the next thing I want to do is define what is a reparametrization of a parametrized curve. To do this I first wanted to define what is a parameter transformation - which is exactly what I'm trying to define here, but I remembered that what I want to define is essentially a diffeomorphism, so I searched for it in mathlib, but the definition is probably a bit more general / complicated than the simpler definition of a diffeomorphism that I know of. Do you think it's better to define what is a parameter transformation by myself instead of using the existing definition of Diffeomorph?</p>",
        "id": 560607991,
        "sender_full_name": "Michael Novak",
        "timestamp": 1764252924
    },
    {
        "content": "<p>Yes, definitely don't use Diffeomorph there, it's overkill. Instead use a map from R to R which is C^r on your interval of definition and with nonvanishing derivative there.</p>",
        "id": 560610067,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764253523
    },
    {
        "content": "<p>O.k, thank you very much! Is it fine if I define a small structure for this?</p>",
        "id": 560610498,
        "sender_full_name": "Michael Novak",
        "timestamp": 1764253638
    },
    {
        "content": "<p>Will the structure really be helpful? Don't forget that definitions are expensive in mathlib (in the sense that you need to develop a whole API around it to make it useful). For instance, the fact that the length of a curve in a Riemannian manifold is invariant under reparameterization is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Manifold.pathELength_comp_of_monotoneOn#doc\">docs#Manifold.pathELength_comp_of_monotoneOn</a> -- it doesn't use a structure, just stating the necessary properties of the reparameterization (which makes it easier to use in practice).</p>",
        "id": 560612928,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764254248
    },
    {
        "content": "<p>I get why it's easier not to create a structure in terms of having less work to do, but it seems to me like this theorem you sent is not very readable. Wouldn't it be more readable if instead of having many hypotheses for the reparametrization I would have just one saying that it is of type reparametrization? Just like in math textbooks we don't fold many definitions in every theorem we state - this would make theorems extremely long and unclear. Also, suppose for example that I work with concrete parametrized curves - let's say the unit sphere in R^2, and I proved that I have some reparametrization of it, then wouldn't it be more comfortable to use this in other theorems I want to use which have a reparametrization in as one of their assumptions? Anyways, I'm planing of writing a small  file with how I plan everything, and then I would like to create a new topic in the mathlib4 channel and ask for feedback about my plan.</p>",
        "id": 560617405,
        "sender_full_name": "Michael Novak",
        "timestamp": 1764255453
    },
    {
        "content": "<p>The theorem doesn't look readable in the docs because there are many typeclass assumptions. If you go to the source code, it's more readable: the code looks like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- The length of a path in a manifold is invariant under a monotone reparametrization. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">pathELength_comp_of_monotoneOn</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"bp\">‚Üí</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">‚â§</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MonotoneOn</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h'f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DifferentiableOn</span><span class=\"w\"> </span><span class=\"n\">‚Ñù</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hŒ≥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MDifferentiableOn</span><span class=\"w\"> </span><span class=\"n\">ùìò</span><span class=\"o\">(</span><span class=\"n\">‚Ñù</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Icc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">pathELength</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"bp\">‚àò</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pathELength</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">Œ≥</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>The assumptions on the reparameterization <code>f</code> are just that it's monotone on <code>[a, b]</code> and differentiable there. If you introduced a new definition for these reparameterizations, then you would also need to introduce another one for the antitone case, and then for the C^r case, and then maybe sometimes you want strict monotonicity instead of monotonicity, and maybe even positive derivative. If you introduce definitions for each of these classes, you will also need a lot of theorems saying that a strictly monotone reparameterization is also a monotone reparameterization, and that the composition of two antitone reparameterizations is a monotone reparameterization, with versions in the different classes of smoothness, and so on. In the end, you will need 1000 lines of boilerplate to make your definitions usable. Avoiding the definitions and going for the unbundled properties is just much much more practical!</p>",
        "id": 560619845,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764256110
    },
    {
        "content": "<p>Thank you for explaining this. It's hard for me to get used to this. Where do we draw the line? Obviously we do have structures in Mathlib, we don't state every theorem using the most primitive types in lean. I also remember I saw a talk on YouTube by Kevin Buzzard where he mentioned that there is value in just creating new definitions in lean.  But in this example especially I can't argue with your explanation.</p>",
        "id": 560639317,
        "sender_full_name": "Michael Novak",
        "timestamp": 1764262104
    },
    {
        "content": "<p>There is no clear cut line, it mostly comes with experience. A good way is to begin the development without the definition, prove interesting theorems, and then if afterwards you feel that a definition would have helped, make it and refactor. The other way around (start with the definitions) is worse as you can easily be stuck with a bad definition.</p>",
        "id": 560719870,
        "sender_full_name": "S√©bastien Gou√´zel",
        "timestamp": 1764314741
    }
]