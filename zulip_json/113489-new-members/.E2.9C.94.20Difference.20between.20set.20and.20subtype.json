[
    {
        "content": "<p>Hey! I'm struggling to understand the difference between sets and subtypes, and when should one be used instead of the other. I understand the type theoretic notion of considering a sigma type, and that if the dependent part is a proposition, then there is essentially no further information from an element lying in the sigma type, but I fail to understand the subtleties going on here. (Also, not sure what's the threshold for simple questions being considered \"spam\", so tell me before I reach it)</p>",
        "id": 269538986,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643272097
    },
    {
        "content": "<p>One easy answer is you can take unions and intersections of sets, but you can't do that with subtypes. THe other way around, a set can always be coerced to the corresponding subtype.</p>",
        "id": 269540369,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643272988
    },
    {
        "content": "<p>I would say that the one of the main differences is that is <code>S : set α</code> and <code>x ∈ S</code>, then <code>x</code> is of type <code>α</code>. This is not true for subtypes. For example, if <code>S = {n : ℝ | 0 ≤ n}</code>, then <code>(3 : ℝ) ∈ S</code> as expected, but if you use <code>S = {n : ℝ // 0 ≤ n}</code> and take <code>x : S</code>, then <code>x</code> is not a real number, so you cannot use directly all the result you have for real numbers (you can of course coerc it to a real number, but this is sometimes a pain).</p>",
        "id": 269540725,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643273223
    },
    {
        "content": "<p>ah, mmh, yes, sets are all of a common type, hence the ability to have operations on them (that was RE Yaël's response)</p>",
        "id": 269540745,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643273229
    },
    {
        "content": "<p>Do you have a specific example where you don't know which one to use?</p>",
        "id": 269540784,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643273257
    },
    {
        "content": "<p>I have an example where I was wondering, but it's not really an important one (just trying to figure things out:)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">signed</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">G</span>\n<span class=\"bp\">|</span> <span class=\"n\">tt</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"bp\">⁻¹</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">words</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"bp\">×</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">val</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">words</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">G</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(⟨</span><span class=\"n\">s</span> <span class=\"o\">,</span> <span class=\"n\">sgn</span><span class=\"o\">⟩</span> <span class=\"o\">::</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">signed</span> <span class=\"n\">s</span> <span class=\"n\">sgn</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"n\">tail</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">words_for</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">words</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">words</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">val</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">geods_for</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">words</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">w</span> <span class=\"bp\">∈</span>  <span class=\"o\">(</span><span class=\"n\">words_for</span> <span class=\"n\">T</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"bp\">∀</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">words_for</span> <span class=\"n\">T</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"o\">(</span><span class=\"n\">length</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>where I'm trying to define the word metric on a group.</p>",
        "id": 269540968,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643273390
    },
    {
        "content": "<p>I would say that <code>s : S</code> in the definition of <code>signed</code> is not a very good choice. <code>s⁻¹</code> doesn't make sense, since the type of <code>s</code> (i.e. <code>S</code>) is not a group. Here probably Lean is smart enough to automatically insert the coercion for you, and <code>s⁻¹</code> means \"send <code>s</code> to <code>G</code> and then take the inverse\", but if you start with <code>(s : G) (hs : s ∈ S)</code> this wouldn't be necessary.</p>",
        "id": 269541585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643273771
    },
    {
        "content": "<p>But the best way is to try and see what happens.</p>",
        "id": 269541701,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643273838
    },
    {
        "content": "<p>I mean, you can define <code>signed</code> on all of <code>G</code>, so why even bother mentioning <code>S</code>?</p>",
        "id": 269541816,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643273886
    },
    {
        "content": "<p>That's right, yes (though this snippet was just to show a place where I'm not sure of the best choice between subtype and set).</p>",
        "id": 269541912,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643273947
    },
    {
        "content": "<p>So, if I'm understanding the source right, subtype is really just a sigma type.</p>",
        "id": 269541956,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643273979
    },
    {
        "content": "<p>Here you are fixing a group <code>G</code> and working with its elements, so I suggest  to take everything of type <code>G</code>, so using sets.</p>",
        "id": 269542067,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643274013
    },
    {
        "content": "<p>Now, when I do <code>\\forall x : subtype</code>, I presumably have that <code>x</code> is a pair consisting of an element of the supertype, plus a proof of its satisfying the subtype-defining-predicate. What about <code>\\forall x \\in set</code> ?</p>",
        "id": 269542179,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643274072
    },
    {
        "content": "<p>Am I right that in the end, coercion and syntax sugar makes a lot of things look simpler than they are?</p>",
        "id": 269542230,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643274113
    },
    {
        "content": "<p>Also, what about the <code>{{_}}</code> notation?</p>",
        "id": 269542606,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643274326
    },
    {
        "content": "<p>This is a semi implicit argument. It behaves like an explicit argument until you pass a later explicit argument, in which case it acts as an implicit one.</p>",
        "id": 269542861,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643274482
    },
    {
        "content": "<p>Maybe looking at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monotone\">docs#monotone</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/convex\">docs#convex</a> will make it make sense</p>",
        "id": 269542919,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643274504
    },
    {
        "content": "<p>OK, so nothing to do with sets/subtypes/membership… good to know</p>",
        "id": 269542974,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643274542
    },
    {
        "content": "<p>OK, I think I'm wrapping my head around it, though I will need a few digestion days. Thanks!</p>",
        "id": 269543671,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643274967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">bottine</span> has marked this topic as resolved.</p>",
        "id": 269544214,
        "sender_full_name": "Notification Bot",
        "timestamp": 1643275335
    },
    {
        "content": "<p>In case you like this sort of explanation, the relationship between sets and subtypes is that the following commutative diagram is a pullback diagram:</p>\n<p><a href=\"/user_uploads/3121/AO3RoIEl1YTVmzA74mLK29Ad/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AO3RoIEl1YTVmzA74mLK29Ad/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/AO3RoIEl1YTVmzA74mLK29Ad/image.png\"></a></div><p>The <code>true -&gt; Prop</code> map send the proof of <code>true</code> to <code>true</code> itself (I could have also done <code>Unit -&gt; Prop</code>; any domain that's a singleton works). This map is a <a href=\"http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/subobject+classifier\">subobject classifier</a>.</p>\n<p>The type <code>set α</code> is a synonym for <code>α → Prop</code>, which is the type of the bottom map.  Given an injection <code>f : β → α</code>, there is a unique map <code>β → ↥s</code>, where <code>s : set α</code> is the image of <code>f</code>, and where this map fits in a commuting triangle with <code>f</code> and <code>↥s → α</code>.</p>\n<p><code>subtype</code> gives a universal construction for these <code>↥s</code> types.</p>",
        "id": 269546712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643276666
    },
    {
        "content": "<p>So, sets on <code>α</code> and isomorphism classes of injective maps to <code>α</code> are \"the same\" (at least conceptually), which justifies the coercion from sets to types via <code>subtype</code>.</p>",
        "id": 269547381,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1643277028
    },
    {
        "content": "<p>Yeah, I was just piecing together the fact that a set is just a predicate over the type at hand, and wondering if the subobject classifier concept tied in, here.</p>",
        "id": 269553601,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643280217
    },
    {
        "content": "<p>A subset in Lean is a term, and a subtype is a type. So, for example, you can't have functions from or to subsets (I mean, you can, but you have to promote them to subtypes first)</p>",
        "id": 269568607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1643288719
    },
    {
        "content": "<p>Mmh, that's something I hadn't thought of.</p>",
        "id": 269586542,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1643296332
    }
]