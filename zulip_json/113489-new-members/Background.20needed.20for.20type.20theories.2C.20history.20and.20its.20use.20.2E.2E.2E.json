[
    {
        "content": "<p>I joined the community for two months but have not really spent time to learn Lean and how it works. I find type theory is quite hard to follow and at this moment I am so confused about it. Could you please give me some information about  what to study. And a brief timeline of type theories and how they are used in theorem prover</p>",
        "id": 520062362,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748009162
    },
    {
        "content": "<p>this is a good overview written by the creator of Coq:</p>\n<p><a href=\"https://plato.stanford.edu/entries/type-theory/\">https://plato.stanford.edu/entries/type-theory/</a></p>",
        "id": 520064018,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1748009664
    },
    {
        "content": "<p>What are you goals? For example, if you are interested in formalizing calculus, linear algebra or similar stuff you can completely ignore type theory.</p>",
        "id": 520068405,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748010980
    },
    {
        "content": "<p>How did you start formalizing mathematics </p>\n<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Background.20needed.20for.20type.20theories.2C.20history.20and.20its.20use.20.2E.2E.2E/near/520068405\">said</a>:</p>\n<blockquote>\n<p>What are you goals? For example, if you are interested in formalizing calculus, linear algebra or similar stuff you can completely ignore type theory.</p>\n</blockquote>",
        "id": 520069607,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748011328
    },
    {
        "content": "<p>You can try the natural number game, most of us started with it. Then you can choose any theorem and try to formalize it. Of course if you want to learn the foundations of Lean this is also possible, but it is quite different from formalizing a theorem.</p>",
        "id": 520069876,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748011423
    },
    {
        "content": "<p>It's like when you learn calculus you don't really need to know how real numbers are defined, and you need even less to know the axioms of mathematics.</p>",
        "id": 520070027,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748011462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Background.20needed.20for.20type.20theories.2C.20history.20and.20its.20use.20.2E.2E.2E/near/520069876\">said</a>:</p>\n<blockquote>\n<p>You can try the natural number game, most of us started with it. Then you can choose any theorem and try to formalize it. Of course you want to learn the foundations of Lean this is also possible, but it is quite different from formalizing a theorem.</p>\n</blockquote>\n<p>How much different is big formalizing projects from formalizing normal mathematics</p>",
        "id": 520072440,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748012073
    },
    {
        "content": "<p>Like FLT. They have to plan out how to do it before start?</p>",
        "id": 520072952,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748012221
    },
    {
        "content": "<p>Which kind of mathematics is harder to formalize and what are the strategies to formalize it</p>",
        "id": 520074517,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748012691
    },
    {
        "content": "<p>I don't completely understand the question, the difference is similar to proving (on paper) a small result compared to a big theorem, it's a lot more work. You can find the details on the strategy in the <a href=\"https://imperialcollegelondon.github.io/FLT/blueprint/\">blueprint</a>.</p>",
        "id": 520074597,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748012713
    },
    {
        "content": "<p>In particular yes, it's <em>much better</em> to have a very precise paper proof before starting the formalization process. This is true for big projects but also for small resutls.</p>",
        "id": 520075482,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748012959
    },
    {
        "content": "<p>FLT for regular primes is not done yet, right?</p>",
        "id": 520081027,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748014677
    },
    {
        "content": "<p>It's done.</p>",
        "id": 520081182,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748014725
    },
    {
        "content": "<p>I think there was a lot of work<br>\nHow long it took to fully formalize it, and how many files, lines of code is it</p>",
        "id": 520083100,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748015385
    },
    {
        "content": "<p>You can have a look at the <a href=\"https://arxiv.org/abs/2410.01466\">paper</a>.</p>",
        "id": 520084359,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1748015836
    },
    {
        "content": "<p>Thank you, I will take a look at it</p>",
        "id": 520085003,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748016032
    },
    {
        "content": "<p>How about Curry Howard correspondence</p>",
        "id": 520147061,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748047188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"779253\">Matteo Cipollina</span> <a href=\"#narrow/stream/113489-new-members/topic/Background.20needed.20for.20type.20theories.2C.20history.20and.20its.20use.20.2E.2E.2E/near/520064018\">said</a>:</p>\n<blockquote>\n<p>this is a good overview written by the creator of Coq:</p>\n<p><a href=\"https://plato.stanford.edu/entries/type-theory/\">https://plato.stanford.edu/entries/type-theory/</a></p>\n</blockquote>\n<p>Type theory has been developed much and alter significantly compared to the one that was used in theorem provers in early days (Four Color Theorem verification)?</p>",
        "id": 520152652,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748052276
    },
    {
        "content": "<p>How much different it is from the early days to this day</p>",
        "id": 520152844,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748052464
    },
    {
        "content": "<p>Type theory has been around much longer than the proof of the Four Color Theorem. There has been a lot of research in type theory within the past few years (think of things like Rust's type theory, Homotopy type theory, etc.), but the type theory used by Lean specifically is extremely similar to that used by Coq at the time of the Four Color Theorem.</p>",
        "id": 520154396,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748053942
    },
    {
        "content": "<p>The two main learning resources for Lean are <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>, which is a learn-by-doing approach, and <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a>, which is a foundations-first approach. It sounds like you might be interested in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a>. Are you interested in learning a lot about the metalogical aspects of type theory because you are interested in type theory specifically, or are just interested in learning how Lean actually works? If the latter, I recommend you start out with <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a>.</p>\n<p>Learning the subject of type theory when you just want to use Lean is kind of like studying linguistics when you just want to learn a new language.</p>",
        "id": 520154709,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748054283
    },
    {
        "content": "<p>I want to know more about how Lean works and type theory. Formalizing mathematics is my secondary priority</p>",
        "id": 520155513,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748055172
    },
    {
        "content": "<p>In other words, I want to learn and understand how type theories (many different kinds) is served as the foundation of mathematics (I vaguely understand it, just knowing it is an alternative foundation replace set theory as way to avoid Russel Paradox). <br>\nCould you tell me the weakness and strength of each kind of type theory, and how it is implemented in the computer to construct mathematical objects in a way for computer to process</p>",
        "id": 520156855,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748056386
    },
    {
        "content": "<p>And about the relationship between computer science and mathematics</p>",
        "id": 520156891,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748056429
    },
    {
        "content": "<p>Those things are mentioned in many places but I want to truly understand it</p>",
        "id": 520157004,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748056561
    },
    {
        "content": "<p>I'm not the person to ask about learning many different type theories, but even though <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> only teaches you about one type theory, I still recommend it as a starting place for learning type theory because for some of the questions you have (like how the Curry-Howard correspondence works, and what's the relationship between CS and math) you only really need to know a single type theory. (Although of course its always insightful to learn more different type theories.)</p>",
        "id": 520160029,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748059448
    },
    {
        "content": "<p>The point of type theory is not to avoid Russell's paradox. Modern set theories avoid Russell's paradox by either not having a set of all sets, or restricting the axiom schema of specification. Type theory does have some advantages over set theory, but avoiding Russell's paradox is not really the purpose of type theory.</p>",
        "id": 520160225,
        "sender_full_name": "Niels Voss",
        "timestamp": 1748059657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/stream/113489-new-members/topic/Background.20needed.20for.20type.20theories.2C.20history.20and.20its.20use.20.2E.2E.2E/near/520160029\">said</a>:</p>\n<blockquote>\n<p>I'm not the person to ask about learning many different type theories, but even though <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> only teaches you about one type theory, I still recommend it as a starting place for learning type theory because for some of the questions you have (like how the Curry-Howard correspondence works, and what's the relationship between CS and math) you only really need to know a single type theory. (Although of course its always insightful to learn more different type theories.)</p>\n</blockquote>\n<p>I want to learn the type theory related to Lean first</p>",
        "id": 520162772,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748061923
    },
    {
        "content": "<p>And how earlier days theorem provers performed proving a statement</p>",
        "id": 520163524,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748062615
    },
    {
        "content": "<p>And some notable development in the field of automated theorem prover. Thank you so much</p>",
        "id": 520164274,
        "sender_full_name": "Anh Nguyễn",
        "timestamp": 1748063377
    },
    {
        "content": "<p>Type theory goes back to Russell, who was trying to develop the foundations of mathematics back in the days when a lot of things we take for granted nowadays were not so clear. Avoiding the paradoxes of set theory was not his only goal, but it was certainly something he had in mind. However, Russell's theory had a number of awkward features and has basically been abandoned.</p>\n<p>Then Church came along and developed \"simple type theory,\" based on the lambda-calculus. Simple type theory is still important today, and forms the basis for some proof assistants such as HOL Light. If you really want to understand type theory thoroughly, then mastering simple type theory is a pretty good way to start.</p>\n<p>The type theory in Lean, however, is more complicated. To motivate it, the following slightly fictionalized historical account may be helpful. Early designers of programming languages soon found that the notion of a type (and here I use \"type\" in the sense of a programming language such as C) was very useful; in particular, it would allow the compiler to catch a lot of bugs via a <em>type-checking</em> algorithm. They developed rather sophisticated typing systems and associated type-checking algorithms, all in the service of developing good programming languages, and not the foundations of mathematics. But at some point, it dawned on people that there was an extremely close parallel between the typing rules and the rules of logic (or at least, intuitionistic logic). This parallel is what we now call the Curry-Howard correspondence. The informal phrasing that I like is:</p>\n<p><em>Proof checking is isomorphic to type checking.</em></p>\n<p>So if you want to develop a proof assistant, you can simply steal the type-checking code from the compiler of a strongly typed programming language. Okay, maybe that's an oversimplification, but it's not far from the truth. It explains why, in Lean, a colon is used both for assertions (the technical term is \"judgments\") of the form \"n is a natural number\" (n : N) and for assertions of the form \"X is a proof of theorem T\" (X : T). In both cases, we verify the assertion by invoking a type-checking algorithm.</p>\n<p>If you have some background in axiomatic set theory, the type-theoretic practice of putting theorems and natural numbers (and other mathematical objects) on an equal footing takes some getting used to. The \"traditional\" approach defines a formal language by specifying the syntax, and then introducing mathematical structures as a semantic interpretation of the formal language. Proofs live in the syntactic world and mathematical structures live in the semantic world, and you have to be careful to keep the distinction clearly in mind. In type theory, or at least the kind of type theory used in Lean, proofs are on an equal footing with natural numbers and real numbers and other mathematical objects. In type theory, the rules for constructing complicated mathematical objects are therefore deeply intertwined with the rules of logic.</p>\n<p>This has the consequence that if you really want to learn type theory, you can't quite go about it the usual way that you learn, say, number theory or differential geometry or whatever. It's more like learning axiomatic set theory; you need to absorb a system of rules for manipulating expressions. Asking \"what is a type?\" is akin to asking \"what is a set?\"; there's no snappy answer that is fully accurate, since an accurate answer must specify the entire system of rules.</p>\n<p>As for where you can learn more details, I rather like the book \"Program = Proof\" by Samuel Mimram. Another good book is \"Type Theory and Formal Proof: An Introduction,\" by Nederpelt and Geuvers.</p>\n<p>One final comment. The Curry-Howard correspondence, which is a major motivation for modern type theory, gets a bit messy when you bring classical logic (the law of the excluded middle) into the picture. For this reason, many type-theoretic proof assistants have a strong constructive flavor. However, Lean, or at least mathlib, has embraced classical logic.</p>",
        "id": 545476610,
        "sender_full_name": "Timothy Chow",
        "timestamp": 1760670252
    },
    {
        "content": "<p>As an additional note on the bibliography, Samuel Mimram's book (or at least a version of it) is available on his webpage, in the \"Teaching\" section (for the Computational Logic course).</p>",
        "id": 545498299,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1760685053
    },
    {
        "content": "<p>Some bits of history a lot of people forget:</p>\n<ul>\n<li>In the first half of XX century, Brouwer–Heyting–Kolmogorov interpretation of logic was formulated</li>\n<li>Inspired by this interpretation, de Bruijn develops Automath (starting from 1967), the first proof assistant (proof checker really) based on dependent types</li>\n</ul>\n<p>In parallel to that</p>\n<ul>\n<li>In 1967, Errett Bishop publishes Foundations of Constructive Analysis, a groundbreaking work in constructive mathematics</li>\n<li>In 1972, Martin-Löf publishes his dependent type theory, with intend to give a formal ground for Bishop style constructive mathematics. Note, that in <a href=\"https://archive-pml.github.io/martin-lof/pdfs/Bibliopolis-Book-retypeset-1984.pdf\">https://archive-pml.github.io/martin-lof/pdfs/Bibliopolis-Book-retypeset-1984.pdf</a> Martin-Löf calls types \"sets\"</li>\n</ul>\n<p>So dependent type theory is a natural development of constructive mathematics.</p>",
        "id": 545503154,
        "sender_full_name": "suhr",
        "timestamp": 1760686970
    },
    {
        "content": "<p>Some history of Automath: <a href=\"https://alexandria.tue.nl/repository/freearticles/597627.pdf\">https://alexandria.tue.nl/repository/freearticles/597627.pdf</a></p>\n<p>History of constructivism in the 20th century: <a href=\"https://pure.uva.nl/ws/files/22817397/_Troelstra_A_S_History_of_Constructivism_in_the_2.pdf\">https://pure.uva.nl/ws/files/22817397/_Troelstra_A_S_History_of_Constructivism_in_the_2.pdf</a></p>",
        "id": 545504377,
        "sender_full_name": "suhr",
        "timestamp": 1760687392
    }
]