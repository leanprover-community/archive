[
    {
        "content": "<p>Hello all. I have my own copy of the natural numbers called MyNat defined in the familiar way:</p>\n<p>inductive MyNat where<br>\n  | zero : MyNat<br>\n  | succ : MyNat → MyNat</p>\n<p>I originally defined less than or equal relation as follows:</p>\n<p>def le (a b : MyNat) : Prop := ∃ c, b = a.add c</p>\n<p>This worked perfectly well for me, but I thought it would be interesting to use a definition that doesn't rely on <code>add</code>. Here is an alternative definition that was recommended to me:</p>\n<p>inductive le : MyNat → MyNat → Prop<br>\n  | refl (m : MyNat) : le m m<br>\n  | step (m n : MyNat) (h : le m n) : le m n.succ</p>\n<p>I like this definition conceptually but I'm struggling to prove the most basic things with it. Can someone give me a tip on how to prove, say, zero.succ is not less than or equal to zero? For inspiration I checked my proof that zero is not a successor but turns out it's just \"simp\".</p>",
        "id": 543636613,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759879560
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.not_succ_le_zero#src\">src#Nat.not_succ_le_zero</a></p>",
        "id": 543636724,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759879635
    },
    {
        "content": "<p>seems like a bunch of <code>nofun</code></p>",
        "id": 543636758,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759879673
    },
    {
        "content": "<p>do you know what <code>nofun</code> does</p>",
        "id": 543636774,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759879687
    },
    {
        "content": "<p>I'm not familiar with <code>nofun</code> but I had some inspiration right after I posted.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">succ_ne_zero</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">mz</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">succ_ne_zero</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eq2</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n</code></pre></div>",
        "id": 543638000,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759880676
    },
    {
        "content": "<p>Fun fact: the original version of the Natural Number Game (when it was just being passed around by Imperial students and wasn't on the web) had this definition of &lt;= and nobody could do anything with it ;-) (which is why I changed it for the web version). You just constantly have to prove things using the recursor i.e. do induction on &lt;=</p>",
        "id": 543638380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759880973
    },
    {
        "content": "<p>Note that your proof also works without any of the <code>have</code>s :-)</p>",
        "id": 543638468,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759881038
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n</code></pre></div>",
        "id": 543638698,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759881213
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨⟩</span>\n</code></pre></div>",
        "id": 543638754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759881254
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nofun</span>\n</code></pre></div>\n<p>as Aaron said</p>",
        "id": 543638948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759881413
    },
    {
        "content": "<p>Lean can show from what it knows about the inductive type that there aren't any cases to consider (in the sense that every case can be ruled out by the basic theory of inductive types e.g. distinct constructors gives distinct terms), so these wacky proofs work.</p>",
        "id": 543638998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759881450
    },
    {
        "content": "<p>In Lean 3 the corresponding proofs were just <code>.</code> and you would get a point whenever someone asked a question on the Zulip and you could prove it with <code>.</code>, this was like a hole in one when it came to code golf.</p>",
        "id": 543639111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759881545
    },
    {
        "content": "<p>Thanks, everyone. This gives me a lot to work with. So we have three very concise proofs of <code>¬ n.succ.le zero</code> here (and my long-winded proof).</p>\n<ol>\n<li><code>:= nofun</code> (Aaron)</li>\n<li><code>:= by intro; contradiction</code> (Robin)</li>\n<li><code>:= by rintro ⟨⟩</code> (Kevin)</li>\n</ol>",
        "id": 543643487,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759884940
    },
    {
        "content": "<p>can't we have just define <code>Nat.le</code> as <code>fun a b =&gt; Nat.ble a b = true</code></p>",
        "id": 543643611,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759885037
    },
    {
        "content": "<p>would make it a lot simpler</p>",
        "id": 543643623,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759885048
    },
    {
        "content": "<p>Here is another very obvious theorem: <code>theorem not_succ_le_self (n : MyNat) : ¬ n.succ.le n</code></p>\n<p>This is just another instance of \"distinct constructors give distinct terms\" as Prof. Buzzard put it. But once again I'm at a loss for a proof.</p>",
        "id": 543648999,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759889679
    },
    {
        "content": "<p>try <code>induction n</code></p>",
        "id": 543649158,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759889825
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.not_succ_le_self#src\">src#Nat.not_succ_le_self</a></p>",
        "id": 543649184,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759889857
    },
    {
        "content": "<p>Thanks Aaron. I got this far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This leaves us with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>So I could close this out if I had the following theorem:<br>\n<code>le_of_succ_le_succ {m n : MyNat} : m.succ.le n.succ → m.le n</code></p>\n<p>But I'm struggling with this one too. I tried induction on m and n and neither quite worked.</p>",
        "id": 543651057,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759891510
    },
    {
        "content": "<p>You can prove it without pattern matching as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">recOn</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_one_le_zero</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">any_zero</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"k\">from</span>\n<span class=\"w\">    </span><span class=\"bp\">λ</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">any_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"bp\">.</span><span class=\"n\">recOn</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ksz</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_ne_zero</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">ksz</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">recOn</span><span class=\"w\"> </span><span class=\"n\">not_one_le_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_succ_le</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Pattern matching definitely makes proving this much easier. But you can always do it in a low-level way if you find the high-level way too confusing.</p>",
        "id": 543670184,
        "sender_full_name": "suhr",
        "timestamp": 1759905881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"430667\">Martin Epstein</span> <a href=\"#narrow/channel/113489-new-members/topic/Ordering.20the.20natural.20numbers.20inductively/near/543651057\">said</a>:</p>\n<blockquote>\n<p>Thanks Aaron. I got this far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_self</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_succ_le_zero</span>\n<span class=\"w\">  </span><span class=\"n\">contrapose!</span><span class=\"w\"> </span><span class=\"n\">hn</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This leaves us with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>So I could close this out if I had the following theorem:<br>\n<code>le_of_succ_le_succ {m n : MyNat} : m.succ.le n.succ → m.le n</code></p>\n<p>But I'm struggling with this one too. I tried induction on m and n and neither quite worked.</p>\n</blockquote>\n<p>Oh yeah you also need to prove that one too</p>",
        "id": 543707512,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759918071
    },
    {
        "content": "<p>it's also induction you should do that first</p>",
        "id": 543707549,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1759918084
    },
    {
        "content": "<p>You should prove a&lt;=b iff there exist c such that b=a+c as soon as possible and then just use that for everything, IMO, if all you want to do is develop API. For example if you have the b=a+c result then m.succ &lt;= n.succ implies m&lt;=n is immediate assuming you have enough results about addition. In NNG I develop all the basic theory for addition in \"advanced addition world\" e.g. x+y=0 -&gt; x=0, a+b=a+c implies b=c etc, and this makes inequality world (the next world) relatively straightforward. I find all this struggling with induction on le much harder than the approach I adopted in NNG, although of course if you are specifically struggling for its own sake then maybe that's the point.</p>\n<p>My take on this is that the inductive definition of &lt;= looks very much like the inductive definition of naturals, and thinking about it with the b=a+c perspective shows you that the two constructors for inductive le are closely represented to zero and succ for c. So in some sense what you're doing is making a second more convoluted copy of the naturals with the inductive definition, and now you don't have access to any of the API you've proved for naturals because you now have this weird new copy instead. The b=a+c definition avoids this problem. That's why I think the le definition is harder to develop API for; basically you have to start again.</p>",
        "id": 543716642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759921073
    },
    {
        "content": "<p>Thanks Kevin, that's a useful way to look at it. Before trying out this inductive definition I had indeed made good progress with the additive definition. I got as far as proving<br>\n1^3 + 2^3 + ... + n^3 = (1 + 2 + ... + n)^2<br>\nThis might not look like a result about ordering, but my proof using telescoping series and this only works in the natural numbers if the order properties are favorable.<br>\nI also had another definition before the additive one: <code>m.le n \\iff m.sub n = zero</code>. This one is truly cursed ;)</p>\n<p>I took another stab at this inductive ordering business today and finally managed to prove a good reduction theorem: <code>le_iff_eq_or_le_pred</code>. Note that I have a predecessor operation <code>pred</code> defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">MyNat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Here is the theorem and proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_iff_eq_or_le_pred</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">left</span><span class=\"bp\">;</span><span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">      </span><span class=\"n\">right</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">pred</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pred</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">eq1</span>\n</code></pre></div>\n<p>With this I was able to prove <code>le_of_succ_le_succ</code> which opens a lot of doors.</p>",
        "id": 543800480,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759944455
    },
    {
        "content": "<p>Here is an alternative approach that doesn't use <code>pred</code>. It seems you can't use induction directly on <code>m.le n.succ</code> since the right side is not an atomic variable. But I found a workaround.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">left</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">right</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">succ_inj</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ha</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hm</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">eq1</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">step</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>",
        "id": 543808449,
        "sender_full_name": "Martin Epstein",
        "timestamp": 1759947361
    }
]