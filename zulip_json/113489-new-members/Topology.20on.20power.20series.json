[
    {
        "content": "<p>(Still trying to understand how things work in Mathlib, what is there and what is not)<br>\n(Also, not sure how to input Unicode characters - the VS code shortcuts don't work)</p>\n<p>Given a variable type <code>X</code> and a commutative semiring <code>R</code>, Mathlib has power series with coefficients in <code>R</code> and variable set <code>X</code> as <code>(X \\to\\0 \\N)\\to R</code> -- I understand <code>X\\to\\0 \\N</code> to describe monomials: function with finite support from <code>X</code> to <code>\\N</code>. So far, so good.</p>\n<p>But then, if I assume <code>R</code> to be a topological semiring (hence, a topological space), I would expect Lean to have an instance for <code>TopologicalSpace (MvPowerSeries X R)</code> (presumably via the <code>Pi</code> product construction), but <code>#synth</code> fails to find it.</p>\n<p>So, am I looking in the wrong place, or doesn't Mathlib have any topology on power series? (I would expect a power series to be the sum of its monomial terms, which in my mind should be true - maybe with a countable variable set? - even with the discrete topology on the ring of coefficients)</p>\n<p>Of course, Mathlib tends to do things with such generality (I never learned about filters in my youth, even though I live in Bourbaki territory), I might very well be missing important conditions, or looking in the wrong place.</p>",
        "id": 485227545,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1732972784
    },
    {
        "content": "<p>Surely it's reasonable to expect that different people might want different topologies on a multi-variable power series. To take an example from number theory, there are at least three topologies on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"double-struck\">p</mi></msub><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>T</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{\\Z_p}[[T]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">]]</span></span></span></span> which people use -- the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic topology, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>-adic topology, and the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>T</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(p,T)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mclose\">)</span></span></span></span>-adic topology. So it's probably dangerous to just make an instance in mathlib of a topology which then applies across the board. It wouldn't surprise me if mathlib has several topologies on power series but that none are activated by default. It also wouldn't surprise me if it has none. Let's try:</p>",
        "id": 485227821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732973023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span>  MvPowerSeries, TopologicalSpace</p>",
        "id": 485227831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732973035
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> nothing found</p>",
        "id": 485227832,
        "sender_full_name": "loogle",
        "timestamp": 1732973036
    },
    {
        "content": "<p>So indeed maybe there are none.</p>",
        "id": 485227878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732973046
    },
    {
        "content": "<p>The reason <code>#synth</code> won't work is that this line</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MvPowerSeries</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"bp\">→₀</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span>\n</code></pre></div>\n<p>will not be unfolded by typeclass synthesis: it can't see through the def.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"c1\">-- you can add naturals</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"c1\">-- Foo is the naturals</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"c1\">-- you can't add Foos (by default)</span>\n</code></pre></div>\n<p>This is by design. For example we definitely do <em>not</em> want typeclass inference to see through the definition when it comes to multiplication; if <code>R</code> has a multiplication then for any type <code>X</code>, the function type <code>X -&gt; R</code> will have a multiplication (pointwise), but if typeclass inference could see through the def then power series would have the <em>wrong</em> multiplication!</p>",
        "id": 485228105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732973225
    },
    {
        "content": "<p>Thanks! I knew (at least in some part of my head) that there were mechanisms designed so that typeclass inference would not pick the wrong instance. And of course I can imagine that people might want to use different topologies.</p>\n<p>But then, if one were to explicitly define (name) two different topologies for the same power series space, what would theorems using them look like? Would they have to mention the topology explicitly? Could one have, say, two namespaces where there would be different \"default\" topologies? (of course this is no longer specific to power series and topologies, just situations where more than one instance of a given typeclass for the same types would be \"natural\" in different contexts)</p>",
        "id": 485243673,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1732984817
    },
    {
        "content": "<p>You can make a topology a <code>local instance</code> and then typeclass inference only knows about it for a finite time (for example until the end of a file)</p>",
        "id": 485246024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732986719
    },
    {
        "content": "<p>There is an extant PR about this (<a href=\"https://github.com/leanprover-community/mathlib4/pull/14866\">#14866</a>).</p>",
        "id": 485248313,
        "sender_full_name": "David Loeffler",
        "timestamp": 1732988673
    },
    {
        "content": "<p>Another approach is to introduce a synonym for your type, this is what is done in the case of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp#doc\">docs#PiLp</a> for example</p>",
        "id": 485251265,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1732991096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/channel/113489-new-members/topic/Topology.20on.20power.20series/near/485251265\">said</a>:</p>\n<blockquote>\n<p>Another approach is to introduce a synonym for your type, this is what is done in the case of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp#doc\">docs#PiLp</a> for example</p>\n</blockquote>\n<p>Like: define a new name for \"power series with the product topology from the discrete topology on coefficients\" (formal power series), and _then_ declare an instance for this \"new type\"?</p>\n<p>I get the idea - but then do you still have access to the general theorems for the original type? Or do you have to \"manually convert\" to the original type?</p>",
        "id": 485251779,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1732991566
    },
    {
        "content": "<p>Yes, the moment you make a type synonym (like <code>Foo</code> above) you have to make a bunch of API for it, and the proofs are all \"abuse definitional equality and deduce it from the old thing\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"c1\">-- you can add naturals</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"c1\">-- Foo is the naturals</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">infer_instance</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_comm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"c1\">-- definitional abuse</span>\n<span class=\"c1\">-- etc etc</span>\n</code></pre></div>",
        "id": 485254308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732993947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/stream/113489-new-members/topic/Topology.20on.20power.20series/near/485251779\">said</a>:</p>\n<blockquote>\n<p>I get the idea - but then do you still have access to the general theorems for the original type? Or do you have to \"manually convert\" to the original type?</p>\n</blockquote>\n<p>As Kevin said it will cause a bit of duplication, but using things like <code>abbrev</code> or <code>reducible</code> will let a lot of tactics (though not the typeclass inference system directly) see through it, so in practice you will not have to duplicate everything (far from it in fact)</p>",
        "id": 485458193,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1733039420
    },
    {
        "content": "<p>In PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/14866\">#14866</a>, <span class=\"user-mention\" data-user-id=\"406490\">@María Inés de Frutos Fernández</span>  and I define the basic topology on power series, which is defined as the product topology when the coefficients are assumed to be endowed with <em>some</em> topology.  For the reason evoked by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , this topology is not made a global instance but can be summoned with <code>open scoped MvPowerSeries.PiTopology</code> (with the obvious variant for <code>PowerSeries</code>).</p>\n<p>There are a few subsequent PRs that allow to evaluate power series (<a href=\"https://github.com/leanprover-community/mathlib4/pull/15019\">#15019</a>, under good circumstances) and to make substitutions (<a href=\"https://github.com/leanprover-community/mathlib4/pull/15158\">#15158</a>). In particular, in this last PR, which is working but probably not yet in final form, it is shown how to endow the ring of coefficients with the discrete topology.</p>",
        "id": 485607514,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1733140695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> <code>abbrev</code> and <code>reducible</code> <em>do</em> let type class synthesis see through the type synonym. One quite inconvenient fact, which I found out only recently, is that Lean can even pull instances <em>backwards</em> through an <code>abbrev</code> <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span> .</p>",
        "id": 485614329,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1733142851
    },
    {
        "content": "<p>meaning if you have <code>abbrev Foo := Bar</code> and an instance for <code>Foo</code>, lean is able to synthesise that instance for <code>Bar</code>?</p>",
        "id": 485614477,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1733142915
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- `instAddNat`</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"c1\">-- `instAddNat` still found</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- `instBarFoo` oh no!</span>\n</code></pre></div>",
        "id": 485614792,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1733143017
    },
    {
        "content": "<p>The context in which I discovered this is that I wanted to make a type synonym for matrices with a specified norm (or rather, <span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span>  did). Since the matrices don't already have a norm, that's great! So I thought, we can just make an <code>abbrev</code> and get everything we want for free, and then just add the norm instance on the new type. But then after some headaches with a proof, I learned that Lean was inferring the new norm instance on <code>Matrix</code>.</p>",
        "id": 485615113,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1733143123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/113489-new-members/topic/Topology.20on.20power.20series/near/485614329\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <code>abbrev</code> and <code>reducible</code> <em>do</em> let type class synthesis see through the type synonym. One quite inconvenient fact, which I found out only recently, is that Lean can even pull instances <em>backwards</em> through an <code>abbrev</code> <span aria-label=\"fear\" class=\"emoji emoji-1f628\" role=\"img\" title=\"fear\">:fear:</span> .</p>\n</blockquote>\n<p><span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span> TIL I guess it’s one of those things I always believed for some reason so never bothered to check</p>",
        "id": 485616020,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1733143406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/channel/113489-new-members/topic/Topology.20on.20power.20series/near/485607514\">said</a>:</p>\n<blockquote>\n<p>In PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/14866\">#14866</a>, <span class=\"user-mention silent\" data-user-id=\"406490\">María Inés de Frutos Fernández</span>  and I define the basic topology on power series, which is defined as the product topology when the coefficients are assumed to be endowed with <em>some</em> topology. </p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> ! With some luck, I'll even manage to understand how it all works (meaning, the difference between the discrete case, which I had in mind, and the more case of a more general topology on the coefficients).</p>\n<p>Any idea when this will make its way into Mathlib?</p>",
        "id": 485617801,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1733143934
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/14866\">#14866</a> just landed!</p>",
        "id": 485617890,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1733143971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"726077\">@Philippe Duchon</span> the definition is the same: a sequence of power series <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> converges to a power series <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> if for each exponent <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span>, the $$d$$th coefficients of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> converge to that of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> (when the topology on the coefficients is discrete, that means ultimately equal).</p>",
        "id": 485624951,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1733146238
    }
]