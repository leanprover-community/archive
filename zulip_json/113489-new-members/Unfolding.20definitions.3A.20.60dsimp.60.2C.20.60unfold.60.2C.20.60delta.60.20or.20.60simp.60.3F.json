[
    {
        "content": "<p>When unfolding a definition, what are some good rules of thumb for deciding between <code>dsimp</code>, <code>unfold</code>, <code>delta</code>, or <code>simp</code>?</p>\n<p>For a simple definition, what is the idiomatic go-to choice, and which are better suited for special cases?</p>\n<p>My guess would be that the \"go-to choice\" would be <code>dsimp</code> or <code>unfold</code>, but I'm not certain about when should one use <code>dsimp</code> instead of <code>unfold</code>, and vice versa.</p>",
        "id": 540589679,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1758378846
    },
    {
        "content": "<p>Maybe we should remove a few of those :)</p>",
        "id": 540590761,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1758379867
    },
    {
        "content": "<p>i use <code>dsimp</code> when i have annotated some definitions as <code>simp</code>, <code>unfold</code> when not, and when i want to mix unfolding with non annotated simplication rules (not just definitions), i use <code>simp</code></p>",
        "id": 540616722,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1758408129
    },
    {
        "content": "<p><code>unfold foo</code> is basically the same as <code>dsimp only [foo]</code>, but I don't see the harm in having it. I've never used or even seen <code>delta</code> besides one or two times, isn't it one of those low-level tactics you're not supposed to use?</p>",
        "id": 540633697,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1758433351
    },
    {
        "content": "<p><code>dsimp</code> and <code>simp</code> are very different. The former only accepts lemmas that are definitionally true, which makes it much more robust as a way to just unfold definitions. Meanwhile <code>simp</code> accepts any collection of equalities/equivalences, and will rewrite and rewrite in some potentially arbitrary order until it can't simplify anymore. Due to the decreased robustness (a proof might break if you add or remove a <code>simp</code> lemma somewhere) the advice is to use it only as a finishing tactic (the last tactic in a block), or to explicitly specify the <code>simp</code> set using <code>simp only</code>.</p>",
        "id": 540634017,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1758433747
    },
    {
        "content": "<p>For educational purposes, I’ve tried collecting the different methods one might use to transform the goal <code>f = 3 ∧ True</code> into <code>1 + 2 = 3 ∧ True</code> (or further into <code>3 = 3 ∧ True</code>) given the definition <code>def f := 1 + 2</code>.</p>\n<p>The idea is to show tactics that you can reasonably expect to see \"in the wild\" in real Lean code.</p>\n<ol>\n<li>Am I missing any obvious method here (see examples below)?</li>\n<li>For this specific example, which approaches would be considered the most idiomatic, which are less idiomatic but still fine, and which would be regarded as unusual or \"weird\"?</li>\n</ol>",
        "id": 540636650,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1758437085
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 3 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">reduce</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 3 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 540636675,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1758437107
    },
    {
        "content": "<p>Bump: Is <code>unfold f</code> the idiomatic \"default choice\" for simple cases like the one in the example? If so, what are some good examples of when it makes sense to use one of the other eight alternatives listed above instead?</p>",
        "id": 541533120,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1758829339
    },
    {
        "content": "<p>the idiomatic default is to not rely on unfolding definitions</p>",
        "id": 541538949,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758831837
    },
    {
        "content": "<p>nobody needs to know that an ideal <code>I</code> being maximal is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/Ideal/Maximal.html#Ideal.IsMaximal\">defined to be</a> <code>IsCoatom I</code></p>",
        "id": 541539087,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758831898
    },
    {
        "content": "<p>nobody ever unfolds the definition of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Image.html#Finset.image\"><code>Finset.image</code></a>, you always use the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Image.html#Finset.mem_image\">Finset.mem_image</a>.</p>",
        "id": 541539323,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758832005
    },
    {
        "content": "<p>So ideomaric lean every def has a _mem or _def theorem even if it just repeats the def?</p>",
        "id": 541560132,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1758844206
    },
    {
        "content": "<p>honestly that's what I would prefer but they don't do that every time</p>",
        "id": 541560733,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758844531
    },
    {
        "content": "<p>let's say every non-low level def should have a _def theorem</p>",
        "id": 541560860,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758844626
    },
    {
        "content": "<p>actually that's exactly the job of <code>@[simps!]</code> to generate those helper theorems</p>",
        "id": 541560880,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758844641
    },
    {
        "content": "<p>(we call those the \"API\")</p>",
        "id": 541560891,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758844647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/channel/113489-new-members/topic/Unfolding.20definitions.3A.20.60dsimp.60.2C.20.60unfold.60.2C.20.60delta.60.20or.20.60simp.60.3F/near/541538949\">said</a>:</p>\n<blockquote>\n<p>the idiomatic default is to not rely on unfolding definitions</p>\n</blockquote>\n<p>I see your point.</p>\n<p>I suppose we can distinguish two scenarios:</p>\n<ol>\n<li>\n<p>There is an existing API (or we’re in a position to add one). In that case, we should prefer using the API rather than unfolding definitions. To be concrete: for the toy example below, what would the idiomatic API look like?</p>\n</li>\n<li>\n<p>There isn’t an API (and it’s not feasible for us to add one). In that situation, would <code>unfold f</code> generally  be considered the idiomatic \"default choice\" for the toy example? What are some good examples of when it makes sense to use one of the other eight alternatives listed above instead?</p>\n</li>\n</ol>\n<p>Toy example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 541906420,
        "sender_full_name": "Louis Cabarion",
        "timestamp": 1759079439
    },
    {
        "content": "<p>I think that in the toy example there is no need for any of the titular tactics:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"c1\">-- By hand, generally to be avoided</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 1 + 2 = 3 ∧ True</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n\n<span class=\"c1\">-- This should be part of the API</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">f_def</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- Now you can prove it as follows</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f_def</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 541908313,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1759081606
    },
    {
        "content": "<p>From a slightly further away perspective, whatever the <em>current</em> definition of <code>f</code> is, may change later on.  However, most likely, the fact that the current definition is actually <em>a valid definition</em> for <code>f</code> would not change.  So, the statement of the theorem <code>f_def</code> should still be true, just its proof may change.</p>\n<p>E.g., at some later point, someone may realize that actually it would be easier to define <code>f</code> as <code>10^700 - 10^700 + 3</code>, instead of <code>1 + 2</code>.  It is still true that <code>f</code> is equal to <code>1 + 2</code>, although the proof may no longer be <code>rfl</code> (in this toy example, the proof is still actually <code>rfl</code>, but the literal code that proves it breaks).</p>",
        "id": 541909750,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1759083251
    },
    {
        "content": "<p>Unfolding has a lot of legitimate use cases: </p>\n<ul>\n<li>unfolding your own definitions when you build your API</li>\n<li>unfolding definitions for lack of API (so extending APIs)</li>\n<li>unfolding programs for program proofs (not everything is math oriented)<br>\nI certainly miss a lot of use cases.</li>\n</ul>",
        "id": 541910882,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1759084625
    },
    {
        "content": "<p>the first two points still imply that API is better than unfolding (i.e. unfold only when building API), and the third point is out of my area so i can't comment.</p>",
        "id": 542718145,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1759404827
    }
]