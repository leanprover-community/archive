[
    {
        "content": "<p>I want to define a proposition like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">EachIsUnique</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">EachIsUnique</span><span class=\"w\"> </span><span class=\"n\">tail</span>\n</code></pre></div>\n<p>i.e. that each item is unique across the entire data structure; but I want to make this Prop agnostic as to the underlying data structure.</p>\n<p>I feel like this should be doable by generalising over any non-recursive, finite data structure – which I believe in Lean is all of them?</p>\n<p>The closest thing I found is the <code>Traversable</code> type class, with its <code>foldr</code> function. But that doesn't <em>quite</em> work. Because I don't just want to fold a single item into an accumulator, but I need to have a way to refer to the data structure as a whole – with the current item sliced off – in each iteration. See how my example does that by recursively matching on the <code>List</code> type and affirming that for each list head, the head is not contained in the tail.</p>\n<p>Is there a way to do this using <code>Traversable.foldr</code>? If not, what do you think would be a better way to do this?</p>",
        "id": 519070035,
        "sender_full_name": "aron",
        "timestamp": 1747651962
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Traversable.foldr#doc\">docs#Traversable.foldr</a>)</p>",
        "id": 519075316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747653283
    },
    {
        "content": "<p>I think you can do this by using <code>foldr</code> to flatten your datatype to a list, then using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Nodup#doc\">docs#List.Nodup</a> ?</p>",
        "id": 519075562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747653349
    },
    {
        "content": "<p>or even skipping <code>foldr</code> and instead using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Traversable.toList#doc\">docs#Traversable.toList</a> ?</p>",
        "id": 519077161,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1747653755
    }
]