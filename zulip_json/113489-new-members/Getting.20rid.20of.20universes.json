[
    {
        "content": "<p>How are universes different from stack size ?</p>\n<p>Why can't we get a big amount of them,  write unsafe paradoxical code, let the program increase the universe index at execution, crash once we reach a certain threshold.</p>",
        "id": 462370828,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1723649819
    },
    {
        "content": "<p>i'm sorry, i don't understand this question. maybe it would help if you first point out why universes <em>are</em> like stack size?</p>",
        "id": 462371703,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723650061
    },
    {
        "content": "<p>because in my mind universes are merely a device to make the system typecheck.</p>",
        "id": 462371936,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723650108
    },
    {
        "content": "<p>(and make sure you can't create an element of the <code>Empty</code> type and such)</p>",
        "id": 462372143,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723650148
    },
    {
        "content": "<p>I know it can avoid paradox, but at what cost ? I'd prefer my program to just crash if it finds one.</p>\n<p>What I write is not paradoxical (distributor composition !), yet I have to pay the price of showing it isn't, and it causes big modularity pb when you have to modify some universe before, because you used some element after...</p>\n<p>They are like stack size, as I understand them, in the sense that we are always proving we are below some amount (which can be - generally inferred - <code>max (max ... )</code>)</p>\n<p>If there is a way out, I want it.</p>",
        "id": 462374233,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1723650709
    },
    {
        "content": "<p>an easy way out if all you're really concerned with is programming, is generally not making your definitions universe-polymorphic.</p>",
        "id": 462374472,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723650786
    },
    {
        "content": "<p>if there is a specific issue you're running into where you'd like help, please post a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 462374896,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1723650922
    },
    {
        "content": "<p>Note that one of the main use of Lean is as a theorem prover, to do mathematics, so we need a solid axiomatic framework.</p>",
        "id": 462377458,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1723651680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257803\">Nicolas Rolland</span> <a href=\"#narrow/stream/113489-new-members/topic/Getting.20rid.20of.20universes/near/462370828\">said</a>:</p>\n<blockquote>\n<p>How are universes different from stack size ?</p>\n<p>Why can't we get a big amount of them,  write unsafe paradoxical code, let the program increase the universe index at execution, crash once we reach a certain threshold.</p>\n</blockquote>\n<p>Because having a program fail at runtime largely defeats the point of Lean? The entire point of all this complex dependent type theory and careful definitions is a static compile-time guarantees that your program is valid. </p>\n<p>Also, it reflects a real mathematical fact, which is that no sort of collection can contain all copies of itself -- there is no set of all sets, no type of all types, no category of all categories, etc. If you don't track universes, then you can prove <code>False</code>, which would make Lean useless as a proof assistant.</p>",
        "id": 462416297,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1723669072
    },
    {
        "content": "<p>You actually can have a set of all sets, and even having it be a member of itself, but making that consistent also requires a rather intricate setup. Of course you need to make some changes to other axioms to keep the whole thing from collapsing. <a href=\"https://leanprover-community.github.io/con-nf/\">Proving the consistency of one such system was one of the major recent successes in lean!</a></p>",
        "id": 462419547,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1723670778
    }
]