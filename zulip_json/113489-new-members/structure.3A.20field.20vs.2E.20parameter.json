[
    {
        "content": "<p>When defining a structure that depends on some type <code>α</code>, one can declare it either as a parameter or a field. Say I want to do something like this (which works well):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">draw_random</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">draw_random</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFintype</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mul_by_const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">draw_random</span>\n<span class=\"w\">  </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>But if I try to declare <code>α</code> as a field, then I run into the following problem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"n\">draw_random</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">G</span>\n<span class=\"w\">  </span><span class=\"n\">draw_random</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFintype</span><span class=\"w\"> </span><span class=\"n\">G</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mul_by_const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">draw_random</span>\n<span class=\"w\">  </span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- failed to synthesize HMul G (bar G).α ?m.14</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>Is there a way to have Lean realize that <code>(bar G).α</code> is actually <code>G</code>?</p>\n<p>As a side question, when should one prefer the field vs. parameter approach? MIL briefly touches the question in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C07_Structures.html#algebraic-structures\">Section7.2</a>:</p>\n<blockquote>\n<p>It is sometimes useful to bundle the type together with the structure, and Mathlib also contains a definition of a <code>Grp</code> structure that is equivalent to the following:</p>\n<p>structure Grp₁ where<br>\n  α : Type*<br>\n  str : Group₁ α</p>\n<p>The Mathlib version is found in <code>Mathlib.Algebra.Category.Grp.Basic</code>, and you can <code>#check</code> it if you add this to the imports at the beginning of the examples file.</p>\n<p>For reasons that will become clearer below, it is more often useful to keep the type <code>α</code> separate from the structure <code>Group α</code>.</p>\n</blockquote>\n<p>The parameter approach seems to facilitate class inference, are there other benefits? When is the field approach preferable?</p>",
        "id": 562654263,
        "sender_full_name": "Yannick Seurin",
        "timestamp": 1765278086
    },
    {
        "content": "<blockquote>\n<p>Is there a way to have Lean realize that <code>(bar G).α</code> is actually <code>G</code>?</p>\n</blockquote>\n<p><code>let x : G ← (bar G).draw_random</code></p>\n<p>Also in general you should use <code>Type*</code> rather than <code>Type</code>, like the MIL example you quoted, unless you have a good reason to not be generic over universes</p>",
        "id": 562788685,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765311176
    },
    {
        "content": "<p>The approaches you describe are bundled vs unbundled. I think the field version is the bundled one.<br>\nThe field approach with <code>Type</code>s isn't that useful AFAIK, but with other things it is.<br>\nFor example, graphs over vertices <code>V : Type*</code> currently have a type <code>Walk (u v : V)</code> where <code>u v</code> are the endpoints specified as parameters, but this makes it hard to compare walks with different endpoints.<br>\nThere's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs#SimpleGraph</a> which has the parameter <code>V : Type*</code>, whereas <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Graph#doc\">docs#Graph</a> has such a parameter but also a field <code>vertexSet : Set V</code> which makes it easier to work with graphs over a different set of vertices.<br>\nYou can also read <a class=\"stream-topic\" data-stream-id=\"287929\" href=\"/#narrow/channel/287929-mathlib4/topic/The.20design.20of.20matroids/with/486062017\">#mathlib4 &gt; The design of matroids</a> which I believe talks about similar problems.</p>",
        "id": 562789986,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1765311539
    },
    {
        "content": "<p>Thanks a lot for the pointers!</p>",
        "id": 562913809,
        "sender_full_name": "Yannick Seurin",
        "timestamp": 1765360327
    }
]