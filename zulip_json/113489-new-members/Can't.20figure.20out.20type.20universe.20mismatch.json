[
    {
        "content": "<p>When I define this data structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">hash</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DependentDisjointSet</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">valType</span>\n</code></pre></div>\n<p>I get this error when I set <code>valType</code> as the value to <code>Std.DHashMap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">valType</span>\n<span class=\"n\">argument</span>\n<span class=\"w\">  </span><span class=\"n\">valType</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">111</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"m\">111</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This doesn't happen when I set the return type of <code>valType</code> to just be a plain <code>Type u</code> instead of the <code>v</code> declared earlier in the type signature. I don't understand what the problem is though. How can I fix this?</p>",
        "id": 497188438,
        "sender_full_name": "aron",
        "timestamp": 1738435841
    },
    {
        "content": "<p>I'm not sure what you're going for here. The <code>valType</code> function gives values of <code>v</code>, but <code>DHashMap</code> wants a function that gives types for each value, not values of <code>v</code>.</p>",
        "id": 497189758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738436838
    },
    {
        "content": "<p>Let's try to use your definition as-is, ignoring the type error. Your definition is<br>\n<code>DependentDisjointSet {v : Type u} (k : Type u) [BEq k] [Hashable k] (valType : Std.HashSet k → v)</code></p>\n<p>I will substitute <code>v := Nat</code>, <code>k := Bool</code> and <code>valType := fun (s : Std.HashSet Bool) =&gt; s.size</code>. You can check that these are all type correct.<br>\nWhat type should <code>innerMap</code> have? According to your definition, it is a <code>Std.DHashMap (Std.HashSet Bool) fun s =&gt; s.size</code>.</p>\n<p>Let's try to insert a value. According to the signature of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DHashMap.insert#doc\">docs#Std.DHashMap.insert</a>, I need to provide a key of type <code>Std.HashSet Bool</code> first. I'll pick <code>{}</code>. Then, I need to provide a value of type <code>(fun s =&gt; s.size) {}</code>, which reduces to <code>0</code>. I need to provide a value of type <code>0</code>. What does that even mean?</p>\n<p>As you can see, I ran into a problem. Lean sees this problem in advance when type-checking your definition, and raises an <code>application type mismatch</code> error.</p>",
        "id": 497189842,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738436889
    },
    {
        "content": "<p>Hm so what I have in mind is for <code>v</code> to be something like <code>MyType n</code>, where <code>n</code> is a <code>Nat</code> that's derived from the key, which in this case is a <code>Std.HashSet Bool</code>. So the dependent type would be more like <code>fun s =&gt; MyType s.size</code> which for the empty key set would equal <code>MyType 0</code>.<br>\nDoes that make more sense? Or have I missed the point you're making?</p>",
        "id": 497190403,
        "sender_full_name": "aron",
        "timestamp": 1738437355
    },
    {
        "content": "<p>What you have in mind is great, but it doesn't stop the possibility of <code>v</code> being <code>Nat</code>. In fact, since the parameter <code>v</code> is a standalone type, it cannot depend on the key.</p>",
        "id": 497190849,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738437706
    },
    {
        "content": "<p>If you want to enforce this, do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DependentDisjointSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">DHashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 497191137,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738437918
    },
    {
        "content": "<p>The example I gave ran into a problem because <code>valType</code> could return something that wasn't a type, which I did by making it return a <code>Nat</code>. This is why the signature of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.DHashMap#doc\">docs#Std.DHashMap</a> requires its second argument to return a <code>Type v</code>.</p>",
        "id": 497191389,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738438108
    },
    {
        "content": "<p>Hmm ok I don't 100% understand the issue yet, but it does make sense to me that if <code>v</code> is a standalone type then it's not a dependent type.<br>\nThe truth is since I don't think I need to reference <code>v</code> outside of <code>valType</code>, I can just make <code>valType</code> have type <code>Std.HashSet k → Type u</code> and that works fine</p>",
        "id": 497192436,
        "sender_full_name": "aron",
        "timestamp": 1738439016
    }
]