[
    {
        "content": "<p>There is the following passage in chapter 12 of <em>Theorem Proving in Lean 4</em></p>\n<blockquote>\n<p>The following is an example of how function extensionality blocks computation inside the Lean kernel:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">f_eq_g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.zero_add</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Eq.recOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f_eq_g</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"c1\">-- does not reduce to 0</span>\n<span class=\"k\">#reduce</span><span class=\"w\"> </span><span class=\"n\">val</span>\n<span class=\"c1\">-- evaluates to 0</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">val</span>\n</code></pre></div>\n<p>First, we show that the two functions <code>f</code> and <code>g</code> are equal using function extensionality, and then we cast <code>0</code> of type <code>Nat</code> by replacing <code>f</code> by <code>g</code> in the type. Of course, the cast is vacuous, because <code>Nat</code>does not depend on <code>f</code>.</p>\n</blockquote>\n<p>I have a hard time figuring out what's in the last quoted paragraph. What does \"then we cast <code>0</code> of type <code>Nat</code> by replacing <code>f</code> by <code>g</code> in the type\" mean here? Any help greatly appreciated.</p>",
        "id": 449502692,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720276303
    },
    {
        "content": "<p>I have a same question.</p>",
        "id": 449744078,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1720400736
    },
    {
        "content": "<p>I never really feel that I understand what <code>cast</code> means, but I suspect that the point they are making is the following.</p>\n<ul>\n<li><code>f = g</code> is true by <code>funext</code> (<code>f_eq_g</code>).</li>\n<li><code>val</code> exploits this equality by essentially defining <code>val</code> to be <code>f 0</code> after you have replaced <code>f</code> by <code>g</code> using <code>f_eq_g</code>.</li>\n<li>Suddenly, <code>#reduce</code> does not see beyond the \"replace\" step and shows <code>#reduce val -- f_eq_g ▸ 0</code> (the black triangle of obscureness is <code>Eq.rec</code>, the term-mode entry point to \"I can't follow the proof anymore\" both for humans and for the kernel).</li>\n<li><code>#eval</code> gets it, though, and still shows <code>0</code>.</li>\n</ul>",
        "id": 449787636,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720421353
    },
    {
        "content": "<p>That's right. In general, given <code>x : T a</code> and <code>h : a = b</code>, <code>Eq.recOn h x</code> has type <code>T b</code>. You can think of this as casting the value of <code>x</code> from type <code>T a</code> to type <code>T b</code>, using the fact that <code>T a</code> and <code>T b</code> are provably equal. </p>\n<p>In the example, we are applying a silly cast to <code>0 : Nat</code>, where we say \"replace <code>f</code> by <code>g</code> in <code>Nat</code>.\" The result is an expression of type <code>Nat</code> that is just a \"renaming\" of 0. It evaluates to 0, but the presence of the cast breaks reduction.</p>",
        "id": 449794699,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1720423831
    }
]