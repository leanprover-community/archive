[
    {
        "content": "<p>I think I read about it in the past, but I forgot how to do it and I can't find this information now: How can you apply to a theorem with many implicit arguments only some of the implicit arguments that are not possible for lean to infer? For example I want apply arguments <code>f</code> and <code>n</code> in theorem <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iteratedDerivWithin_of_isOpen#doc\">docs#iteratedDerivWithin_of_isOpen</a>. Btw, why are these arguments in this theorem implicit to begin with? How could lean possibly infer them?</p>",
        "id": 574683720,
        "sender_full_name": "Michael Novak",
        "timestamp": 1771493683
    },
    {
        "content": "<p><code>foo (x := 1) (y := 2)</code></p>",
        "id": 574692271,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1771496543
    },
    {
        "content": "<p>Thank you very much!</p>",
        "id": 574692812,
        "sender_full_name": "Michael Novak",
        "timestamp": 1771496714
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=iteratedDerivWithin_of_isOpen#doc\">docs#iteratedDerivWithin_of_isOpen</a></p>",
        "id": 574719819,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771505705
    },
    {
        "content": "<blockquote>\n<p>Btw, why are these arguments in this theorem implicit to begin with? How could lean possibly infer them?</p>\n</blockquote>\n<p>They could be inferred by the context of the surrounding goal. So it wouldn't work with a <code>have h := ...</code>, you're right. Imagine that I have a conclusion of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">piecewise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDerivWithin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that I want to prove. Now I know that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Piecewise.html#continuousOn_piecewise_ite\">continuousOn_piecewise_ite</a> will be useful, so I could do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">continuousOn_piecewise_ite</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">(</span><span class=\"n\">iteratedDerivWithin_of_isOpen</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>for example. In this case, the arguments to <code>iteratedDerivWithin_of_isOpen </code> are inferred. Or another way this could appear is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">continuousOn_piecewise_ite</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">complicated</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">iteratedDerivWithin_of_isOpen</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>or something, so where I get a sidegoal for <code>Set.EqOn</code> and then it fills it in there.</p>",
        "id": 574746588,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1771512369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> <a href=\"#narrow/channel/113489-new-members/topic/Applying.20specifc.20implicit.20arguemnts/near/574746588\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Btw, why are these arguments in this theorem implicit to begin with? How could lean possibly infer them?</p>\n</blockquote>\n<p>They could be inferred by the context of the surrounding goal. So it wouldn't work with a <code>have h := ...</code>, you're right. Imagine that I have a conclusion of the form</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">ContinuousOn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">piecewise</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDerivWithin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">iteratedDeriv</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">ite</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>that I want to prove. Now I know that <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Piecewise.html#continuousOn_piecewise_ite\">continuousOn_piecewise_ite</a> will be useful, so I could do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">continuousOn_piecewise_ite</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">(</span><span class=\"n\">iteratedDerivWithin_of_isOpen</span><span class=\"w\"> </span><span class=\"bp\">?_</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>for example. In this case, the arguments to <code>iteratedDerivWithin_of_isOpen </code> are inferred. Or another way this could appear is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">continuousOn_piecewise_ite</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">fun_prop</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">complicated</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">iteratedDerivWithin_of_isOpen</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>or something, so where I get a sidegoal for <code>Set.EqOn</code> and then it fills it in there.</p>\n</blockquote>\n<p>That makes sense, thank you very much!</p>",
        "id": 574747128,
        "sender_full_name": "Michael Novak",
        "timestamp": 1771512500
    },
    {
        "content": "<p>Another reason for making arguments implicit (which does not apply here) is in <code>rw</code> lemmas: if you want to <code>rw</code> by a lemma, any argument that is present on both sides can usually be implicit. This is why, for instance, <code>f</code> is implicit in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=continuousOn_univ#doc\">docs#continuousOn_univ</a>.</p>",
        "id": 574747606,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1771512615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113489-new-members/topic/Applying.20specifc.20implicit.20arguemnts/near/574747606\">said</a>:</p>\n<blockquote>\n<p>Another reason for making arguments implicit (which does not apply here) is in <code>rw</code> lemmas: if you want to <code>rw</code> by a lemma, any argument that is present on both sides can usually be implicit. This is why, for instance, <code>f</code> is implicit in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=continuousOn_univ#doc\">docs#continuousOn_univ</a>.</p>\n</blockquote>\n<p>Thank you very much!</p>",
        "id": 574752299,
        "sender_full_name": "Michael Novak",
        "timestamp": 1771513667
    }
]