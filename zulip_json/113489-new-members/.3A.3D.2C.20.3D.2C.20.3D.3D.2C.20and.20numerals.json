[
    {
        "content": "<p>Hello, I am a lean4 beginner who is trying to grok <code>:=</code>, <code>=</code>, &amp; <code>==</code> (and also numerals).   </p>\n<p>I'm trying to develop an internal understanding of these symbols in lean which I present below, and was hoping others could provide critiques  or suggested reading to help me refine my understanding.  </p>\n<ul>\n<li><code>:=</code> is a core symbol in lean4.  It associates names (which appear on the left side) with lean4 expressions (that appear on the right) (with the understanding that the syntactic sugar for defining functions can make the left hand side look a little more involved than what I just said)</li>\n<li><code>=</code> is something you use when you do \"math in lean\"; it is one (of many) ways to build <code>Proposition</code>s,which can possibly be proven to be true or not.  <code>=</code> in lean4 is very, very different than <code>=</code> in common programming languages like python, java. etc.</li>\n<li><code>==</code> is something you use when programming in lean4;  It instructs the lean4 evaluator to reduce the expressions on the left and right (using rules for name lookup and reduction rules from lambda calculus) and then determine if the reduced expressions identical.  <code>==</code> triggers \"computation\"; it is similar to <code>==</code> in python</li>\n</ul>\n<p>Does this sound reasonable?</p>\n<p>Numerals:<br>\n(I probably need to move the numerals question into a separate topic...but it sort of feels like it is related to the above)<br>\n I am trying to understand to what extent the numeral 3 in the following contexts:</p>\n<ul>\n<li><code>if 3 == 4 ...</code></li>\n<li><code>nth_rewrite 3 ...</code></li>\n<li>\n<p><code>3 = 4 - 1</code><br>\nare represented as a single \"computational concept\" (I'm having trouble expressing this.) Basically do those <code>3</code>'s refer to wildly different parts of the lean4 code base or there a single computational concept (for simplicity a single location in the lean4 source code) for <code>3</code> that works for all three use cases. How does that actually work?  Where do I learn more about this?  What are some of the words I should be googling?  </p>\n</li>\n<li>\n<p>I'm wondering if <code>3</code> is always \"peano 3\" in all of the above, but that the compiler knows how to use <code>gmp</code> to optimize execution speed when creating code, but that is just an implementation detail separate from the core definition.   </p>\n</li>\n<li>I'm wondering if it would be possible to create theorems and proofs about <code>nth_rewrite 3</code> (and if not, is the issue because of <code>nth_rewrite</code> or <code>3</code> or both)</li>\n<li>and also hoping to not fall down a rabbit hole... <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></li>\n</ul>\n<p>Thanks for any help! - nehal</p>",
        "id": 504869074,
        "sender_full_name": "Nehal Patel",
        "timestamp": 1741705622
    },
    {
        "content": "<p>Keep in mind that <code>if x = 4 then ... else ...</code> can be quite similar to <code>if x == 4 then ... else ...</code>: it uses an instance of <code>Decidable</code> to decide if <code>x</code> equals <code>4</code> or not. So it also triggers computation.</p>",
        "id": 504871160,
        "sender_full_name": "suhr",
        "timestamp": 1741706058
    },
    {
        "content": "<p>Also, there's two kinds of computation in Lean: one is reduction (symbolic computation by the kernel) and the other one is evaluation (compiling to machine code and executing). Compilation erases proposition since they are indistinguishable (due to proof irrelevance).</p>",
        "id": 504873645,
        "sender_full_name": "suhr",
        "timestamp": 1741706594
    },
    {
        "content": "<p>(compilation also erases types)</p>",
        "id": 504874276,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741706736
    },
    {
        "content": "<p>with regard to your question about numerals: in <code>if 3 == 4 ...</code> and  <code>3 = 4 - 1</code>, <code>3</code> is used as a term, i.e. a thing which has a clear meaning in the type theory. The elaboration process uses instances and expected types to figure out in what type <code>3</code> should live, i.e. if <code>3</code> means a natural number, integer, real number, fraction, element of some ring, or whatever else.</p>\n<p>In <code>nth_rewrite 3 ...</code>, <code>3</code> is part of the specific notation of  the tactic <code>nth_rewrite</code>, used in a spot where (afaik) any positive numeral is accepted. this is used by the <em>compiler</em> to produce a <em>proof term</em>. at no point does lean try to find the type of 3, it is understood by the parser to be a simple numeral.</p>\n<p>Which is to say, lean has the following syntax rules (simplified):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"bp\">-</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">+</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\">  </span><span class=\"c1\">-- whole bunch of options, extensible</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nth_rewrite_syntax</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"nth_rewrite\"</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"s2\">\"[\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">,</span><span class=\"bp\">?</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"]\"</span>\n</code></pre></div>\n<p>in the first and third case lean follows the first and second syntax rules, whereas in the <code>nth_rewrite</code> case lean follows the first and third syntax rules.</p>",
        "id": 504878402,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741707498
    },
    {
        "content": "<p>i hope that makes sense</p>",
        "id": 504878574,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741707535
    },
    {
        "content": "<p>expanding a bit more after reading your question more carefully:<br>\nlean has the following (simplified) process of turning code into executable:<br>\nparse -&gt; elaborate -&gt; compile.<br>\nAt the parse step, lean determines if your use of a numeral like <code>3</code> is as a <code>term</code> or something else. If it is a term, at the elaborate step, lean uses contextual info to determine what type <code>3</code> should have. Then, at the compile step, lean uses the type info to choose the computational representation.</p>",
        "id": 504881761,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741708096
    },
    {
        "content": "<p>learning more about this can be done by reading the <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/01_intro.html\">metaprogramming in lean</a> book</p>",
        "id": 504882382,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741708204
    },
    {
        "content": "<p>Thanks! -- this is very helpful and gives me many threads to pull.</p>",
        "id": 504882566,
        "sender_full_name": "Nehal Patel",
        "timestamp": 1741708238
    }
]