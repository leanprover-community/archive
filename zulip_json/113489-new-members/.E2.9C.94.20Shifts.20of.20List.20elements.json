[
    {
        "content": "<p>Hi, I would like to have a function that shifts an element of a list by a natural number (an integer, in fact, but it should not be hard to build it from there). My two attempts so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Rotate</span>\n<span class=\"kn\">open</span> <span class=\"n\">Classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list_shift_nat</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">l.length</span>\n  <span class=\"k\">let</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">l.indexOf</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">%</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"n\">l</span>\n    <span class=\"bp\">·</span> <span class=\"n\">contradiction</span>\n    <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.mod_lt</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">l</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"bp\">%</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">list_shift_nat'</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">al</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span>\n <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">aesop</span>\n  <span class=\"k\">let</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">l.indexOf</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">i</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">l.rotate</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">isRotated_nil_iff.not.mpr</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The problem is that I don't know how to use these efficiently with rotations. For example, here's a proof of a simple lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list_shift_1_nat''</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">Nodup</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">list_shift_nat'</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">nodup</span>\n  <span class=\"k\">have</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">use</span> <span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">rfl</span>\n  <span class=\"n\">convert</span> <span class=\"n\">shift_nat_of_rot</span> <span class=\"n\">R</span> <span class=\"n\">nodup</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Eq.symm</span> <span class=\"bp\">$</span> <span class=\"n\">list_shift_1_nat</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Unfortunately, the above proof uses a custom lemma <code>shift_nat_of_rot</code>. Here's my best attempt to prove it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">shift_nat_of_rot</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span><span class=\"n\">r</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nodup₁</span><span class=\"o\">:</span> <span class=\"n\">Nodup</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">al₁</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">al₂</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list_shift_nat'</span> <span class=\"n\">l₁</span> <span class=\"n\">a</span> <span class=\"n\">al₁</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">list_shift_nat'</span> <span class=\"n\">l₂</span> <span class=\"n\">a</span> <span class=\"n\">al₂</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">l₁.length</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"n\">R</span>\n  <span class=\"k\">have</span> <span class=\"n\">len_eq</span> <span class=\"o\">:=</span> <span class=\"n\">length_rotate</span> <span class=\"n\">l₁</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">len_eq</span>\n  <span class=\"k\">have</span> <span class=\"n\">nodup₂</span> <span class=\"o\">:</span> <span class=\"n\">Nodup</span> <span class=\"n\">l₂</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hm</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">nodup_rotate.mpr</span> <span class=\"n\">nodup₁</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hm</span><span class=\"o\">,</span> <span class=\"n\">list_shift_nat'</span><span class=\"o\">,</span> <span class=\"n\">rotate_rotate</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">indexOf</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">l₁</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"bp\">%</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">indexOf</span> <span class=\"n\">a</span> <span class=\"n\">l₁</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction'</span> <span class=\"n\">m</span> <span class=\"k\">with</span> <span class=\"n\">M</span> <span class=\"n\">iM</span>\n    <span class=\"bp\">·</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">Nat.mod_eq_of_lt</span> <span class=\"bp\">$</span> <span class=\"n\">indexOf_lt_length.mpr</span> <span class=\"n\">al₁</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">iM</span><span class=\"o\">]</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_add</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">]</span>\n      <span class=\"n\">cases</span> <span class=\"n\">l₁</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">contradiction</span>\n      <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">h</span> <span class=\"n\">t</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Nat.succ_eq_add_one</span><span class=\"o\">]</span>\n          <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">rotate_rotate</span><span class=\"o\">]</span>\n          <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">rotate_eq_rotate'</span><span class=\"o\">]</span>\n          <span class=\"gr\">sorry</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">rotate</span> <span class=\"n\">l₁</span> <span class=\"o\">(</span><span class=\"n\">indexOf</span> <span class=\"n\">a</span> <span class=\"n\">l₁</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">rotate</span> <span class=\"n\">l₁</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">indexOf</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">rotate</span> <span class=\"n\">l₁</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">ring_nf</span><span class=\"bp\">;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">rotate_mod</span><span class=\"o\">]</span>\n    <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lhs</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">indexOf_lt_length.mpr</span> <span class=\"n\">al₂</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">len_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n    <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">rotate_mod</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">Nat.mod_eq_of_lt</span> <span class=\"n\">this</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rhs</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Am I missing something simple, or would you advise a different approch?</p>",
        "id": 364108168,
        "sender_full_name": "Vláďa Sedláček",
        "timestamp": 1686083027
    },
    {
        "content": "<p>Your lemma <code>shift_nat_of_rot</code> seems unlikely to be true if the lists don't have distinct elements.</p>",
        "id": 364155610,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1686109790
    },
    {
        "content": "<p>Good catch, I've added a Nodup assumption to the above code (and filled in one unrelated sorry). Still not sure how to proceed though; perhaps changing the definition to be compatible with List.get_rotate might be easier.</p>",
        "id": 364268979,
        "sender_full_name": "Vláďa Sedláček",
        "timestamp": 1686142379
    },
    {
        "content": "<p>Perhaps a simpler and more fundamental question is: how to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">List.Nodup</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">→</span> <span class=\"n\">List.indexOf</span> <span class=\"n\">b</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">intro</span> <span class=\"n\">nodup</span><span class=\"bp\">;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>? When a,b,c are replaced by concrete numbers or strings, a <code>rfl</code> is enough to close the goal, but this does not work if they stay abstract, even when α is replaced by ℕ. Are there any assumptions on α missing?</p>",
        "id": 364339631,
        "sender_full_name": "Vláďa Sedláček",
        "timestamp": 1686156496
    },
    {
        "content": "<p><del>That looks true but it's going to be very annoying</del></p>",
        "id": 364373165,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686164850
    },
    {
        "content": "<p>Note that it's true much more weakly for just <code>a \\ne b</code></p>",
        "id": 364373361,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686164899
    },
    {
        "content": "<p>I would guess you can then just use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.indexOf_cons_ne#doc\">docs4#List.indexOf_cons_ne</a></p>",
        "id": 364373573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1686164965
    },
    {
        "content": "<p>Thanks, that did the trick! I've switched back to the original definition of <code>list_shift_nat</code> and found a way to prove everything without <code>shift_nat_of_rot</code>; hopefully this will suffice for now.</p>",
        "id": 364393750,
        "sender_full_name": "Vláďa Sedláček",
        "timestamp": 1686171445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"613795\">Vladimír Sedláček</span> has marked this topic as resolved.</p>",
        "id": 364396920,
        "sender_full_name": "Notification Bot",
        "timestamp": 1686172622
    }
]