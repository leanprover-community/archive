[
    {
        "content": "<p>Hi all!<br>\nI think Lean is cool and I wanna learn it. However, I usually try to learn a language by making a game in it (like snake or flappy bird or something)<br>\nHowever, Lean isn’t a typical language, so would you recommend doing that or nah</p>",
        "id": 535624372,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755845047
    },
    {
        "content": "<p>I should also stress that I’m not talking about the math proof game server stuff, I’m talking about arcade style games</p>",
        "id": 535627830,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755846646
    },
    {
        "content": "<p>Well Lean is a full-featured programming language, so it is of course possible, although I don't know if any graphics apis exist. So you might have difficulty actually displaying things to the screen, and you might have to learn how lean's FFI works so you can hook up C code. (There is a <a href=\"https://github.com/kmill/lean4-raytracer\">raytracer</a> but I don't think it's real time, and it seems to be more like a demo.) Alternatively, you can use browser technologies, since you can embed HTML in Lean. If your primary motivation is to learn Lean programming, maybe a terminal game might be the least painful to create.</p>",
        "id": 535629913,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755847616
    },
    {
        "content": "<p>Are you at all interested in the proving side of Lean, or mostly just the programming side? For the programming side, I recommend reading Functional Programming in Lean 4, or at least enough to get familiar with the language. If you've used functional programming languages like Haskell before, you'll find it very familiar (a lot of the programming part of Lean was based on Haskell).</p>",
        "id": 535630172,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755847761
    },
    {
        "content": "<p>The proving side kinda sounds interesting, I might as welll learn it since it looks really foreign to me and it will probably be fun. </p>\n<p>This is gonna sound dumb, but I thought a fun way of using Lean would be to like have proofs of game mechanics. </p>\n<p>Not sure how that would work, but somehow being able to have a formal proof of something like Balatros game mechanics, and have the game rules all be proofs or something</p>",
        "id": 535631535,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755848392
    },
    {
        "content": "<p>Like could you somehow have a mathematical formal proof of flappy bird? Or Tetris?</p>",
        "id": 535632473,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755848869
    },
    {
        "content": "<p>Tetris is probably more interesting since you’d want to prove that you could play it forever</p>",
        "id": 535632560,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755848897
    },
    {
        "content": "<p>Well at the very least, there's the combinatorial games project <a href=\"https://github.com/vihdzp/combinatorial-games\">https://github.com/vihdzp/combinatorial-games</a>, where people are proving properties about various simple terminating games, such as Nim or Chomp. However it is more focused on the math side of games, like the ability to multiply and divide games and to use them to construct the surreal numbers.</p>\n<p>It is in theory possible to prove properties of nontrivial games like tetris, provided you have a precise statement of what you want to prove, but for something like tetris it will incredibly difficult.</p>",
        "id": 535634480,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755849692
    },
    {
        "content": "<p>I recommend that you code the snake game. It's simple, it has properties that are easy enough to prove.</p>",
        "id": 535635572,
        "sender_full_name": "(deleted)",
        "timestamp": 1755850146
    },
    {
        "content": "<p>Lean is a full fledged programming language. Go ahead and do it.</p>",
        "id": 535635734,
        "sender_full_name": "(deleted)",
        "timestamp": 1755850209
    },
    {
        "content": "<p>The first proof should be the player eventually loses!</p>",
        "id": 535635813,
        "sender_full_name": "(deleted)",
        "timestamp": 1755850238
    },
    {
        "content": "<p>Yes I agree. Even though snake is real time, you can model it as a turn-based game for the purposes of proving properties (as opposed to something like flappy bird). (Although I don't actually think the player must lose eventually if they never pick up any fruit)</p>",
        "id": 535636645,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755850613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950553\">Srayan Jana</span> <a href=\"#narrow/channel/113489-new-members/topic/using.20games.20to.20learn.20lean/near/535632560\">said</a>:</p>\n<blockquote>\n<p>Tetris is probably more interesting since you’d want to prove that you could play it forever</p>\n</blockquote>\n<p>IIRC this isn't true? I thought I once read that if you drop S and Z pieces in the ratio 1:sqrt(2) then the player is doomed for any finite board.</p>",
        "id": 535650689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755856583
    },
    {
        "content": "<p>I once tried to prove the correctness of the classical recursive algorithm for the hanoi tower. But I couldn't get it done</p>",
        "id": 535654681,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1755858335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/using.20games.20to.20learn.20lean/near/535650689\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"950553\">Srayan Jana</span> <a href=\"#narrow/channel/113489-new-members/topic/using.20games.20to.20learn.20lean/near/535632560\">said</a>:</p>\n<blockquote>\n<p>Tetris is probably more interesting since you’d want to prove that you could play it forever</p>\n</blockquote>\n<p>IIRC this isn't true? I thought I once read that if you drop S and Z pieces in the ratio 1:sqrt(2) then the player is doomed for any finite board.</p>\n</blockquote>\n<p>Most modern Tetris games use a bagging system which guarantees the frequency of pieces is 1:1:1:1:1:1:1 and for which play-forever strategies have been devised.</p>",
        "id": 535655936,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755858895
    },
    {
        "content": "<p>How it works is they drop one of every piece in a random order, and then they keep doing that, so the first 7n pieces will have n of each piece.</p>",
        "id": 535656601,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755859175
    },
    {
        "content": "<p>For dropping pieces with independent uniform distribution every strategy loses with probability 1.</p>",
        "id": 535656743,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755859247
    },
    {
        "content": "<p>Tower of Hanoi would be a nice project. Widgets offer you a GUI so you can play yourself, small boards could be solved by brute force, and then one could prove a theorem giving an optimal algorithm for moving an n-tower from one column to another.</p>",
        "id": 535658061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1755859765
    },
    {
        "content": "<p>In my very early days as an undergrad, we were shown the recursive algorithm for the tower of hanoi. It looked like magic. Maybe a theorem proving that it was correct would have made it less magical</p>",
        "id": 535661452,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1755861195
    },
    {
        "content": "<blockquote>\n<p>Maybe a theorem proving that it was correct would have made it less magical</p>\n</blockquote>\n<p>The proof would likely to be essentially the same (induction = recursion). Proving that it's the best you can do is probably more tricky though.</p>",
        "id": 535663538,
        "sender_full_name": "suhr",
        "timestamp": 1755862087
    },
    {
        "content": "<p>The proof has to use the algorithm definition and state that it turns the initial state into the final state (all disks were moved and no illegal move was performed). With just the algorithm, you can run it a few times to test if it works and that's pretty much it</p>",
        "id": 535664080,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1755862349
    },
    {
        "content": "<p>This is a page on the Tetris wiki that talks about how you could potentially play forever, and also links to some research papers on the subject.<br>\nNow i kinda want to write a proof for a failstate for Tetris in Lean, I think that could be really neat<br>\n<a href=\"https://tetris.wiki/Playing_forever\">https://tetris.wiki/Playing_forever</a></p>",
        "id": 535726777,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1755883721
    },
    {
        "content": "<p>One simple exercise for programming in Lean is to generate levels for the game 4D Golf in the style of RollerCoaster Tycoon.</p>\n<p>Here is my attempt:<br>\n<a href=\"https://github.com/madvorak/lean4-koch\">https://github.com/madvorak/lean4-koch</a></p>",
        "id": 536030931,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1756130221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950553\">Srayan Jana</span> <a href=\"#narrow/channel/113489-new-members/topic/using.20games.20to.20learn.20lean/near/535632560\">said</a>:</p>\n<blockquote>\n<p>Tetris is probably more interesting since you’d want to prove that you could play it forever</p>\n</blockquote>\n<p>FYI, formally proving (non)existence of certain strategies for Tetris has been suggested several times.<br>\nEvery time, the conclusion was that it would be a nightmare to implement.</p>",
        "id": 536031399,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1756130356
    }
]