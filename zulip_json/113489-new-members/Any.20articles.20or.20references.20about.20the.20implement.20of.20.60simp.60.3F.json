[
    {
        "content": "<p>I want to understand the specific implementation principles of the <code>simp</code> tactic. I am currently reading the source code for <code>simp</code>, but I feel that I lack some background knowledge (or prerequisite knowledge), which makes it somewhat difficult. I would like to ask if there are any articles that directly and thoroughly explain the specific principles behind <code>simp</code>?</p>\n<p>I have already read <a href=\"https://leanprover-community.github.io/extras/simp.html\">Simp</a>, but this article does not delve into the specific implementation details.</p>",
        "id": 476884824,
        "sender_full_name": "White Chen",
        "timestamp": 1728961587
    },
    {
        "content": "<p>I have already read most of <strong>Type Theory and Formal Proof: An Introduction</strong>. To understand the implementation of the <code>simp</code> tactic, are there any additional books or articles I should read?</p>",
        "id": 476885233,
        "sender_full_name": "White Chen",
        "timestamp": 1728961780
    },
    {
        "content": "<p>Are you familiar with how <code>rw</code> works?</p>",
        "id": 476917812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1728976220
    },
    {
        "content": "<p>I apologize for the late reply.</p>\n<p>Before reading the <code>simp</code> code, I hadn't really read the implementation of <code>rw</code>. However, I've just studied it, and I believe I can understand the implementation of <code>rw</code>. To ensure I truly understand it, I'd like to briefly explain my understanding of <code>rewrite</code>:</p>\n<p>I think the key to <code>rewrite</code> lies in the <code>_root_.Lean.MVarId.rewrite</code> function. In this function, I believe the most important lines are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eAbst</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">withConfig</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">oldConfig</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">config</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">oldConfig</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"o\">})</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">kabstract</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"w\"> </span><span class=\"n\">config</span><span class=\"bp\">.</span><span class=\"n\">occs</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eNew</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eAbst</span><span class=\"bp\">.</span><span class=\"n\">instantiate1</span><span class=\"w\"> </span><span class=\"n\">rhs</span>\n</code></pre></div>\n<p>These two lines accomplish the rewriting behavior we want.</p>\n<p>The first line abstracts all occurrences of <code>p</code> in our target expression <code>e</code> as a loose bound var. To match all occurrences of <code>p</code> in <code>e</code>, we define a recursive <code>visit</code> function in <code>kabstract</code>. This recursive function first checks if the entire expression <code>e</code> is definitionally equal to <code>p</code> (actually, it first checks <code>e.toHeadIndex</code> and <code>e.headNumArgs</code> for performance). If not equal, it uses <code>visitChildren</code> to recursively check if <code>e</code>'s subexpressions are definitionally equal to <code>p</code>.</p>\n<p>The second line then instantiates this newly created loose bound var with <code>rhs</code>.</p>\n<p>Of course, this isn't the entirety of <code>rewrite</code>. Subsequently, <code>rewriteTarget</code> or <code>rewriteLocalDecl</code> is needed to replace the old <code>goal</code> or <code>local declaration</code>, as well as <code>replaceMainGoal</code>. My understanding of this part isn't very deep, but I don't think it affects my understanding of the <code>rewrite</code> implementation mechanism, so I'll skip it.</p>\n<p>This is my understanding of <code>rewrite</code>. If there are any errors or omissions, please feel free to point them out and provide additional information.</p>\n<p>Next, I'd like to add to my original question.</p>\n<p>Regarding the motivation for studying <code>simp</code>: Initially, I planned to study (or even participate in) the <code>aesop</code> project, but due to unfamiliarity with meta-programming and functional programming, I was forced to temporarily abandon this plan. Instead, I decided to study some commonly used tactics first. (Of course, I should have started with <code>rw</code>; <code>simp</code> seems more complex than I imagined.)</p>\n<p>While reading the <code>simp</code>-related code, I did encounter some specific difficulties, such as <code>DiscrTree</code>, <code>Simproc</code>, <code>Method</code>, etc., but I guess it would be better to create dedicated topic threads to inquire about these?</p>",
        "id": 477002143,
        "sender_full_name": "White Chen",
        "timestamp": 1729002300
    },
    {
        "content": "<p><code>simp</code> is a fairly complicated tactic, since it has a lot of features yet needs to be efficient, but the core idea is that given a term <code>e</code>, simp will produce a proof of an equality <code>h : e = e'</code>. If <code>?g</code> is the goal and <code>?g : e</code>, then you can use <code>h</code> to form a new goal <code>?g' : e'</code> and assign <code>?g := cast (Eq.symm h) ?g'</code>.</p>\n<p>The algorithm is recursive and iterative. Suppose's looking at <code>e</code>. In its basic form:</p>\n<ol>\n<li>It looks for a <code>@[simp↓]</code> lemma (a \"pre simp lemma\") whose LHS matches <code>e</code> exactly. Then <code>e'</code> is the resulting RHS and the simp lemma is the proof of <code>e = e'</code>. If this succeeds, start step 1 again with <code>e'</code> to get <code>e''</code> and use <code>Eq.trans</code> to chain the equalities.</li>\n<li>It constructs a <em>congruence lemma</em> using <code>e</code>. For example, if <code>e</code> is <code>f x y</code>, it will construct a lemma <code>a = a' -&gt; b = b' -&gt; f a b = f a' b'</code>. Simp recurses, simplifying <code>x</code> to <code>x'</code> and <code>y</code> to <code>y'</code>. The resulting equalities are plugged into the congruence lemma, and the result is <code>f x' y'</code>. Or, if <code>e</code> is a <code>fun</code>, it will use <code>funext</code> to \"enter\" the function.</li>\n<li>It tries step one again but with the <code>@[simp]</code> lemmas (the \"post simp lemmas\", the default). If it succeeds, start again from step 1.</li>\n<li>Otherwise, return that nothing happened. The result is <code>e</code> with proof <code>rfl : e = e</code>.</li>\n</ol>\n<p>Here are a couple explanations I found that I'd written before on <code>simp</code> and its relationship to <code>rw</code> (it's a very different algorithm):<br>\n<a href=\"#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391348828\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/simp.20vs.20rw.20again/near/391348828</a><br>\n<a href=\"#narrow/stream/270676-lean4/topic/SimpTheorems/near/408624455\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/SimpTheorems/near/408624455</a><br>\n<a href=\"#narrow/stream/113488-general/topic/algorithmic.20documentation.20of.20simp/near/278613746\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algorithmic.20documentation.20of.20simp/near/278613746</a></p>",
        "id": 477015776,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729006264
    },
    {
        "content": "<p>The <code>conv</code> tactic uses <code>simp</code>-like machinery (congruence lemmas and <code>funext</code>) to navigate into subexpressions.</p>",
        "id": 477016118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729006340
    },
    {
        "content": "<p><code>DiscrTree</code> is a data structure to accelerate looking for applicable simp lemmas.</p>\n<p>A simproc is a simplification procedure that can do arbitrary transformations to an expression. Each simp lemma can be thought of as a simple simproc that matches on some specific LHS pattern and replaces it with a specific RHS. You can make simprocs to add together number literals for example, something you can't do with simp lemmas.</p>\n<p>A <code>Method</code> corresponds to actions that occur at different steps of the simp algorithm, like whether to apply <code>@[simp]</code> lemmas at all. It's highly configurable.</p>",
        "id": 477020156,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729007542
    }
]