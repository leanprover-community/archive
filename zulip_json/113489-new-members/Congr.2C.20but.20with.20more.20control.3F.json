[
    {
        "content": "<p>In UniMath, we have a lemma <code>maponpaths</code>, that takes a function <code>f</code> and an equality <code>a = b</code>, and returns <code>f a = f b</code>. How is such functionality implemented in lean?<br>\nFrom Mathematics In Lean, I gathered that there is a <code>congr</code> tactic, but it seems that I have no control over which \"function\" is applied. For example,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom_inv_id</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">stdSimplex</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">hom</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>\n<p>I want to remove the <code>≫ g</code> part on both sides. But if I use <code>congr</code>, I get 4 new goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"w\"> </span><span class=\"bp\">≫</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">SimplexCategory</span><span class=\"bp\">.</span><span class=\"n\">δ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">unop</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">hom_inv_id</span><span class=\"w\"> </span><span class=\"bp\">≍</span><span class=\"w\"> </span><span class=\"n\">hom</span>\n</code></pre></div>\n<p>Is there a tactic or lemma version of congr that provides more control?</p>",
        "id": 565774497,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767092710
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=congr_arg#doc\">docs#congr_arg</a> is the exact thing you ask for</p>",
        "id": 565776998,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767094209
    },
    {
        "content": "<p>Ah, right. Thanks! ^^</p>",
        "id": 565777085,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767094276
    },
    {
        "content": "<p>But a more general option would to use <code>congr(f $h)</code> where <code>h : a = b</code></p>",
        "id": 565777121,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767094303
    },
    {
        "content": "<p>Can you give an example of how you'd use the congr tactic here?</p>",
        "id": 565787537,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767100464
    },
    {
        "content": "<p><code>congr</code> converts <code>f a_1 ... a_n = g b_1 ... b_n</code> to goals <code>f = g</code>, <code>a_1 = b_1</code>, ..., <code>a_n = b_n</code>. You can use <code>congr 1</code> to get two goals: <code>f a_1 ... a_{n-1} = g b_1 ... b_{n-1}</code> and <code>a_n = b_n</code>. You didn't provide an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> but I'm guessing you probably want to use <code>congr 1</code> or <code>congr 2</code>.</p>",
        "id": 565799370,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1767107728
    },
    {
        "content": "<p>you can also do things like <code>congrm constant + ?_ + $h</code> for a goal <code>constant + a + b = constant + c + d</code>. <code>?_</code> creates a new subgoal <code>a = c</code>. <code>$h</code> plugs in an existing hypothesis <code>h: b = d</code></p>",
        "id": 565807829,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1767112420
    },
    {
        "content": "<p>Thanks! That gives a lot of good options</p>",
        "id": 565808621,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767112939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"406521\">Arnoud van der Leer</span> <a href=\"#narrow/channel/113489-new-members/topic/Congr.2C.20but.20with.20more.20control.3F/near/565787537\">said</a>:</p>\n<blockquote>\n<p>Can you give an example of how you'd use the congr tactic here?</p>\n</blockquote>\n<p>I would do something like <code>congr 1</code>, or whatever small number makes it most useful</p>",
        "id": 565811072,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1767114495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/113489-new-members/topic/Congr.2C.20but.20with.20more.20control.3F/near/565807829\">said</a>:</p>\n<blockquote>\n<p>you can also do things like <code>congrm constant + ?_ + $h</code> for a goal <code>constant + a + b = constant + c + d</code>. <code>?_</code> creates a new subgoal <code>a = c</code>. <code>$h</code> plugs in an existing hypothesis <code>h: b = d</code></p>\n</blockquote>\n<p>And <code>congrm?</code> as an interactive version (filling the pattern automatically by user's click).</p>",
        "id": 565940909,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767225079
    },
    {
        "content": "<p>That is really useful!</p>",
        "id": 565986470,
        "sender_full_name": "Arnoud van der Leer",
        "timestamp": 1767283158
    }
]