[
    {
        "content": "<p>It seems there are functions such as</p>\n<p><code>UIntX.ofNat </code> as well as <code>Int.ofNat</code>, <code>Float.ofNat</code>, <code>Fin.ofNat</code> etc.  Most of these also have a corresponding <code>T.toNat</code> (with the exception of Float and Fin, which potentially seems like an omission)</p>\n<p>However, I can't seem to find any <em>type classes</em> which would support these operations, which makes it hard to write generic numeric code.  Does something like that exist?  Do I need to somehow manually invoke <code>Coe.coe</code>?</p>",
        "id": 472444189,
        "sender_full_name": "Tom",
        "timestamp": 1727169837
    },
    {
        "content": "<p>Hi, maybe you've seen <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Coe.html#Coercion\">this page</a> from the docs,  that shows the typeclass Coe being instantiated with two parameters:</p>\n<p><code>instance : Coe Nat Int := ⟨Int.ofNat⟩</code></p>\n<p>As for manually invoking a coercion, are you familiar with the up arrow? From the same page ^^</p>\n<blockquote>\n<p>You can also use the <code>↑</code> operator to explicitly indicate a coercion.</p>\n</blockquote>\n<p>Maybe posting a specific piece of code that demonstrates the problematic generic code would help others pin down better suggestions.</p>",
        "id": 472529188,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1727194610
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatCast#doc\">docs#NatCast</a></p>",
        "id": 472529311,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727194657
    },
    {
        "content": "<p>If you want to write proofs I think you should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=AddMonoidWithOne#doc\">docs#AddMonoidWithOne</a> (and strengthen it if you need stronger assumptions)</p>",
        "id": 472532322,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727195625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/Missing.20numeric.20conversion.20type.20classes.3F/near/472529311\">said</a>:</p>\n<blockquote>\n<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NatCast#doc\">docs#NatCast</a></p>\n</blockquote>\n<p><code>Nat.cast</code> is the preferred spelling of the function performing the coercion</p>",
        "id": 472535633,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727196831
    },
    {
        "content": "<p>Hi, </p>\n<p>Thanks everyone for helping me out and the pointers to documentation.  I really appreciate it.  As I mentioned, I was \"aware\" of the <code>Coe</code> type class but perhaps using it wrong.  Let me write down some examples of the kinds of issues I was running into:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"bp\">.</span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"c1\">-- Does not work (why?)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\">     </span><span class=\"c1\">-- Docs say this is an alternate syntax for \"uparrow\".</span>\n<span class=\"w\">                                       </span><span class=\"c1\">-- Not sure why I have to spell the \"current\" type again unless it's something hardcoded</span>\n<span class=\"w\">                                       </span><span class=\"c1\">-- in the parser?</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">nat</span>\n</code></pre></div>\n<p>Why does the explicit type class syntax not work?  My understanding is that that's what's the \"sugar\" is doing.</p>",
        "id": 472553003,
        "sender_full_name": "Tom",
        "timestamp": 1727203182
    },
    {
        "content": "<p>Now, while this seems to work for the above, the following examples do not work for me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Does not work</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"w\">                                 </span><span class=\"c1\">-- Does not work</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">float</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mf\">1.3</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">float</span><span class=\"w\">                                 </span><span class=\"c1\">-- Does not work</span>\n</code></pre></div>\n<p>Now, I am guessing that this is because these conversions are not \"safe\" in the numeric sense but then that would mean that <code>Coe</code> cannot apply to these things in day-to-day programming when I know it's safe and don't want to have to prove.  Interestingly, all the <code>toNat</code> etc functions which are associated with specific types happily convert back and forth by e.g. just throwing away bits.</p>",
        "id": 472553532,
        "sender_full_name": "Tom",
        "timestamp": 1727203364
    },
    {
        "content": "<p>To further understand/illustrate my point, I wrote a helper</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test_conversions</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\">  </span><span class=\"n\">Nat</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">conv</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ret_conv</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">conv</span>\n<span class=\"w\">  </span><span class=\"n\">ret_conv</span>\n</code></pre></div>",
        "id": 472553679,
        "sender_full_name": "Tom",
        "timestamp": 1727203429
    },
    {
        "content": "<p>Note that none of UInt8/16/32 etc work with this function!  Yet,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">test_conversions</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">UInt8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"c1\">-- But this works</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nn</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10000</span><span class=\"w\">           </span><span class=\"c1\">-- Even though it's \"out of range\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ui8</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">UInt8</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">nn</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">nn</span><span class=\"bp\">.</span><span class=\"n\">toUInt8</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">ui8</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>",
        "id": 472553861,
        "sender_full_name": "Tom",
        "timestamp": 1727203493
    },
    {
        "content": "<p>It's a similar story for <code>Fin</code> and <code>Float</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Doesn't work</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">test_conversions</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">           </span><span class=\"c1\">-- Doesn't work</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fin_bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">1001</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">nn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Does not work</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">nn</span><span class=\"w\"> </span><span class=\"c1\">-- Have to say, coe is not working.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fin</span>\n\n<span class=\"c1\">-- Doesn't work</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">test_conversions</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\">                   </span><span class=\"c1\">-- Doesn't work</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">float_bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">nn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- Does not work</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">flt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"n\">nn</span><span class=\"w\"> </span><span class=\"c1\">-- Have to say</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">flt</span>\n</code></pre></div>",
        "id": 472554300,
        "sender_full_name": "Tom",
        "timestamp": 1727203696
    },
    {
        "content": "<p>if you replace <code>Coe</code> with <code>CoeHTCT</code>, your <code>test_conversions</code> should be a bit more general...</p>",
        "id": 472554396,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727203755
    },
    {
        "content": "<p>i think it still won't work with <code>UInt8</code> and the like though, because you'd rather not such lossy casting happens implicitly...</p>",
        "id": 472554630,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727203823
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> </p>\n<p>I guess there a few observations here:</p>\n<p>1) I've never even heard of <code>CoeHTCT</code>.  From a \"learner\" perspective, I don't see any mentioned of it in either FPiL or TPiL, so it's hard to know if it's just an implementation detail or should be used by users.</p>\n<p>2) As a programmer, with my current impression is that converting between numerical types is very inconsistent/haphazard.  Some things convert and just \"reinterpret\", even if values are \"out of range\".  Sometimes explicit conversions compile, and sometimes they don't.</p>\n<p>3) I seem to be missing some type classes to reach for - e.g. (an unsafe) <code>ofNat</code> seems to exist on (most?) of the built-in types but I can't seem to find a type class where I could do this generically.  I can't find a similar thing for <code>toX</code> either.</p>\n<p>I guess I was trying to learn to write some generic code but am running into a lot of roadblocks.</p>",
        "id": 472555982,
        "sender_full_name": "Tom",
        "timestamp": 1727204331
    },
    {
        "content": "<p>if you'd like, i could try and explain exactly how the <code>Coe</code>-family of typeclasses works, but i find the documentation for this (which is in the defining file) is well-written...</p>",
        "id": 472557570,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1727204993
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> </p>\n<p>I appreciate your continued help.  I want to assure you that I am trying to read documentation but as I mentioned, some of type classes are not mentioned in either one of the \"reference\" texts, such as FPiL or TPiL. </p>\n<p>I am interpreting your last suggestion as \"go read the <code>Init/Coe.lean</code> code, ie. parts of the implementation of the compiler.  I had looked at that file but it specifically says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">On</span><span class=\"w\"> </span><span class=\"n\">top</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">instances</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"n\">defines</span><span class=\"w\"> </span><span class=\"n\">several</span><span class=\"w\"> </span><span class=\"n\">auxiliary</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">classes</span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">snip</span><span class=\"bp\">&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"ss\">`CoeHTCT</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CoeHead?</span><span class=\"w\"> </span><span class=\"n\">CoeOut</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">CoeTail?</span><span class=\"bp\">`</span>\n</code></pre></div>\n<p>Which is why I think this may not be for \"users\" and certainly not for someone like me just trying to learn the ropes! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span><br>\nIn fact, the documentation string (aside from being basically identical to Coe), says</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/--</span>\n<span class=\"sd\">Auxiliary class implementing `CoeHead* Coe* CoeTail?`.</span>\n<span class=\"sd\">Users should generally not implement this directly.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CoeHTCT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- Coerces a value of type `α` to type `β`. Accessible by the notation `↑x`,</span>\n<span class=\"sd\">  or by double type ascription `((x : α) : β)`. -/</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">coe_decl</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">CoeHTCT</span><span class=\"bp\">.</span><span class=\"n\">coe</span>\n</code></pre></div>\n<p>Hopefully this clarifies why I'm not sure of the \"correct way\" of accomplishing what I'm looking for.</p>\n<p>Thanks.</p>",
        "id": 472560045,
        "sender_full_name": "Tom",
        "timestamp": 1727206060
    },
    {
        "content": "<p>You can use <code>set_option trace.Meta.synthInstance true</code> to see what typeclasses are being used during coercion.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">trace</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">synthInstance</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"c1\">-- [Meta.synthInstance] ✅️ CoeT ℕ nat ℤ</span>\n</code></pre></div>",
        "id": 472563836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727207706
    },
    {
        "content": "<p>The elaborator has special support for coercions as well, including unfolding the <code>coe</code> function once a coercion has been found. You shouldn't use these functions directly.</p>",
        "id": 472563895,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727207739
    },
    {
        "content": "<p>No need to write <code>def b : Int := ((nat : Nat) : Int) </code>, <code>def b : Int := (nat : Int) </code> will do.</p>",
        "id": 472564274,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727207887
    },
    {
        "content": "<p>For numbers, it's important that all the coercions for numbers form a directed acyclic graph, and that none of the coercions are lossy. Coercions can be chained. What's to stop <code>5 : Nat</code> from going through <code>Fin 2</code> and back to <code>Nat</code>?</p>",
        "id": 472564489,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727207974
    },
    {
        "content": "<p>What should be stopping it is no coercion from Nat to Fin 2 ;-) but people don't like to put in the proof that n &lt; 2...</p>",
        "id": 472565300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1727208302
    },
    {
        "content": "<p>In fact right now all of these work fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nbar</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">nbar</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>so I don't quite understand Kyle's last point.</p>",
        "id": 472565547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1727208411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> </p>\n<blockquote>\n<p>What should be stopping it is no coercion from Nat to Fin 2 ;-) but people don't like to put in the proof that n &lt; 2...</p>\n</blockquote>\n<p>While I am excited to continue exploring Lean as a vehicle toward learning more about mathematics and formal systems (obviously not to the same degree as someone as yourself), I am primarily interested in using it for programming.  I like the idea of using stricter types to build more correct programs and have the option of proving certain properties if I chose to.  </p>\n<p>I guess there eventually need to be some parts of the language/library which allow me to say \"I know this is fine\", e.g. converting a <code>Nat</code> to a <code>Float</code>, perhaps similar to how I can choose to avoid proving the termination of a <code>def</code> by saying <code>partial def</code>.  Kind of reminds me of the <code>unsafe</code> blocks in e.g. Rust, if you know what I mean.</p>",
        "id": 472566913,
        "sender_full_name": "Tom",
        "timestamp": 1727209054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Mathlib's had a bug for a while due to the fact it introduces a coercion from <code>Nat</code> to <code>Fin 2</code>. Core does not have this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- In core Lean</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- false</span>\n\n<span class=\"c1\">-- In mathlib:</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- true (!)</span>\n</code></pre></div>",
        "id": 472575038,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727212642
    },
    {
        "content": "<p>Context: <a href=\"#narrow/stream/287929-mathlib4/topic/Mathlib4.20.60calc.60.20issue.3F/near/438679909\">https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Mathlib4.20.60calc.60.20issue.3F/near/438679909</a></p>",
        "id": 472575232,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727212720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Missing.20numeric.20conversion.20type.20classes.3F/near/472566913\">said</a>:</p>\n<blockquote>\n<p>[...]  </p>\n<p>I guess there eventually need to be some parts of the language/library which allow me to say \"I know this is fine\", e.g. converting a <code>Nat</code> to a <code>Float</code>, perhaps similar to how I can choose to avoid proving the termination of a <code>def</code> by saying <code>partial def</code>.  Kind of reminds me of the <code>unsafe</code> blocks in e.g. Rust, if you know what I mean.</p>\n</blockquote>\n<p>For floats in particular I think that there is very little on Lean about them, because everything about it is <code>opaque</code>, i.e. nothing can be proven about it, so general type classes don't work well for it. You can add <code>local instance</code>s if you want to have those coercions locally, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Float.ofNat#doc\">docs#Float.ofNat</a>. A function from <code>Float</code> to <code>Nat</code> does seem to be missing, but you can go through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Float.toRat0#doc\">docs#Float.toRat0</a> and then convert the rational number to a <code>Nat</code></p>",
        "id": 472600135,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1727230218
    }
]