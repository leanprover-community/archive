[
    {
        "content": "<p>Hi,</p>\n<p>Following  advice from <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html\">chapter 7 of TPIL</a>, I am trying to develop the concept of partial function (function that is defined only for some elements of a given type) composition. Here is what I have got:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span>\n    <span class=\"o\">:=</span>\n    <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">match</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>Next, I wanted to prove some properties of this definition. As a warm up, I decided to show that if for a given argument, the inner function evaluates to none, then so does the composition. I wanted to write this proof without using tactics or the triangle <code>▸</code> macro, in order to better understand how the proofs involving equality actually work. Here is what I was able to come up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">→</span> <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n    <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span>\n        <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span>\n            <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span>   <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n            <span class=\"bp\">|</span>   <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n            <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span>\n            <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">none</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span>   <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n            <span class=\"bp\">|</span>   <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Whilst this seems to be correct, repeatedly writing down those pattern matching expressions seems a bit awkward. Is there a nicer way of writing this proof, without resorting to the means I mentioned above? Is there a general method of proving things about functions defined using pattern matching? Is there a nice way of combining pattern matching and calculational proofs?</p>\n<p>Any other suggestions about how to make this definition and/or proof nicer are also very welcome.</p>\n<p>Update:<br>\nIn order to understand a bit better how equality works in lean, I tried to supply the motive for the Equality type recursor by hand, instead of relying on the elaborator. The following is my attempt:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">),</span>\n    <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"bp\">→</span> <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n    <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">hyp</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">calc</span>\n        <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n            <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">none</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n            <span class=\"o\">:=</span> <span class=\"n\">Eq.rec</span>\n                <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n                    <span class=\"o\">((</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n                        <span class=\"k\">match</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n                <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n                <span class=\"n\">hyp</span>\n        <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>It fails, with the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"bp\">@</span><span class=\"n\">Eq.rec</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">x_1</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n        <span class=\"k\">match</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">x_1</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Eq.refl</span>\n      <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n      <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Eq.refl</span>\n    <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>This makes no sense to me. Why is lean inserting <code>x_1</code> into one of the match expressions? What am I missing here?</p>",
        "id": 341942530,
        "sender_full_name": "Kuba",
        "timestamp": 1678845371
    },
    {
        "content": "<p>The nicer way of writing the proof is to use tactics, precisely because the intuitively clear concept of \"replace this subterm of a term with this equal term\" gets totally drowned in type theory when you write it as \"apply the recursor for equality to this specific motive\". The debugging hell that you're going through trying to explicitly use the recursor is exactly what should be telling you to use the <code>rw</code> tactic. Compare with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">inner</span> <span class=\"n\">a</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">compose_part</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>The simplifier just does all the rewrites for you and deals with all the recursor stuff. I appreciate that you have a question above, but the point of tactics is exactly so that humans don't have to bother with that kind of question.</p>",
        "id": 342257416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678959572
    },
    {
        "content": "<p>You can see the proof which the tactic generated under the hood with <code>#print theorem1</code>.</p>",
        "id": 342268467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678962347
    },
    {
        "content": "<p>Yeah, I definitely would not want to do it the hard way every time, but I am still determined to try a few examples by hand. One of the reasons I picked up lean is that I want to learn a bit more about theorem proving itself. Also, I guess I can't stop myself from taking things apart to see how they work.</p>\n<p>Anyway, I followed your advice about printing the auto-generated proof. After some digging and then more digging, I realised that for the sort of low level, manual work that I am trying to do, I might want to alter my definition of <code>compose_part</code>. Here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span>\n    <span class=\"o\">:=</span>\n    <span class=\"n\">Option.rec</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>To my dismay, I get the following message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">code</span> <span class=\"n\">generator</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">support</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Option.rec'</span> <span class=\"n\">yet</span><span class=\"o\">,</span>\n<span class=\"n\">consider</span> <span class=\"n\">using</span> <span class=\"bp\">'</span><span class=\"k\">match</span> <span class=\"bp\">...</span> <span class=\"k\">with</span><span class=\"bp\">'</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"n\">structural</span> <span class=\"n\">recursion</span>\n</code></pre></div>\n<p>How is this possible? Recursors seem to be quite fundamental objects, so it seems weird one would not be supported. Also, aren't match expressions supposed to be compiled to recursors? Am I making a mistake here? Is it possible this is a bug in some part of lean (probably not)?</p>",
        "id": 343804196,
        "sender_full_name": "Kuba",
        "timestamp": 1679527997
    },
    {
        "content": "<p>Do you actually want executable code for your purposes? If not you can simply use <code>noncomputable def</code> here as a workaround for now.</p>",
        "id": 343804398,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679528123
    },
    {
        "content": "<p>I am not sure what computability has to do with my problem. I am not familiar with noncomputable def. Can you elaborate (pun unintended)?</p>",
        "id": 343804728,
        "sender_full_name": "Kuba",
        "timestamp": 1679528335
    },
    {
        "content": "<p>By default lean tries to produce executable code for all definitions so that for appropriate arguments functions can be actually run and the output evaluated. The error you are seeing is that the code generator, which is the system that produces the executable code for this, doesn't support what you are doing (yet). So if you never want to actually evaluate your functions as if it were a program (rather you just want to prove things about them) then telling lean you don't want to produce code for them then there is no longer an issue</p>",
        "id": 343804972,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1679528507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587316\">Kuba</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343804196\">said</a>:</p>\n<blockquote>\n<p>Is it possible this is a bug in some part of lean (probably not)?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/2049\">lean4#2049</a></p>",
        "id": 343805262,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1679528662
    },
    {
        "content": "<p>Hmm, I see. I think I would like to be able to actually run this function.</p>\n<p>I should probably mention that I do not get this message if I use casesOn:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span>\n    <span class=\"o\">:=</span>\n    <span class=\"n\">Option.casesOn</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But if you print what casesOn actually is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#print</span> <span class=\"n\">Option.casesOn</span>\n\n<span class=\"kd\">@[reducible]</span> <span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">Option.casesOn.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">,</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span>\n  <span class=\"o\">{</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">none</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">val</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"o\">}</span> <span class=\"n\">t</span> <span class=\"n\">none</span> <span class=\"n\">some</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Option.rec</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">val</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>It is a 'wrapper' around Option.rec</p>\n<p>I will see if I can actually evaluate an expression with compose_part thus defined.</p>",
        "id": 343805801,
        "sender_full_name": "Kuba",
        "timestamp": 1679528956
    },
    {
        "content": "<p>If I use <code>casesOn</code> instead of <code>rec</code> it seems to work fine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span>\n    <span class=\"o\">:=</span>\n    <span class=\"n\">Option.casesOn</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">none</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span>   <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span>   <span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"mi\">0</span> <span class=\"c1\">-- some 2</span>\n<span class=\"k\">#eval</span> <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"mi\">1</span> <span class=\"c1\">-- none</span>\n</code></pre></div>\n<p>This seems weird given that <code>casesOn</code> is itself defined using <code>rec</code>.</p>",
        "id": 343807863,
        "sender_full_name": "Kuba",
        "timestamp": 1679530382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343805262\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"587316\">Kuba</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343804196\">said</a>:</p>\n<blockquote>\n<p>Is it possible this is a bug in some part of lean (probably not)?</p>\n</blockquote>\n<p><a href=\"https://github.com/leanprover/lean4/pull/2049\">lean4#2049</a></p>\n</blockquote>\n<p>Does this mean that the code generator has to be modified every time a new inductive type is defined in order for it to support its corresponding recursor?</p>",
        "id": 343808039,
        "sender_full_name": "Kuba",
        "timestamp": 1679530523
    },
    {
        "content": "<p>No, thankfully not. The code generator is able to see that there's a <code>match</code> and compile it, rather than going through recursors.</p>\n<p>There are some reasons not to expand everything out to recursors and then compile those. One reason I know of is that since Lean has strict evaluation semantics, there are things that can evaluate you didn't expect to evaluate. However, there are plans to get the code generator to know how to compile recursors. It's just not been a priority, as I understand.</p>",
        "id": 343808570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679531011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343808570\">said</a>:</p>\n<blockquote>\n<p>No, thankfully not. The code generator is able to see that there's a <code>match</code> and compile it, rather than going through recursors.</p>\n<p>There are some reasons not to expand everything out to recursors and then compile those. One reason I know of is that since Lean has strict evaluation semantics, there are things that can evaluate you didn't expect to evaluate. However, there are plans to get the code generator to know how to compile recursors. It's just not been a priority, as I understand.</p>\n</blockquote>\n<p>Does this mean that pattern matching expressions are compiled directly to executable code, without going through recursors? Does <code>casesOn</code> use pattern matching under the hood and that is why it works where <code>rec</code> fails?</p>",
        "id": 343809973,
        "sender_full_name": "Kuba",
        "timestamp": 1679532236
    },
    {
        "content": "<p>It looks like sticking with the definition of <code>compose_part</code> that uses pattern matching might be a better option then.<br>\nBut this brings me back to the question of how to prove my little toy theorem, without using tactics. Is there a general way of writing term style theorem proofs that involve functions defined using pattern matching?</p>",
        "id": 343810220,
        "sender_full_name": "Kuba",
        "timestamp": 1679532427
    },
    {
        "content": "<p>I'm not sure why <code>casesOn</code> compiles, but I'd guess there's special support for it.</p>",
        "id": 343810416,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679532606
    },
    {
        "content": "<p>Here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span> <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">f</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">from</span>\n    <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 343810625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679532785
    },
    {
        "content": "<p>I'm not sure if there's a good way to unfold the definition of <code>compose_part</code> without tactics.</p>",
        "id": 343810655,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679532813
    },
    {
        "content": "<p>But the idea is that once you rewrite <code>g x = none</code> the equality is true by definition of <code>match</code>.</p>",
        "id": 343810681,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679532838
    },
    {
        "content": "<p>in term mode you can unfold things by using <code>show</code> and asserting the unfolded expression</p>",
        "id": 343810783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679532903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343810416\">said</a>:</p>\n<blockquote>\n<p>I'm not sure why <code>casesOn</code> compiles, but I'd guess there's special support for it.</p>\n</blockquote>\n<p>Yes</p>",
        "id": 343810884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679532971
    },
    {
        "content": "<p>The same support could in principle exist for <code>rec</code>, it just hasn't been done yet</p>",
        "id": 343810917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679533005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343810783\">said</a>:</p>\n<blockquote>\n<p>in term mode you can unfold things by using <code>show</code> and asserting the unfolded expression</p>\n</blockquote>\n<p>Right, that's what I did, but you can't use any placeholder tricks to avoid stating the whole definition</p>",
        "id": 343811069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1679533112
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 343811103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679533145
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n  <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">Option.casesOn</span> <span class=\"bp\">·</span> <span class=\"bp\">..</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 343811334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1679533352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Pattern.20matching.20and.20proofs.20involving.20equality/near/343811103\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">theorem1</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Hmm, I tried this, the exact code being:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">compose_part.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">outer</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span>\n    <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span>   <span class=\"n\">some</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">outer</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">theorem1.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">compose_part</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span>\n    <span class=\"o\">:=</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"k\">from</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But I get the following message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Option.casesOn</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3242</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3243</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">Option.casesOn</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3242</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3243</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Option.casesOn</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3242</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">m.3243</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 343812677,
        "sender_full_name": "Kuba",
        "timestamp": 1679534537
    }
]