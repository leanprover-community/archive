[
    {
        "content": "<p>I notice that the following code, below, works but that the following simple, seemingly equivalent, code replacement breaks it. Don't worry, there's really not much code to read: three typeclasses, each extending from the previous; instances for nat; and a simple foldr function implementation that tries to use the binary operation stored in the instance for the typeclass as the bottom of the stack.</p>\n<p>Change this code at the end</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"k\">let</span> <span class=\"n\">mop</span> <span class=\"o\">:=</span> <span class=\"n\">m.op</span> <span class=\"k\">in</span>\n    <span class=\"n\">mop</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">mul_foldr</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>to this seemingly equivalent code </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">m.op</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">mul_foldr</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the code is no longer accepted by Lean. The error is like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"bp\">'</span><span class=\"n\">alg.has_op.op'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">explicit</span> <span class=\"n\">argument</span> <span class=\"k\">with</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">alg.has_op</span> <span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"n\">Lean</span>\n</code></pre></div>\n<p>What am I missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"c1\">-- test import</span>\n<span class=\"k\">#check</span> <span class=\"n\">has_mul</span>\n<span class=\"k\">#check</span> <span class=\"n\">semigroup</span>\n<span class=\"k\">#check</span> <span class=\"n\">has_one</span>\n<span class=\"k\">#check</span> <span class=\"n\">monoid</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">alg</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Stack of three typeclasses, each extending from the previous</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">@[class]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">my_has_one</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">has_op</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">@[class]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">has_op</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">ext_has_op extends from has_op</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[class]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">ext_has_op</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_op</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">ext_ext_has_op: optiplicative semigroup plus optiplicative one</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[class]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">ext_ext_has_op</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">ext_has_op</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">string</span><span class=\"o\">)</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Instances for nat</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">@[instance]</span>\n<span class=\"kd\">def</span> <span class=\"n\">has_one_nat</span> <span class=\"o\">:</span> <span class=\"n\">my_has_one</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"mi\">1</span> <span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">haz_op nat instance</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">@[instance]</span>\n<span class=\"kd\">def</span> <span class=\"n\">has_op_nat</span> <span class=\"o\">:</span> <span class=\"n\">has_op</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">nat.mul</span> <span class=\"o\">⟩</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">ext_has_op nat instance</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">ext_has_op_nat</span> <span class=\"o\">:</span> <span class=\"n\">ext_has_op</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"n\">tt</span> <span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">ext_ext_has_op nat instance</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">instance</span> <span class=\"n\">ext_ext_has_op_nat</span> <span class=\"o\">:</span> <span class=\"n\">ext_ext_has_op</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span> <span class=\"s2\">\"Hello\"</span> <span class=\"o\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">set_option trace.class_instances true</span>\n<span class=\"cm\">set_option class.instance_max_depth 20</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul_foldr</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ext_ext_has_op</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">my_has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">:</span>\n  <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">o.one</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">mop</span> <span class=\"o\">:=</span> <span class=\"n\">m.op</span> <span class=\"k\">in</span>\n    <span class=\"n\">mop</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">mul_foldr</span> <span class=\"n\">t</span><span class=\"o\">)</span>                     <span class=\"c1\">-- Change code here</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">mul_foldr</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">,</span><span class=\"mi\">5</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">alg</span>\n</code></pre></div>",
        "id": 229204467,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1615138960
    },
    {
        "content": "<p>You can't use dot notation on classes, because the typeclass argument of the projection (in this case <code>ext_ext_has_op.op</code>) is implicit</p>",
        "id": 229208622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615142698
    },
    {
        "content": "<p>you should write <code>ext_ext_has_op.op α</code> instead</p>",
        "id": 229208862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615142759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Little.20typeclass.20syntaxy.20thing/near/229208862\">said</a>:</p>\n<blockquote>\n<p>you should write <code>ext_ext_has_op.op α</code> instead</p>\n</blockquote>\n<p>The language is a little funny in that it allows dot notation on classes, and it works sometimes but not others (when implicit instances need to be looked up). There are still two things I'm wondering about:</p>\n<p>(1) Why exactly does binding m.op to mop then using mop work when using m.op directly doesn't?</p>\n<p>(2) Where exactly should I write <code>ext_ext_has_op.op α</code> instead? Not seeing it.</p>",
        "id": 229293503,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1615208243
    },
    {
        "content": "<p>Yeah, that's a bug. It's not supposed to work at all</p>",
        "id": 229422380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615265935
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mul_foldr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ext_ext_has_op</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">my_has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">my_has_one.one</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">::</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_op.op</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">mul_foldr</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 229422626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615266133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124175\">@Kevin Sullivan</span></p>",
        "id": 229422635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615266145
    },
    {
        "content": "<p>Basically, you don't need to refer to variables in square brackets except in exceptional circumstances (which is why they are usually anonymous)</p>",
        "id": 229422686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615266195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Little.20typeclass.20syntaxy.20thing/near/229422380\">said</a>:</p>\n<blockquote>\n<p>Yeah, that's a bug. It's not supposed to work at all</p>\n</blockquote>\n<p>That's helpful.  Thanks for confirming. I knew that typeclass instances were generally anonymous, but had also seen a few instances where they weren't. It was also clear after a few minutes of thinking that there would be a problem finding implicit instances going up the stack lacking a sufficiently right context for inference. What wasn't clear was why the dot notation was supported at all. As a final question, if you've got a sec to complete this thread, can you characterize situations where it's necessary/helpful to have a non-anonymous (a \"nonymous\") typeclass instance?</p>",
        "id": 229533312,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1615316568
    },
    {
        "content": "<p>If you are using a lemma that takes a typeclass argument in <code>()</code> binders, you will need to specify it. This is sometimes done for typeclasses that are also props and intended to be used as such (i.e. participating in nontrivial logical positions like negations and disjunctions), like <code>nat.prime</code>. It's also necessary to specify typeclasses sometimes when the one that is inferred is not the one you want, which only happens occasionally, mostly when there is a non-defeq diamond in the typeclass hierarchy (which we try to avoid). Plus sometimes it's just the shortest way to write a proof</p>",
        "id": 229540410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615318975
    },
    {
        "content": "<p>Also it comes up when the typeclass itself has some structure on it and is the subject of the theorem, like this one from topology:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">ctop</span> <span class=\"n\">α</span> <span class=\"n\">σ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">F</span> <span class=\"n\">b</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F.to_topsp</span> <span class=\"bp\">=</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext'</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">H₂</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span> <span class=\"n\">mem_nhds_sets_iff.2</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">H₁</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 229540688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615319100
    },
    {
        "content": "<p>Here the type <code>topological_space α</code> is a typeclass, useful for providing topological structure on types, but it's also the space of topologies on <code>α</code>, which is a complete lattice with a map operator and interesting lemmas about it</p>",
        "id": 229540945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615319197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20dot.20notation.20with.20typeclass.20instsances/near/229540410\">said</a>:</p>\n<blockquote>\n<p>If you are using a lemma that takes a typeclass argument in <code>()</code> binders, you will need to specify it. This is sometimes done for typeclasses that are also props and intended to be used as such (i.e. participating in nontrivial logical positions like negations and disjunctions), like <code>nat.prime</code>. It's also necessary to specify typeclasses sometimes when the one that is inferred is not the one you want, which only happens occasionally, mostly when there is a non-defeq diamond in the typeclass hierarchy (which we try to avoid). Plus sometimes it's just the shortest way to write a proof</p>\n</blockquote>\n<p>Thank you, Mario. I also changed the title of this thread to better reflect the subject it addresses.</p>",
        "id": 229551120,
        "sender_full_name": "Kevin Sullivan",
        "timestamp": 1615322954
    }
]