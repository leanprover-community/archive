[
    {
        "content": "<p>Still going through the language reference. In general it seems that function definitions can be written in two ways:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This makes sense (JS/TS has the same distinction with function f vs const = x =&gt; ...).</p>\n<p>Seems that when declaring inductive constructors one can use both forms too (am I correct?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyList2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyList2</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyList2</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyList2</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>I believe the two cons are the same.</p>\n<p>But when it comes to the inductive type itself, it appears that there is big difference between the two, where the first set are arguments and the second indices?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq3</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq3</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>The second one fails to compile, while I was expecting it will be equivalent to <code>Eq2</code>. Also when I hover over <code>Eq2</code> and <code>Eq3</code> they have the same type <code>Eq? : {α : Sort u} → α → α → Prop</code>. How can I get my head around the fact that they are different, even though they are one seemingly benign syntactic transformation from each other.</p>",
        "id": 499958007,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739660900
    },
    {
        "content": "<p>For functions and constructors, yes, the results are the same. (However! With <code>f1</code> you can write <code>f1 (n  := 3)</code> to call it, but you can't do that for <code>f2</code>)</p>\n<p>For the main inductive type, there needs to be some convention to say where parameters end and indices start. The convention is where the <code>:</code> is. One could imagine another convention where you'd write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq3</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>instead. (That's not what Lean chose to do.)</p>",
        "id": 499958292,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661233
    },
    {
        "content": "<p>Note that the <code>:</code> isn't exactly where the indices start. The rule is that everything before <code>:</code> is a parameter (or, equivalently, that indices can only come after <code>:</code>). Lean can automatically \"promote\" what comes after <code>:</code> to be a parameter, if it remains constant across all constructors.</p>",
        "id": 499958432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661355
    },
    {
        "content": "<p>yeah, I am starting to see that it has to do with what happens in the constructors. Can you help me see what <code> remains constant across all constructors</code> means?</p>",
        "id": 499958616,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739661517
    },
    {
        "content": "<p>See in <code>MyList</code> how the first argument given to <code>MyList</code> is always alpha? That's an example of the index remaining constant, so it gets promoted to be a parameter.</p>",
        "id": 499958661,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661575
    },
    {
        "content": "<p>Somehow I'm not saying the rule right, since with Eq2 you might think the last argument could be a parameter.</p>",
        "id": 499958767,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661686
    },
    {
        "content": "<p>read my mind, I was just staring at it :)</p>",
        "id": 499958784,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739661714
    },
    {
        "content": "<p>Maybe it's \"if the argument always appears as its own a free variable in each occurrence of the type constructor\"</p>",
        "id": 499958793,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661721
    },
    {
        "content": "<p>The issue there is that the second <code>a</code> is re-used; it's not its own free variable.</p>",
        "id": 499958852,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739661753
    },
    {
        "content": "<p>I see, and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>will be an example of a promotion to argument (not equality at all)</p>",
        "id": 499959007,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739661913
    },
    {
        "content": "<p>I was also just contemplating why it is that Lean uses this <code>:</code> rule at all anymore, given that indices can be promoted. That is, why not have everything be an index at first?</p>\n<p>I could imagine that there are some complicated inductive types that might be difficult to elaborate without knowing that some of the type's arguments are supposed to be parameters (parameters get forced to be the same across all applications of the type constructor by unification). Things you thought were parameters might come out as indices, if the constructors elaborate at all.</p>\n<p>Though, it would be possible to write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyList</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyList</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">MyList</span>\n</code></pre></div>\n<p>when you want to guarantee that the arguments be parameters.</p>",
        "id": 499959161,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662047
    },
    {
        "content": "<p>Yes, and with <code>Eq4</code> you can verify the number of parameters is 3:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">Eq4</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">inductive Eq4.{u} : {α : Sort u} → α → α → Prop</span>\n<span class=\"cm\">number of parameters: 3</span>\n<span class=\"cm\">constructors:</span>\n<span class=\"cm\">Eq4.refl : ∀ {α : Sort u} {a b : α}, Eq4 a b</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 499959235,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662103
    },
    {
        "content": "<p>One final one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ex5</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Ex5</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>(changed to Ex instead of Eq). I thought b should stay index, but it says 3 params?</p>",
        "id": 499959451,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739662308
    },
    {
        "content": "<p>I guess a ctor arg is still \"free\" as it is an arg</p>",
        "id": 499959648,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739662480
    },
    {
        "content": "<p>Yeah, for index promotion, the free variables will appear as constructor arguments.</p>\n<p>In fact, you're taking advantage of autoImplicits for the <code>Eq4</code> example, and it's actually the same as Ex5 (but with an implicit argument instead of the explicit <code>x</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Don't forget that <code>(b : α)</code> in the type after the colon does not bring <code>b</code> in scope for the constructors.</p>",
        "id": 499959923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662764
    },
    {
        "content": "<p>This would have been the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq4</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>",
        "id": 499960011,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739662826
    },
    {
        "content": "<p>aaah, <span aria-label=\"mind\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"mind\">:mind:</span> forgot about autoImplicits</p>",
        "id": 499960160,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739662944
    },
    {
        "content": "<p>This might be my biggest hold up about dependent type languages so far (this being the first one I have worked with) - I have no good quick intuition of variable scoping when variables can cross the term and type syntactic positions.</p>",
        "id": 499960339,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739663115
    },
    {
        "content": "<p>Here's a peek of bleeding-edge Lean and the VS Code extension:</p>\n<p><a href=\"/user_uploads/3121/jxM_5i_cLUcRS2P8naqu4kZh/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jxM_5i_cLUcRS2P8naqu4kZh/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"836x76\" src=\"/user_uploads/thumbnail/3121/jxM_5i_cLUcRS2P8naqu4kZh/image.png/840x560.webp\"></a></div><p>Auto-implicits insert themselves as inlay hints.</p>",
        "id": 499960365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663152
    },
    {
        "content": "<p>Here's the general rule: if the binder appears before the the colon, then the value is available in the entire body. If it appears in a construct such as a pi type (e.g. <code>(b : α) → Prop</code>), it only appears in the body of the pi type itself.</p>",
        "id": 499960446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663214
    },
    {
        "content": "<p>So now back to the original question, one can write imagine any inductive type as indices only and after all ctors args (implicit or not) are taken into account, some of the incides are promoted to type parameters. The type parameter syntax is a way to force that promotion.<br>\ne.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ex6</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ex6</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>which is equivalent to <code>Eq2</code> earlier.</p>\n<p>:hand-wavy: generally the ctors are allowed to \"vary\" in a more restrictive way than the overarching type, and when they are equally free (over all ctors it seems) these are the type \"parameters\"</p>",
        "id": 499960921,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739663736
    },
    {
        "content": "<p>Two more examples:</p>\n<p>It's possible to put <em>everything</em> after the colon and rely on promotion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ex7</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ex7</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>When there are parameters, Lean knows what the value is supposed to be for them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ex7</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ex7</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 499961118,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> has marked this topic as resolved.</p>",
        "id": 499961422,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739664134
    },
    {
        "content": "<p>Thanks for the good discussion! This is making a lot more sense to me now :)</p>",
        "id": 499961557,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739664298
    },
    {
        "content": "<p>If you want to dig deeper into the implementation, <a href=\"https://github.com/leanprover/lean4/blob/747ea91c3af40a95df169bbed44ed6a12e96127b/src/Lean/Elab/MutualInductive.lean#L451\">https://github.com/leanprover/lean4/blob/747ea91c3af40a95df169bbed44ed6a12e96127b/src/Lean/Elab/MutualInductive.lean#L451</a> is the entry point to the promotion algorithm.</p>",
        "id": 499961875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739664545
    },
    {
        "content": "<p>If you do <code>set_option trace.Elab.inductive true</code>, it looks like it'll print out \"masks\", which is somehow used when computing what can be promoted.</p>",
        "id": 499961904,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739664600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Inductive.20families.20question/near/499960365\">said</a>:</p>\n<blockquote>\n<p>Here's a peek of bleeding-edge Lean and the VS Code extension:</p>\n<p><a href=\"/user_uploads/3121/jxM_5i_cLUcRS2P8naqu4kZh/image.png\">image.png</a></p>\n<p>Auto-implicits insert themselves as inlay hints.</p>\n</blockquote>\n<p>now that's bleeding-edge <span aria-label=\"blown\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"blown\">:blown:</span></p>",
        "id": 499995654,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739698333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Inductive.20families.20question/near/499960365\">said</a>:</p>\n<blockquote>\n<p>Here's a peek of bleeding-edge Lean and the VS Code extension:</p>\n<p><a href=\"/user_uploads/3121/jxM_5i_cLUcRS2P8naqu4kZh/image.png\">image.png</a></p>\n<p>Auto-implicits insert themselves as inlay hints.</p>\n</blockquote>\n<p>Looks like there's still some bug with this feature ...<br>\n<a href=\"/user_uploads/3121/DauVj53TWEDGEZJwwOst47DJ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/DauVj53TWEDGEZJwwOst47DJ/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1581x284\" src=\"/user_uploads/thumbnail/3121/DauVj53TWEDGEZJwwOst47DJ/image.png/840x560.webp\"></a></div><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">prod_X_sub_C_natDegree</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NoZeroDivisors</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">natDegree</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">natDegree_prod</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">X_sub_C_ne_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">natDegree_X_sub_C</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_const</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">card_fin</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 509676939,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1743595323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Inductive.20families.20question/near/509676939\">said</a>:</p>\n<blockquote>\n<p>Looks like there's still some bug with this feature ...</p>\n</blockquote>\n<p>I can't reproduce this issue - this example doesn't show any inlay hints for me.</p>\n<p>I tried removing the <code>open Polynomial</code> line, which (correctly) caused inlay hints to appear, and re-adding it made them disappear again after a short delay.</p>",
        "id": 509678572,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1743595706
    },
    {
        "content": "<p>Indeed the hints go away after refreshing. I think it's the old issue that the server sometimes doesn't receive all updates from the editor (which happens more often in the web editor than in local VSCode, maybe due to latency). Sorry for the noise!</p>",
        "id": 509687310,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1743597927
    },
    {
        "content": "<blockquote>\n<p>I think it's the old issue that the server sometimes doesn't receive all updates from the editor</p>\n</blockquote>\n<p>I'd like to know more about this, too. Is this something you encounter regularly in VS Code on recent Lean versions?</p>",
        "id": 509687831,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1743598052
    }
]