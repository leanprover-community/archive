[
    {
        "content": "<p>Not sure if the title makes sense, but this is the first time I run into universe problem and can't just write <code>Type*</code> and call it a day...</p>\n<p>I am translating some theory about maximally complete field. I translated the definition as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">Γ</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">Γ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Γ'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Γ'</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">HasExtension</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- This definition is not important. Just certain property about the extension of valuation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsImmediate</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"bp\">''</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊥</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subalgebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsLocalRing</span><span class=\"bp\">.</span><span class=\"n\">ResidueField</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">integer</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"bp\">.</span><span class=\"n\">integer</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- \"If field K admits no proper immediate extensions, K is said to be maximal\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsMaximal</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Γ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearOrderedCommGroupWithZero</span><span class=\"w\"> </span><span class=\"n\">Γ'</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">V'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">Γ'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Algebra</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Valuation</span><span class=\"bp\">.</span><span class=\"n\">HasExtension</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsImmediate</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">V'</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">algebraMap</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- I'd like to prove a theorem with a goal ¬IsMaximal V</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMaximal</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsMaximal</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- I'd like to give an example that's a proper immediate extension, using K[X] as an example</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">Application type mismatch: The argument</span>\n<span class=\"cm\">  K</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Type u_1</span>\n<span class=\"cm\">of sort `Type (u_1 + 1)` but is expected to have type</span>\n<span class=\"cm\">  Type u_5</span>\n<span class=\"cm\">of sort `Type (u_5 + 1)` in the application</span>\n<span class=\"cm\">  @Polynomial K</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In the definition <code>IsMaximal</code>, I'd like to express \"for all field L that's an extension of K...\", which leads to the quantifier over type. I wrote <code>Type*</code> there without thinking much. But later on, I realized that when I want to provide an example field, it is not necessarily in the universe defined by <code>Type*</code>. </p>\n<p>Maybe I should enforce that in <code>IsMaximal</code>, <code>K</code> and <code>L</code> should be from the same universe? That would allow me to proceed with the proof, but would that mean it isn't a real quantification over <em>all</em> fields? I feel I am trying to write \"for all universes\", but that's not a thing in Lean, is it?</p>",
        "id": 555258521,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763002440
    },
    {
        "content": "<p>the problem is that \"all fields\" is a proper class so quantifying over it can lead to <del>set-theoretic</del> type-theoretic difficulties</p>",
        "id": 555259171,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763002975
    },
    {
        "content": "<p>usually when this happens there's a better definition that doesn't quantify over a proper class or sometimes it suffices to stop looking after a certain cardinality</p>",
        "id": 555259302,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763003065
    },
    {
        "content": "<p>for example, your <code>IsImmediate</code> seems to be wanting that a certain map is surjective, so perhaps if the big field is too big you can never be surjective and so you don't have to worry about too big fields</p>",
        "id": 555259522,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763003226
    },
    {
        "content": "<p>I see. I haven't come up with an alternative definition yet. I think I'll restrict them to be in the same universe and see how far I can go</p>",
        "id": 555259592,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763003297
    },
    {
        "content": "<p>Another common theme is you can prove something like \"if it is not maximal there exists a larger one in <code>Type max u v</code>\", so you can make the definition quantify over <code>Type max u v</code> and provide a constructor that takes in arbitrary <code>Type _</code>.</p>",
        "id": 555414351,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1763053973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873350\">Weiyi Wang</span> <a href=\"#narrow/channel/113489-new-members/topic/Quantifier.20over.20all.20type.20.2F.20universe/near/555259592\">said</a>:</p>\n<blockquote>\n<p>I see. I haven't come up with an alternative definition yet. I think I'll restrict them to be in the same universe and see how far I can go</p>\n</blockquote>\n<p>Can you say something like \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is <code>v</code>-maximal if for all fields in universe <code>v</code> ...\" and then have a theorem with universe parameters <code>v</code> and <code>w</code> the properties of being <code>v</code>-maximal and <code>w</code>-maximal are equivalent?</p>",
        "id": 555469833,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763072682
    },
    {
        "content": "<p>You can do that but then you have to use that theorem whenever you want to change universes</p>",
        "id": 555471148,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763073332
    },
    {
        "content": "<p>The literature I am reading introduces a lemma to bound the cardinality of the field (<code>card(K) &lt;= card(ResidueField) ^ card(Γ)</code>). I wonder if it is going to effectively say that the field to look for is within a certain universe. Haven't finished reading yet</p>",
        "id": 555495335,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763087949
    },
    {
        "content": "<p>If it's below the next inaccessible cardinal then you're in the same universe as the largest of all the things in the formula</p>",
        "id": 555495923,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763088412
    },
    {
        "content": "<p>This bounds the universe to max(universe of residue field, universe of Gamma)</p>",
        "id": 555496011,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763088506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> I know the literature is full of <code>Valuation</code>s but mathematicians are very good at moving between equivalent valuations in a transparent way, and this is harder in Lean. If I were setting up the theory of immediate extensions then I would be strongly tempted to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ValuativeRel#doc\">docs#ValuativeRel</a> instead of <code>Valuation</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ValuativeExtension#doc\">docs#ValuativeExtension</a> instead of <code>Valuation.HasExtension</code>. The point is that you do not <em>really</em> care what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> is, and in particular even though your code is universe polymorphic (as is the custom here) you <em>definitely</em> don't care what universe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> is in, not least because it can be replaced with the image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> giving an equivalent valuation in the same universe as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>. A <code>ValuativeRel</code> on a field is exactly the same thing as an equivalence class of valuations so for any mathematics where you only care about valuations up to equivalence (which is the case here) you should make your life easier by removing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> completely from the definitions, and if you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow><annotation encoding=\"application/x-tex\">\\Gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Γ</span></span></span></span> then you should use <code>ValuativeRel.valuation</code>, which takes values in <code>ValueGroupWithZero K</code>, a totally ordered group with 0 in the same universe as <code>K</code>.</p>\n<p>This solves one of your universe problems in <code>IsMaximal</code>, but not the other one, because you still want to quantify over all extensions L. The trick for this case is to only quantify over fields L in the same universe as K in the <em>definition</em>, and then if you actually care about universes then <em>prove</em> that being maximal is the same as \"for all L in all universes, K=L\". Definitions should not involve extra types being quantified over in random universes, because it is not possible to say \"for all universes\" in Lean (this is a foundational issue) and what you are actually making is infinitely many definitions, some of which are mathematically meaningless (you might be quantifying over all fields in a smaller universe than K, so K will turn out to be maximal for the stupid reason that no such K-fields exist because the universe is too small). You are also making a footgun for yourself because whenever you don't specify the universe of the field being quantified over you are asking Lean to figure it out itself, and universe unification in these situations can lead to very weird and hard-to-diagnose timeouts.</p>",
        "id": 555544281,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763113661
    },
    {
        "content": "<blockquote>\n<p>If I were setting up the theory of immediate extensions then I would be strongly tempted to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ValuativeRel#doc\">docs#ValuativeRel</a> instead of <code>Valuation</code> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ValuativeExtension#doc\">docs#ValuativeExtension</a> instead of <code>Valuation.HasExtension</code></p>\n</blockquote>\n<p>I am really glad you said this. I suspected this after already writing a bunch of it but didn't have the courage to rewrite it. Now I have more motivation to do it</p>",
        "id": 555546721,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763114396
    },
    {
        "content": "<p>Let us know pain points in the rewrite! There are still parts of mathlib which need converting but <code>ValuativeRel</code> seems to be working fine in e.g. the theory of nonarchimedean local fields (see e.g. <a href=\"https://github.com/kbuzzard/ClassFieldTheory/blob/main/ClassFieldTheory/IsNonarchimedeanLocalField/Basic.lean\">https://github.com/kbuzzard/ClassFieldTheory/blob/main/ClassFieldTheory/IsNonarchimedeanLocalField/Basic.lean</a> )</p>",
        "id": 555555191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763116874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Quantifier.20over.20all.20type.20.2F.20universe/near/555544281\">said</a>:</p>\n<blockquote>\n<p>The trick for this case is to only quantify over fields L in the same universe as K in the <em>definition</em>, and then if you actually care about universes then <em>prove</em> that being maximal is the same as \"for all L in all universes, K=L\".</p>\n</blockquote>\n<p>I really don't like this either because then if you don't know the library so you unfold the definition to try to prove things with it then you're not universe general. I just feel like it's best to avoid quantifying over <code>Type _</code> lest you start getting stuff like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.injective_iff#doc\">docs#Module.injective_iff</a> which isn't universe general.</p>",
        "id": 555562131,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763118852
    },
    {
        "content": "<p>In which case the answer is to find a characterisation of being maximal (in the sense of valuation theory) which doesn't involve quantifying over anything. For example we did this with being a localization -- the universal property for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">f:R\\to A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> being a localisation at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">R\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to units, we get  a unique <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> making the diagram commute. However mathlib's definition of the predicate is: \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> is a unit for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>, every <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a\\in A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(r)/f(s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ker(f)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span></span></span></span> is the annihilator of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>\". Neil Strickland had the insight here. Maybe you need another insight to come with a more mathlib-appropriate definition of <code>IsMaximal</code>.</p>",
        "id": 555589702,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763127559
    },
    {
        "content": "<p>Is the ideal situation to have two theorems</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">no_immediate_of_maximal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsMaximal</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsImmediate</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">K</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">maximal_of_no_immediate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsImmediate</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">IsMaximal</span><span class=\"w\"> </span><span class=\"n\">K</span>\n</code></pre></div>\n<p>where the first refers secretly to L in all universes, and the second forces K and L to be the same universe?</p>",
        "id": 555636448,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763139324
    },
    {
        "content": "<p>I would say make <code>maximal_of_no_immediate</code> also not quantify over <code>Type u</code> but rather something smaller like <code>IntermediateField K (AlgClosure K)</code> or whatever you need to be able to prove the theorem</p>",
        "id": 555645398,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763142422
    },
    {
        "content": "<p>Well, at least I know AlgebraicClosure is not large enough, because the I already showed that there can be transcendental immediate extension. Immediate extension seems to form a really large closure. But I get your point, and I'll try this way for other theories</p>",
        "id": 555649075,
        "sender_full_name": "Weiyi Wang",
        "timestamp": 1763143774
    },
    {
        "content": "<p>We know that the mathematical notion has nothing to do with universes so <code>no_immediate_of_maximal</code> must be true but I don't know a maths proof (but I didn't look for one -- no doubt any proof that any explicit field is maximal will turn into one). </p>\n<p>Interestingly, I do think that the mathematical community plays a little fast and loose with size issues in this area. In Wedhorn's adic spaces article he defines the set of equivalence classes of valuations on a commutative ring but without knowing about <code>ValuativeRel</code> it wasn't obvious (at least ro me) why this was a set (certainly the collection of all valuations on a commutative ring is not a set).</p>",
        "id": 555650179,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763144168
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873350\">@Weiyi Wang</span> This is the first time I'm reading this thread, so I'm sure all of what I have to say has already been said. When you translate something to Lean, it isn't always very straightforward, and you shouldn't just stick to one definition without thinking. As you've discovered, this universe issue is particularly important.</p>\n<p>Now I've talked to people who are fine with things like <code>AlgebraicClosure K</code> living in one universe higher than <code>K</code>, and I consider them to be lunatics, and they also consider me to be a lunatic. (all jokes btw)</p>\n<p>So you should first construct something in the same universe of <code>K</code> with a very ugly definition that will be the completion of <code>K</code> (wait, don't we have that already?), and then prove that for any <code>L</code> in any other universe, <code>L</code> maps to the completion of <code>K</code>. This is how you solve the unvierse problem in type theory. You should view the cardinality bound in set theory as the analogue of the universe problem in type theory.</p>\n<p>And then secondly I saw that someone pointed out ValuativeRel before. This is another piece of new Mathlib object that is the result of careful consideration of paper maths. This is the cornerstone of the valuation library in Mathlib and you should definitely use it instead of an arbitrary Valuation.</p>\n<p>In other words, maybe next time you can phrase your question as \"here's a definition i tried, should I try another definition?\" instead of \"here's the definition i have, i'm running into all these problems, lean is broken\" (I know you didn't actually say this)</p>",
        "id": 555650209,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763144180
    },
    {
        "content": "<p>Kenny this is not about completions, it is more subtle mathematically.</p>",
        "id": 555650887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763144430
    },
    {
        "content": "<p>I apologise, I've read more now. So now my approach would be:</p>\n<ul>\n<li>First define an arbitrary maximal completion of any given field with valuative rel (<a href=\"https://math.mit.edu/~poonen/papers/amsval.pdf\">Cor 6 by Poonen</a>). Note that this is not unique, and note that at this point I have deliberately <strong><em>not</em></strong> introduced the predicate <code>IsMaximallyComplete</code>!</li>\n<li>Then define the predicate to mean that the map <code>K -&gt; MaximalCompletion K</code> is surjective. Note that I have not quantified over any universe in this definition!</li>\n<li>Now prove the theorem that if <code>K</code> is maximally complete, then it satisfies the textbook definition (which does quantifier over all universes, and is allowed in a statement but not a definition)</li>\n</ul>",
        "id": 555652207,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763144932
    },
    {
        "content": "<p>Aah (from that pdf), apparently Krull showed that there's a bound on the cardinality of a valued field with a given value group and residue field, which would resolve all universe issues. Note that this must have a little content, e.g. the p-adic numbers are an uncountable field with countable value group and finite residue field.</p>",
        "id": 555652745,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763145123
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/ZCueCVG73SEBcts01Jn2dfRo/Screenshot-from-2025-11-14-18-34-03.png\">Screenshot from 2025-11-14 18-34-03.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/ZCueCVG73SEBcts01Jn2dfRo/Screenshot-from-2025-11-14-18-34-03.png\" title=\"Screenshot from 2025-11-14 18-34-03.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"861x754\" src=\"/user_uploads/thumbnail/3121/ZCueCVG73SEBcts01Jn2dfRo/Screenshot-from-2025-11-14-18-34-03.png/840x560.webp\"></a></div><p>(the dagger is just the footnote \"if S is a set then |S| is the cardinality of S\")</p>",
        "id": 555653118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763145251
    },
    {
        "content": "<p>the cardinality bounds might not be very helpful for now, unless we do an explicit approach like what another theorem prover did, with \"now let's consider all the possible ring structures on this type\"; such as this <a href=\"https://stacks.math.columbia.edu/tag/09GT\">glorious proof in Stacks project that alg closure exists</a></p>",
        "id": 555653559,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763145416
    },
    {
        "content": "<p>Oh they are helpful, because the technique of the paper shows the following result: if K is a valued field, with value group Gamma and residue field R (in the same universe as K because they're subquotients of K), and if L is an immediate extension of K which might live in some much bigger universe, then there's an injection L -&gt; (Gamma -&gt; R), and hence L bijects with a subtype of something in K's universe giving us an isomorphism of L with a field in the same universe as K and thus proving that \"no immediate extensions in K's universe\" implies \"no immediate extensions in any higher universe\".</p>",
        "id": 555720280,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1763189045
    }
]