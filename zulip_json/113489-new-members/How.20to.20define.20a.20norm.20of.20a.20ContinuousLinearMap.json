[
    {
        "content": "<p>I need do define a norm of  C(\\Z_[p],\\Z_[p])\\toL[\\Z_[p]]\\Z_[p],as we always define, so However Mathlib cant define this because \\Z_[p] not a field , how can I solve this problem?</p>",
        "id": 510803250,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744079272
    },
    {
        "content": "<p>Could you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> of what you're trying to define?</p>",
        "id": 510804757,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744080220
    },
    {
        "content": "<p><code>ℤ_[p]</code> is a <code>NormedRing</code>, does that help?</p>",
        "id": 510804939,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744080329
    },
    {
        "content": "<p>/-</p>\n<p>Copyright (c) 2025 Hanliu Jiang. All rights reserved.</p>\n<p>Released under Apache 2.0 license as described in the file LICENSE.</p>\n<p>Authors: Shanwen Wang, Hanliu Jiang<br>\n-/</p>\n<p>import Mathlib.NumberTheory.Padics.MahlerBasis</p>\n<p>import Mathlib.RingTheory.PowerSeries.Basic</p>\n<p>/-!</p>\n<h1>The Amice Transform of p-adic measure</h1>\n<h2>References</h2>\n<ul>\n<li>[P. Colmez, <em>Fonctions d'une variable p-adique</em>][colmez2010]</li>\n</ul>\n<h2>Tags</h2>\n<p>Bojanic<br>\n-/</p>\n<p>open Finset IsUltrametricDist NNReal Filter PowerSeries</p>\n<p>open scoped fwdDiff ZeroAtInfty Topology</p>\n<p>variable {p : ℕ} [hp : Fact p.Prime]</p>\n<p>namespace PadicInt</p>\n<p>section norm_1</p>\n<p>noncomputable def to_Bound_function :</p>\n<p>(ℕ → ℤ_[p]) →ₗ[ℤ_[p]] ( BoundedContinuousFunction ℕ ℤ_[p]) where</p>\n<p>toFun a:= {</p>\n<p>toFun := a</p>\n<p>continuous_toFun :=continuous_of_discreteTopology</p>\n<p>map_bounded' := sorry</p>\n<p>}</p>\n<p>map_add' _ _:=rfl</p>\n<p>map_smul' _ _ := rfl</p>\n<p>noncomputable def to_Bound_norm :  AddGroupNorm (ℕ → ℤ_[p])where</p>\n<p>toFun f := ‖to_Bound_function f‖</p>\n<p>map_zero' :=by</p>\n<p>unfold to_Bound_function</p>\n<p>simp</p>\n<p>rfl</p>\n<p>add_le' a b:=by</p>\n<p>simp</p>\n<p>exact norm_add_le (to_Bound_function a) (to_Bound_function b)</p>\n<p>neg' a:=by</p>\n<p>simp</p>\n<p>eq_zero_of_map_eq_zero' x sx:=by</p>\n<p>have:to_Bound_function x=0 :=by sorry</p>\n<p>unfold to_Bound_function at this</p>\n<p>simp at this</p>\n<p>sorry</p>\n<p>noncomputable instance:  SeminormedAddCommGroup (ℕ → ℤ_[p])</p>\n<p>:=AddGroupSeminorm.toSeminormedAddCommGroup</p>\n<p>( AddGroupNorm.toAddGroupSeminorm (to_Bound_norm))</p>\n<p>end norm_1</p>\n<p>section norm_2</p>\n<p>`</p>\n<p>noncomputable def Amice_iso :</p>\n<p>(C(ℤ_[p],ℤ_[p]) →L[ℤ_[p]] ℤ_[p])≃ₗᵢ[ℤ_[p]]</p>\n<p>ℕ→ ℤ_[p] :=sorry</p>",
        "id": 510804967,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744080357
    },
    {
        "content": "<p>it cant help</p>",
        "id": 510805027,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744080381
    },
    {
        "content": "<p>please use <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a></p>",
        "id": 510805032,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744080384
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">Copyright (c) 2025 Hanliu Jiang. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: Shanwen Wang, Hanliu Jiang</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">NumberTheory</span><span class=\"bp\">.</span><span class=\"n\">Padics</span><span class=\"bp\">.</span><span class=\"n\">MahlerBasis</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">RingTheory</span><span class=\"bp\">.</span><span class=\"n\">PowerSeries</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># The Amice Transform of p-adic measure</span>\n\n\n<span class=\"cm\">## References</span>\n\n<span class=\"cm\">* [P. Colmez, *Fonctions d'une variable p-adique*][colmez2010]</span>\n\n<span class=\"cm\">## Tags</span>\n\n<span class=\"cm\">Bojanic</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">IsUltrametricDist</span><span class=\"w\"> </span><span class=\"n\">NNReal</span><span class=\"w\"> </span><span class=\"n\">Filter</span><span class=\"w\"> </span><span class=\"n\">PowerSeries</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">fwdDiff</span><span class=\"w\"> </span><span class=\"n\">ZeroAtInfty</span><span class=\"w\"> </span><span class=\"n\">Topology</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">PadicInt</span>\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">norm_1</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">BoundedContinuousFunction</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"n\">continuous_of_discreteTopology</span>\n<span class=\"w\">    </span><span class=\"n\">map_bounded'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">:=</span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">map_smul'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">to_Bound_norm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">AddGroupNorm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‖</span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">‖</span>\n<span class=\"w\">  </span><span class=\"n\">map_zero'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span>\n\n<span class=\"w\">       </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">to_Bound_function</span>\n<span class=\"w\">       </span><span class=\"n\">simp</span>\n<span class=\"w\">       </span><span class=\"n\">rfl</span>\n\n<span class=\"w\">  </span><span class=\"n\">add_le'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:=</span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">norm_add_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">neg'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:=</span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n\n<span class=\"w\">  </span><span class=\"n\">eq_zero_of_map_eq_zero'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">sx</span><span class=\"o\">:=</span><span class=\"k\">by</span>\n<span class=\"w\">       </span><span class=\"k\">have</span><span class=\"o\">:</span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">       </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">to_Bound_function</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">       </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">       </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">SeminormedAddCommGroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span>\n<span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"n\">AddGroupSeminorm</span><span class=\"bp\">.</span><span class=\"n\">toSeminormedAddCommGroup</span>\n<span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">AddGroupNorm</span><span class=\"bp\">.</span><span class=\"n\">toAddGroupSeminorm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_Bound_norm</span><span class=\"o\">))</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">norm_1</span>\n<span class=\"kn\">section</span><span class=\"w\"> </span><span class=\"n\">norm_2</span>\n<span class=\"bp\">`</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Amice_iso</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">],</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"bp\">≃ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]]</span>\n<span class=\"w\">   </span><span class=\"n\">ℕ</span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 510805083,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744080417
    },
    {
        "content": "<p>sorry<br>\nim a rookie</p>",
        "id": 510805104,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744080433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481963\">@David Loeffler</span> have you been thinking about this sort of thing recently?</p>",
        "id": 510878074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1744103194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/270676-lean4/topic/How.20to.20define.20a.20norm.20of.20a.20ContinuousLinearMap/near/510878074\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> have you been thinking about this sort of thing recently?</p>\n</blockquote>\n<p>Yes, I have. At the moment Mathlib's support for normed modules over non-field base rings is a bit fragmentary; I have been working on building it up, but it's a slow job, and it's delicate to do it in a way that doesn't slow down or lose functionality for the core case of normed vector spaces over a normed field.</p>\n<p>As for the problem at hand: you are trying to define the Amice transform as a <code>LinearIsometryEquiv</code>, which is a huge amount of data bundled all together – you need to define a map, define the inverse map, show it is linear, show it preserves the norm, etc. Perhaps it might be sensible to do this in stages? Try first defining</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Amice_transform</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">(</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ_</span><span class=\"o\">[</span><span class=\"n\">p</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mahler</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then think about upgrading it in various ways later.</p>\n<p>(FWIW, as a mathematician who uses p-adic function theory very often in my own research, I'm not sure the norm on the space <code>C(ℤ_[p], ℤ_[p]) →L[ℤ_[p]] ℤ_[p]</code> is very important anyway. This space of measures has two topologies, the \"strong\" topology induced by the operator norm, and the \"weak\" topology induced by the evaluation functionals coming from elements of <code>C(ℤ_[p], ℤ_[p])</code>. If you give it the strong topology it's really a pretty nasty object: it's not separable, for instance, and its dual is enormous, far bigger than <code>C(ℤ_[p], ℤ_[p]) </code>. But if you give it the weak topology, it's as nice a space as you could ask for – a compact Hausdorff space – and its dual is <code>C(ℤ_[p], ℤ_[p]) </code> again.)</p>",
        "id": 510908071,
        "sender_full_name": "David Loeffler",
        "timestamp": 1744112243
    },
    {
        "content": "<p>ok thanks and i'm try to build p-adc l funtion with Shanwen Wang  in RUC</p>",
        "id": 510925913,
        "sender_full_name": "Hanliu Jiang",
        "timestamp": 1744117213
    },
    {
        "content": "<p>That's interesting! That's a goal I'd also had in mind for the future, I'd be happy to discuss and maybe work on it together. Do you mean p-adic L-functions for Dirichlet characters? Or for something fancier (modular forms etc)?  Please give my regards to Shanwen, by the way; he and I know each other from the \"normal maths world\", since we both work on Euler systems, I didn't know he was also interested in Lean.</p>",
        "id": 510951128,
        "sender_full_name": "David Loeffler",
        "timestamp": 1744122808
    }
]