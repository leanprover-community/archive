[
    {
        "content": "<p>Defining the set of all powers of p dividing n:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">times_p</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"err\">↪</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"n\">inj</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">prod</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">prod</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">mul_right_inj</span> <span class=\"n\">pos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">prod</span><span class=\"o\">,</span> <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">powers_dividing</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">],</span> <span class=\"n\">finset</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"n\">p</span> <span class=\"n\">is_prime</span> <span class=\"o\">:=</span> <span class=\"k\">have</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">p</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">p</span> <span class=\"err\">∣</span> <span class=\"n\">n</span> <span class=\"k\">then</span>\n    <span class=\"n\">insert</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">times_p</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"bp\">.</span><span class=\"n\">pos</span> <span class=\"n\">is_prime</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">powers_dividing</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"n\">is_prime</span><span class=\"o\">))</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">singleton</span> <span class=\"mi\">1</span>\n</code></pre></div>\n\n\n<p>But Lean fails at the recursive call to <code>powers_dividing</code> to synthesise the type class instance that results in <code>nat.prime p</code>, even though it's right there in scope, it's <code>is_prime</code>. Can I tell it any harder to use <code>is_prime</code>?</p>",
        "id": 197186829,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222391
    },
    {
        "content": "<p>Actually now I type this, I realise I can probably look at the Sylow theorems to find something like this</p>",
        "id": 197186916,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117987\">Patrick Stevens</span> <a href=\"#narrow/stream/113489-new-members/topic/Failed.20to.20synthesize.20type.20class.20instance/near/197186829\">said</a>:</p>\n<blockquote>\n<p>Can I tell it any harder to use <code>is_prime</code>?</p>\n</blockquote>\n<p>Yes, several ways</p>",
        "id": 197187179,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222553
    },
    {
        "content": "<p>But the easiest is to move the <code>(p) [nat.prime p]</code> left of the colon</p>",
        "id": 197187270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222601
    },
    {
        "content": "<p>since it doesn't seem to be changing anyways</p>",
        "id": 197187284,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222609
    },
    {
        "content": "<p>Stuff like <code>[nat.prime p]</code> to the right of the colon is not added to the typeclass database.</p>",
        "id": 197187411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589222673
    },
    {
        "content": "<p>The <code>[]</code> only affects how somebody calls your function and not what is available for instance search.</p>",
        "id": 197187476,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222704
    },
    {
        "content": "<p>Ah, of course - thanks</p>",
        "id": 197187512,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222724
    },
    {
        "content": "<p><code>def powers_dividing (n : nat) (p : nat) [nat.prime p] : finset nat := ...</code></p>",
        "id": 197187518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589222728
    },
    {
        "content": "<p>In this case I do need things on the right of the colon, because I need to recurse, I think - but I can certainly move the prime bits over</p>",
        "id": 197187627,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222764
    },
    {
        "content": "<p>If you're really committed to this order of function arguments, then there are other options</p>",
        "id": 197187663,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222781
    },
    {
        "content": "<p>My next question was \"suppose I do need to change <code>p</code> as I go, what do I do then\", which  comes under the same banner</p>",
        "id": 197187723,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222811
    },
    {
        "content": "<p>You can use <code>letI</code> and <code>haveI</code>  to register instances</p>",
        "id": 197187746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589222828
    },
    {
        "content": "<p>But <code>def powers_dividing (p : nat) [is_prime : nat.prime p] : nat → finset nat</code> is perfect for my current function</p>",
        "id": 197187755,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222835
    },
    {
        "content": "<p><code>by exactI</code> is one (this will make all local variables available as instances), otherwise <code>@</code> can help you out</p>",
        "id": 197187760,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222839
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 197187775,
        "sender_full_name": "Patrick Stevens",
        "timestamp": 1589222848
    },
    {
        "content": "<p>I assume <code>@</code> also works with recursive calls although I'm not sure I ever tried it.</p>",
        "id": 197187925,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589222908
    },
    {
        "content": "<p>Hi - I'm using the <code>instance</code> keyword for the first time, and don't really understand what the error message is telling me. My #mve is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">pi_instances</span>\n\n<span class=\"n\">def</span> <span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subgroup_</span><span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span> <span class=\"k\">begin</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"k\">forall</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">inv_mk</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"err\">Δ</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span> <span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n<p>which gives</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"n\">G</span>\n<span class=\"err\">⊢</span> <span class=\"n\">is_submonoid</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>I can't work out what I'm being asked to add here. Could you show me where to insert a <code>sorry</code> to make the error go away, so that I can work out what I'm supposed to do?</p>",
        "id": 201133985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592397150
    },
    {
        "content": "<p>I think is_subgroup might be deprecated, and I don't use it, but if it's a class then after := you might want to type <code>{! !}</code>, click on the bulb, select the bottom but one option (the one about structures) and see what lean wants you to prove</p>",
        "id": 201134625,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592397560
    },
    {
        "content": "<p>I think the correct thing to do nowadays though is to make a term of type <code>subgroup (G \\times G)</code> with Delta as the carrier</p>",
        "id": 201134757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592397632
    },
    {
        "content": "<p>Is <code>{!</code> equivalent to a unicode character?</p>",
        "id": 201136111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592398371
    },
    {
        "content": "<p>no</p>",
        "id": 201136160,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592398402
    },
    {
        "content": "<p>Just tried it out - that was super helpful, thanks @kbuzzard!</p>",
        "id": 201136200,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592398428
    },
    {
        "content": "<p><code>suggest</code> should also give you the the thing that <code>{! !}</code> gives you, in addition to lemmas that let you do the construction with fewer arguments</p>",
        "id": 201136305,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1592398490
    },
    {
        "content": "<p>If you have a super recent Lean (maybe even too recent for mathlib? not sure) then I hear you can use <code>_</code> in place of this <code>{! !}</code> thing.</p>",
        "id": 201136321,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592398502
    },
    {
        "content": "<p>A follow-up question - given my definition of <code>subgroup_Δ</code> above, how can I construct a <code>normal_subgroup</code>? Do I have to copy the fields over elementwise?</p>",
        "id": 201137349,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592399033
    },
    {
        "content": "<p>I think Yury bundled normal_subgroup recently so you might want to look at any constructors he made for that</p>",
        "id": 201137470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592399085
    },
    {
        "content": "<p>Here's what I'm trying that is giving me a type mismatch:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">normal_</span><span class=\"err\">Δ</span><span class=\"bp\">_</span><span class=\"n\">iff_comm</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normal_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">sorry</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h_comm</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"err\">∈</span> <span class=\"err\">Δ</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"err\">Δ</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n            <span class=\"n\">sorry</span>\n        <span class=\"o\">},</span>\n        <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup_</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">one_mem</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">one_mem</span><span class=\"o\">,</span>\n                <span class=\"n\">mul_mem</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">mul_mem</span><span class=\"o\">,</span>\n                <span class=\"n\">inv_mem</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">inv_mem</span><span class=\"o\">,</span>\n                <span class=\"n\">normal</span> <span class=\"o\">:=</span> <span class=\"n\">j</span> <span class=\"o\">},</span>\n    <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201137657,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592399180
    },
    {
        "content": "<p>It seems unhappy with the RHS of the <code>have h :</code> line. Replacing <code>G</code> with <code>sorry</code> makes everything work.</p>\n<p>The error is:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">subgroup_</span><span class=\"err\">Δ</span> <span class=\"n\">G</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">G</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">u_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"err\">?</span> <span class=\"err\">?</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">((</span><span class=\"n\">max</span> <span class=\"err\">?</span> <span class=\"err\">?</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 201137712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592399212
    },
    {
        "content": "<p>I think begin/end is a bad way to make terms of a structure</p>",
        "id": 201139764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592400244
    },
    {
        "content": "<p>Right, but the structure here is a term in a larger proof</p>",
        "id": 201139884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592400312
    },
    {
        "content": "<p>Oh I see you're doing something else. I'm not at lean right now. I would look at the definition of normal subgroup in the library and find the constructor you need</p>",
        "id": 201139897,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1592400321
    },
    {
        "content": "<p>I think my issue now is less that my piecewise constructor is ugly, and more that I can't work out how to leverage my previous <code>subgroup_Δ</code> <code>instance</code>.</p>",
        "id": 201140448,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592400595
    },
    {
        "content": "<p>Did you fix that instance? Earlier Lean was complaining.</p>",
        "id": 201140646,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592400659
    },
    {
        "content": "<p>Yes, I fixed that.</p>",
        "id": 201140679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592400672
    },
    {
        "content": "<p>But we can pretend it's just implemented as <code>sorry</code>, right?</p>",
        "id": 201140698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592400681
    },
    {
        "content": "<p>Well, something appears to be introducing an extra universe parameter</p>",
        "id": 201140752,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592400719
    },
    {
        "content": "<p>Oh, you're right. Replacing my instance delcaration with <code>sorry</code> makes the error go away</p>",
        "id": 201140942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592400789
    },
    {
        "content": "<p>so, it sounds like the issue is in code you haven't shown us <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 201141144,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592400879
    },
    {
        "content": "<p>Indeed. Here's the reduced case:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">subgroup_</span><span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">one_mem</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"k\">forall</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"k\">forall</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">hab</span> <span class=\"n\">hcd</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- rw prod.mk_mul_mk,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">subgroup_</span><span class=\"err\">Δ</span>\n</code></pre></div>\n\n\n<p>Uncommenting that  commented line introduces the unwanted universe parameter</p>",
        "id": 201141378,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592401001
    },
    {
        "content": "<p>It looks like <code>prod.mk_mul_mk</code> is not inferring the type arguments in the way I want. Passing <code>G G</code> explicitly solves it.</p>",
        "id": 201141741,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592401187
    },
    {
        "content": "<p>I don't know what's going on but combining your snippets doesn't work for me.</p>",
        "id": 201141754,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592401194
    },
    {
        "content": "<p>Let me try and reduce the whole thing to just the bit that can't infer arguments to <code>mk_mul_mk</code></p>",
        "id": 201141876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592401243
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 201141992,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592401295
    },
    {
        "content": "<p>Indeed</p>",
        "id": 201142060,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592401319
    },
    {
        "content": "<p>ok I seem to have found the issue, and it is a real issue that needs fixing; let me gather my thoughts</p>",
        "id": 201143783,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402083
    },
    {
        "content": "<p>Wonderful, thanks. I got distracted fighting with an outdated lean on codewars which does not consider <code>∈</code> and <code>set.mem</code> as equivalent...</p>",
        "id": 201143861,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592402122
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">pi_instances</span>\n\n<span class=\"n\">def</span> <span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"o\">}</span>\n<span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">universes</span> <span class=\"n\">true</span>\n<span class=\"kn\">instance</span> <span class=\"n\">is_subgroup_</span><span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">one_mem</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">congr&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"k\">forall</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"c1\">-- (a, b) ∈ Δ.{?l_1} G → (a, b)⁻¹ ∈ Δ.{?l_1} G</span>\n    <span class=\"n\">rw</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">inv_mk</span><span class=\"o\">,</span> <span class=\"c1\">-- (a, b) ∈ Δ.{(max ?l_1 ?l_2)} G → (a⁻¹, b⁻¹) ∈ Δ.{(max ?l_1 ?l_2)} G</span>\n    <span class=\"c1\">-- intros h,</span>\n    <span class=\"c1\">-- rw Δ at *,</span>\n    <span class=\"c1\">-- simp at *,</span>\n    <span class=\"c1\">-- exact h,</span>\n    <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span> <span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">inv_mk</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">prod.inv_mk.{u_1 u_2} :</span>\n<span class=\"cm\">  ∀ {G : Type u_1} {H : Type u_2} [_inst_1 : has_inv.{u_1} G] [_inst_2 : has_inv.{u_2} H] (a : G) (b : H),</span>\n<span class=\"cm\">    (a, b)⁻¹ = (a⁻¹, b⁻¹)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 201144573,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402440
    },
    {
        "content": "<p>somehow <code>rw prod.inv_mk</code> brought into existence a new universe variable</p>",
        "id": 201144589,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402450
    },
    {
        "content": "<p>(it is noteworthy that avoiding <code>Type*</code> and using explicit universe variables avoids the problem completely</p>",
        "id": 201144627,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402468
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 201144696,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402491
    },
    {
        "content": "<p>Oh right, so one perhaps surprising thing is that <code>instance</code> is treated as a <code>def</code> even when (as here) we're proving a <code>Prop</code>; and this means that the body is used to elaborate the statement</p>",
        "id": 201144862,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592402556
    },
    {
        "content": "<p>and <code>Type*</code> makes no claim about the universe level</p>",
        "id": 201144944,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592402599
    },
    {
        "content": "<p>for the time being OP can use this (use <code>haveI</code> for instances instead of <code>have</code>):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory</span><span class=\"bp\">.</span><span class=\"n\">subgroup</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">pi_instances</span>\n\n<span class=\"n\">def</span> <span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">is_subgroup_</span><span class=\"err\">Δ</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">one_mem</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">hp</span> <span class=\"n\">hq</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">q</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">congr&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">congr&#39;</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">normal_</span><span class=\"err\">Δ</span><span class=\"bp\">_</span><span class=\"n\">iff_comm</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normal_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">sorry</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">intro</span> <span class=\"n\">h_comm</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"err\">∈</span> <span class=\"err\">Δ</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"err\">∈</span> <span class=\"err\">Δ</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span>\n            <span class=\"n\">sorry</span>\n        <span class=\"o\">},</span>\n        <span class=\"n\">haveI</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subgroup</span> <span class=\"o\">(</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_subgroup_</span><span class=\"err\">Δ</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">normal</span> <span class=\"o\">:=</span> <span class=\"n\">j</span> <span class=\"o\">},</span>\n    <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 201145132,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1592402665
    },
    {
        "content": "<p><code>Type*</code> is asking for trouble really</p>",
        "id": 201145227,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592402715
    },
    {
        "content": "<p>Note that the definition of Δ came from <a href=\"https://www.codewars.com/kata/5eb806b4e7c54e00246f70e1\">https://www.codewars.com/kata/5eb806b4e7c54e00246f70e1</a></p>",
        "id": 201145295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1592402746
    },
    {
        "content": "<p>I think using <code>Type*</code> in top-level <code>variables</code> should be \"safe\", although it probably won't be in Lean 4 from what I hear</p>",
        "id": 201145847,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592402990
    },
    {
        "content": "<p>Indeed, if you move <code>(G : Type*)</code> from <code>instance is_subgroup_Δ</code> to a top-level <code>variables</code>, then the extra universes disappear.</p>",
        "id": 201146453,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592403232
    },
    {
        "content": "<p>That said, the behavior Kenny showed also looks quite odd to me.</p>",
        "id": 201147075,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592403478
    },
    {
        "content": "<p>Oh, here's another thing I don't understand. If you put your cursor on the <code>prod.inv_mk</code> at the end of Kenny's file, it displays</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">inv_mk</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but the one in the line <code>rw prod.inv_mk</code> gives</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">inv_mk</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span><span class=\"bp\">.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">)}</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span><span class=\"bp\">.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"n\">u_1</span> <span class=\"n\">u_2</span><span class=\"o\">)}</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">⁻¹</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 201147291,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592403564
    },
    {
        "content": "<p>this is actually two things I don't understand, namely?</p>\n<ul>\n<li>why doesn't Lean just always show me the type of the declaration <code>prod.inv_mk</code>? what kind of local processing does it do?</li>\n<li>how did it arrive at this idea of using the universe <code>max u_1 u_2</code>, but not unifying <code>G</code> and <code>H</code> or <code>u_1</code> and <code>u_2</code>?</li>\n</ul>",
        "id": 201148050,
        "sender_full_name": "Reid Barton",
        "timestamp": 1592403873
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Note that you can request for the latest Lean version <a href=\"https://github.com/codewars/codewars-runner-cli/issues/new?template=request-language-version.md\">over at Codewars/codewars-runner-cli</a></p>",
        "id": 201261634,
        "sender_full_name": "Donald Sebastian Leung",
        "timestamp": 1592484008
    },
    {
        "content": "<p>BTW we have a <a class=\"stream\" data-stream-id=\"238266\" href=\"/#narrow/stream/238266-Codewars\">#Codewars</a> stream for Codewars-specific questions, if you'd like to take a look. I also created a topic there on upgrading Lean on Codewars to the latest version.</p>",
        "id": 201262876,
        "sender_full_name": "Donald Sebastian Leung",
        "timestamp": 1592484746
    },
    {
        "content": "<p>I can't understand why <code>representation k A V</code> is underlined with \"fails to synthesize type class instance for <code>module k (V →ₗ[k] V)</code>\" in :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">subrepresentation</span>\n  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">assoc_algebra</span> <span class=\"n\">k</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">k</span> <span class=\"n\">A</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but it succeeds when I change <code>structure</code> to <code>def</code>. Lean also succeeds if I copy the same variables into a <code>variables</code>.</p>",
        "id": 241681544,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622969778
    },
    {
        "content": "<p>For context, <code>representation</code> is defined with these variables:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">assoc_algebra</span> <span class=\"n\">k</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)]</span>\n</code></pre></div>",
        "id": 241681585,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622969872
    },
    {
        "content": "<p>What are your imports?</p>",
        "id": 241681859,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622970286
    },
    {
        "content": "<p><code>import algebra.module</code></p>",
        "id": 241681869,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622970312
    },
    {
        "content": "<p>Sorry, I guess I mean what is a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? For example, where is <code>assoc_algebra</code> from?</p>",
        "id": 241681886,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622970356
    },
    {
        "content": "<p><code>class assoc_algebra\n  (k : Type _) [field k] (A : Type _) [ring A] extends module k A</code></p>",
        "id": 241681936,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622970378
    },
    {
        "content": "<p>And then finally, what's your <code>representation</code> definition?</p>",
        "id": 241681952,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1622970433
    },
    {
        "content": "<p>Sorry I should really be including everything, but the problem seems to be fixed when I <code>import linear_algebra.basic</code></p>",
        "id": 241681971,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622970470
    },
    {
        "content": "<p>Which is where the instance for the module in question is defined</p>",
        "id": 241682014,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622970487
    },
    {
        "content": "<p>What's strange is that it succeeds when I write <code>def</code> instead of <code>structure</code>...</p>",
        "id": 241682022,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1622970513
    },
    {
        "content": "<p>I assume you're deliberately avoiding <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra\">docs#algebra</a> as a learning exercise?</p>",
        "id": 241682564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622971342
    },
    {
        "content": "<p>How can I fix this problem? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kd\">def</span> <span class=\"n\">S</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">S</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_one</span> <span class=\"bp\">↥</span><span class=\"n\">S</span>\n</code></pre></div>",
        "id": 242324033,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1623405730
    },
    {
        "content": "<p><code>f</code> returns an element of <code>S</code>, i.e. an element <code>y : ℕ</code> along with a proof <code>y ∈ S</code>. So you need to return the proof as well:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">set.mem_insert</span> <span class=\"mi\">1</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}⟩</span>\n</code></pre></div>",
        "id": 242324698,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1623406179
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/formation\">noted</a>, when you write <code>1 : S</code>, it really means \"lean can parse the syntax 1 into a term of type S\". So there's an alternative way to make your original version of <code>f</code> work, namely by telling Lean how to interpret the syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">set.mem_insert</span> <span class=\"mi\">1</span> <span class=\"o\">{</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}⟩⟩</span>\n</code></pre></div>\n<p>(This is the reason you got an error along the lines of \"failed to synthesize type class instance for <code>has_one S</code>\", rather than \"expected type <code>S</code>, but <code>1</code> has type <code>ℕ</code>\": Lean uses these typeclass instances to interpret numerals.)</p>",
        "id": 242325371,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1623406569
    },
    {
        "content": "<p>Note that the <code>1</code> is purely a bit of syntax with no meaning. So you can also define that <code>1 : S</code> actually corresponds to the natural number <code>2</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">set.mem_insert_of_mem</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">set.mem_insert</span> <span class=\"mi\">2</span> <span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">})⟩⟩</span>\n</code></pre></div>",
        "id": 242325457,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1623406621
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">fin.has_one'</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">#check</span> <span class=\"n\">fin.has_one'</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">fin.has_one'</span> <span class=\"n\">n</span> <span class=\"n\">i</span>\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Why does the definition of <code>f</code> report</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 247967545,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627936295
    },
    {
        "content": "<p>Since <code>fin n</code> is not a class, the argument <code>i</code> in the context is not available for your <code>fin.has_one'</code> instance to be selected, I think.</p>",
        "id": 247968027,
        "sender_full_name": "Reid Barton",
        "timestamp": 1627936526
    },
    {
        "content": "<p>Is there a minor change that solves this problem?</p>",
        "id": 247969305,
        "sender_full_name": "Alex Zhang",
        "timestamp": 1627937183
    },
    {
        "content": "<p>You could replace <code>{i : fin n}</code> by <code>[inhabited (fin n)]</code>.<br>\nBut the mathlib way is to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.has_one\">docs#fin.has_one</a>, which only gives <code>has_one (fin (succ n))</code></p>",
        "id": 247970251,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627937662
    },
    {
        "content": "<p>There might be a better/more mathlib-approved way of doing whatever it is you want to do with <code>1 : fin n</code>.</p>",
        "id": 247972140,
        "sender_full_name": "Reid Barton",
        "timestamp": 1627938762
    },
    {
        "content": "<p>You can always construct the same value as <code>⟨1, your_proof_that (1 &lt; n)⟩</code></p>",
        "id": 247975203,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627940559
    },
    {
        "content": "<p>Just because you somehow have a term of <code>i : fin 0</code> doesn't mean that suddenly you should be able to write <code>1</code> for things of <code>fin 0</code>.</p>",
        "id": 247975292,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1627940636
    },
    {
        "content": "<p>Hi, the following code fails with this message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">integral_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">R : Type u_1,</span>\n<span class=\"cm\">_inst_1 : integral_domain R,</span>\n<span class=\"cm\">K : Type u_2,</span>\n<span class=\"cm\">_inst_2 : field K,</span>\n<span class=\"cm\">_inst_3 : comm_ring K,</span>\n<span class=\"cm\">_inst_4 : algebra R K</span>\n<span class=\"cm\">⊢ algebra R K</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>I don't know why lean does not see the instance <code>_inst_4</code>...</p>",
        "id": 258266153,
        "sender_full_name": "Eloi Torrents",
        "timestamp": 1634675237
    },
    {
        "content": "<p>Try adding <code>set_option pp.all true</code> after the imports, is there a difference then?</p>",
        "id": 258266352,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1634675314
    },
    {
        "content": "<p>K is both a field and a comm ring</p>",
        "id": 258266475,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1634675385
    },
    {
        "content": "<p>So it has two completely unrelated ring structures and Lean is completely confused</p>",
        "id": 258266565,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1634675407
    },
    {
        "content": "<p>Try removing the <code>[comm_ring K]</code></p>",
        "id": 258266614,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1634675424
    },
    {
        "content": "<p>In my quest to learn Lean, I am trying to prove a result from one of my papers. Here is an excerpt of the proof :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.p_group</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.subgroup.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.quotient_group</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span>\n<span class=\"kn\">include</span> <span class=\"n\">hp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lemma1</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">is_p_group</span> <span class=\"n\">p</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≠</span> <span class=\"n\">subgroup.center</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∉</span> <span class=\"n\">subgroup.center</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">*</span><span class=\"n\">g</span><span class=\"bp\">*</span><span class=\"n\">s</span><span class=\"bp\">⁻¹*</span><span class=\"n\">g</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">∈</span> <span class=\"n\">subgroup.center</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.center</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">⧸</span> <span class=\"n\">Z</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">t₀</span> <span class=\"o\">:</span> <span class=\"n\">is_p_group</span> <span class=\"n\">p</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">is_p_group.to_quotient</span> <span class=\"n\">h₁</span> <span class=\"n\">Z</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">ZQ</span> <span class=\"o\">:=</span> <span class=\"n\">subgroup.center</span> <span class=\"n\">Q</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">tt</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">rr</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">Q</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">subgroup.center</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_p_group.center_nontrivial</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">zz</span> <span class=\"o\">:</span> <span class=\"n\">nontrivial</span> <span class=\"o\">(</span><span class=\"n\">subgroup.center</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">is_p_group.center_nontrivial</span> <span class=\"n\">t₀</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The first call to <code>is_p_group.center_nontrivial</code> works fine, but the second one yields an error : failed to synthesize type class instance</p>\n<p>The problem seems to be that <code>nontrivial Q</code> is not proved, but I did prove it (well, admit it) just before. </p>\n<p>What I am doing wrong?</p>",
        "id": 282766274,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652868714
    },
    {
        "content": "<p>You should use <code>haveI</code> instead of <code>have</code>, so that typeclass inference knows about it.</p>",
        "id": 282766922,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652869088
    },
    {
        "content": "<p>Oh, that worked. Thanks a lot.</p>",
        "id": 282766993,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652869164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> has marked this topic as resolved.</p>",
        "id": 282767009,
        "sender_full_name": "Notification Bot",
        "timestamp": 1652869169
    },
    {
        "content": "<p>The CS crowd don't like <code>lemma1</code> (and they convinced me they had a point!). But probably the \"mathlib name\" of your lemma is pretty long :-/</p>\n<p>Your <code>h₂</code> doesn't say what you think it says. Equality of types is a dangerous thing. If you want to say that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo stretchy=\"false\">(</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Z(G)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span></span></span></span> is not all of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> then you should say an equality of terms: <code>(h₂ : subgroup.center G ≠ ⊤)</code>. In Lean, <code>ℕ = ℤ </code> is undecidable!</p>\n<p><code>fintype</code> is constructive finiteness, it's not just the statement \"I am finite\", it's the data of the collection of all the elements. So it should be <code>letI  rr : fintype Q</code> -- this is because <code>fintype Q : Type</code> (or <code>Type u</code> in your case).</p>",
        "id": 282783178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652878724
    },
    {
        "content": "<p>Do we have a version of <code>is_field</code> for commutativity (apart from <code>commutative</code> and <code>is_commutative</code>, which don't have any API)? If so, that would be the right way to spell <code>subgroup.center G ≠ ⊤</code>.</p>",
        "id": 282784132,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652879026
    },
    {
        "content": "<p><code>is_abelian</code> doesn't seem to be a thing, so I guess not.</p>",
        "id": 282784224,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652879050
    },
    {
        "content": "<p>Kevin, thanks for the advice. I can see that things are a bit more complicated than I thought. </p>\n<p>In any case, I'll work on improving my lemma's names once I can finish a proof <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 282787668,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652880590
    },
    {
        "content": "<p>Learning quickly the difference between a type and a term is useful, and knowing which universe things are happening in is also useful (I tell my students that there are two universes, <code>Prop</code> and <code>Type</code>, although you seem to have already discovered that in fact there are infinitely many universes <code>Type u</code> indexed by the naturals; my feeling is that this is to a large extent of the axiom in type theory saying that everything must have a type, even <code>Type</code> itself; I am not sure this is relevant to mathematics until you get to e.g. etale cohomology and start having to worry about taking limits over things which are not sets). I don't know why we don't have a <code>Prop</code> stating that a type is finite; people have often talked about adding it but it hasn't quite happened yet. </p>\n<p>The type/term thing is happening because \"a subgroup is not a group\". A subgroup of G is a term, of type <code>subgroup G</code>. Of course one sometimes wants to make it into a group, and one does this using that \"promote a term to a type\" up-arrow which you might have spotted in your version of h2: <code>G ≠ ↥(subgroup.center G)</code>.  I suspect that even if G were abelian, <code>h2</code> might still be true, although it would probably also be unprovable. The problem is that if you take a type and then start playing around with it, making it into a term and then back into a type, the new type carries the same data as the old type but it's all wrapped up in a different way so it would probably not <em>equal</em> to the old type. An example which is perhaps less weird would be the statement that if you take a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and then quotient out by the zero ideal, you would get a new ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">R/\\{0\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span> which is not <em>equal</em> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, even though it's canonically isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>. You don't tend to get such problems with equality of terms; this concept is much better behaved.</p>",
        "id": 282793150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652882928
    },
    {
        "content": "<p>Yes, I think that fully understanding the difference between term and type and how to distinguish between the two is something I need to work on. Thanks for the taking the time to explain this to me !</p>",
        "id": 282797371,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652884828
    },
    {
        "content": "<p>It is term : type and type : universe, e.g. pi : real and real : Type, or &lt;proof&gt; : &lt;statement&gt; and &lt;statement&gt; : Prop. I learnt far too late that it was important to keep track of where \"usual mathematical objects\" lived in this hierarchy. For example if you want to define f : X -&gt; Y then X and Y had better be types (so you can have maps between groups but not between subgroups, unless you promote them from terms to types). Another stupid thing which didn't dawn on me for a long time: X -&gt; Y is itself a type, and <code>f : X -&gt; Y</code> is a term.</p>",
        "id": 282798099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652885118
    }
]