[
    {
        "content": "<p>In the following code, I don't see the definition of <code>fac</code> when my cursor is at the <code>have</code> keyword.  The <code>simp</code> tactic also fails with the error message: \"invalid argument, variable is not a proposition or let-declaration\".  But other than the squiggly line below <code>simp [fac]</code>, I don't see other error messages.  What is wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fac</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 512196675,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744676787
    },
    {
        "content": "<p>On the other hand, the following code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 512197034,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744676995
    },
    {
        "content": "<p><code>let rec</code> is basically shorthand for</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">mutual</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fac</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fac</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>and mutual definitions cannot unfold each others' definitions while being elaborated.</p>",
        "id": 512197223,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744677100
    },
    {
        "content": "<p>Maybe we should introduce <code>have rec</code> syntax as <a href=\"https://github.com/leanprover/lean4/issues/5216#issuecomment-2614404545\">discussed here</a>, since <code>have</code> already has \"cannot be unfolded\" semantics</p>",
        "id": 512198450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744677800
    },
    {
        "content": "<p>Reasonable idea. I'll make a note. (I'm going to try to make <code>let</code> and <code>have</code> have the same syntax this quarter.)</p>",
        "id": 512198850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744678010
    },
    {
        "content": "<p>Are you basically saying that <code>let rec</code> does not work in proof mode and only non-recursive <code>let</code> works?</p>",
        "id": 512211971,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744686222
    },
    {
        "content": "<p>It's more general: you cannot unfold a <code>let rec</code> from within the declaration that defines it. This is not only a limitation of proofs.</p>\n<p>In contrast, you can unfold non-recursive <code>let</code> because <code>let</code> simply creates a let binding in the local context.</p>",
        "id": 512214569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744687851
    },
    {
        "content": "<p>(<code>let rec</code> defines a global constant)</p>",
        "id": 512214603,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744687877
    },
    {
        "content": "<p>So, in order to define a recursive function in the proof mode, we basically need to make the recursive definition outside the proof or use some sort of iterator to make the definition non-recursive.  Correct?</p>",
        "id": 512215229,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744688250
    },
    {
        "content": "<p>Yes (but again, this is not about proof mode, it's about not being able to unfold <code>let rec</code> definitions until you leave the current declaration)</p>",
        "id": 512216562,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744688986
    },
    {
        "content": "<p>Actually, I think I agree that the <code>let rec</code> tactic is broken in concept. I don't know why it exists, given that you can't unfold such a definition from within a proof. (Left a comment <a href=\"https://github.com/leanprover/lean4/issues/7878#issuecomment-2803721112\">here</a>)</p>",
        "id": 512217141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744689319
    },
    {
        "content": "<p>Thanks for the explanations!</p>",
        "id": 512223138,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744692441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> has marked this topic as resolved.</p>",
        "id": 512223150,
        "sender_full_name": "Notification Bot",
        "timestamp": 1744692451
    },
    {
        "content": "<p>Relevant issue: <a href=\"https://github.com/leanprover/lean4/pull/7878\">lean4#7878</a> (oops, I see Kyle just mentioned it above)</p>",
        "id": 512250853,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1744703414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Is.20local.20recursive.20definition.20broken.20in.20proof.20mode.3F/near/512217141\">said</a>:</p>\n<blockquote>\n<p>Actually, I think I agree that the <code>let rec</code> tactic is broken in concept. I don't know why it exists, given that you can't unfold such a definition from within a proof. (Left a comment <a href=\"https://github.com/leanprover/lean4/issues/7878#issuecomment-2803721112\">here</a>)</p>\n</blockquote>\n<p>I don't understand this \"broken in concept\" bit, the <code>let rec</code> tactic is just the tactic version of the <code>let rec</code> term constructor and it works just fine as that</p>",
        "id": 512320443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744723620
    },
    {
        "content": "<p>the <code>let rec</code> tactic is no more broken than the corresponding term</p>",
        "id": 512320579,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744723655
    },
    {
        "content": "<p>besides this, I have definitely done proofs that use <code>let rec</code>. You can use it to do proofs by induction using the power of the equation compiler</p>",
        "id": 512320727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744723691
    },
    {
        "content": "<p>I think the confusion would all go away if it were instead called <code>have rec</code>. <code>let rec</code> seems broken only if you compare it to <code>let</code>.</p>",
        "id": 512322371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744724114
    },
    {
        "content": "<p>(the same is true for <code>let</code> pattern matching, <a href=\"https://github.com/leanprover/lean4/pull/5216\">lean4#5216</a>)</p>",
        "id": 512322511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1744724157
    },
    {
        "content": "<p>I feel like most of the resistence to this is people wanting lean to use <code>let</code> the way it is used in ML and Haskell</p>",
        "id": 512327444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744725363
    },
    {
        "content": "<p>It's definitely true that we would have a better time if we just got on board with using <code>have</code> in programming instead of <code>let</code></p>",
        "id": 512327625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744725406
    },
    {
        "content": "<p>people were talking about <code>let dep</code> for what we now call <code>let</code> but it seems to just be trying too hard</p>",
        "id": 512327782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744725444
    },
    {
        "content": "<p><code>let rec</code> just has that ring of familiarity that <code>have rec</code> doesn't</p>",
        "id": 512328208,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744725535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Could you give an example of how <code>let rec</code> is used effectively in proof mode?</p>",
        "id": 512378005,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744738332
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">join_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">join</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flatten</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">cs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">cs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flatten</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"bp\">⟩::</span><span class=\"n\">ss</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">go</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n</code></pre></div>",
        "id": 512378741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744738581
    },
    {
        "content": "<p>the original version of this proof was written with <code>where</code> and term mode but the idea is the same</p>",
        "id": 512378810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744738610
    },
    {
        "content": "<p>Here are some questions for you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>:</p>\n<p>If the <code>let rec</code> tactic only supported mutual recursion inside the <code>let rec</code>(so, no calling the top-level theorem being defined, or other declarations in a <code>mutual</code> block, or any <code>where</code> definitions, or term-mode <code>let rec</code>s), would you feel like you're missing anything? If so, would this limitation be worth it if it allowed unfolding the auxiliary definitions in the rest of the proof?</p>\n<p>What I mean by \"conceptually broken\" is that defining recursive data is not useful from within a proof. Generally for data there's no question about whether a type is empty or not, and <code>let rec</code> inside a proof right now only seems to be useful for proving a type is inhabited. I fully support having something like <code>let rec</code> for use within proofs, there's no need to defend that.</p>\n<p>We could let <code>have rec</code> be the current <code>let rec</code> tactic, since there's no harm in allowing arbitrary recursion, especially if it's clear the value is opaque. I just keep seeing questions about <code>let rec</code> pop up, and I think we could support almost every case if we accept the need for more limited mutual recursion. We could even give nice error messages with suggestions of what to do instead in case the recursion is unsupported.</p>",
        "id": 512382729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744739847
    },
    {
        "content": "<blockquote>\n<p>If the <code>let rec</code> tactic only supported mutual recursion inside the <code>let rec</code>(so, no calling the top-level theorem being defined), would you feel like you're missing anything? If so, would this limitation be worth it if it allowed unfolding the auxiliary definitions in the rest of the proof?</p>\n</blockquote>\n<p>To my knowledge I have never used the facility of <code>let rec</code> to call the parent declaration</p>",
        "id": 512382829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744739880
    },
    {
        "content": "<p>I agree that it feels like a layering violation</p>",
        "id": 512382932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744739904
    },
    {
        "content": "<p>although things get interesting when you have multiple <code>let rec</code>s in a single declaration</p>",
        "id": 512383021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744739926
    },
    {
        "content": "<p>I think for declarations with <code>where</code>, there have been cases of the child functions calling the main one</p>",
        "id": 512383137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744739965
    },
    {
        "content": "<p>and it would be sad to break the equivalence between <code>where</code> and <code>let rec</code></p>",
        "id": 512383173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744739982
    },
    {
        "content": "<p>Just to be clear, I'm in full support of changing <code>let rec</code> to <code>have rec</code> and using <code>let rec</code> for something which elaborates first and has definition unfolding</p>",
        "id": 512383500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744740063
    },
    {
        "content": "<p>I'm pretty sure I've used <code>where</code> functions to call the main function.</p>\n<p>I wouldn't propose to change that. The scope is just the <code>let rec</code> tactic: is it OK if it's not exactly the <code>let rec</code> term, if it allows definition unfolding.</p>",
        "id": 512383662,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744740114
    },
    {
        "content": "<p>I'm merely speculating regarding why people (lean devs) have historically been reticent to stop using <code>let</code> in do blocks and <code>let rec</code> in this case even though we have <code>have</code> as a clear and consistent alternative with the semantics we want</p>",
        "id": 512383944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744740184
    },
    {
        "content": "<p><del><code>have</code> isn't even a doElem</del></p>",
        "id": 512384068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744740221
    },
    {
        "content": "<p>It seems to me that Mario's example does not correspond to how <code>let</code>is typically used in a proof.  For example, consider the proof of Baire's theorem in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a>:</p>\n<p><a href=\"https://leanprover-community.github.io/mathematics_in_lean/C10_Topology.html#completeness\">https://leanprover-community.github.io/mathematics_in_lean/C10_Topology.html#completeness</a></p>\n<p>Here a sequence of <code>let</code>s are used to organize the definitions of some terms which appear in propositions to be proved.  If that represents how <code>let</code> is typically used in proofs, then a \"normal\" user (like me) would expect <code>let rec</code> should behave in the same way and be very surprised when it doesn't.</p>",
        "id": 512389898,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744742124
    },
    {
        "content": "<p>I'm using <code>let rec</code> there like someone would use <code>have</code> or <code>suffices</code> in a normal proof</p>",
        "id": 512389975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742159
    },
    {
        "content": "<p>(followed by a proof by induction, some case splitting and other things which <code>let rec</code> gives nice syntax for)</p>",
        "id": 512390068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742188
    },
    {
        "content": "<p>Then call it <code>have rec</code> instead.</p>",
        "id": 512390155,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1744742232
    },
    {
        "content": "<p>I think I have been vigorously agreeing with everyone on that point?</p>",
        "id": 512390209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742253
    },
    {
        "content": "<p>the people who come out in support of <code>let</code> are not present in this discussion</p>",
        "id": 512390466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742358
    },
    {
        "content": "<p>and even the ones who speak out have seemingly been doing so on behalf of others</p>",
        "id": 512390551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742389
    },
    {
        "content": "<p>related discussions: <a href=\"https://github.com/leanprover/lean4/pull/1345\">lean4#1345</a>, <a href=\"https://github.com/leanprover/lean4/pull/1449\">lean4#1449</a>. Note that <code>have</code> is never actually considered in the posts there, but <code>let_fun</code> exists and it's so obvious a candidate that I can only imagine that it's been rejected out of hand for reasons not elucidated in the thread</p>",
        "id": 512391563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744742731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Is.20local.20recursive.20definition.20broken.20in.20proof.20mode.3F/near/512390551\">said</a>:</p>\n<blockquote>\n<p>and even the ones who speak out have seemingly been doing so on behalf of others</p>\n</blockquote>\n<p>What do you mean? Are you talking about previous discussions in support of <code>let</code>?</p>\n<p>Thanks for linking to these Lean issues. Right now I'm in the requirements collection phase to finally try to do something about the whole family of <code>let</code> syntaxes this quarter. I'm not sure why <code>have</code> wasn't considered back in 2022. I think there's agreement among Lean devs that \"<code>let_fun</code>\" is an obscure name.</p>\n<p>My current thinking is that <code>let</code> and <code>have</code> are too well-known at this point, and anything that adjusts whether or not <code>let</code> bindings can zeta reduce is problematic (so probably no <code>let dep</code>). I think we should deprecate <code>let_fun</code> in favor of <code>have</code> too, if there are no technical obstacles. An idea we have to address the <code>let</code> performance issues is to have an elaboration step that aggressively turns <code>let</code>s into <code>have</code>s in terms (for example, done while <code>let</code> is elaborated, in case the body has no metavariables, or before a declaration is added to the environment).</p>\n<p>It sort of makes sense to me to have the <code>let</code>/<code>have</code> tactics be slightly different from the corresponding terms, but I am strongly trying to avoid it; the idea would be that the <code>let</code> term would be non-dependent, <code>let dep</code> would be the dependent term, and <code>let</code> the tactic would be <code>let dep</code>. Beyond the confusion (I'm sure we'd see \"why can't I lift this <code>let</code> outside the <code>by</code> block\" on Zulip), a big problem with this is that in programming contexts people do occasionally depend on zeta reduction (e.g. <code>let n := 2; let m : Fin n := 1; ...</code> — why should it not work just because a constant was used?). There's no mechanism to have Lean teach people about <code>let dep</code> when something that looks like it should work doesn't work.</p>\n<p>(I don't know if it will happen, but ideally we would allow other defeqs, like in pattern matching <code>let</code>, given that questions keep coming up and there are no good alternatives. I could imagine <code>match</code> being able to preserve defeqs in some well-specified circumstances, in particular when destructing a structure.)</p>",
        "id": 512407254,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744748611
    },
    {
        "content": "<blockquote>\n<p>I think there's agreement among Lean devs that \"<code>let_fun</code>\" is an obscure name.</p>\n</blockquote>\n<p>Just in case that sentence was confusing: \"it's so obvious a candidate\" is referring to <code>have</code>, and to me the only possible explanation I can give for <code>let_fun</code> existing is because we want <code>have</code> semantics while still keeping a <code>let</code> based name. So I deduce that we must really not have liked <code>have</code> because <code>let_fun</code> is so much worse from every other perspective.</p>",
        "id": 512409200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744749411
    },
    {
        "content": "<p>I believe you're right that this is why <code>let_fun</code> exists (it has <code>let</code> in the name). I think the fact that still people are confused about <code>let_fun</code> (does it define a function? or what?) will be enough to have it be deprecated in favor of <code>have</code>. We'll see.</p>\n<p>A pushback in the past has been that <code>have</code> seems like it might be for proofs only. However, I think that the word still works for data. With <code>let x : Nat := v</code>, you're saying \"let <code>x</code> stand for the natural number <code>v</code>\", but with <code>have x : Nat := v</code>, you're saying \"we have a natural number <code>x</code>, and it has the value <code>v</code>\". It's less focus on it <em>being</em> <code>v</code>. Whether or not anyone buys this, there's still a good story here when it comes to streamlining the language.</p>",
        "id": 512411524,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744750350
    },
    {
        "content": "<p>There is also the possibility of introducing other programmy keywords from other languages like <code>val</code> or <code>var</code> but I can't imagine this making things clearer</p>",
        "id": 512411811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744750447
    },
    {
        "content": "<p>Yeah, there was also the idea of <code>abbrev</code> instead of <code>let</code>, since at least that's a keyword already, but we can't realistically change <code>let</code>.</p>",
        "id": 512411982,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744750518
    },
    {
        "content": "<p>It would be neat if <code>let</code>/<code>have</code> had some syntax to get an equality, like what <code>set</code>/<code>generalize</code> provide. (I don't have any serious syntax for it, but <code>have x := h : 2</code> would work, as ugly as that might be. Or perhaps <code>have h:@x := 2</code> would be some variant of <code>@</code> patterns that can get access to the value being matched?)</p>\n<p>One idea that came up at some point was letting <code>have</code> generalize the expected type. That's not good in general, but it could be behind an option (<code>have +generalize x := 2</code>?), and then the <code>generalize</code> tactic would be a frontend.</p>",
        "id": 512412688,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744750823
    },
    {
        "content": "<p>if you use the <code>set</code> tactic syntax you would get <code>have x := 2 with h</code></p>",
        "id": 512413267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744751065
    },
    {
        "content": "<p>it's not particularly self-documenting, but then again neither are the sigil heavy options</p>",
        "id": 512413327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744751095
    },
    {
        "content": "<p>maybe just keep it simple/general and do <code>have (eq := h) x := 2</code>?</p>",
        "id": 512413431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744751136
    },
    {
        "content": "<p>That last one is nice since it lets you see the variables being defined up front. It also works well with \"<code>haveEqnsDecl</code>\" declarations, where a trailing <code>with</code> clause would be awkward.</p>",
        "id": 512414549,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744751636
    },
    {
        "content": "<p>Also, I assume you are already considering this but just in case, I would like there not to be <code>haveEqnsDecl</code> and <code>letEqnsDecl</code> any more after your refactor. They should be identical grammars except for the head keyword</p>",
        "id": 512414924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744751783
    },
    {
        "content": "<p>(I am <em>not</em> looking forward to the bootstrapping issues :-/ but yeah, it needs to be done.)</p>",
        "id": 512415080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1744751856
    },
    {
        "content": "<p>yeah, changing parsers is never fun</p>",
        "id": 512415111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744751873
    }
]