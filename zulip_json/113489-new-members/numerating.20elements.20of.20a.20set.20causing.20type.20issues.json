[
    {
        "content": "<p>Hello everyone,</p>\n<p>I defined a directed walk in a directed graph with start and ending points in V. However, I would like to have a path which starting and ending points are in A and B, respectively. Additionally, as I want to define n different path, I want to numerate the elements in A.verts and B.verts by making them a list. But then the nth member of that list hast the wrong type to be plugged in the direct walk. Here a MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">directed_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">):=</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">directed_simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive decidable_eq]</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">directed_walk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">vertex_subset_n</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">verts</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"o\">:</span> <span class=\"n\">verts.card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">vertex_subset_n</span> <span class=\"n\">n</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">directed_walk</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">A.verts</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">finish</span> <span class=\"o\">:</span> <span class=\"n\">B.verts</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p2</span> <span class=\"o\">:</span> <span class=\"n\">G.directed_walk</span> <span class=\"n\">start</span> <span class=\"n\">finish</span><span class=\"o\">}</span> <span class=\"c1\">--works but start and end point are not numerated</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">A.verts</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_list.nth</span> <span class=\"mi\">1</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">directed_walk</span> <span class=\"n\">t</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"c1\">-- does not work</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">directed_walk</span>\n<span class=\"kd\">end</span> <span class=\"n\">directed_simple_graph</span>\n</code></pre></div>\n<p>The knowledge that <code>.nth 0</code> up to <code>.nth (n-1)</code> is a member of the list :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">A_verts_list_length_eq_n</span> <span class=\"o\">:</span> <span class=\"n\">A.verts.to_list.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>  <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.length_to_list</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">A.card</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>How can I combine those such that I can numerate my start and end points, as it is important to differentiate between different ones ?<br>\nAny help is appreciated.</p>",
        "id": 321618475,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673868864
    },
    {
        "content": "<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>",
        "id": 321618750,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673868957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417654\">Martin Dvořák</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321618750\">schrieb</a>:</p>\n<blockquote>\n<p>I didn't read your code so my answer is possibly OT, but I wanna say that <code>list.nth</code> and <code>list.nth_le</code> indexes elements from zero.</p>\n</blockquote>\n<p>Thats true, but unfortunately not helpful. Nevertheless, edited the last part, should be correct now.</p>",
        "id": 321619226,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673869071
    },
    {
        "content": "<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>",
        "id": 321620031,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673869284
    },
    {
        "content": "<p>Also, having a universe <code>u</code> and a \"graph vertex <code>u</code>\" is probably not a good idea.</p>",
        "id": 321620883,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1673869544
    },
    {
        "content": "<p>Is there a way to make the compiler complain about these name collisions?</p>",
        "id": 321621222,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673869665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031\">schrieb</a>:</p>\n<blockquote>\n<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>\n</blockquote>\n<p>Fair enough.<br>\nWell I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>\n<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>\n<ul>\n<li>a permutation s and its sign</li>\n<li>n paths p_i : A_i \\to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>\n(- vertex disjointness of the paths)</li>\n</ul>\n<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>",
        "id": 321621638,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673869803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620883\">said</a>:</p>\n<blockquote>\n<p>Also, having a universe <code>u</code> and a \"graph vertex <code>u</code>\" is probably not a good idea.</p>\n</blockquote>\n<p>Maybe not, but for better or for worse we've been doing this in mathlib code throughout the graph library and its seems to work out fine</p>",
        "id": 321644888,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673876900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"573061\">@Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>",
        "id": 321645574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877101
    },
    {
        "content": "<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>",
        "id": 321646478,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> I see your <span aria-label=\"prohibited\" class=\"emoji emoji-1f6ab\" role=\"img\" title=\"prohibited\">:prohibited:</span>, but universe level variables and normal variables are in different namespaces, so it can't cause problems for Lean at least.</p>",
        "id": 321646864,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673877483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321621638\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321620031\">schrieb</a>:</p>\n<blockquote>\n<p>Can we <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this? What is the main theorem you're wanting to prove? You're getting into territory where it's helpful to know the goal.</p>\n</blockquote>\n<p>Fair enough.<br>\nWell I am trying to formalize the Lindström Gessel Viennot Lemma as a bachelor thesis (therefore all the directed stuff). So I am working on establishing all the necessary objects which are weights, weight of a walk, path system, weight of path system, path matrix.</p>\n<p>The current goal is to define the structure of a (vertex disjoint) path system which needs </p>\n<ul>\n<li>a permutation s and its sign</li>\n<li>n paths p_i : A_i \\to B_s(i), whereas A and B are subsets of the vertices of cardinality n<br>\n(- vertex disjointness of the paths)</li>\n</ul>\n<p>Therefor the effort to numerate A.verts and B.verts and get the correct elements as an input for direct walks.</p>\n</blockquote>\n<p>Let's rather focus on the question.</p>",
        "id": 321647292,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1673877603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321645574\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"573061\">Christopher Schmidt</span> I'm not sure I understand exactly what you're trying to do yet (what does it mean to <em>numerate</em> a set?), but maybe it's helpful to know that the way we talk about ordered finite lists of elements is either <code>f : fin n -&gt; V</code> or the combination <code>[fintype α]</code> with <code>f : α -&gt; V</code>. Sometimes we use a coercion, where <code>s : finset α</code> and then use <code>f : s -&gt; V</code>.</p>\n</blockquote>\n<p>Maybe, what I have got by now, illustrates my issue more clearly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">structure</span> <span class=\"n\">path_system</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">vertex_subset_n</span> <span class=\"n\">n</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">finset.range</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">start_pts</span> <span class=\"o\">:=</span> <span class=\"n\">A.verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">finish_pts</span> <span class=\"o\">:</span> <span class=\"n\">B.verts</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">start</span>  <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">A.verts</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- λ i, A.verts.to_list.nth i</span>\n<span class=\"o\">(</span><span class=\"n\">finish</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">B.verts</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- λ i, B.verts_to_list.nth σ(i)</span>\n<span class=\"o\">(</span><span class=\"n\">n_walks</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">G.directed_walk</span> <span class=\"n\">start_pt</span> <span class=\"n\">finish_pt</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.directed_walk</span> <span class=\"n\">start_pt</span> <span class=\"n\">finish_pt</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">start_pt</span> <span class=\"bp\">=</span> <span class=\"n\">start</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">finish_pt</span> <span class=\"bp\">=</span> <span class=\"n\">finish</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)})</span>\n<span class=\"o\">(</span><span class=\"n\">sgn</span> <span class=\"o\">:=</span> <span class=\"n\">σ.sign</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I somehow want to manage that the starting and ending point of a walk are precisely the corresponding ones in the following sense:<br>\nn_walk (i) goes from i to \\sigma(i).<br>\nTherefore, I need to be able to numerate the elements of A and B. But a list as suggested in the comments cuases type issues. Is there a way out of this arising type issue ?</p>\n<p>I also thought about leaving away the \\sigma and just claim that any starting and ending point of A and B is only used once. However, I need the concrete bijection as I need the sign.</p>",
        "id": 321652264,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673878796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321646478\">said</a>:</p>\n<blockquote>\n<p>Then when you have a pair of such a family of elements (for example <code>[fintype α]</code> with <code>f g : α -&gt; V</code>), you can work with <code>Π (i : α), G.directed_walk (f i) (g i)</code>, which is an <code>α</code>-indexed family of walks.</p>\n</blockquote>\n<p>Let me mention this again, since this is how you can have a system of walks that go between corresponding vertices.</p>",
        "id": 321653671,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879118
    },
    {
        "content": "<p>There are a few formulations of this, but this is the general idea.</p>",
        "id": 321653754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879136
    },
    {
        "content": "<p>In Lean, you usually have to translate things from set theory to type theory. Oftentimes, if you see \"a finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a_1,\\dots,a_n\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>\" it's better to translate it to \"a function <code>f : fin n -&gt; A</code>\" rather than speak of sets at all.</p>",
        "id": 321654149,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/numerating.20elements.20of.20a.20set.20causing.20type.20issues/near/321653754\">schrieb</a>:</p>\n<blockquote>\n<p>There are a few formulations of this, but this is the general idea.</p>\n</blockquote>\n<p>Ok thank you. I thought its just shifting the problem to defining the sign, but I will try.</p>",
        "id": 321654413,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673879301
    },
    {
        "content": "<p>The sign of a permutation should already exist somewhere in mathlib.</p>",
        "id": 321654487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879320
    },
    {
        "content": "<p>Unless you're talking about defining a new concept, like a sign of a path system or something.</p>",
        "id": 321654637,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879358
    },
    {
        "content": "<p>Oh, I see, you already found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.sign\">docs#equiv.perm.sign</a></p>",
        "id": 321654837,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673879407
    },
    {
        "content": "<p>Yes. Well, I better try to use your suggested approach with f and g and hoepfully get the points and sign right. <br>\nThanks again.<br>\nI apologize if I have not stated the problem properly and/or wasted your time.</p>",
        "id": 321656255,
        "sender_full_name": "Christopher Schmidt",
        "timestamp": 1673879729
    }
]