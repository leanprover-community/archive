[
    {
        "content": "<p>I am trying to use bv_decide on a vector of variables, and it returns with a \"potientially spurious counterexample\": </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">BitVec</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The prover found a counterexample, consider the following assignment: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> x = 0x3#2 -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> y = 0x3#2 -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"bp\">~~~</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The prover found a potentially spurious counterexample: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> - It abstracted the following unsupported expressions as opaque variables: [x[1], x[0]] -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Consider the following assignment: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> v[0] = 0x3#2 -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> v[1] = 0x3#2 -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">vector_test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;&amp;</span><span class=\"w\"> </span><span class=\"bp\">~~~</span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n</code></pre></div>\n<p>I  understand from this GitHub issue [<a href=\"http://url\">https://github.com/leanprover/lean4/issues/5326</a>] that bv_decide doesn't always work with abstracted terms. In the case above, the counterexample is correct, but I want to use Array.foldl to generate new constraints (e.g., to check whether each component of the vector is 0). Is there a way that I could generate n variables (of the same type) in a theorem using a macro, or would I need to combine my variables into a single BitVec? I tried writing a macro to create two variables, and that didn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"#vars\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">))</span>\n\n<span class=\"bp\">#</span><span class=\"n\">vars</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> unknown identifier 'x' -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> unknown identifier 'y' -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">macro_test</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">bv_decide</span>\n</code></pre></div>",
        "id": 491771930,
        "sender_full_name": "Oscar Bender-Stone",
        "timestamp": 1735917569
    },
    {
        "content": "<blockquote>\n<p>I understand from this GitHub issue <a href=\"https://github.com/leanprover/lean4/issues/5326\">https://github.com/leanprover/lean4/issues/5326</a> that bv_decide doesn't always work with abstracted terms</p>\n</blockquote>\n<p>Yes, the reason for this is that <code>bv_decide</code> only works on <code>BitVec</code> and <code>Bool</code> theory so when you have, in your case, a <code>Vector</code> term around there is nothing saying that you might not have additional hypotheses from the theorey that your <code>BitVec</code> atoms are coming from that would invalidate counter examples that <code>bv_decide</code> finds so it has to account for this.</p>\n<p>Your macro doesn't work because of <a href=\"https://leanprover-community.github.io/lean4-metaprogramming-book/main/06_macros.html?highlight=hygiene#hygiene-issues-and-how-to-solve-them\">hygiene</a>.</p>\n<p>It's not quite clear to me what your desired end goal here is. Do you want to generate a theorem statements automatically? Do you want to automatically introduce additional hypotheses?</p>",
        "id": 491773941,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1735918522
    },
    {
        "content": "<p>Oh I see - thank you for the clarification on bv_decide and hygiene.</p>\n<p>I want to generate theorem statements automatically. For instance, I would like to write something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"n\">xn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">x1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">...</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">xn</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>for, say, n = 3.</p>",
        "id": 491774497,
        "sender_full_name": "Oscar Bender-Stone",
        "timestamp": 1735918807
    },
    {
        "content": "<p>You can write a macro that does something like this in principle sure. Is there a particular reason you dislike the <code>Vector</code> based approach?</p>",
        "id": 491774664,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1735918922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/Variable.20Macro.20For.20bv_decide/near/491774664\">said</a>:</p>\n<blockquote>\n<p>Is there a particular reason you dislike the <code>Vector</code> based approach? In my situation, I have several constraints like these:</p>\n</blockquote>\n<p>Is there a way to make bv_decide work with Vector and Array.foldl?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> The prover found a potentially spurious counterexample: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> - It abstracted the following unsupported expressions as opaque variables: [BitVec.ofBool (gt_one vars)] -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Consider the following assignment: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> BitVec.ofBool (gt_one vars) = 0x0#1 -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">gt_one_test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">bv_decide</span>\n</code></pre></div>\n<p>I want to make sure bv_decide does return sat if the theorem is actually sat and not this error message. It would be great if I could also get the counter-example. Either way, I am not sure how to expand out Array.foldl to make this work.</p>",
        "id": 491775744,
        "sender_full_name": "Oscar Bender-Stone",
        "timestamp": 1735919450
    },
    {
        "content": "<p>Basically speaking <code>bv_decide</code> will only work on things that are within the basic <code>BitVec</code> theory of Lean so if you want to call it you need to first simplify your goal towards this. What you can do in this specific situation is run something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">gt_one_test</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">gt_one</span><span class=\"w\"> </span><span class=\"n\">vars</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">gt_one</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">foldlM</span><span class=\"bp\">.</span><span class=\"n\">loop</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n</code></pre></div>\n<p>Which is of course a bit annoying but works out. If we had more <code>simp</code> API around this type of stuff this would certainly be more convenient to write.</p>",
        "id": 491776257,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1735919717
    },
    {
        "content": "<p>Thank you, that works well! I appreciate your help! I didn't know about completely simplifying Array.foldl.</p>",
        "id": 491777453,
        "sender_full_name": "Oscar Bender-Stone",
        "timestamp": 1735920259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816443\">Oscar Bender-Stone</span> has marked this topic as resolved.</p>",
        "id": 491777472,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735920267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816443\">Oscar Bender-Stone</span> has marked this topic as unresolved.</p>",
        "id": 491798598,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735930967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816443\">Oscar Bender-Stone</span> has marked this topic as resolved.</p>",
        "id": 491798803,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735931074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816443\">Oscar Bender-Stone</span> has marked this topic as unresolved.</p>",
        "id": 491810882,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735937381
    },
    {
        "content": "<p>Could anyone provide some code to generate variables via a macro in a theorem? Currently, when I use BitVec, it sometimes assigns the same component of a vector two two different numbers. I think the main culprit is using .toNat in a few functions, so if there is a way to simplify .toNat methods instead, that would be even better.</p>",
        "id": 491811052,
        "sender_full_name": "Oscar Bender-Stone",
        "timestamp": 1735937466
    }
]