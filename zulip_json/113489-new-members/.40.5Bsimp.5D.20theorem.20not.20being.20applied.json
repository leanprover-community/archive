[
    {
        "content": "<p>In the following, why is <code>ofReal_re</code> not being applied by <code>simp</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n  <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyComplex</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofReal_re</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 384876245,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692038982
    },
    {
        "content": "<p>Because <code>(2 : MyComplex).re</code> is not syntactically the same as <code>((2 : ℝ) : MyComplex).re</code></p>",
        "id": 384876532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692039046
    },
    {
        "content": "<p>I see.  I goes from Nat to MyComplex without going through Real.</p>",
        "id": 384876688,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692039091
    },
    {
        "content": "<p>You want a lemma more like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_re</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">Real</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ofNat</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">ofNat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 384876958,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1692039138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/.40.5Bsimp.5D.20theorem.20not.20being.20applied/near/384876958\">said</a>:<br>\nThanks a lot Eric.  I'm struggling to get this to work.  On the one hand, <code>OfNat</code> seems to only work for raw number literals, as <code>#check (2 : MyComplex)</code> works, but this doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>On the other hand, the <a href=\"https://github.com/leanprover/lean4/blob/master/src/Init/Prelude.lean#L1061\">definition of OfNat</a> seems like it should work for all <code>Nat</code>.  Also, to get your example to pass the type checker, I changed it to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_re</span> <span class=\"n\">n</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>However, <code>simp</code> is still refusing to simplify <code>(2 : MyComplex).re</code>.  Here's my latest <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n  <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">Real</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyComplex</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofReal_re</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_re</span> <span class=\"n\">n</span> <span class=\"o\">[</span><span class=\"n\">OfNat</span> <span class=\"n\">ℝ</span> <span class=\"n\">n</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>\n</code></pre></div>",
        "id": 385280524,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692130837
    },
    {
        "content": "<p>No, <code>OfNat</code> is specifically for number literals</p>",
        "id": 385280967,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692131100
    },
    {
        "content": "<p>So the parser translates expressions like <code>(2 : X)</code> into <code>OfNat.ofNat X 2 (instOfNatX 2)</code>, but doesn't do the same for <code>(n : X)</code> where <code>n</code> is a <code>Nat</code>?</p>",
        "id": 385281465,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692131390
    },
    {
        "content": "<p>I don't really know how it works. It seems like this might be more of a <code>simp</code> issue?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n  <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyComplex</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofReal_re</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_re</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">OfNat.ofNat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"c1\">-- Does nothing</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ofNat_re</span><span class=\"o\">]</span> <span class=\"c1\">-- Does nothing</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ofNat_re</span><span class=\"o\">]</span> <span class=\"c1\">-- Works</span>\n  <span class=\"n\">simp</span><span class=\"bp\">?</span> <span class=\"n\">says</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Nat.cast_ofNat</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ofNat_re</span> <span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- Works</span>\n</code></pre></div>",
        "id": 385281737,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1692131522
    },
    {
        "content": "<p>Here's the latest strangeness: including <code>OfNat</code> causes an unrelated example to fail:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n  <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">⟩</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">zero_re</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Add</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span>  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">w.re</span><span class=\"o\">,</span> <span class=\"n\">z.im</span> <span class=\"bp\">+</span> <span class=\"n\">w.im</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">add_re</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"bp\">+</span> <span class=\"n\">w.re</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyComplex</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>\n<p>Adding <code>rw [zero_re]</code> I get \"did not find instance of <code>0.re</code>\" in <code>0.re = 0</code>.  Similar with <code>apply zero_re</code>.  What's going on here?</p>",
        "id": 385977835,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692387779
    },
    {
        "content": "<p>Note that the first <code>example</code> succeeds, only the second one fails.</p>",
        "id": 385977897,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692387813
    },
    {
        "content": "<p>The issue is that we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Zero.toOfNat0#doc\">docs#Zero.toOfNat0</a> which gives you an <code>OfNat α 0</code> instance in the presence of <code>Zero α</code>. But then since you have (actually, yours is missing <code>{n : ℕ}</code>, but whatever):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">MyComplex</span> <span class=\"n\">n</span> <span class=\"n\">where</span>\n  <span class=\"n\">ofNat</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">}</span>\n</code></pre></div>\n<p>you get a <em>new</em> <code>OfNat MyComplex 0</code> instance, and these are not the same.</p>",
        "id": 385980000,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1692388611
    },
    {
        "content": "<p>You can see how we deal with this in mathlib by looking at <a href=\"https://tqft.net/mathlib4files/Mathlib/Mathlib/Data/Nat/Cast/Defs\">file#Mathlib/Mathlib/Data/Nat/Cast/Defs</a> where we define an <code>AtLeastTwo</code> type class, and only provide an instance for that for <code>n + 2 : ℕ</code>. Then we give an <code>OfNat</code> instance for only those things that are <code>AtLeastTwo</code>. This circumvents the issues that would arise if we gave generic <code>OfNat</code> instances like you did in the presenve of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Zero.toOfNat0#doc\">docs#Zero.toOfNat0</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=One.toOfNat1#doc\">docs#One.toOfNat1</a>.</p>",
        "id": 385980744,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1692388906
    },
    {
        "content": "<p>Thanks again for the pointer.  I've been staring at this for a while, but I'm not sure how I can use it.  Do I declare my own instance of <code>NatCast MyComplex</code>?  The <code>R</code> in that file is never explicitly defined.  I assume it's inferred as a variable from the definition <code>NatCast R</code>?</p>",
        "id": 387144166,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692902664
    },
    {
        "content": "<p>I just tried it, and it seems to be working...</p>",
        "id": 387144698,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692902908
    },
    {
        "content": "<p>If you first make the complexes into a ring then there will automatically be a coercion from the naturals, and if you've defined another one then by the time you've shown it's a ring there might be problems.</p>",
        "id": 387146889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1692903953
    },
    {
        "content": "<p>On the other hand, I now can't get my original example working:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">where</span>\n  <span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n  <span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Coe</span> <span class=\"n\">ℝ</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofReal_re</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Zero</span> <span class=\"n\">MyComplex</span> <span class=\"o\">:=</span> <span class=\"o\">⟨(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">zero_re</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">NatCast</span> <span class=\"n\">MyComplex</span> <span class=\"n\">where</span>\n  <span class=\"n\">natCast</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">re</span> <span class=\"o\">:=</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">im</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_re</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">ofNat_im</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">MyComplex</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ofNat_re</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Also, why am I able to prove <code>ofNat_re</code> for all <code>n</code>, when I haven't provided an instance of <code>One</code>?</p>",
        "id": 387147141,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692904077
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/.40.5Bsimp.5D.20theorem.20not.20being.20applied/near/387146889\">said</a>:</p>\n<blockquote>\n<p>If you first make the complexes into a ring then there will automatically be a coercion from the naturals, and if you've defined another one then by the time you've shown it's a ring there might be problems.</p>\n</blockquote>\n<p>Yes, and that seems to be the way Mathlib does it.  I was hoping to avoid all of that, yet still be able to prove examples like <code>(2 + 3 * I) * (4 + 5 * I)</code>.  I could in Lean 3.  But maybe in Lean 4 there is no shortcut.  Thanks.</p>",
        "id": 387147446,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692904213
    },
    {
        "content": "<p>The <code>bit0</code>/<code>bit1</code> stuff did seem a little awkward though.</p>",
        "id": 387155565,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1692907984
    }
]