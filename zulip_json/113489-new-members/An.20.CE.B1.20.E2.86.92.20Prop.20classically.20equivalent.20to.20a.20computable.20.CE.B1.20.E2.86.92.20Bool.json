[
    {
        "content": "<p>I'm trying to get rid of Classical in one of my projects in Lean. Not that I have any particular objection against Classical, mind you (I use it recklessly in some of my projects), it's just that this particular project is about concrete manipulation of strings, and Classical in that context just seems, well, strange.</p>\n<p>Let's say I have a binary relation R on strings, R : String → String → Prop, or R : String → String → Bool if you prefer. I <em>assume</em> it's computable, by doing a [cR : (a b) → Decidable R a b] in all the theorems I prove. I also assume (via other typeclasses) that R satisfies certain properties. All those properties are computable, <em>assuming that</em> R <em>is computable/decidable</em>. Actually they can all be reduced to inductive properties (only) using ite's and no fancy termination_by 's.</p>\n<p>I then build some (R dependent) binary operator, still using only ite's,  then I proceed to develop a small theory based on the associativity of this operator. That theory, as it's actually written in Lean, needs em (R a b), and only  em (R a b) (an only to do case analysis on the ite's I started with), in addition to some dependency to propext (which I certainly won't try to remove).</p>\n<p>Now let's say that I define two particular instances of R, R1 and R2, for both of which I'm able to prove the required properties and apply the theory, except that:</p>\n<ul>\n<li>R1 is computable, which means that all the development (checking the required properties, apply the theory) goes smoothly without using Classical at all</li>\n<li>R2 \"isn't\" (but you will soon see why I put quotes around \"isn't\") ; hence for this particular case I'm forced to <em>assume</em> Decidable (R2 a b), essentially to force Lean to accept my constructive definitions by ite's and my proofs by em's.</li>\n</ul>\n<p>And ........ after a (rather large) bit of work using the theory I built, I end up proving that R1 = R2.</p>\n<p>This proves (Classically) that R2 is computable, and meta-justifies the Decidable (R2 a b) I started with.</p>\n<p>When I think of that, I realize that this is not the first time I'm faced with such a strange construct. It reminded me of nonstandard analysis, in which any \"standard\" ZF statement, when proved using nonstandard axioms, is still a valid statement in ZF.</p>\n<p>Robinson proves this using models, but Nelson doesn't, if I remember correctly: he does this by reasoning directly on the statements. Maybe his reasoning can be formalized in Lean, and maybe not using Classical? I don't really know (I don't think so, I think he uses Zorn at some point to create a suitable ultrafilter). Anyway, that was just an analogy, irrelevant to my own problem.</p>\n<p>All this prompts this question:</p>\n<p><strong>Is it possible to conclude (constructively)  that R2 is computable?</strong></p>\n<p>Here is another way of saying this. Does there exist a theory, somewhere, that proves that any classical proof of the fact that R2 = R1 where R1 is (unconditionally) computable can be turned into a constructive proof of that same fact?</p>\n<p>Of course,  as the statement is correct, it would certainly be feasible to modify the proof to make it constructive. But in its current form, the proof uses heavily the associativity of the operator in multiple computations, each of one would be cumbersome to convert...</p>",
        "id": 451611759,
        "sender_full_name": "LB",
        "timestamp": 1721072577
    },
    {
        "content": "<p>concretely, would this be a correct summation?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instDecidableR1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">instDecidableR2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- insert proof here</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">instDecidableR2</span><span class=\"w\"> </span><span class=\"c1\">-- no use of Choice here.</span>\n</code></pre></div>",
        "id": 451619513,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721073917
    },
    {
        "content": "<p>Yes and no.</p>\n<p>Yes, for summarizing the general context.</p>\n<p>No, because my use case of Classical is specifically reduced to using em to do case analysis on ite's that are in the definitions.</p>\n<p>I can't hope for the general result. I may hope for the restricted result.</p>",
        "id": 451621340,
        "sender_full_name": "LB",
        "timestamp": 1721074291
    },
    {
        "content": "<p>right... so rather than <code>[Decidablerel R2]</code>, it'd be something like <code>(h: ∀ p:Prop, p ∨ ¬ p)</code>?</p>",
        "id": 451622116,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721074512
    },
    {
        "content": "<p>No, it would be:</p>\n<p><code>(h: ∀ a b: String, R2 a b ∨ ¬(R2 a b))</code></p>\n<p>but even that can be restricted to a few very targeted applications.</p>\n<p><em>Edit</em>. I was not sure you can do ite's on a relation that just has em, and not the full Decidable property. I checked in VSCode: Lean doesn't accept the definition.</p>",
        "id": 451622986,
        "sender_full_name": "LB",
        "timestamp": 1721074781
    },
    {
        "content": "<p>right... i don't think there are tools for this... might i ask what precisely your use case is?</p>",
        "id": 451624610,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721075298
    },
    {
        "content": "<p>Sure. I am in the process of formalizing a proof of results about look-and-say sequences.</p>",
        "id": 451624750,
        "sender_full_name": "LB",
        "timestamp": 1721075356
    },
    {
        "content": "<p>Having Classical in axioms wouldn't bother me at all. It's just that I was finding that particular stuff interesting...</p>",
        "id": 451625074,
        "sender_full_name": "LB",
        "timestamp": 1721075452
    },
    {
        "content": "<p>what specifically are the definitions of <code>R1</code> and <code>R2</code>?</p>",
        "id": 451625096,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721075461
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>where ϕ is the look-and-say operator, and iterate is what you think it is</p>",
        "id": 451625919,
        "sender_full_name": "LB",
        "timestamp": 1721075798
    },
    {
        "content": "<p>i'm guessing the trouble is proving </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">iterate</span><span class=\"w\"> </span><span class=\"n\">ϕ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>\n<p>?</p>",
        "id": 451626647,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721076076
    },
    {
        "content": "<p>No real bother once you have proved the main (Conway's) result.</p>\n<p>I don't really <em>need</em> the result, it's just that when I finally put the draft on paper, I noticed the strange phenomenon I talked about in my OP. And thought that if there was a way to meta-reason about the proof, it would rid me of Classical magically...</p>\n<p>48 is just what I had in mind (as I said, I'm not focused on that part), but I guess 25 would work as well (but probably not 24).</p>",
        "id": 451627656,
        "sender_full_name": "LB",
        "timestamp": 1721076445
    },
    {
        "content": "<p>I'm pretty sure the answer to this is no in general, because Godel. The statement \"R2 is computable\" is a true statement in Lean's computable subset, but that doesn't necessarily mean that it can be proved true within Lean's computable subset. It might be, but there can't be a theorem that makes it true always, because Lean's computable subset is still stronger than Peano arithmetic.</p>",
        "id": 451636300,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1721079994
    },
    {
        "content": "<p>Not sure I follow you. \"R2 is computable\" isn't just any true statement in Lean's computable subset, it's a <em>classically provable</em> statement in Lean's computable subset.</p>\n<p>When you use the word \"true\", you admit that it is equal to \"R1 is computable\" (whatever your reasons for that). By admitting it, you admit by the same process that it is computably true, as \"R1 is computable\" is computably true.</p>\n<p>Could you please reformulate without using the word \"true\"?</p>",
        "id": 451638323,
        "sender_full_name": "LB",
        "timestamp": 1721080896
    },
    {
        "content": "<p>My analogy with nonstandard analysis wasn't just fortuitous. Nelson proves (using some ZFC as a meta-tool) that for any proof in IST of a standard statement, there is a proof in ZF.</p>",
        "id": 451639253,
        "sender_full_name": "LB",
        "timestamp": 1721081302
    },
    {
        "content": "<p>AFAIK there is a way for extracting constructive proofs from _some_ kind of classical proofs that use non-computable axioms like LEM. It basically boils down to proving your statement under a limited double-negation monad that would let you extract the result in the end. You can find an example of its use <a href=\"https://rt.quasicoherent.io/transcripts/dickson.html#1516\">here</a> (it's in Agda however). Unfortunately I don't remember the proper name of this technique.</p>",
        "id": 451639518,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1721081423
    },
    {
        "content": "<p>Yes!! That (the double negation) was exactly the direction I was thinking about! Thank you for this pointer, I'll follow your link with eagerness. Thanks!</p>",
        "id": 451639695,
        "sender_full_name": "LB",
        "timestamp": 1721081517
    },
    {
        "content": "<p>If I'm not mistaken, the stuff you should be googling is \"realizability\"</p>",
        "id": 451882629,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1721169916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466290\">@Luigi Massacci</span> I gave it a look and what I saw is either too broad or too technical for me to find a hint about my specific problem. But yes, it seems to be the right direction. I'll try again later. Thank you!</p>",
        "id": 451889657,
        "sender_full_name": "LB",
        "timestamp": 1721172048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"358432\">LB</span> <a href=\"#narrow/stream/113489-new-members/topic/An.20.CE.B1.20.E2.86.92.20Prop.20classically.20equivalent.20to.20a.20computable.20.CE.B1.20.E2.86.92.20Bool/near/451638323\">said</a>:</p>\n<blockquote>\n<p>Not sure I follow you. \"R2 is computable\" isn't just any true statement in Lean's computable subset, it's a <em>classically provable</em> statement in Lean's computable subset.</p>\n<p>When you use the word \"true\", you admit that it is equal to \"R1 is computable\" (whatever your reasons for that). By admitting it, you admit by the same process that it is computably true, as \"R1 is computable\" is computably true.</p>\n<p>Could you please reformulate without using the word \"true\"?</p>\n</blockquote>\n<p>Sure. The computable subset of Lean is a set of axioms, including several induction/type recognition axiom schema. <code>open Classical</code> (or using theorems or <code>noncomputable</code>) adds a number of additional axioms, including at least one stronger induction/recognition schema. \"R2 = R1\" is a statement that can be proved using the latter (stronger) axiom schema, but may be independent of the former. As a result, \"R2 is computable\" may not in fact be in Lean's computable subset at all.</p>\n<p>To say something is computable is to say that <em>there exists</em> an algorithm for computing it. But a classical proof of that statement may not be constructive -- it may not actually provide the algorithm, in which case there is no general way of automatically converting that classical proof into a computable one. Alternatively, it might provide an algorithm with no computable proof of correctness; this case is essentially Godel's second theorem. Proving existence, exhibiting a concrete object, and recognizing a satisfactory object are all distinct problems.</p>",
        "id": 451979361,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1721203373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/An.20.CE.B1.20.E2.86.92.20Prop.20classically.20equivalent.20to.20a.20computable.20.CE.B1.20.E2.86.92.20Bool/near/451619513\">said</a>:</p>\n<blockquote>\n<p>concretely, would this be a correct summation?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"kt\">Type</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instDecidableR1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">instDecidableR2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableRel</span><span class=\"w\"> </span><span class=\"n\">R2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- insert proof here</span>\n\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">instDecidableR2</span><span class=\"w\"> </span><span class=\"c1\">-- no use of Choice here.</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Here's a specific example where it can't be done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">eq_true</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"bp\">.</span><span class=\"n\">of_not_not</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_not_em</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 451990119,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721205667
    }
]