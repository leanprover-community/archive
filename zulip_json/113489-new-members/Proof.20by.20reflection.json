[
    {
        "content": "<p>I was looking at the seminal FOL system from the late 70s, which shows the first instance of proof by reflection.</p>\n<p>I have a live playground here: <a href=\"https://io.livecode.ch/learn/namin/GETFOL\">https://io.livecode.ch/learn/namin/GETFOL</a></p>\n<p>I wanted to show a simple example of proof by reflection in GETFOL and Lean 4.<br>\nThe example is proving that a number is even by calculating parity.</p>\n<p>Example in GETFOL: <a href=\"https://io.livecode.ch/repl/namin/GETFOL#9781902967e45e3f0901260be9b9c2d0\">https://io.livecode.ch/repl/namin/GETFOL#9781902967e45e3f0901260be9b9c2d0</a></p>\n<p>Example in Lean 4:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Even number checking by reflection in Lean 4</span>\n<span class=\"c1\">-- This parallels our GETFOL example</span>\n\n<span class=\"c1\">-- Object level: inductively defined Even predicate</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- First, let's prove some facts the hard way by applying the inductive constructors</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">even2_hard</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">succ_succ</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">even4_hard</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">succ_succ</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">succ_succ</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n\n<span class=\"c1\">-- Meta level: computational even checker</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- Test our computational definition</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">    </span><span class=\"c1\">-- true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\">    </span><span class=\"c1\">-- true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\">    </span><span class=\"c1\">-- true</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\">    </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\">  </span><span class=\"c1\">-- true</span>\n\n<span class=\"c1\">-- Soundness theorem: if isEven returns true, then Even holds</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isEven_sound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isEven</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isEven</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">succ_succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isEven_sound</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"c1\">-- Reflection tactic - this is like GETFOL's reflect command</span>\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"reflect_even\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span>\n<span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isEven_sound</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Now prove facts by reflection (like GETFOL's reflect MAKETHM FACT2)</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">reflect_even</span>\n</code></pre></div>\n<p>The example in Lean 4 doesn't really move from object level to meta level and back explicitly, and feels rather standard, completely incorporated into the language. Would you still call this proof by reflection, or would you reserve the term for some fancier metaprogramming?</p>\n<p>Thanks!</p>",
        "id": 523599041,
        "sender_full_name": "Nada Amin",
        "timestamp": 1749659664
    },
    {
        "content": "<p>My very limited understanding is that this does indeed count as reflection, but is doing roughly the same thing as the builtin <code>decide</code> tactic does</p>",
        "id": 523600027,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1749659928
    },
    {
        "content": "<p>Here's how to hook into <code>decide</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Object level: inductively defined Even predicate</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ_succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Meta level: computational even checker</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">isEven_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">fun_induction</span><span class=\"w\"> </span><span class=\"n\">isEven</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">contextual</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"bp\">.</span><span class=\"n\">succ_succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isEven</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">decidable_of_decidable_of_iff</span><span class=\"w\"> </span><span class=\"n\">isEven_iff</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">kernel</span><span class=\"w\"> </span><span class=\"c1\">-- skip the elaborator when evaluating `isEven`.</span>\n</code></pre></div>",
        "id": 523602410,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749660802
    },
    {
        "content": "<p>The <code>decide</code> tactic wants a decision procedure rather than a semidecision procedure, hence the <code>iff</code> version of the soundness theorem.</p>\n<p>That does enable many more applications. For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">101</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">error: tactic 'decide' proved that the proposition</span>\n<span class=\"cm\">  Even 101</span>\n<span class=\"cm\">is false</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"mi\">101</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- succeeds</span>\n</code></pre></div>",
        "id": 523602483,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749660836
    },
    {
        "content": "<p>Or even</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n</code></pre></div>",
        "id": 523602550,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749660868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587286\">Nada Amin</span> <a href=\"#narrow/channel/113489-new-members/topic/Proof.20by.20reflection/near/523599041\">said</a>:</p>\n<blockquote>\n<p>The example in Lean 4 doesn't really move from object level to meta level and back explicitly, and feels rather standard, completely incorporated into the language.</p>\n</blockquote>\n<p>I guess this illustrates the progress in ITPs since the 70s!</p>\n<p>Having a theory with a notion of computation via reduction is very powerful. Lean's kernel can compute with recursively defined functions thanks to the computation rules of recursors.</p>",
        "id": 523636049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749674780
    },
    {
        "content": "<p>except that it doesn't work for well-founded recursion <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 523639062,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1749676178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> thanks for the snippets. Which version of Lean are you using? In 4.20.1, I get simp made no progress for this <code>simp +contextual [Even.zero, Even.succ_succ, *]</code>.</p>",
        "id": 523646224,
        "sender_full_name": "Nada Amin",
        "timestamp": 1749680183
    },
    {
        "content": "<p>If you click the \"view in lean playground\" button in the upper right corner of the snippet, it seems to work. The <code>#version</code> command says it's running 4.21.0-rc3.</p>",
        "id": 523646891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749680640
    },
    {
        "content": "<p>I recently had the idea that since Lean now trusts GMP and uses it in the kernel, it might be very efficient to encode data as integers and perform computations there. (I'm mainly concerned with polynomials. <a href=\"https://gist.github.com/alreadydone/2dca4fde11fb2e9be7f8a10b59216b3f#file-polynomialreflection-lean-L298-L299\">Verifying</a> <code>(1 + X) ^ 11 = 1 + X ^ 11</code> in <code>ZMod 11</code> by <code>decide</code> takes 3 seconds with exponentiation by squaring implemented, and I'm thinking about ways to speed this up possibly using a better data structure, e.g. a sigma type of iterated product types, or just a bignum.)</p>",
        "id": 523648657,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749681479
    },
    {
        "content": "<p>The new <code>grind</code> tactic (which I believe will not have the \"this is experimental warning\" in the next Lean release!) does this example in 28ms on my machine:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">baz</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>",
        "id": 523649425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749681942
    },
    {
        "content": "<p>(Tested on a mathlib master branch from a few days ago.)</p>",
        "id": 523649521,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749681993
    },
    {
        "content": "<p>If I'm reading the generated proof correctly, it decides to do a proof by reflection. It converts both polynomials to an efficient polynomial type (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Grind.CommRing.Poly#doc\">docs#Lean.Grind.CommRing.Poly</a>) and then gets the kernel to evaluate both sides.</p>",
        "id": 523650263,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749682429
    },
    {
        "content": "<p>Thanks! Where is the conversion from Polynomial to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Grind.CommRing.Poly#doc\">docs#Lean.Grind.CommRing.Poly</a>? <a href=\"https://github.com/search?q=repo%3Aleanprover-community%2Fmathlib4%20polynomial%20grind&amp;type=code\">Code search</a> and <a href=\"https://loogle.lean-lang.org/?q=%22grind%22%2C+Polynomial\">Loogle</a> found nothing relevant.</p>",
        "id": 523652234,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749683671
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"331356\">@Hagb (Junyu Guo)</span> <span class=\"user-mention\" data-user-id=\"708643\">@Junqi Liu</span></p>",
        "id": 523652257,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749683699
    },
    {
        "content": "<p>I believe the integration with grind is done purely through <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRing.toGrindCommRing#doc\">docs#CommRing.toGrindCommRing</a> (and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instIsCharPOfCharP#doc\">docs#instIsCharPOfCharP</a>)</p>\n<p>It's not seeing <code>Polynomial</code> as being polynomials per se, but it's recognizing that these are ring expressions, and that <code>X</code> can be regarded as a variable. (Similar to atoms in <code>linarith</code>.)</p>\n<p>This works too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">baz</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">]):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"o\">)[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>In the proof, it's calling <code>a</code> and <code>b</code> variables number 0 and 1.</p>",
        "id": 523655425,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749685844
    },
    {
        "content": "<p>It is amazing! I was working on a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Data/RBMap/Basic.html#Batteries.RBMap\"><code>Batteries.RBMap</code></a>-based solution for faster speed, and now I can see <code>grind</code> is much faster than it!</p>",
        "id": 523655628,
        "sender_full_name": "Hagb (Junyu Guo)",
        "timestamp": 1749685974
    },
    {
        "content": "<p>Hmm I'm not quite seeing the difference between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRing#doc\">docs#CommRing</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Grind.CommRing#doc\">docs#Lean.Grind.CommRing</a>; it seems they mainly differ in that the latter doesn't extend NatCast etc. but includes them as fields.</p>",
        "id": 523656214,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749686338
    },
    {
        "content": "<p>The difference is that <code>Lean.Grind.CommRing</code> is designed specifically for the grind tactic, and it is the interface for hooking user's types into the tactic.</p>\n<p>This is good practice for designing tactics. This lets theory develop for sake of theory while letting the metaprogram have a fixed interface. No need for compromises.</p>",
        "id": 523656591,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749686505
    },
    {
        "content": "<p>Oh I missed that Grind.CommRing is also more minimal as it doesn't include zsmul etc.</p>",
        "id": 523656734,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749686591
    },
    {
        "content": "<p>(Even if it did have a need for zsmul etc., it still is better to have a separate class.)</p>\n<p>Another thing to think about is that if Lean.Grind.CommRing extended anything like NatCast, then that instance could start providing the NatCast instance rather than the one that's defined for theory purposes. There might be a more-efficient implementation that's better suited for these grind proofs.</p>",
        "id": 523657060,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749686784
    },
    {
        "content": "<p>For  polynomial ring <code>R[X]</code> over <code>R</code>, it seems that <code>smul</code> of an element of <code>R</code> and an element of <code>R[X]</code> should be covered to deal with polynomial (or more generally <code>Module</code>)?<br>\nAs an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">module</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n</code></pre></div>\n<p>edit: add two other examples.<br>\nedit 2: sorry for my off-topic. i just found the topic not specially for polynomial.</p>",
        "id": 523663753,
        "sender_full_name": "Hagb (Junyu Guo)",
        "timestamp": 1749691301
    },
    {
        "content": "<p>It's amazing that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Grind.CommRing#doc\">docs#Lean.Grind.CommRing</a> does not require mathlib...</p>",
        "id": 523669174,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749696620
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"331356\">Hagb (Junyu Guo)</span><a href=\"#narrow/stream/113489-new-members/topic/Proof.20by.20reflection/near/523663753\">said</a>：</p>\n<blockquote>\n<p>For  polynomial ring <code>R[X]</code> over <code>R</code>, it seems that <code>smul</code> of an element of <code>R</code> and an element of <code>R[X]</code> should be covered to deal with polynomial (or more generally <code>Module</code>)?<br>\nAs an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">module</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\">  </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"c1\">-- fail</span>\n</code></pre></div>\n<p>edit: add two other examples.<br>\nedit 2: sorry for my off-topic. i just found the topic not specially for polynomial.</p>\n</blockquote>\n<p>Hmmm after checking the source code and trying <code>#print</code> the proof of some samples proved by <code>grind</code>, I found <a href=\"https://github.com/leanprover/lean4/blob/c2876a1a6a42e6df458ffb37abbc3868632beb58/src/Init/Grind/CommRing/Poly.lean#L24\"><code>Poly</code></a> uses Int for its \"constant\" and \"coefficient\", and when <code>grind</code> deals with ring, parts other than NatCast will keep invariant, corresponding to <code>Poly.var</code>?</p>",
        "id": 523796142,
        "sender_full_name": "Hagb (Junyu Guo)",
        "timestamp": 1749746993
    },
    {
        "content": "<p>Could <code>grind</code> replace <code>ring</code> and even run faster than it? And <code>field_simp</code> as well (I just saw the new PR <a href=\"https://github.com/leanprover-community/mathlib4/pull/25697\">#25697</a>)</p>",
        "id": 523845396,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1749769210
    },
    {
        "content": "<p><code>ring</code> yes, <code>ring_nf</code> not necessarily</p>",
        "id": 523846397,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1749769846
    }
]