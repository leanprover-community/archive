[
    {
        "content": "<p>Hi!</p>\n<p>I am new to Lean and I'm working through the exercises in The Mechanics of Proof. Example 2.1.6 is about proving simple inequalities.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I can solve it with the tactics introduced so far in the textbook:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">addarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">addarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hy</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">-</span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rel</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">numbers</span>\n</code></pre></div>\n<p>However, what bothers me is that I have to tell Lean what the intermediate goals are. For example, I have to say that from <code> y ≥ 3-2*x</code> I want to prove <code>_ ≥ 3-2*(-1)</code>. Then I use the tactic <code>rel</code> to prove this. When reading about Lean, I was under the impression that the way it works is by applying various tactics that keep modifying the goal. Right now, it feels like I'm the one modifying the goal. So how could I make Lean substitute <code>x ≤ -1</code> in <code> y ≥ 3-2*x</code>, such that it automatically tells me the result is <code>y ≥ 3-2*(-1)</code>, meaning I now only need to prove <code> 3-2*(-1)&gt;3</code>. </p>\n<p>I'm asking this because clearly Lean can make the substitution, but it seems like it only likes it when I say what the end result is. I would like for Lean to make the substitution and tell when what the result is, letting me continue from there.</p>\n<p>I hope it is clear what I'm asking, and I apologize if it's simple, but I could not find answers online.</p>",
        "id": 519744904,
        "sender_full_name": "Eliseu Kloster",
        "timestamp": 1747888376
    },
    {
        "content": "<p>I guess the issue with your proposal is that if you had <code>37 &lt; _ := by numbers</code> then there are infinitely many choices for what can go in the <code>_</code>, so what would Lean choose? Yes Lean can certainly modify the goal itself, but what Lean cannot do is supply <em>ideas</em> needed in a proof, and in some sense the RHS of each intermediate step of your proof is a new idea.</p>\n<p>Here I think is the proof you're looking for (written in mathlib's dialect of Lean)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ y &gt; 3</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">sub_right_le_of_le_add</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 3 - 2 * x &gt; 3</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">gt_of_ge_of_gt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">sub_le_sub_left_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">mul_le_mul_of_nonneg_left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">le_sub_right_of_add_le</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"c1\">-- ⊢ 3 - 2 * (2 - 3) &gt; 3</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c1\">-- this is mathlib's version of `numbers`</span>\n</code></pre></div>\n<p>Here I don't supply any of the intermediate RHS's. However my proof is much uglier to read and much harder to write, because now I cannot use general tactics which try and prove a &lt;= b <em>knowing a and b beforehand</em> by using standard techniques, as I <strong>don't know b</strong>. So I have to use the internal Lean names for all the techniques and spell out which order to use them in (for example <code>Int.sub_right_le_of_le_add</code> is the theorem that <code>p ≤ q + r =&gt; p - r ≤ q</code>), and if I spell out the more precise operations then Lean can now figure out exactly what b is <em>in every case</em>, even without me specifying it. You can hover over every theorem name to see exactly what it does.</p>\n<p>So in short yes Lean can do exactly what you ask, but you have to be more of an expert in knowing all the internal workings, and the whole point of the introductory chapters of that book is to demonstrate that you can use Lean without knowing any of these internal workings.</p>",
        "id": 519753002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747893805
    },
    {
        "content": "<p>Probably this is not the example where a more automated approach can shine. Lean will happily cancel terms from an expression like <code>a + 3 = b + 3</code>, for example, without making the three explicit</p>",
        "id": 519753517,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1747894061
    },
    {
        "content": "<p>I think a summary of my post is: \"you can prove a &lt;= b by applying general principles sensibly, you can prove a &lt;= ? by applying these specific principles in this specific order and figuring out ? at the end, but you can't hope to prove a &lt;= ? by applying general principles sensibly because there is more than one answer for ? in general (e.g. if you know 1 &lt;= x and 1 &lt;= y then general principles can't work out a unique solution to 1 &lt;= ?)\". Tactics are applying general principles sensibly, theorems are specific principles.</p>",
        "id": 519758176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747896552
    },
    {
        "content": "<p>Thank you very much for the answer. This proof is indeed of the flavor I had in mind!</p>\n<p>Your explanation of tactics vs theorems is also wonderful, so let me see if I understand what you're saying:</p>\n<p>Because tactics cover a lot of different scenarios, I need to provide some information on what I'm trying to achieve (like the RHS of the inequalities). But I don't need to provide this information when using theorems because it is in some sense already contained in the act of choosing which theorem to use.</p>\n<p>If that's so, then is it fair to say that tactics can't ever make \"half-progress\"? My initial expectation was that if I asked a tactic to show a &lt;= b, maybe it could fail but still tell me that it managed to show a&lt;=c, for some useful c.  Using the same line of reasoning as before, it seems like Lean tactics actually can't do that because there isn't any well-defined notion of what \"useful\" / \"half-proving\" means.</p>",
        "id": 519767105,
        "sender_full_name": "Eliseu Kloster",
        "timestamp": 1747899937
    },
    {
        "content": "<p>There are plenty of Lean tactics which make half-progress. A great example is the <code>simp</code> tactic which will try to prove your theorem but if it fails to do so then it might say \"well I reduced it to this\" and the goal is now much simpler than it was before. <code>numbers</code> will also make partial progress. But <code>addarith</code> and <code>rel</code> are not designed to do that. Your question is too vague to expect anything concrete here. For example if you know 1&lt;=x and 1&lt;=y and your goal is 1&lt;=z, you probably don't want a tactic which, when you apply it, turns the goal into x&lt;=z on the basis that this would be enough but it might also be a step in the wrong direction (i.e. it might have just changed the goal from a true goal to a false goal, which is not ideal behaviour for a tactic). For example <code>simp</code> is designed in such a way that it will simplify goals but will never turn a true problem into a false one.</p>",
        "id": 519780421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747903908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"918798\">Eli Kloster</span> has marked this topic as resolved.</p>",
        "id": 520108178,
        "sender_full_name": "Notification Bot",
        "timestamp": 1748024771
    }
]