[
    {
        "content": "<p>I tried writing a \"generic\" factorial function in two different ways.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact1</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The above doesn't work because of <code>dependent elimination failed, type mismatch when solving alternative with type\n  motive inst✝.1\nbut expected\n  motive n✝</code></p>\n<p>Does this error mean that <code>match</code> can be only used to distinguish between inductive constructors because the Elaborator converts it to some recursive eliminator (if that's the right nomenclature?)</p>\n<p>This simple, non-generic, example with <code>Float</code> has the same issue, which makes me think the above explanation is \"right\". </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">tt</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Float</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>Is it possible to pattern match values, like in other \"more mainstream\" FP languages?</p>",
        "id": 472582670,
        "sender_full_name": "Tom",
        "timestamp": 1727216864
    },
    {
        "content": "<p>In light of the above, I also tried writing the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Now I get the error <code>failed to synthesize\n  Decidable (n ≤ 1)\n</code></p>\n<p>I <em>think</em> I could use a <code>BEq a</code> with <code>(n == 0)</code> or <code>Ord a</code> but then it seems I would have to make the function partial.  </p>\n<p>However, without changing the code, I think I have a sense why with <code>Nat</code>, <code>&lt;=</code> is Decidable - because the implementation for <code>LT</code> is function can be written to be a total function by recursing through the <code>Nat</code> constructors.  </p>\n<p>Is there a way to write the above code \"generically\" while maintaining decidability?</p>",
        "id": 472583163,
        "sender_full_name": "Tom",
        "timestamp": 1727217154
    },
    {
        "content": "<p>I tried adding </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>but now the error is that </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">Decidable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 472583321,
        "sender_full_name": "Tom",
        "timestamp": 1727217258
    },
    {
        "content": "<p>You need the assumption that that is decideable for all <code>n</code> in your recursion, not just the original</p>",
        "id": 472591295,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727223078
    },
    {
        "content": "<p><code>DecidablePred (fun n : α =&gt; n &lt;= 1)</code> should do it</p>",
        "id": 472591373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1727223126
    },
    {
        "content": "<p>Ah,  cool!  Thanks to for your help.  Now I just need to figure out termination checking.<br>\nI was able to come up with the following first-attempt monstrosity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Use this to have a \"generic\" conversion from T -&gt; Nat</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toUInt64</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n\n<span class=\"c1\">-- Main computation</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact2'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)]:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact2'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- \"user interface\"</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ToNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">[</span><span class=\"n\">DecidablePred</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)]:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fact2'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ToNat</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">fact2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It's not pretty! <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span>   I am currently trying to read about <code>termination_by</code> to see if I can get rid of the helper/fuel idea.</p>\n<p>Thanks for the pointer RE: DecidablePred.  Every question is another rabbit hole!</p>",
        "id": 472598019,
        "sender_full_name": "Tom",
        "timestamp": 1727228720
    },
    {
        "content": "<p>Hey Tom, I rewrote your fact2' using a match expression and the system stopped complaining,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact2'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fuel</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">fuel</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\">     </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fact2'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>By the way, If you have a comprehensive source for <code>termination_by</code> then please let me know.  The mechanics of proof has some examples that use it, but I wasn't able to fully understand how it operates.</p>",
        "id": 472726183,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1727278824
    },
    {
        "content": "<p>here's an example that uses <code>termination_by</code><br>\n<a href=\"https://hrmacbeth.github.io/math2001/06_Induction.html?highlight=termination_by#pascal-s-triangle\">https://hrmacbeth.github.io/math2001/06_Induction.html?highlight=termination_by#pascal-s-triangle</a></p>",
        "id": 472726451,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1727278911
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"317929\">@Derek Rhodes</span> </p>\n<p>Thanks for the feedback!  I guess the key step for me was to convert the <code>α</code> to a <code>Nat</code> for <code>fuel</code>, which to some degree motivated my original question about \"generically converting numbers to <code>Nat</code>\" (and hence why I had to write the extra type class, which I think is ugly).  </p>\n<p>You are right that I could have switched to a <code>match</code>.  I didn't do that because next, I was hoping to get rid of the <code>fuel</code> and try to prove termination and general numbers don't have a \"lower bound\"/base case like Nat, so I didn't want to assume that (this is also the first  unanswered question from this thread about when <code>match</code> can be used)</p>\n<p>As for termination, I am also trying to figure it out.  The reason why I used <code>fuel</code> was to rely on structural recursion.  I found two recent blog posts on the Lean website about this:</p>\n<p><a href=\"https://lean-lang.org/blog/2024-1-11-recursive-definitions-in-lean/\">Recursive definitions in Lean</a><br>\n<a href=\"https://lean-lang.org/blog/2024-5-17-functional-induction/\">Functional Induction</a></p>\n<p>I understand about the first half of the article on Recursive definitions.  I \"understand\" the second half in spirit but because I'm not yet familiar with Lean's tactics, I can't say that <br>\n1) I know what each step in the proofs actually does<br>\n2) E.g. I can't see from the article how to then apply e.g. <code>theorem : search_const_none</code> to the original <code>search</code> function (do they have to be mutually recursive?)</p>\n<p>Again, I get the gist of the second article but due to my lack of knowledge of tactics I don't think I would be able to apply it in practice yet.</p>",
        "id": 472749371,
        "sender_full_name": "Tom",
        "timestamp": 1727287339
    },
    {
        "content": "<p>Thanks for the links, I was reading down through those articles and somewhere was mentioned that newer versions of lean would handle termination better, so I tried out your code with <code>leanprover/lean4:v4.11.0-rc2</code> and it just works without any changes.</p>",
        "id": 472762401,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1727293027
    },
    {
        "content": "<p>You mean the generic \"non-fuel\" version just works?</p>",
        "id": 472771016,
        "sender_full_name": "Tom",
        "timestamp": 1727296893
    },
    {
        "content": "<p>no, I meant that the code you posted in \"first-attempt monstrosity\" .. hmm, maybe I've just been using an older version than you from the get go and have been seeing errors that you have not been seeing, if so, sorry about that.</p>",
        "id": 472773651,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1727298081
    },
    {
        "content": "<p>Something to think about: the <code>Sub</code> instance could have <code>n - 1 = n</code>.</p>\n<p>This actually happens with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ENat#doc\">docs#ENat</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"bp\">∞</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 472774401,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727298439
    },
    {
        "content": "<p>Thanks - I realized that even e.g. <code>#eval 0 - 1 == 0</code> is true, which is why my original recursive function was trying to condition on <code>n &lt;= 1</code> rather than on <code>n = 0</code> because I assumed that may come up in the proof.</p>",
        "id": 472776101,
        "sender_full_name": "Tom",
        "timestamp": 1727299327
    },
    {
        "content": "<p>Just so I can close this question, could someone please help answer the first/original question wrt to the <code>match</code> statement, please?</p>",
        "id": 473001316,
        "sender_full_name": "Tom",
        "timestamp": 1727403486
    },
    {
        "content": "<p>What's the current state of your question? There's a lot to read through to try to figure that out. Is it just the following?</p>\n<blockquote>\n<p>Does this error mean that <code>match</code> can be only used to distinguish between inductive constructors because the Elaborator converts it to some recursive eliminator (if that's the right nomenclature?)</p>\n</blockquote>\n<p>Yes, <code>match</code> is for distinguishing values by constructor, and the way it's implemented is that it expands to recursors/eliminators (not sure about the \"right\" terminology), so in some sense that's \"why\" it has limitations.</p>\n<p>It's not like in some other languages where it's sugar for an <code>if</code>/<code>else if</code> chain of equality testing. If you're familiar with discriminated unions, its for conveniently doing cases on the tag.</p>",
        "id": 473002089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727403990
    },
    {
        "content": "<p>Thanks!  That's all I was looking for.  Sorry, I should have been more specific, esp given the follow-ups got a little tangential.</p>\n<p>And yes, I was thinking about other languages where the matching is also on constructors but can also be on specific values, or even have conditionals attached.  Rather than \"linearly\" matching though, they can build tree matchers which can avoid e.g. re-testing the same conditions.</p>\n<p>It seems some types which are not inductive cannot be matched (e.g. Float), or in the case of the generic <code>α</code> type in my first example.  For example, this is valid Haskell code</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Num</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"n\">test</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">of</span>\n<span class=\"w\">     </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">     </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">     </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n\n<span class=\"n\">main</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"o\">()</span>\n<span class=\"n\">main</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">putStrLn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"mf\">1.0</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"n\">putStrLn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Note that <code>test</code> is generic.  I guess this is tricky in a language with such strict notions of equality as Lean.</p>\n<p>And sorry for all my questions, there is no \"language manual/reference\" yet and it seems a lot of this is just \"lore\" that people have in their heads.  I appreciate your time and patience.</p>",
        "id": 473004386,
        "sender_full_name": "Tom",
        "timestamp": 1727405643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> has marked this topic as resolved.</p>",
        "id": 473004478,
        "sender_full_name": "Notification Bot",
        "timestamp": 1727405729
    },
    {
        "content": "<p>There's no problem with that <code>case</code> example, it's just that <code>match</code> isn't an exact replacement for <code>case</code>. You can easily define such syntax in Lean using equality testing. The Lean equivalent of Eq is DecidableEq.</p>",
        "id": 473004621,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727405831
    },
    {
        "content": "<p>There are a few examples of a Lisp-like <code>cond</code> construction <a href=\"#narrow/stream/113488-general/topic/alternative.20to.20nesting.20of.20if.2E.2Ethen.2E.2Eelse/near/452857693\">around here</a>. It'd be possible to modify it to be like <code>case</code>.</p>",
        "id": 473004754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727405931
    },
    {
        "content": "<p>You mean like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Sub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>That still doesn't work for me <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 473004817,
        "sender_full_name": "Tom",
        "timestamp": 1727405985
    },
    {
        "content": "<p>No, not at all. I mean that you could <em>make</em> such syntax using metaprogramming</p>",
        "id": 473004898,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727406020
    },
    {
        "content": "<p>(<code>match</code> is similar to but not the same as <code>case</code>. <code>case</code> sure can do pattern matching of algebraic data types, but it can also handle other sorts of equality testing. I don't know the full scope of differences, it's been awhile since I've used Haskell.)</p>",
        "id": 473004925,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727406038
    },
    {
        "content": "<p>I see.  And thanks for the <code>cond</code> pointer.  While it's not exactly what I have in mind, that thread seems like an awesome example of metaprogramming, so I'll definitely study it later.</p>\n<p>For now, I'll just accept that what I'm asking is hard.  Thanks.</p>",
        "id": 473005154,
        "sender_full_name": "Tom",
        "timestamp": 1727406201
    },
    {
        "content": "<p>All I know is that <code>match</code> uses some algorithm that seems to be specifically for processing patterns and working out (1) how to implement it as a nested application of recursors and (2) whether or not the patterns are exhaustive. It just seems like it's not well suited for types that aren't some known inductive types.</p>",
        "id": 473005571,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727406513
    }
]