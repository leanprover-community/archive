[
    {
        "content": "<p>Hi everyone. I've started learning lean recently but encountered a problem when trying to apply the <code>rw</code> tactic to rewrite some statements and hope someone can help.</p>\n<p>Here's some context. My main goal is to formalize the isoperimetric inequality in 2D, but that is probably too complicated, so I'm just playing around for now, seeing how far I can get. I've defined <code>Plane</code> as an abbreviation for 2D Euclidean space</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Plane</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>For curves I'm using <code>Path</code> from mathlib, which is a map from the unit interval. Then I want to define curve length as the supremum of the lengths of inscribed polygonal chains. To do that, first I defined a <code>UnitSequence</code> as a monotone sequence of points on the unit interval, starting at 0 and ending at 1:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">UnitSequence</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">unitInterval</span>\n\n<span class=\"w\">  </span><span class=\"n\">n_ge_two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"n\">monotone</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monotone</span><span class=\"w\"> </span><span class=\"n\">points</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_of_lt</span><span class=\"w\"> </span><span class=\"n\">n_ge_two</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"kn\">end</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sub_one_lt_of_lt</span><span class=\"w\"> </span><span class=\"n\">n_ge_two</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test_sequence</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UnitSequence</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mf\">0.5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mf\">0.5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span>\n\n<span class=\"w\">  </span><span class=\"n\">n_ge_two</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">  </span><span class=\"n\">monotone</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">unitInterval</span><span class=\"bp\">.</span><span class=\"n\">le_one'</span>\n<span class=\"w\">  </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"kn\">end</span><span class=\"bp\">'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>This structure is supposed to represent values of the curve parameter, where polygonal chain endpoints on a curve are located. I then defined a curve for testing purposes, that just stays at the origin, and a lemma to help rewrite expressions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Plane</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Plane</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">source'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">target'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">continuous_toFun</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">continuous_const</span>\n\n<span class=\"c1\">-- zero_path at any point equals 0</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">zero_path_eq_zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">unitInterval</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Before trying to define the polygonal chain length, which is a sum of lengths of line segments, I was playing around with expressions involving sums to get the hang of them. But I've encountered a problem, that if the expression is complicated enough, the <code>rw</code> tactic doesn't work. I'm want to use <code>rw [zero_path_eq_zero]</code> to replace points on <code>zero_path</code> with the origin. Here, it works fine on the first 3 cases, which are simplified versions of the last one, but gives an error on this last one, even though it clearly contains an expression of the form <code>zero_path (...)</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- evaluating zero_path at point 0 in test_sequence, rw works fine</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">rw_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_succ</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path_eq_zero</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- evaluating zero_path at point (i + 1) in test_sequence, rw works fine</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">rw_2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_lt_of_lt_sub</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path_eq_zero</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- sum over i of (evaluating zero_path at general point x), rw works fine</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">rw_3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">unitInterval</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path_eq_zero</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- sum over i of (evaluating zero_path at point (i + 1) in test_sequence)</span>\n<span class=\"c1\">-- tactic 'rewrite' failed, did not find instance of the pattern in the target expression</span>\n<span class=\"c1\">-- zero_path ?x</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">rw_4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">zero_path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">points</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_lt_of_lt_sub</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">test_sequence</span><span class=\"bp\">.</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path_eq_zero</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Here's full code:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Full code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>import Mathlib.Analysis.InnerProductSpace.PiL2<br>\nimport Mathlib.Tactic</p>\n<p>abbrev Plane := EuclideanSpace ℝ (Fin 2)</p>\n<p>-- a monotone sequence of points on a unit interval<br>\nstructure UnitSequence where<br>\n  n : ℕ<br>\n  points : Fin n → unitInterval</p>\n<p>n_ge_two : n ≥ 2<br>\n  monotone: Monotone points<br>\n  start : points ⟨0, Nat.zero_lt_of_lt n_ge_two⟩ = 0<br>\n  end' : points ⟨n - 1, Nat.sub_one_lt_of_lt n_ge_two⟩ = 1</p>\n<p>def test_sequence : UnitSequence where<br>\n  points := ![0, ⟨0.5, by norm_num⟩, ⟨0.5, by norm_num⟩, 1]</p>\n<p>n_ge_two := by norm_num<br>\n  monotone := by simp; exact unitInterval.le_one'<br>\n  start := by simp<br>\n  end' := by simp</p>\n<p>def zero_path : Path (!₂[0, 0] : Plane) (!₂[0, 0] : Plane) where<br>\n  toFun _ := !₂[0, 0]<br>\n  source' := by simp<br>\n  target' := by simp<br>\n  continuous_toFun := continuous_const</p>\n<p>-- zero_path at any point equals 0<br>\nlemma zero_path_eq_zero (x: unitInterval): zero_path x = !₂[0, 0] := by dsimp [zero_path]</p>\n<p>-- evaluating zero_path at point 0 in test_sequence, rw works fine<br>\nlemma rw_1 : zero_path (test_sequence.points ⟨0, Nat.zero_lt_succ 3⟩) = !₂[0, 0] := by rw [zero_path_eq_zero]</p>\n<p>-- evaluating zero_path at point (i + 1) in test_sequence, rw works fine<br>\nlemma rw_2 (i : Fin (test_sequence.n - 1)) : zero_path (test_sequence.points ⟨i + 1, Nat.add_lt_of_lt_sub i.2⟩) = !₂[0, 0] := by rw [zero_path_eq_zero]</p>\n<p>-- sum over i of (evaluating zero_path at general point x), rw works fine<br>\nlemma rw_3 (x: unitInterval): ∑ i : Fin (test_sequence.n - 1), zero_path x = ∑ i : Fin (test_sequence.n - 1), !₂[0, 0] := by rw [zero_path_eq_zero]</p>\n<p>-- sum over i of (evaluating zero_path at point (i + 1) in test_sequence)<br>\n-- tactic 'rewrite' failed, did not find instance of the pattern in the target expression<br>\n-- zero_path ?x<br>\nlemma rw_4 : ∑ i : Fin (test_sequence.n - 1), zero_path (test_sequence.points ⟨i + 1, Nat.add_lt_of_lt_sub i.2⟩) = ∑ i : Fin (test_sequence.n - 1), !₂[0, 0] := by rw [zero_path_eq_zero]</p>\n</div></div>",
        "id": 505511883,
        "sender_full_name": "Viktor Kryshtal",
        "timestamp": 1741895038
    },
    {
        "content": "<p><code>rw</code> won't rewrite expressions with bound variables inside, try using <code>simp_rw</code> or <code>conv</code> instead.</p>",
        "id": 505516483,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741896693
    },
    {
        "content": "<p><code>simp_rw</code> solved the issue, thanks</p>",
        "id": 505518522,
        "sender_full_name": "Viktor Kryshtal",
        "timestamp": 1741897428
    },
    {
        "content": "<p><code>conv</code> is really nice to learn for this, since it lets you more surgically do the rewrite. <code>simp_rw [t]</code> has a deficiency where it's like doing <code>repeat rw [t]</code>.</p>\n<p>This is how you can use <code>conv</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">enter</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">zero_path_eq_zero</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>You can move your cursor across the <code>enter</code> command to see how it enters the expression.</p>",
        "id": 505671710,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741958071
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"888566\">Viktor Kryshtal</span> has marked this topic as resolved.</p>",
        "id": 506264530,
        "sender_full_name": "Notification Bot",
        "timestamp": 1742247001
    }
]