[
    {
        "content": "<p>I'm trying to create a tactic that rewrites a term of the form <code>(c+n)!</code> into <code>(c+n)*((c-1)+n)!</code>, where <code>c</code> is any concrete positive integer (so not a variable). How can I do this?</p>\n<p>I can prove a theorem stating <code>(1+n)! = (1+n) * n !</code>, but feeding this to simp doesn't simplify an expression of the form <code>(2+n)!</code>. I've also tried instead giving simp a theorem stating <code>((succ m)+n)! = ((succ m)+n) * (m+n)!</code>, but this doesn't simplify <code>(2+n)!</code> either.</p>",
        "id": 518349370,
        "sender_full_name": "Benjamin",
        "timestamp": 1747326225
    },
    {
        "content": "<p>Note that <code>(c+n)! = (c+n)*((c-1)+n)!</code> is false if <code>c = 0</code>.</p>",
        "id": 518350572,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1747326589
    },
    {
        "content": "<p>Right, <code>c</code> is a concrete positive integer.</p>",
        "id": 518350737,
        "sender_full_name": "Benjamin",
        "timestamp": 1747326627
    },
    {
        "content": "<p>For example, I want to rewrite <code>(7+n)!</code> into <code>(7+n)*(6+n)!</code>.</p>",
        "id": 518350877,
        "sender_full_name": "Benjamin",
        "timestamp": 1747326667
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"mi\">6</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">succ_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">factorial_succ</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>works</p>",
        "id": 518351237,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1747326776
    },
    {
        "content": "<p>That works, thanks. But for some reason, running <code>ring_nf</code> before the rewrite makes it break. Any idea why that is?</p>",
        "id": 518352721,
        "sender_full_name": "Benjamin",
        "timestamp": 1747327176
    },
    {
        "content": "<p>I think it has something to do with <code>ring_nf</code> making 7 a <code>instOfNatAtLeastTwo</code>.</p>",
        "id": 518353454,
        "sender_full_name": "Benjamin",
        "timestamp": 1747327380
    },
    {
        "content": "<p>It's very odd because <code>ring_nf</code> does not visibly change the goal.</p>",
        "id": 518363024,
        "sender_full_name": "Benjamin",
        "timestamp": 1747330430
    },
    {
        "content": "<p>I found that using <code>erw</code> instead of <code>rw</code> for <code>succ_add</code> works, even after applying <code>ring_nf</code>. I'm not sure why though.</p>",
        "id": 518402663,
        "sender_full_name": "Benjamin",
        "timestamp": 1747344158
    },
    {
        "content": "<p>I think relying on this is probably poor form anyway, and you should split the numeral yourself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">7</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"mi\">6</span><span class=\"bp\">+</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ring_nf</span><span class=\"w\"> </span><span class=\"c1\">-- to break `succ_add`</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">succ_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">factorial_succ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 518409123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747347200
    },
    {
        "content": "<p>In theory you could write some clever lemmas with <code>ofNat()</code>s in it, but I don't know if <code>ofNat(n.succ)</code> is actually well-behaved.</p>",
        "id": 518409225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747347245
    },
    {
        "content": "<p>How should I do this if I'm writing a tactic where I don't know what the numeral is going to be?</p>",
        "id": 518409254,
        "sender_full_name": "Benjamin",
        "timestamp": 1747347267
    },
    {
        "content": "<p>In a tactic, you can match against <code>OfNat.ofNat n</code> to get the numeral</p>",
        "id": 518411179,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747348258
    },
    {
        "content": "<p>Do you mind giving an example of how I would modify this tactic?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"ring_fact\"</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">repeat</span><span class=\"w\"> </span><span class=\"n\">first</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail_if_no_progress</span><span class=\"w\"> </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">factorial_zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">factorial_succ</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">erw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_add</span><span class=\"o\">])</span>\n</code></pre></div>",
        "id": 518411305,
        "sender_full_name": "Benjamin",
        "timestamp": 1747348333
    },
    {
        "content": "<p>Ah, what I'm proposing would have to be an <code>elab</code> not a <code>macro</code></p>",
        "id": 518411353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1747348363
    }
]