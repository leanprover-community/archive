[
    {
        "content": "<p>Hi, I'm trying to show that a module M over a k-algebra A is also a vector space over k, but I keep getting the error in the title. My code so far is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₃</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">M</span> <span class=\"n\">where</span>\n</code></pre></div>\n<p>I've tried permuting the orders of things around a bit, but nothing seems to make a difference...</p>",
        "id": 400623214,
        "sender_full_name": "Ali Ramsey",
        "timestamp": 1699310412
    },
    {
        "content": "<p>This can't be an instance since Lean has no way to figure out what H is looking only at the goal <code>Module F M</code>. However, if you bake H into the type M, then it can be an instance, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=RestrictScalars.module#doc\">docs#RestrictScalars.module</a>. If you don't want to change the type M, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.compHom#doc\">docs#Module.compHom</a>, which is a def as it can't be an instane, and it's used to define <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModuleCat.RestrictScalars.obj%27#doc\">docs#ModuleCat.RestrictScalars.obj'</a>.</p>\n<p>By the way, the usual mathlib way to work in your situation is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">AddCommGroup</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>but it depends on your purposes.</p>",
        "id": 400624680,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699311343
    },
    {
        "content": "<p>Thank you! I was trying to make an instance because I'm trying to show that the category A-mod has a monoidal structure (imitating the way the monoidal structure of R-mod is built up in ModuleCat.Monoidal.Basic), but when I started with something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tensorObj'</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ModuleCat.of</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would get the error <code>failed to synthesize instance Module F ↑M</code> so I figured Lean didn't know M was also a vector space over F. I've now changed it to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">tensorObj'</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">F</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">F</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">IsScalarTower</span> <span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ModuleCat.of</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which doesn't throw any errors, but it just seems a little strange to have something like [Module F M] which looks like an assumption when it should just be true. Am I going about this the right way?</p>",
        "id": 400627905,
        "sender_full_name": "Ali Ramsey",
        "timestamp": 1699313368
    },
    {
        "content": "<p>I think you might need a dedicated <code>AModuleCat R A</code> type</p>",
        "id": 400629128,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314212
    },
    {
        "content": "<p>You'll need it anyway for the monoidal structure to be unambiguous against the existing one</p>",
        "id": 400629251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314294
    },
    {
        "content": "<p>You can think of <code>[Module F M]</code> as \"initialise the notation <code>f • m</code>\" and <code>[IsScalarTower F H M]</code> to mean \"and furthermore define <code>f • m</code> to mean the obvious thing\".</p>",
        "id": 400629382,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699314389
    },
    {
        "content": "<p>Something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">AModuleCat</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">CommRing</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">ModuleCat</span> <span class=\"n\">A</span> <span class=\"n\">where</span>\n   <span class=\"n\">toBaseModule</span> <span class=\"o\">:</span> <span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">carrier</span>\n   <span class=\"n\">tower</span> <span class=\"o\">:</span> <span class=\"n\">IsScalarTower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">carrier</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">AModuleCat.toBaseModule</span> <span class=\"n\">AModuleCat.tower</span>\n</code></pre></div>",
        "id": 400629491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314472
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> can tell you if that's reasonable</p>",
        "id": 400629586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314532
    },
    {
        "content": "<p>You should then be able to copy the approach used by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuadraticModuleCat.instMonoidalCategory#doc\">docs#QuadraticModuleCat.instMonoidalCategory</a> to get the monoidal category on <code>AModuleCat</code></p>",
        "id": 400629885,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699314743
    }
]