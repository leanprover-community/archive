[
    {
        "content": "<p>How does one create subtypes? Say I want a function  of two parameters one is an arbitrary natural number, the other is a natural number &lt; 100.</p>",
        "id": 196071923,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588456628
    },
    {
        "content": "<p>In this case I would just use <code>fin</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>In general, <code>{a // P a}</code> where <code>α : Type</code> and <code>P : α → Prop</code> is notation for the subtype of terms of type <code>α</code> that satisfy <code>P</code>. Subtypes are mentioned briefly in TPiL <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\" title=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\">in chapter 7</a>. See also <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic\">this mathlib doc page</a>.</p>",
        "id": 196072236,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588457225
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 196072433,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457602
    },
    {
        "content": "<p>Why doesn't this work?</p>",
        "id": 196072434,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457606
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"c1\">-- ok</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"c1\">--error</span>\n</code></pre></div>",
        "id": 196072437,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457611
    },
    {
        "content": "<p>Because <code>4</code> is not a term of that subtype. You can construct a term like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">⟩</span>\n<span class=\"c1\">-- dec_trivial also works and doesn&#39;t require any import</span>\n</code></pre></div>",
        "id": 196072649,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588458004
    },
    {
        "content": "<p>But <code>example : fin 100 := 4</code> works</p>",
        "id": 196072787,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588458262
    },
    {
        "content": "<p>That's because <code>4</code> is a term of type <code>fin 100</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">numerals</span> <span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">100</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">bit0 (bit0 has_one.one) : fin (bit0 (bit0 (bit1 (bit0 (bit0 (bit1 has_one.one))))))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n\n\n<p>See <a href=\"https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56\" title=\"https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56\">here</a>. Note how Lean interprets numerals in terms of <code>bit0</code>, <code>bit1</code> and <code>has_one.one</code> and <code>has_zero.zero</code>.</p>",
        "id": 196073091,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588458810
    },
    {
        "content": "<p>Just because the thing you defined, <code>{n : ℕ // n ≤ 100}</code> is \"pretty much exactly the same thing as\" <code>fin 100</code>, doesn't mean that everything that works for <code>fin 100</code> will work for <code>{n : ℕ // n ≤ 100}</code>. There are lots of extra definitions which have been put on top of <code>fin n</code>, e.g. it has a 0, a 1, an add, and so on. If you want the same for your type you'll have to give it a name and put all these structure on it yourself.</p>",
        "id": 196074984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588462201
    }
]