[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">≠</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>Can someone help me understand what is going on here? I am working through the natural number game in Lean4, and here is the corresponding lean3 code <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/mynat/definition.lean#L32-L34\">https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/src/mynat/definition.lean#L32-L34</a> - both are solved the same way.</p>\n<p>My confusion is what is going on with cases. For <code>succ_inj</code>, I think what is happening is <code>=</code> has one inductive type constructor, <code>refl</code>, that somehow takes our goal state from <code>a = b</code> to <code>a = a</code>, using natural number ... something? Confused here.</p>\n<p>For <code>zero_ne_succ</code>, I am even more confused. Again there seems to be some case based on the inductive type, but our goal state is False, and our hypothesis is <code>h : zero = succ a</code>, and somehow <code>cases h</code> on its own leads to False and solves our proof.</p>\n<p>I even tried to be explicit about the cases</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">≠</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I got this error in <code>zero_ne_succ</code>: <code>invalid occurrence of wildcard alternative, it must be the last alternative</code>.</p>\n<p>Thank you for taking the time to read my question and I look forward to your answer! I tried to look through <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/tactics.html\">https://leanprover.github.io/theorem_proving_in_lean4/tactics.html</a> here to figure it out on my own, but no such luck.</p>",
        "id": 338254694,
        "sender_full_name": "Alex Kassil",
        "timestamp": 1677482739
    },
    {
        "content": "<p>The tactic <code>cases</code> breaks down <code>h</code> according to the definition of equality:<br>\n<a href=\"https://xenaproject.wordpress.com/2021/04/18/induction-on-equality/\">https://xenaproject.wordpress.com/2021/04/18/induction-on-equality/</a></p>",
        "id": 338256592,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677483492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"244020\">Alex Kassil</span> <a href=\"#narrow/stream/113489-new-members/topic/Peano.20axioms.20with.20cases/near/338254694\">said</a>:</p>\n<blockquote>\n<p>My confusion is what is going on with cases. For <code>succ_inj</code>, I think what is happening is <code>=</code> has one inductive type constructor, <code>refl</code>, that somehow takes our goal state from <code>a = b</code> to <code>a = a</code>, using natural number ... something? Confused here.</p>\n</blockquote>\n<p>Exactly! The constructor</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eq</span> <span class=\"n\">a</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>says that for <code>eq x y</code> to hold, <code>x</code> must match <code>y</code>.</p>\n<p>If you want to write it without <code>cases</code> you can do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.succ.inj</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">≠</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Nat.noConfusion</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 338260729,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677485210
    },
    {
        "content": "<p>Golfed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">Nat.succ.inj</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_succ</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Nat.zero</span> <span class=\"bp\">≠</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"n\">Nat.noConfusion</span>\n</code></pre></div>",
        "id": 338261419,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677485481
    },
    {
        "content": "<p>Written as implications:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">succ_inj</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span>  <span class=\"bp\">→</span>  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>  <span class=\"o\">:=</span>\n<span class=\"n\">Nat.succ.inj</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">zero_ne_succ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">Nat.zero</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span>  <span class=\"bp\">→</span>  <span class=\"n\">False</span>  <span class=\"o\">:=</span>\n<span class=\"n\">Nat.noConfusion</span>\n</code></pre></div>",
        "id": 338261752,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677485613
    },
    {
        "content": "<p>Afaik both <code>.inj</code> and <code>.noConfusion</code> are autogenerated for all inductive types. The following code works without any imports:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Natttt</span> <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">zer</span> <span class=\"o\">:</span> <span class=\"n\">Natttt</span>\n<span class=\"bp\">|</span> <span class=\"n\">suc</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Natttt</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Natttt</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">Natttt.noConfusion</span>\n<span class=\"k\">#check</span> <span class=\"n\">Natttt.suc.inj</span>\n</code></pre></div>",
        "id": 338262886,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677485987
    },
    {
        "content": "<p>If you are confused by the goal state changing from <code>a = b</code> to <code>a = a</code> consider:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span>  <span class=\"bp\">→</span>  <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Nat.add_comm</span>\n</code></pre></div>\n<p>The line <code>cases h</code> rewrites all <code>b</code>s to <code>a</code>s in the goal (actually in the whole local context, but there isn't more in the example above), so<br>\n<code>⊢ a * b + a = b + a * b</code> changes to <code>⊢ a * a + a = a + a * a</code> and you can proceed.</p>",
        "id": 338263906,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677486316
    },
    {
        "content": "<p>Watch what happens to <code>hyp</code> after the line <code>cases h</code> in the following silly example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hyp</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">^</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">Nat.succ</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">b</span>  <span class=\"bp\">→</span>  <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">42</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 338265288,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677486788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"417654\">@Martin Dvořák</span> wow, thank you for writing up such a well explained, detailed answer to my question. This clears up ALL of my confusion, and teaches me a lot more things too. And you linked a great resource as well. Thanks so much for such a high caliber answer :D</p>",
        "id": 338298267,
        "sender_full_name": "Alex Kassil",
        "timestamp": 1677496348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"244020\">Alex Kassil</span> has marked this topic as resolved.</p>",
        "id": 338298278,
        "sender_full_name": "Notification Bot",
        "timestamp": 1677496352
    },
    {
        "content": "<p>You're welcome! Just be careful; the linked article uses Lean 3.</p>",
        "id": 338299060,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1677496607
    }
]