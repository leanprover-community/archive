[
    {
        "content": "<p>I'm trying to complete the following proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">{</span> <span class=\"n\">a</span> <span class=\"bp\">//</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">as</span> <span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">List.Nodup</span> <span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ms.length</span> <span class=\"bp\">≤</span> <span class=\"n\">as.length</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">nodup</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">List.length_nil</span><span class=\"o\">,</span> <span class=\"n\">zero_le</span><span class=\"o\">]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">p</span> <span class=\"n\">nodup</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">rename_i</span> <span class=\"n\">m</span> <span class=\"n\">ms</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.length_cons</span><span class=\"o\">]</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">nodup</span>\n\n      <span class=\"k\">show</span> <span class=\"n\">ms.length</span> <span class=\"bp\">&lt;</span> <span class=\"n\">as.length</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but am not sure how to proceed. Intuitively, I can convince myself by imagining a mapping between the two lists where the map from <code>ms</code> to <code>as</code> has to be injective, but it seems like there should be an easier way of proving it?</p>",
        "id": 371855951,
        "sender_full_name": "yokatta",
        "timestamp": 1688354871
    },
    {
        "content": "<p>I don't know how to finish your proof, but if I were working on it, I would start as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">qux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ms</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">nodup</span> <span class=\"o\">:</span> <span class=\"n\">List.Nodup</span> <span class=\"n\">ms</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">subt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ms</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">ms.length</span> <span class=\"bp\">≤</span> <span class=\"n\">as.length</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">as</span>\n  <span class=\"n\">induction</span> <span class=\"n\">ms</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">m</span> <span class=\"n\">ms</span> <span class=\"n\">ih</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">intros</span> <span class=\"n\">as</span> <span class=\"n\">hyp</span>\n      <span class=\"c1\">-- apply `ih` to the list `as` without the element `m`</span>\n      <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 371921746,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1688374890
    },
    {
        "content": "<p>What I want to say is that I'd perform induction on <code>ms</code> but I cannot have <code>as</code> fixed. I want to work with <code>∀ as</code> in the induction step.</p>",
        "id": 371923524,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1688375229
    }
]