[
    {
        "content": "<p>Hello everyone, I've been trying to do a recursive computation on an inductive type that represents a transitive closure. However I'm running into an error from lean 4, at the pattern match in the <code>tryRec</code> function:</p>\n<p><code>tactic 'cases' failed, nested error: tactic 'induction' failed, recursor 'tc.casesOn' can only eliminate into Prop</code></p>\n<p>When I change my inductive type to not be in Prop, the pattern matching works. However, then I cannot do \"tc ... ∧ ...\" anymore, as \"tc ...\" is no longer in prop.</p>\n<p>For context: my goal is to have the transitive closure of a small-step semantics, and then use a recursive function to walk the trace of states extracted from the transitive closure to prove things about the trace, such as some state is reached such that... For that I'll need to pattern match on the transitive closure, and do a recursive call on the \"step\" case of the tc type.</p>\n<p>Can somebody point me towards a source that explains how to do this, or explain what I'm doing wrong/what a more idiomatic way to do this is? Code snippet reproducing the problem included below. I'm very new to lean so all tips are welcome!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n\n<span class=\"c1\">-- Pattern matching works when defined as follows, but then tc is not in Prop anymore:</span>\n<span class=\"c1\">-- inductive tc (α : Sort u) (r: α → α → Prop) : α → α → Sort (max u 1) where</span>\n\n<span class=\"c1\">-- Works for ∧, but breaks pattern matching:</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">tc</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"n\">where</span>\n\n<span class=\"bp\">|</span> <span class=\"n\">base</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tc</span> <span class=\"n\">α</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">hh</span><span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"o\">:</span> <span class=\"n\">tc</span> <span class=\"n\">α</span> <span class=\"n\">r</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tc</span> <span class=\"n\">α</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tcAnd</span> <span class=\"o\">:</span> <span class=\"n\">tc</span> <span class=\"n\">Nat</span> <span class=\"n\">x</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">True</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">And.intro</span>\n    <span class=\"o\">(</span><span class=\"n\">tc.base</span> <span class=\"o\">(</span><span class=\"n\">True.intro</span><span class=\"o\">))</span>\n    <span class=\"n\">True.intro</span>\n  <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">tryRec</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">tc</span> <span class=\"n\">Nat</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">tc.base</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">tc.step</span> <span class=\"n\">hh</span> <span class=\"n\">ht</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">True</span>\n</code></pre></div>",
        "id": 341423791,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1678703969
    },
    {
        "content": "<p>I see my question is already discussed on the \"Matching on Prop\" thread at <a href=\"#narrow/stream/113489-new-members/topic/Matching.20on.20prop\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Matching.20on.20prop</a> . I guess I'll need to read that and think. Sorry for the useless post.</p>",
        "id": 341425236,
        "sender_full_name": "Bob Rubbens",
        "timestamp": 1678704366
    }
]