[
    {
        "content": "<p>That's maybe not a great title for a post but I'm trying to give the general purpose definition of the Fitting subgroup of an arbitrary group G without assumption of it being finite. So in general this is the subgroup generated by all of the normal nilpotent subgroups of G.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">Nilpotent</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">Group</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nn_subgroups</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">.</span><span class=\"n\">Normal</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">IsNilpotent</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>Checking the type of our interim definition shows <code>Set (Subgroup G)</code> like we would expect. We don't have an index for this set of subgroups (presumably there is a result which can axiom of choice this into being for us?), but assuming we could solve that problem we have elements of type Subgroup G and not type Set G. Our endgame would be if we had a Set (Set G) we could define the subgroup we want as <code>⨆ i, s i</code>.</p>\n<p>Is this making things too hard? Can we do this concisely in a single definition rather than employing a temporary definition just to define the set of subgroups we want to close? Is the right approach to coerce from Subgroup G to Set G somehow when we form this union?</p>",
        "id": 546769454,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1761253633
    },
    {
        "content": "<p><code>sSup (nn_subgroups G)</code> is what you're after.</p>",
        "id": 546769901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1761253867
    },
    {
        "content": "<p>That's really interesting, so even though sSup is a set operation it understands that we are talking about the closure in a group theory sense? How does it know about that?</p>",
        "id": 546770238,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1761254041
    },
    {
        "content": "<p>Lean knows that <code>Subgroup G</code> is a complete lattice, so it's a partial order with a meet and a join operator. This structure is all defined in the file <code>Mathlib/Algebra/Group/Subgroup/Lattice.lean</code> if you want to poke around in there. The join of two subgroups is the intersection of all the subgroups containing them both etc etc.</p>",
        "id": 546770482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1761254144
    },
    {
        "content": "<p>One crazy thing about Lean which took me a while to learn is that it doesn't do magic -- any question you ask of this nature can be answered by reading the code, although it takes some time to get the hang of how to read the code; you can't just look at it on e.g. github, you really need VS Code or equivalent to interact with it. But the bottom line is that it's all just maths, and you can find your way to it by jumping around in the code.</p>\n<p>You can start the journey with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">CompleteLattice</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and then click on <code>#synth</code> and you'll see <code>instCompleteLattice</code> in the infoview, then you can ctrl-click on this and jump to the place where the term of type <code>CompleteLattice (Subgroup G)</code> is defined, and read what's going on there.</p>",
        "id": 546770726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1761254283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"952891\">Ryan Smith</span> <a href=\"#narrow/channel/113489-new-members/topic/Cleanly.20defining.20the.20Fitting.20subgroup/near/546770238\">said</a>:</p>\n<blockquote>\n<p>even though sSup is a set operation</p>\n</blockquote>\n<p>Aah no no no, <code>sSup</code> is a lattice operation, or even a partially ordered set operation. It's \"supremum of a subset of your poset\".</p>",
        "id": 546770922,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1761254407
    },
    {
        "content": "<p>You may be thinking of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.sUnion#doc\">docs#Set.sUnion</a>, which is a set operation (you can tell because it says <code>Set</code> in the name)</p>",
        "id": 546771321,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761254651
    },
    {
        "content": "<p>to be clear, <code>Set.sUnion</code>  literally <em>is</em> <code>sSup</code>, just in the specific context of the lattice structure of sets</p>",
        "id": 546790225,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1761266963
    },
    {
        "content": "<p>Yeah it's just defined as <code>sSup</code></p>",
        "id": 546791604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761268177
    },
    {
        "content": "<p>But I guess this way you can't accidentally pass in something else</p>",
        "id": 546791664,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1761268237
    }
]