[
    {
        "content": "<p>I couldn't find any information on how to write custom patterns. I only found about <code>@[match_pattern]</code>, but it is not applicable in many cases.</p>\n<p>Is it possible to implement for example something similar to that haskell code?</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"cm\">{-# LANGUAGE PatternSynonyms #-}</span>\n<span class=\"cm\">{-# LANGUAGE ViewPatterns #-}</span>\n\n<span class=\"kr\">data</span><span class=\"w\"> </span><span class=\"kt\">Foo</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Foo</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"kt\">Int</span>\n\n<span class=\"nf\">add</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Foo</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Int</span>\n<span class=\"nf\">add</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Foo</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"nf\">pattern</span><span class=\"w\"> </span><span class=\"kt\">FooAdd</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Foo</span>\n<span class=\"nf\">pattern</span><span class=\"w\"> </span><span class=\"kt\">FooAdd</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">&lt;-</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n<span class=\"nf\">foo</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Foo</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span>\n<span class=\"nf\">foo</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">FooAdd</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">True</span>\n<span class=\"nf\">foo</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">False</span>\n\n<span class=\"c1\">-- |</span>\n<span class=\"c1\">-- &gt;&gt;&gt; foo (Foo 2 3)</span>\n<span class=\"c1\">-- True</span>\n<span class=\"c1\">-- &gt;&gt;&gt; foo (Foo 4 1)</span>\n<span class=\"c1\">-- True</span>\n<span class=\"c1\">-- &gt;&gt;&gt; foo (Foo 2 2)</span>\n<span class=\"c1\">-- False</span>\n</code></pre></div>\n<p>And, another MWE more in line with my actual problem, is how to make this <code>Foo.succ</code> pattern work, like in <code>m₁</code>. I.e. it should match <code>x</code> on pattern <code>{ val := Nat.succ i, prop }</code>, and then it should construct <code>y</code> from matched values (<code>i</code> and <code>prop</code>), as <code>y = { val := i, prop := by injection prop }</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m₁</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">match_pattern</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 497553151,
        "sender_full_name": "MrQubo",
        "timestamp": 1738625981
    },
    {
        "content": "<p>The only options right now are <code>@[match_pattern]</code> or writing a completely custom <code>match</code> command, sorry.</p>",
        "id": 497553459,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738626149
    },
    {
        "content": "<p>Maybe there's an unexplored hack where you make a term that elaborates differently when it's used in a pattern context... but I haven't tried it.</p>",
        "id": 497553611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738626240
    },
    {
        "content": "<p>Hmm, <code>Nat.succ (Foo.val y)</code> isn't a valid match pattern due to the <code>Foo.val</code> projection.</p>",
        "id": 497554334,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738626622
    },
    {
        "content": "<p>Yes, it is not. <code>y</code> requires to also specify value of <code>prop</code>, which cannot be infered from that pattern. In math terms, it's like asking for an inverse of a projection.</p>",
        "id": 497554621,
        "sender_full_name": "MrQubo",
        "timestamp": 1738626819
    },
    {
        "content": "<p>Yeah, I guess fundamentally the problem is that <code>Foo.succ v =?= x</code> needs to somehow solve for <code>v</code>. I'm not sure how it could unify <code>congrArg Nat.succ v.prop =?= x.prop</code> to solve for <code>v</code> without some ad hoc method.</p>",
        "id": 497554719,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738626867
    },
    {
        "content": "<p>(Just checking that the unifier has no tricks up its sleeve:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  rfl</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ?m.2499 = ?m.2499 : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Foo.succ ?m.2471 = x : Prop</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>)</p>",
        "id": 497554914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738626971
    },
    {
        "content": "<p>So with the macro approach you suggested, I would probably need to write a macro that rewrites <code>| Foo.succ $y:ident =&gt; $t:term</code> in match to something like <code>| { val := Nat.succ _i, prop := _prop } =&gt; let $y = { val := _i, prop := by injection _prop }; $t</code>?</p>\n<p>I will try to implement that.</p>",
        "id": 497555182,
        "sender_full_name": "MrQubo",
        "timestamp": 1738627120
    },
    {
        "content": "<p>I've tried like this, but that doesn't work. I think that the error \"invalid pattern\" comes from here: <a href=\"https://github.com/leanprover/lean4/blob/b81dd3e7adb5252a89afb5d9abfc14ee54e59881/src/Lean/Elab/PatternVar.lean#L270\">https://github.com/leanprover/lean4/blob/b81dd3e7adb5252a89afb5d9abfc14ee54e59881/src/Lean/Elab/PatternVar.lean#L270</a>.<br>\nSeems like my macro isn't being run at all.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"foo_succ\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">macro</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">matchAlt</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo_succ_impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Macro</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">matchAltExpr</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo_succ</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">matchAltExpr</span><span class=\"bp\">|</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"c1\">--match { val := i, prop := by injection _prop } with</span>\n<span class=\"w\">        </span><span class=\"c1\">--  | $y =&gt; $t</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo_succ</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 497564022,
        "sender_full_name": "MrQubo",
        "timestamp": 1738632536
    },
    {
        "content": "<p>A macro gotcha is that macros don't indiscriminately expand, but instead they expand in particular places. For example, terms and macros get macro expanded in their entirety.</p>\n<p>We can simulate this with match alts by adding a macro for <code>match</code> that expands <code>matchAlt</code> macros.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"foo_succ\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">macro</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">matchAlt</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo_succ_impl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Macro</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">matchAltExpr</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo_succ</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">matchAltExpr</span><span class=\"bp\">|</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">injection</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">prop</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">t</span>\n<span class=\"w\">    </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">macro</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Parser</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">match</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expandMatchAlts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Macro</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  @[builtin_term_parser] def «match» := leading_parser:leadPrec</span>\n<span class=\"cm\">    \"match \" &gt;&gt; optional generalizingParam &gt;&gt; optional motive &gt;&gt; sepBy1 matchDiscr \", \" &gt;&gt;</span>\n<span class=\"cm\">    \" with\" &gt;&gt; ppDedent matchAlts</span>\n<span class=\"cm\">  -/</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">alts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">getArgs</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">changed</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">alts</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">alt</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">expandMacro?</span><span class=\"w\"> </span><span class=\"n\">alts</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">!</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">alts</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">alts</span><span class=\"bp\">.</span><span class=\"n\">set!</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">alt</span>\n<span class=\"w\">      </span><span class=\"n\">changed</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">changed</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">setArg</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">][</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"bp\">.</span><span class=\"n\">setArgs</span><span class=\"w\"> </span><span class=\"n\">alts</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">Macro</span><span class=\"bp\">.</span><span class=\"n\">throwUnsupported</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">m₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">foo_succ</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 497577920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738641337
    },
    {
        "content": "<p>Thanks!<br>\nThough, I still don't understand, why <code>match</code> gets expanded, and <code>matchAlt</code> doesn't?<br>\nIs it because <code>match</code> term is already expanded using some internal function, and that function doesn't expand macros?</p>",
        "id": 497619772,
        "sender_full_name": "MrQubo",
        "timestamp": 1738662034
    },
    {
        "content": "<p><del>Looking at the code for <code>elabMatch</code> it seems like it might expand <code>Lean.Parser.Term.matchAlts</code>, but not <code>Lean.Parser.Term.matchAlt</code>.</del> nvm</p>",
        "id": 497624811,
        "sender_full_name": "MrQubo",
        "timestamp": 1738663475
    },
    {
        "content": "<p>It's because the <code>term</code> elaborator's steps are</p>\n<ol>\n<li>see if the current term has a macro expansion, if so expand and go back to 1.</li>\n<li>see if there is an elaborator for this term. if so, apply it, and return the result.</li>\n<li>otherwise, thrown a 'no such elaborator' error</li>\n</ol>\n<p>Macro expansion isn't applied to subterms before we're actually considering them for elaboration.</p>\n<p>There's a similar flow for commands and tactics, but tactics have a backtracking version of macro expansion, where if the macro expansion leads to a tactic error, it backtracks and tries the next applicable macro.</p>",
        "id": 497673066,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738677734
    },
    {
        "content": "<p><code>match</code> is a term, so its macros get applied, <code>matchAlt</code> is just some syntax that goes into a <code>match</code>, so macros don't get applied unless we explicitly create our own macro driver (like I did)</p>",
        "id": 497673359,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738677801
    }
]