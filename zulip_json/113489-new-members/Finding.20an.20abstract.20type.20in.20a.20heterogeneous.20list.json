[
    {
        "content": "<p>I appreciate how helpful the community has been with beginner questions. I have yet another one. This question is a bit more open-ended, as I'm really not sure where to begin. Suppose I set up a heterogeneous list as follows.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n\n<span class=\"c1\">-- Example of a heterogeneous List Element</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elems</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Element</span><span class=\"bp\">.</span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"bp\">.</span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}]</span>\n</code></pre></div>\n<p>I can now write a function that filters a <code>List Element</code> to find, for example, all the points.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getPoints</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">toPoint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elem</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">point</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">none</span>\n\n<span class=\"w\">  </span><span class=\"n\">elems</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"n\">toPoint</span>\n</code></pre></div>\n<p>But suppose I want to do something more abstract. I want to filter a heterogeneous list to find all the elements that have x and y fields. I can set up a type class for this property, as described below, but could anyone suggest a way to look through a list and find all the elements that satisfy this type class, returning a list of elements that are guaranteed to have x and y values? Thanks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">y</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"bp\">.</span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 510532121,
        "sender_full_name": "misterdrgn",
        "timestamp": 1743983682
    },
    {
        "content": "<blockquote>\n<p>but could anyone suggest a way to look through a list</p>\n</blockquote>\n<p>Can you say what type you intend said <code>List</code> to have? Are you still using <code>List Element</code>?</p>",
        "id": 510533567,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743984860
    },
    {
        "content": "<p>I'm getting the sense that <span class=\"user-mention\" data-user-id=\"754034\">@misterdrgn</span> is trying to do structural typing, but Lean's type system is nominal</p>",
        "id": 510533910,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1743985108
    },
    {
        "content": "<p>for example, the <code>Locatable</code> classes don't actually add any new data/props, they merely re-use existing fields... I don't think that's typical of the way Lean uses typeclasses</p>",
        "id": 510534108,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1743985285
    },
    {
        "content": "<p>I could provide a <code>Locatable</code> instance for <code>Size</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>of course that would be stupid, but the point is that <code>Locatable</code> doesn't provide any guarantees about the fields on the original structure</p>",
        "id": 510534678,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1743985709
    },
    {
        "content": "<p>(maybe this is irrelevant to the problem at hand... I just think there might be some conceptual confusion here that could lead to issues down the road)</p>",
        "id": 510534974,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1743985937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Finding.20an.20abstract.20type.20in.20a.20heterogeneous.20list/near/510533567\">said</a>:</p>\n<blockquote>\n<p>Can you say what type you intend said <code>List</code> to have? Are you still using <code>List Element</code>?</p>\n</blockquote>\n<p>Yeah, that's kind of the question. I've long wondered about the best way to capture this functionality that my research group uses in our AI (not machine learning) framework, which was originally in Clojure, and then I later ported it to Swift. Of course, those languages are very different. Clojure allows you to stick whatever you want in a hashmap, and Swift allows you to upcast and downcast freely. So in Swift, you could have Point and Rect as structs, and then they both conform to the Locatable protocol,  and then everything conforms to the Element protocol (swift protocols are type classes without higher-kinded types, if you're unfamiliar). So you can start with an array of Element, and then downcast to an array of Locatable (filtering out the things that don't conform to Locatable), and you can interact with the Locatables and get their x and y values, and then you could later downcast to an array of Point (again, filtering out the things that aren't Point).</p>\n<p>When I first looked at Lean maybe 6 months back, I tried to do something similar with downcasting, but it was tricky. It seems like the correct way to handle heterogeneous lists in many languages is to use enums, or in lean inductive types. Those make it easy to go from Element to Point, but I don't know how to get to the intermediate Locatable type.</p>\n<p>One way to do it is to nest the types. Something like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Located</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Located</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Located</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Located</span>\n</code></pre></div>\n<p>But this doesn't seem ideal because when you've unwrapped everything down to <code>Point</code> or <code>Rect</code>, you've lost the <code>x</code> and <code>y</code> fields that are represented up at the <code>Locatable</code> level.</p>",
        "id": 510536545,
        "sender_full_name": "misterdrgn",
        "timestamp": 1743987158
    },
    {
        "content": "<p>Oh, another approach is to make <code>Locatable</code> a separate struct that just has <code>x</code> and <code>y</code> fields, and then have a way to convert some types to <code>Locatable</code>.</p>\n<p>And then you could write a version of the getPoints function I defined above that's <code>getLocatables</code>, and it gets all the types that can be converted to <code>Locatable</code> and converts them. A couple downsides are:<br>\n1) There's no way to downcast further. That is, you can't convert a <code>Locatable</code> back to a <code>Point</code>. But that might be okay for present purposes.<br>\n2) I suspect the <code>getLocatables</code> function would have to reference every type that can be converted to <code>Locatable</code> explicitly, which means you'd have to modify the function whenever you add a new type.</p>",
        "id": 510537322,
        "sender_full_name": "misterdrgn",
        "timestamp": 1743987721
    },
    {
        "content": "<p>Does this help you?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">y</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"bp\">.</span><span class=\"n\">y</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">AbstractLocatable</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">locatable</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Example of a heterogeneous List Element</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elems</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">AbstractLocatable</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">}</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"o\">}</span><span class=\"bp\">⟩</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 510538676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743988760
    },
    {
        "content": "<p>what about using inheritance?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Locatable</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Size</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Locatable</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Element</span>\n</code></pre></div>",
        "id": 510539881,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1743989558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks for the suggestion. This is actually close to the original approach I tried several months ago. The idea was to encode both the original data (e.g., x and y values) and the original type (e.g., <code>Point</code>) in a generic struct, so that these could be recovered later. However, in practice recovering the original types was difficult because Lean4, like many statically typed languages (but unlike Swift and I think Scala), doesn't keep type information at runtime. If you know of a good way to take your<code>List AbstractLocation</code> and convert that back to a <code>List Point</code>, removing all the values that can't be downcast to <code>Point</code>, I'd be very interested.</p>",
        "id": 510914199,
        "sender_full_name": "misterdrgn",
        "timestamp": 1744114020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> Wow, somehow I missed that extending structs was even a thing. I can see where that would be convenient, but my question is the same as above. In fact, a quick look at the functional programming in lean4 book indicates that once you upcast a <code>Point</code> to a <code>Locatable</code>, there's no way to recover the original <code>Point</code>. So you can upcast but not downcast.</p>\n<p>Thanks for the suggestion.</p>",
        "id": 510914630,
        "sender_full_name": "misterdrgn",
        "timestamp": 1744114141
    },
    {
        "content": "<p>You could bundle a <code>toPoint?</code> field into all the elements of the list</p>",
        "id": 510917120,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1744114943
    },
    {
        "content": "<p>I think what you want is the ability to downcast like Rust's <a href=\"https://doc.rust-lang.org/std/any/index.html\">Any::downcast_ref</a>. One possible implementation to assign a unique ID to each type (such as the type's name represented as <code>Lean.Name</code>), and use that information to implement the downcast.</p>\n<p>Unfortunately, it's possible that <code>Nat = Int</code> in Lean via a so-called cardinality model, so I think it's not possible to assign such an ID to every type within Lean's logic. I guess we need an unsafe (or at least opaque) definition to handle the ID assignment.</p>",
        "id": 510955380,
        "sender_full_name": "pandaman",
        "timestamp": 1744123816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/channel/113489-new-members/topic/Finding.20an.20abstract.20type.20in.20a.20heterogeneous.20list/near/510914630\">said</a>:</p>\n<blockquote>\n<p>@Matt Diamond Wow, somehow I missed that extending structs was even a thing. I can see where that would be convenient, but my question is the same as above. In fact, a quick look at the functional programming in lean4 book indicates that once you upcast a <code>Point</code> to a <code>Locatable</code>, there's no way to recover the original <code>Point</code>. So you can upcast but not downcast.</p>\n</blockquote>\n<p>Just to temper your expectations here, lean doesn't have subtyping. When you extend a structure it's just sugar for declaring a structure with a field whose type is the parent (aka \"composition over inheritance\"). The \"upcast\" isn't really a cast, it's just a field projection</p>",
        "id": 510957451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744124326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/113489-new-members/topic/Finding.20an.20abstract.20type.20in.20a.20heterogeneous.20list/near/510957451\">said</a>:</p>\n<blockquote>\n<p>Just to temper your expectations here, lean doesn't have subtyping. When you extend a structure it's just sugar for declaring a structure with a field whose type is the parent (aka \"composition over inheritance\"). The \"upcast\" isn't really a cast, it's just a field projection</p>\n</blockquote>\n<p>Yeah, understood. Go does something similar, though it looks like Lean does it better. If I was looking for OOP, I'd look elsewhere.</p>",
        "id": 511047035,
        "sender_full_name": "misterdrgn",
        "timestamp": 1744157506
    },
    {
        "content": "<p>The equivalent of Rust <code>Any</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dynamic#doc\">docs#Dynamic</a>, where <code>Any::downcast_ref</code> becomes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dynamic.get%3F#doc\">docs#Dynamic.get?</a> . But it's an opaque function, so you won't be able to prove theorems using this method</p>",
        "id": 511083464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744178646
    },
    {
        "content": "<p>The usual approach here is to just use the \"universe pattern\" and make an inductive type containing all of your types of interest, as you have done. The typeclass becomes a red herring then, you can just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getLocatable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">elems</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"k\">fun</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>",
        "id": 511084287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744179015
    },
    {
        "content": "<p>But if you wanted to generalize this over different types replacing <code>Element</code>, you can build the function out of typeclasses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Point</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"c1\">-- default instance</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"bp\">..</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"bp\">.</span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getLocatable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Element</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">elems</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"n\">MaybeLocatable</span><span class=\"bp\">.</span><span class=\"n\">pt</span>\n</code></pre></div>",
        "id": 511084984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1744179331
    }
]