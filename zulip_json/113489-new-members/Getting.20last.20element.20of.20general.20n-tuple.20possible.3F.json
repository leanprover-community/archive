[
    {
        "content": "<p>Hi! I've been wondering whether it's possible to write a function that extracts the last element of a general n-tuple (the one with right-associative Prod, not the (Fin n -&gt; a) stuff). First thing I tried was matching on the type constructor, but that doesn't seem to be possible.</p>\n<p>I tried looking for prior discussion about this, but couldn't find any. I imagine you can run into the same problem in many different guises though.</p>",
        "id": 488933326,
        "sender_full_name": "Kaarel August Kurik",
        "timestamp": 1734130020
    },
    {
        "content": "<p>You could do it with typeclasses, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"kd\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span>\n<span class=\"kd\">class</span><span class=\"w\"> </span><span class=\"n\">HasLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p.snd</span>\n\n<span class=\"kd\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HasLast</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getLast</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HasLast.getLast</span><span class=\"w\"> </span><span class=\"n\">p.snd</span>\n\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">HasLast.getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 8</span>\n<span class=\"k\">#eval</span><span class=\"w\"> </span><span class=\"n\">HasLast.getLast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"asdf\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(),</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- false</span>\n</code></pre></div>\n<p>But I don't think this is a very good solution. Can you explain what you are trying to accomplish?</p>",
        "id": 488945829,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734138276
    },
    {
        "content": "<p><code>Prod</code> tuples aren't very well behaved, as it's ambiguous what their length is if you intend one of the elements of the tuple to itself be a <code>Prod</code></p>",
        "id": 488946053,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1734138449
    },
    {
        "content": "<p>That's a neat solution!<br>\nThe only pragmatic goal here was to implement generic indexing on n-tuples, so I figured getting the last element would be a good simplification to test that. Other than that, I was just curious about how Lean's features support (or don't) this sort of thing.</p>",
        "id": 488966625,
        "sender_full_name": "Kaarel August Kurik",
        "timestamp": 1734156797
    },
    {
        "content": "<p>I wrote something about code like this, it might be of interest <a href=\"https://lecopivo.github.io/scientific-computing-lean/Miscellaneous/Typeclasses-as-Interfaces-and-Function-Overloading/#Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading\">https://lecopivo.github.io/scientific-computing-lean/Miscellaneous/Typeclasses-as-Interfaces-and-Function-Overloading/#Scientific-Computing-in-Lean--Miscellaneous--Typeclasses-as-Interfaces-and-Function-Overloading</a></p>",
        "id": 488972991,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1734163560
    },
    {
        "content": "<blockquote>\n<p>The only pragmatic goal here was to implement generic indexing on n-tuples, so I figured getting the last element would be a good simplification to test that. Other than that, I was just curious about how Lean's features support (or don't) this sort of thing.</p>\n</blockquote>\n<p>It's possible that getting the last element of a n-tuple is actually much harder than getting the <code>i</code>th element of an n-tuple. This is because getting the size of an n-tuple is hard. Consider the following:<br>\n<code>(3, \"asdf\", true, 3.5)</code><br>\nShould this be interpreted as a member of <code>Nat × String × Bool × Float</code> or as a member of <code>Nat × String × (Bool × Float)</code>? Both of these types are exactly the same, since <code>×</code> by default associates to the right. And you can imagine defining a new type <code>def T := Bool × Float</code> or <code>abbrev T := Bool × Float</code> and asking whether getting the last element should \"see through\" <code>T</code>. So, no, getting the last element is not a simplification of getting the n-th element, it is actually more challenging.</p>\n<p>If you wanted to get the <code>ith</code> element, it is probably possible with metaprogramming, I'm just not quite sure how. The reason that this is easier than getting the last element is that it is right associative, so you can just iterate <code>Prod.snd</code> a bunch of times possibly followed by <code>Prod.fst</code>, and you get the same result if you place parentheses on the right (like around <code>Bool × Float</code>).</p>",
        "id": 488983047,
        "sender_full_name": "Niels Voss",
        "timestamp": 1734173097
    }
]