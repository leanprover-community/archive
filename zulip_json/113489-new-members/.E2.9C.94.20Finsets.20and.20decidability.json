[
    {
        "content": "<p>I'm reading MIL, and in <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C05_Elementary_Number_Theory.html#infinitely-many-primes\">this chapter</a> there's a passage:</p>\n<blockquote>\n<p>Let’s consider a variation of the proof above, where instead of using the factorial function, we suppose that we are given by a finite set <code>{p_1, ..., p_n}</code> and we consider a prime factor of <code>∏_i=1..n p_i + 1</code>. That prime factor has to be distinct from each <code>p_i</code>, showing that there is no finite set that contains all the prime numbers.</p>\n<p>Formalizing this argument requires us to reason about finite sets. In Lean, for any type <code>α</code>, the type <code>Finset α</code> represents finite sets of elements of type <code>α</code>. Reasoning about finite sets computationally requires having a procedure to test equality on <code>α</code>, which is why the snippet below includes the assumption <code>[DecidableEq α]</code>. For concrete data types like <code>ℕ</code>, <code>ℤ</code>, and <code>ℚ</code>, the assumption is satisfied automatically. When reasoning about the real numbers, it can be satisfied using classical logic and abandoning the computational interpretation.</p>\n</blockquote>\n<p>I'm curious: does this assumption (decidability of equality) map to the mathematical formulation of this theorem? Or is this some kind of limitation specific to Lean's formalization?</p>",
        "id": 501311116,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740265910
    },
    {
        "content": "<p>I'm asking because I've never seen decidability mentioned in non-CS contexts when discussing math results. Unless they're specifically about logic.</p>\n<p>So I'm trying to understand when it \"creeped in\" here. Does it mean that I should expect other math theorems to have decidability constraints on some types that aren't obvious from reading the mathematical formulation? Or is this somehow possible to work around in this proof? Is this decidability requirement also \"present\" in math formulation of this theorem but is hidden behind some other concept?</p>",
        "id": 501311493,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740266255
    },
    {
        "content": "<p>Maybe another way to phrase it — is a noncomputational proof of this theorem possible in Lean?</p>",
        "id": 501311577,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740266307
    },
    {
        "content": "<p>So the issue here is how the type <code>Finset</code> specifically is implemented in mathlib: it is a <code>List</code> without duplicates (*), ignoring order. So if you want to take the union of {a,b,c} and {d,e,f}, you need to be able to check <em>within the algorithm that merges the lists</em> whether a = d and so on</p>\n<p>(*) strictly speaking a multiset</p>",
        "id": 501312250,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740266887
    },
    {
        "content": "<p>It's also possible to work with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a>, which doesn't have these decidability requirements, but there tends to be more theory about <code>Finset</code> sums and products.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Finsets.20and.20decidability/near/501311577\">said</a>:</p>\n<blockquote>\n<p>Maybe another way to phrase it — is a noncomputational proof of this theorem possible in Lean?</p>\n</blockquote>\n<p>Yes, in a sense. It's possible to enable do <code>open scoped Classical</code> to enable the noncomputable decidability instances, and then not have <code>DecidableEq</code> in theorem statements. However, this tends to cause issues (decidable instances are all propositionally equal to each other but not necessarily definitionally equal).</p>",
        "id": 501313968,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740268505
    },
    {
        "content": "<p>I see. Is this general situation considered okay in long term, or is this something the community would like to see a solution to eventually? Just curious what kind of concessions in Mathlib design are considered acceptable, and whether people run into this in general.</p>",
        "id": 501314156,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740268685
    },
    {
        "content": "<p>Another question — does the “computational” nature of the proof mean that some code dealing with sets <em>actually has to run</em> during the proof? How can that make sense given that we’re dealing with arbitrary sets and not specific ones? And if it <em>doesn’t</em> have to run, then why is this proof considered computational? Or does it have to run, but only for a few predetermined sets, and so it doesn’t have to “take forever”?</p>\n<p>Pardon for a weird formulation but I hope the question makes sense. I’m basically asking how can a proof have computational sections if we’re not literally “running” it for all inputs.</p>",
        "id": 501314536,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740269001
    },
    {
        "content": "<p>I’m guessing that the code does run, but the set items aren’t “concrete”, so it’s fine. Ie they’re just terms like “a natural number” but not necessarily concrete numbers.</p>",
        "id": 501314634,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740269088
    },
    {
        "content": "<p>One big ongoing project for the last couple years has been creating <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite#doc\">docs#Finite</a>, which is a proposition, to replace <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a> in theorems that don't need it. That's cleaned up a lot of decidability assumptions.</p>\n<p>I've been pushing for a completely <code>Set</code>-like <code>FiniteSet</code> myself, but that hasn't seen as much support. One worry is that it's yet another way to work with finiteness, and also it makes it less amenable to computing the finite sets (which does occasionally come up in proofs — we'd need <code>Finset</code> for that still). It's also a much larger project than <code>Finite</code> to make a <code>FiniteSet</code> version of the library.</p>",
        "id": 501314666,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740269131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/Finsets.20and.20decidability/near/501314536\">said</a>:</p>\n<blockquote>\n<p>does the “computational” nature of the proof mean that some code dealing with sets <em>actually has to run</em> during the proof?</p>\n</blockquote>\n<p>Usually no. Sometimes there are proofs that reduce a Finset to enumerate its elements (that's what the <code>fin_cases</code> tactic can do).</p>\n<p>It's not the proof itself that's computational; it's that the functions the proof is talking about are computational, so to even talk about them you need to include all the extra stuff the function needs to do its computation, even if it's never actually used in the proof. The decidability stuff is all passed as arguments to these functions.</p>",
        "id": 501314862,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740269293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 501314943,
        "sender_full_name": "Notification Bot",
        "timestamp": 1740269389
    },
    {
        "content": "<p>OK makes sense, thanks for explaining!</p>",
        "id": 501314951,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740269396
    },
    {
        "content": "<p>I think the phrasing \"abandoning the computational interpretation\" in the quote is referring to how, while all the <code>Finset</code> operations are concrete algorithms (like what Rubin said), if you use the classical decidable instances, they revert to being \"just sets\" (though \"just sets\" that have inconvenient properties for classical reasoning — hence why I'd like to see a <code>FiniteSet</code> that's just a set with no computational content).</p>",
        "id": 501315014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740269459
    },
    {
        "content": "<p>If I remove <code>[DecidableEq α]</code>, the squiggles show up at the usage of union:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">synthesize</span>\n<span class=\"w\">  </span><span class=\"n\">Union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a way for me to \"jump to definition\" of how <code>Union</code> is defined for <code>DecidableEq</code>?</p>",
        "id": 501315286,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740269748
    },
    {
        "content": "<blockquote>\n<p>It's not the proof itself that's computational; it's that the functions the proof is talking about are computational, so to even talk about them you need to include all the extra stuff the function needs to do its computation, even if it's never actually used in the proof. The decidability stuff is all passed as arguments to these functions.</p>\n</blockquote>\n<p>This makes sense but I struggle to follow along with this specific example — would appreciate pointers on some specific chain of usage down to where decidability stuff is unavoidable. E.g. is it in the <code>Union</code> algorithm? (Where is that in the source?)</p>",
        "id": 501315453,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740269900
    },
    {
        "content": "<blockquote>\n<p>Is there a way for me to \"jump to definition\"</p>\n</blockquote>\n<p>There's not a great way to do this right now from the \"failed to synthesize\" error. The typeclass instance synthesis system isn't able to answer \"these are the instances you'd need to be able to synthesize this instance\". It's frustrating, and you sometimes have to add in decidable instances (or use <code>open scoped Classical</code>) to see if that's the reason the instance can't be found.</p>\n<p>Here's one possibility: Type this in</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>then hover over the union symbol in the infoview, and see that there's an instance argument that uses the word finset</p>\n<p><a href=\"/user_uploads/3121/wvREcBVvRP0gc7BNItcbJibO/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/wvREcBVvRP0gc7BNItcbJibO/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"976x174\" src=\"/user_uploads/thumbnail/3121/wvREcBVvRP0gc7BNItcbJibO/image.png/840x560.webp\"></a></div><p>Then, on a mac, command click on that to go to the definition.</p>\n<p>This instance is written in an indirect way for some reason. It only gives the proof argument, letting the type of the proof fill in that it calculates the union with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset.ndunion#doc\">docs#Multiset.ndunion</a></p>\n<p><a href=\"/user_uploads/3121/Anvh90BFXwsXHybyllSMYfbZ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Anvh90BFXwsXHybyllSMYfbZ/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1758x216\" src=\"/user_uploads/thumbnail/3121/Anvh90BFXwsXHybyllSMYfbZ/image.png/840x560.webp\"></a></div><p><em>Edit:</em> this screenshot was supposed to include the hover, but it didn't make it in. It had the type of the underlined proof term.</p>",
        "id": 501316080,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740270458
    },
    {
        "content": "<p>That process could also be used on the pre-existing union symbol in the original working local context before you deleted the <code>DecidableEq</code>.</p>",
        "id": 501316132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740270488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501315453\">said</a>:</p>\n<blockquote>\n<p>would appreciate pointers on some specific chain of usage</p>\n</blockquote>\n<p>The chain of usage is that <code>Finset</code> union makes use of a <code>Multiset</code> union operation, which makes use of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.union#doc\">docs#List.union</a>, which has the semantics \"adds all the elements of the first list to the front of the second list, if they aren't already present\". The \"if they aren't already present\" needs an <code>if</code>, so it needs an algorithm to decide equality, which percolates all the way back up to the <code>Finset</code> union needing an algorithm to decide equality.</p>",
        "id": 501316323,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740270663
    },
    {
        "content": "<p>Then, in the proof, the only reason there's DecidableEq at all is to be able to refer to the <code>Finset</code> union operation. The decision procedure is not necessarily ever being used.</p>\n<p>In fact, if you need the <code>DecidableEq</code> parameter to your theorem, the decision procedure <em>can't</em> be used in any real way within the proof, because that's representing a some abstract decision procedure (exactly like if you have a <code>(f : Nat -&gt; Nat)</code> parameter there's nothing about <code>f</code> that you can evaluate). It's all to demonstrate to Lean that there's a union operation in the first place.</p>",
        "id": 501316480,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740270803
    },
    {
        "content": "<p>Got it, thanks for the pointer.</p>\n<p>I think intuitively this is still confusing, though maybe there's just no way to avoid that confusion and I should accept it and move on.</p>\n<p>It feels confusing because if some code never runs, and we're also not reasoning about <em>how</em> that code works (we're not <em>proving</em> that \"if they aren't already present\" is actually implemented correctly, are we?), I don't see why it \"matters\" for it to be decidable. Could we just run in some kind of a \"proof mode\" where unreachable things don't factor into the types? Or is that what <code>Classical</code> essentially does? Why isn't that behavior the default?</p>\n<p>Put it another way, what would break if Lean didn't enforce this?</p>",
        "id": 501316744,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740271043
    },
    {
        "content": "<p>Your question is like asking \"why do I need to supply anything for the <code>_</code>'s in the following theorem?\"</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 501316850,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271161
    },
    {
        "content": "<p>(I'm trying to draw a parallel here, I don't mean that to be a dismissive \"it's like asking\" sort of statement)</p>",
        "id": 501316868,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271192
    },
    {
        "content": "<p>This is where you have to internalize that instance arguments are exactly like any other kind of argument. It's just an argument that Lean tries to fill in for you automatically using typeclass instance synthesis.</p>",
        "id": 501316937,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271247
    },
    {
        "content": "<p>A value of <code>Decidable p</code> is exactly like a value of <code>Bool</code>. It's some data. In my example above, <code>f</code> wants this <code>n : Nat</code> parameter. That's data too.</p>",
        "id": 501316977,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271305
    },
    {
        "content": "<p>Dan, are you asking \"why does Decidability matter in proofs since proofs aren't computational anyway?\"</p>",
        "id": 501317042,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740271337
    },
    {
        "content": "<p>You can ignore what \"decidability\" represents completely to understand the issue. There's an argument that the Finset union operation needs. You can't just not supply it.</p>",
        "id": 501317043,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271340
    },
    {
        "content": "<p>Hmm. This is a shot in the dark but would it be accurate to say that...</p>\n<ol>\n<li><code>Finset</code> is designed to be able to use computationally (i.e. to write actual programs)</li>\n<li>Therefore it's implemented as a \"real thing\" with a \"real\" union operation that has runtime semantics</li>\n<li>That requires some notion of equality, which has to be expressed in types</li>\n<li>In our proof, we happen to be using <code>Finset</code>, so we have to abide by its types</li>\n<li>So we have to specify a thing that our proof doesn't care about because that's what the types say</li>\n</ol>\n<p>And then if we went ahead and surgically edited <code>Finset</code> so that it's just a \"math thing\" and doesn't have runtime semantics (which would break its contract and how many people use it), we'd be able to get rid of the decidability constraint.</p>",
        "id": 501317051,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740271355
    },
    {
        "content": "<p>If we changed <code>Finset</code> itself, people's code should still typecheck at least, but the broken contract would be that the code generator doesn't accept their code anymore, and so they can't run their programs.</p>",
        "id": 501317176,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271473
    },
    {
        "content": "<p>OK that clarifies it, thanks!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501317042\">said</a>:</p>\n<blockquote>\n<p>Dan, are you asking \"why does Decidability matter in proofs since proofs aren't computational anyway?\"</p>\n</blockquote>\n<p>Sort of! I guess I was wondering why can't this constraint / type be relaxed/erased/something when writing proofs. Sort of how types get erased in running programs.</p>\n<p>(I haven't actually thought through how this erasing would be done and whether it is even possible to represent without breaking the type system.)</p>",
        "id": 501317232,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1740271524
    },
    {
        "content": "<p>(<code>Finset</code> is a least-common-denominator finite set data structure by the way. It's <em>only</em> assuming that you can test elements for equality. You can do better if you can test for order, or hash.)</p>",
        "id": 501317248,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501317051\">said</a>:</p>\n<blockquote>\n<p>Hmm. This is a shot in the dark but would it be accurate to say that...</p>\n<ol>\n<li><code>Finset</code> is designed to be able to use computationally (i.e. to write actual programs)</li>\n<li>Therefore it's implemented as a \"real thing\" with a \"real\" union operation that has runtime semantics</li>\n<li>That requires some notion of equality, which has to be expressed in types</li>\n<li>In our proof, we happen to be using <code>Finset</code>, so we have to abide by its types</li>\n<li>So we have to specify a thing that our proof doesn't care about because that's what the types say</li>\n</ol>\n<p>And then if we went ahead and surgically edited <code>Finset</code> so that it's just a \"math thing\" and doesn't have runtime semantics (which would break its contract and how many people use it), we'd be able to get rid of the decidability constraint.</p>\n</blockquote>\n<p>This matches my own understanding of it (though I'm wrong a lot, lol)</p>",
        "id": 501317316,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740271603
    },
    {
        "content": "<p>At least for <code>Decidable</code>, you can \"erase\" it by using the <code>Classical</code> decidable instance, like I was suggesting earlier.</p>\n<p>That just causes some issues sadly, from the \"wrong\" instances being used in different places. What I was saying about not necessarily being definitionally equal.</p>",
        "id": 501317458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740271728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501317051\">said</a>:</p>\n<blockquote>\n<p>Hmm. This is a shot in the dark but would it be accurate to say that...</p>\n<ol>\n<li><code>Finset</code> is designed to be able to use computationally (i.e. to write actual programs)</li>\n<li>Therefore it's implemented as a \"real thing\" with a \"real\" union operation that has runtime semantics</li>\n<li>That requires some notion of equality, which has to be expressed in types</li>\n<li>In our proof, we happen to be using <code>Finset</code>, so we have to abide by its types</li>\n<li>So we have to specify a thing that our proof doesn't care about because that's what the types say</li>\n</ol>\n<p>And then if we went ahead and surgically edited <code>Finset</code> so that it's just a \"math thing\" and doesn't have runtime semantics (which would break its contract and how many people use it), we'd be able to get rid of the decidability constraint.</p>\n</blockquote>\n<ol>\n<li>Yes.</li>\n<li>The code generator generates code for it.</li>\n<li>This requires certain operations, such as <code>Union</code>, to take in as an argument a method to decide whether two elements are equal. This is reflected in the signature of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.instUnion#doc\">docs#Finset.instUnion</a> taking <code>[DecidableEq α]</code> as an assumption.</li>\n<li>Yes.</li>\n<li>I would say that your proof does care about which instance is used, since even though all <code>[DecidableEq α]</code> instances are (propositionally) equal, you still want your proof to work for any instance, instead of just asserting something about the <code>Union</code> operation derived from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Classical.decEq#doc\">docs#Classical.decEq</a> and then having to rewrite the decidability instance to use this one every time you apply the theorem.</li>\n</ol>",
        "id": 501317686,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740271935
    },
    {
        "content": "<p>I would love to see <code>Finset</code> removed and replaced by a classical variant so that we don't have to worry about all this constructivist nonsense. The whole decidable thing is confusing for mathematician beginners who as you say don't have a clue about what it all means because mathematicians are taught using classical logic in 99% of their courses. The reason <code>Finset</code> is so engrained in the system is that it was already there in 2017 when the maths library was being written by people who cared a lot more about constructivism. Initially we tried to fix the decidable issue by just switching on classical logic at the beginning of every file but this sometimes led to very confusing errors when sometimes the system would pick up the correct algorithm for the naturals and sometimes the LEM one giving diamonds. So now we deal with things by sprinkling decidable instances in exactly the right places, which is lots of places. </p>\n<p>To actually remove finset now would be a lot of work, but it would be doable. One problem I envisage would be the following. Right now I suspect you can prove the finsets {1,2,3} and {3,2,1} are equal with the <code>decide</code> tactic. If we made them classical then we'd need another tactic for this which would also have to be written. When we make polynomials classical we already had the <code>ring</code> tactic available so the<code>rfl</code> proofs which broke could be easily fixed.</p>",
        "id": 501318541,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740272675
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501318541\">said</a>:</p>\n<blockquote>\n<p>When we make polynomials classical we already had the <code>ring</code> tactic available so the<code>rfl</code> proofs which broke could be easily fixed.</p>\n</blockquote>\n<p>Sure, but we then had to wait a very long time for <code>compute_degree</code>, and things like <code>rfl : (X ^ 2 + X  +1 : ℤ[X]).leadingCoeff = 2</code> are lost as well.</p>",
        "id": 501322455,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740276271
    },
    {
        "content": "<blockquote>\n<p>and doesn't have runtime semantics (which would break its contract and how many people use it)</p>\n</blockquote>\n<p>This is only half the picture; while <code>Decidable</code> almost always give runtime semantics (unless you do something nuts like <code>noncomputabe instance : Decidable</code>), it also often gives kernel-reduction semantics. If you replace it with the classical instance, then things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>are not longer true. (Kevin points out above that <code>decide</code> fails here, but <code>rfl</code> is similarly affected).</p>",
        "id": 501322615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740276430
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Finsets.20and.20decidability/near/501318541\">said</a>:</p>\n<blockquote>\n<p>So now we deal with things by sprinkling decidable instances in exactly the right places, which is lots of places.</p>\n</blockquote>\n<p>Maybe a solution here is \"autoimplicit Decidable arguments\", so that this sprinkling is automatic and invisible?</p>",
        "id": 501322766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740276588
    },
    {
        "content": "<p>Or make that computationally efficient Polynomial type and a tactic to reflect questions about math polynomials to it.</p>",
        "id": 501322958,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740276761
    },
    {
        "content": "<p>Similarly, there could be a tactic to reflect questions about FiniteSet to Finset and do a computation there.</p>",
        "id": 501323008,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1740276828
    },
    {
        "content": "<p>Writing tactics of that form scales much less well though; a mathematician can write some complex definition in terms of <code>Finset.union</code>, <code>Fintype.card</code>, etc, and while lean will complain at them about <code>DecidableEq</code> and <code>Fintype</code>, the upshot is that if they manage to comply they get a medium level of tactic support for free. If we try to erase those arguments, then we erase that free tactic support too.</p>\n<p>As you say, we can get it back with some clever reflection to the computable versions (ideally with minimal meta code), but anyone qualified to write those computable versions surely already understands the existing typeclass support for these things.</p>",
        "id": 501323768,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740277584
    },
    {
        "content": "<p>(Of course, the reflection mechanims would still be a great thing to have in various other places!)</p>",
        "id": 501323919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740277718
    },
    {
        "content": "<p>My personal experience was that I did not have a good understanding of the decidable dance that came with Finset, and when working with an undergraduate (who also didn't understand it) on a project which involved a lot of counting of finite groups I got so frustrated that I argued that we should just introduce a noncomputable classical concept of size which didn't need decidability at all and just took an arbitrary set and returned its size if it was finite and 0 otherwise (which worked particularly well for subgroups because the empty set is not a group so 0 always meant \"infinite\"). So we did this and of course then had to make an API for it, and in making the API we just reduced all the theorems to Finset.card so by the end of it, ironically, I had developed a good understanding of the decidable dance so I stopped complaining about it and from then on if a maths student got confused about decidability I would just curse constructivism and then explain to them how to make their code work by adding decidability assumptions in exactly the right places. The upshot was an instance of the xkcd standards cartoon where I learnt useful stuff but all that happened to mathlib was that it got a new way of expressing the size of a finite set, which is in some sense bad.</p>",
        "id": 501352904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1740300802
    }
]