[
    {
        "content": "<p>A few weeks ago I implemented Project Euler Problem 10 in lean and started to proof correctness of the solution. A few days ago I finally completed the proof of correctness.</p>\n<p>The problem statement is to calculate<br>\ndef S (n: Nat) := ∑ p ∈ Nat.primesBelow n, p<br>\n--#eval S 2000000 -- Does not work</p>\n<p>This does not work out of the box (segfault for 500,000 &lt; n), so I wrote a more optimized solution. It constructs an Array with arr[i] = i.minFac using a modified version of the Sieve of Eratosthenes and uses this array to calculate S. The modified function works on my machine for n &lt;= 1,350,000,000</p>\n<p>For anyone interested, the code and proof is here:<br>\n<a href=\"https://github.com/ssar/euler_lean/blob/main/Problems/P10.lean\">https://github.com/ssar/euler_lean/blob/main/Problems/P10.lean</a></p>\n<p>A few things I learned along the way</p>\n<ul>\n<li>The lean community is super helpful. Thanks!</li>\n<li>While the implementation of the algorithm is easy, proving correctness was challenging for me. There were many small hiccups along the way where I spent time on proving things that seem trivial.</li>\n<li>I tried to separate the algorithm implementation from the proof of correctness. But this doesn't fully work as array access and termination of recursive functions require mixing some proofs into the program logic.</li>\n<li>I was expecting that doing work with lean would enable me to \"read\" lean proofs. Unfortunately I can't even read my own proof. I guess this is also partially doe to my proof being badly structured.</li>\n<li>Most importantly for me as this is purely a hobby project to learn about programming and proving in Lean: I had fun doing this :)</li>\n</ul>\n<p>I'll probably do some followup project, but I'm currently undecided what exactly. Candidates are:</p>\n<ol>\n<li>Improve tactics used for array access to achieve better separation of code and proof. get_elem_tactic_trivial seems easy to extend and I already had some success creating a custom extension that just does simp[*]; omega</li>\n<li>Implement some more complex algorithm</li>\n<li>Try to make some statement about runtime behavior of the program. I found some previous discussion about complexity theory here and it seems there is no framework available yet. A problem might be that the definitions in lean don't match what gets executed. But it should be possible to define a simplified framework that just allows making statements about upper bounds by defining axioms for basic operations. Maybe even a statement about the number of array accesses would be good enough in this case.</li>\n<li>Try to make some statement about memory consumption of the program.</li>\n</ol>",
        "id": 502904337,
        "sender_full_name": "ssar",
        "timestamp": 1740952757
    },
    {
        "content": "<p>By \"reading\" lean proofs, do you mean just the text or stepping through them in the editor while looking at the infoview?</p>",
        "id": 502905229,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740953408
    },
    {
        "content": "<p>Because I don't know anyone who can do the former with proofs of any complexity :)</p>",
        "id": 502905279,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1740953461
    },
    {
        "content": "<p>Thanks for sharing! Looks like the proof of correctness is 5x the length of the algorithm. I am new to verified algorithms, is that what is roughly expected/normal for basic algorithm verification?</p>\n<p>\"3. Try to make some statement about runtime behavior of the program.\" - this sound very interesting</p>",
        "id": 502907991,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1740955597
    },
    {
        "content": "<p>Statements about runtime behavior are not preserved by equality (two functions that compute the same thing are equal even if one is much slower). So to make statements about runtime, the objects being reasoned about cannot be vanilla Lean definitions but must be defined in terms of a computational model. People are doing this but it seems like a huge departure from the \"standard\" way Lean definitions and proofs work. So it's not necessarily something that can be just done by expanding on an existing Lean project.</p>",
        "id": 502908670,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1740956131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/Finished.20my.20first.20lean.20mini-project/near/502905229\">said</a>:</p>\n<blockquote>\n<p>By \"reading\" lean proofs, do you mean just the text or stepping through them in the editor while looking at the infoview?</p>\n</blockquote>\n<p>Yeah, seems following proof from just the text is close to impossible (e.g. following what new subgoals get introduced by a tactic like rw). Good to know that's not just me. I guess there should be proof styles that are easier to follow. <br>\nEven with infoview is still quite hard to understand how I ended with in the current goals.</p>",
        "id": 503119022,
        "sender_full_name": "ssar",
        "timestamp": 1741034299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"638715\">Adomas Baliuka</span> <a href=\"#narrow/channel/113489-new-members/topic/Finished.20my.20first.20lean.20mini-project/near/502908670\">said</a>:</p>\n<blockquote>\n<p>Statements about runtime behavior are not preserved by equality (two functions that compute the same thing are equal even if one is much slower). So to make statements about runtime, the objects being reasoned about cannot be vanilla Lean definitions but must be defined in terms of a computational model. People are doing this but it seems like a huge departure from the \"standard\" way Lean definitions and proofs work. So it's not necessarily something that can be just done by expanding on an existing Lean project.</p>\n</blockquote>\n<p>Ah, right. I proved what the content of my arrays is at every point of the algorithm, so not even a statement about number of array accesses would work.<br>\nReading <a href=\"https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#function-extensionality\">https://lean-lang.org/theorem_proving_in_lean4/axioms_and_computation.html#function-extensionality</a><br>\nI wonder if It would still be possible to still make statements about lean programs if we take care to not use funext (i.e. the Quot.sound axiom)?</p>",
        "id": 503123211,
        "sender_full_name": "ssar",
        "timestamp": 1741035897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/Finished.20my.20first.20lean.20mini-project/near/502907991\">said</a>:</p>\n<blockquote>\n<p>Thanks for sharing! Looks like the proof of correctness is 5x the length of the algorithm. I am new to verified algorithms, is that what is roughly expected/normal for basic algorithm verification?</p>\n<p>\"3. Try to make some statement about runtime behavior of the program.\" - this sound very interesting</p>\n</blockquote>\n<p>I'm also new to this, so no idea what's expected. It's sure possible to shorten my proof by a lot.  The amount of time I invested on the proof of correctness was definitely more than 10x of the time I used for implementing the algorithm.</p>",
        "id": 503123878,
        "sender_full_name": "ssar",
        "timestamp": 1741036192
    }
]