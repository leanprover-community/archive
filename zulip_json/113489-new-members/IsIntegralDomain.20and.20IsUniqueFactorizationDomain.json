[
    {
        "content": "<p>Would the following be the correct and idiomatic definitions for <code>IsIntegralDomain</code> and <code>IsUniqueFactorizationDomain</code>?</p>\n<p>What can be improved?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsIntegralDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">IsUniqueFactorizationDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CancelCommMonoidWithZero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">UniqueFactorizationMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegralDomain</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">IsIntegralDomain</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsUniqueFactorizationDomain</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">IsUniqueFactorizationDomain</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n<span class=\"w\">  </span><span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 468467491,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725738858
    },
    {
        "content": "<p>No, I'm pretty sure combining <code>[CommRing α] [CancelCommMonoidWithZero α]</code> will cause trouble</p>",
        "id": 468470533,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1725740672
    },
    {
        "content": "<p>Maybe <code>def IsUniqueFactorizationDomain (α : Type) [CommRing α] [NoZeroDivisors α]</code></p>",
        "id": 468470568,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1725740727
    },
    {
        "content": "<p>New try:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- An integral domain is a commutative ring without zero divisors.</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">IntegralDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"c1\">-- ℤ is an integral domain.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IntegralDomain</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n\n<span class=\"c1\">-- A unique factorization domain is an integral domain where every element can be written as a product of prime elements.</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">UniqueFactorizationDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">UniqueFactorizationMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"c1\">-- ℤ is a unique factorization domain.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UniqueFactorizationDomain</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">constructor</span>\n</code></pre></div>\n<p>Is it correct, and idiomatic?</p>",
        "id": 468482805,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725749458
    },
    {
        "content": "<p>Can be contrasted with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsAlgClosed</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Field</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">K</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">K</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">EuclideanDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsPrincipalIdealRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">UniqueFactorizationMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CancelCommMonoidWithZero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">IsCancelMulZero</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semiring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">AddGroupWithOne</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"bp\">…</span>\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">NonUnitalRing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">NonUnitalNonAssocRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">NonUnitalSemiring</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"bp\">…</span>\n</code></pre></div>",
        "id": 468484176,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725750404
    },
    {
        "content": "<p>Upon further reflection, I think my inquiry is twofold:</p>\n<ol>\n<li>\n<p>If <code>IntegralDomain</code> were defined in Mathlib, what would its structure and implementation be? For example, would it take the form: <code>class IntegralDomain (α : Type) [CommRing α] [IsDomain α]</code>?</p>\n</li>\n<li>\n<p>Should such a structure exist in Mathlib (as a separate <code>class</code>), and if so, what are the reasons for or against its inclusion?</p>\n</li>\n</ol>",
        "id": 468917072,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725916216
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">IntegralDomain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsDomain</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>\n<p>We don't really need it, because instead of saying <code>[IntegralDomain R]</code> we can just say <code>[CommRing R] [IsDomain R]</code>, so in some sense it's just clogging the typeclass system up and the system is already extremely large and unwieldy. An argument for it is better readability for mathematicians, but there might be other ways to achieve this.</p>",
        "id": 468919323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725917034
    },
    {
        "content": "<p>Ah, thanks! I understand.</p>\n<p>When you mention clogging up the typeclass system, are you referring strictly to performance issues, where having too many type classes slows down processing? Or are you also talking about usability concerns, where an excess of type classes makes the code more difficult to handle for Mathlib users or developers?</p>\n<p>A naïve undergraduate (like myself) just starting with Lean and Mathlib would likely assume the following naming conventions and use <code>grep</code> accordingly:</p>\n<table>\n<thead>\n<tr>\n<th>Name in undergraduate literature</th>\n<th>Expected name in Mathlib</th>\n<th>Actual name in Mathlib (IIUC)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>algebraically closed fields</td>\n<td><code>AlgebraicallyClosedField</code></td>\n<td><code>IsAlgClosed</code></td>\n</tr>\n<tr>\n<td>fields</td>\n<td><code>Field</code></td>\n<td><code>Field</code></td>\n</tr>\n<tr>\n<td>Euclidean domains</td>\n<td><code>EuclideanDomain</code></td>\n<td><code>EuclideanDomain</code></td>\n</tr>\n<tr>\n<td>principal ideal domains</td>\n<td><code>PrincipalIdealDomain</code></td>\n<td><code>IsDomain</code> + <code>IsPrincipalIdealRing</code></td>\n</tr>\n<tr>\n<td>unique factorization domains</td>\n<td><code>UniqueFactorizationDomain</code></td>\n<td><code>IsDomain</code> + <code>CommRing</code> + <code>UniqueFactorizationMonoid</code></td>\n</tr>\n<tr>\n<td>GCD domains</td>\n<td><code>GCDDomain</code></td>\n<td><code>IsDomain</code> + <code>CommRing</code> + <code>GCDMonoid</code></td>\n</tr>\n<tr>\n<td>integrally closed domains</td>\n<td><code>IntegrallyClosedDomain</code></td>\n<td><code>IsDomain</code> + <code>IsIntegrallyClosed</code></td>\n</tr>\n<tr>\n<td>integral domains</td>\n<td><code>IntegralDomain</code></td>\n<td><code>IsDomain</code> + <code>CommRing</code></td>\n</tr>\n<tr>\n<td>commutative rings</td>\n<td><code>CommutativeRing</code></td>\n<td><code>CommRing</code></td>\n</tr>\n<tr>\n<td>rings</td>\n<td><code>Ring</code></td>\n<td><code>Ring</code></td>\n</tr>\n<tr>\n<td>rngs, non-unital rings</td>\n<td><code>NonUnitalRing</code></td>\n<td><code>NonUnitalRing</code></td>\n</tr>\n</tbody>\n</table>\n<p>Fortunately, most of the entries in the hierarchy align with the expectations of a naïve beginner, but some do not—specifically the non-Euclidean integral domains. (To be completely honest, I'm not entirely sure I got the Mathlib column for all the non-Euclidean integral domains correct above... Please let me know if any of them are wrong!)</p>\n<p>Does Lean support some kind of \"type aliases\" that would allow for aliases like the following without affecting performance?</p>\n<ul>\n<li><code>[PrincipalIdealDomain P]</code> as an alias for <code>[IsDomain P] [IsPrincipalIdealRing P]</code></li>\n<li><code>[UniqueFactorizationDomain P]</code> as an alias for <code>[IsDomain P] [CommRing P] [UniqueFactorizationMonoid P]</code></li>\n<li><code>[GCDDomain P]</code> as an alias for <code>[IsDomain P] [CommRing P] [GCDMonoid P]</code></li>\n<li><code>[IntegrallyClosedDomain P]</code> as an alias for <code>[IsDomain P] [IsIntegrallyClosed P]</code></li>\n<li><code>[IntegralDomain P]</code> as an alias for <code>[IsDomain P] [CommRing P]</code></li>\n</ul>\n<p>Another question out of curiosity: why is it <code>class IsAlgClosed</code> instead of the more <code>grep</code>-friendly and predictable <code>class AlgebraicallyClosedField</code>?</p>",
        "id": 469172196,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1725991275
    }
]