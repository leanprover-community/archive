[
    {
        "content": "<p>I've reached Chapter 4 of Heather Macbeth's Mechanics of Proof and am finding new syntax being introduced without explanation.</p>\n<p>Here is one I can't understand:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>The accompanying text says:</p>\n<blockquote>\n<p>Let  n be an integer and suppose that every integer m  between 1 and 5 is a factor of n. Show that 15 is a factor of n.</p>\n</blockquote>\n<p>I would have expected the hypothesis to be a <strong>conjunction</strong>, not a chained implication.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n</code></pre></div>\n<p>So what does <code> P → Q → R</code> mean?</p>",
        "id": 479972642,
        "sender_full_name": "rzeta0",
        "timestamp": 1730416718
    },
    {
        "content": "<p><code>∀ m, 1 ≤ m ∧ m ≤ 5 ∧ m ∣ n</code>  says \"every number <strong>is</strong> between 1 and 5 <strong>and</strong> divides <code>n</code>\" not, \"every number <strong>that is</strong> between 1 and 5 divides <code>n</code>\"</p>",
        "id": 479972844,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730416862
    },
    {
        "content": "<p>You could write <code>∀ m, 1 ≤ m ∧ m ≤ 5 → m ∣ n</code>  instead, which would have the correct meaning (see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=and_imp#doc\">docs#and_imp</a> for the equivalence)</p>",
        "id": 479973001,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730416949
    },
    {
        "content": "<p>\"<code>P → Q → R</code>\" means \"if P and if Q then R\". You can read each successive arrow as \"and if\"</p>",
        "id": 479973004,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730416952
    },
    {
        "content": "<p>It is logically equivalent to \"<code>P /\\ Q -&gt; R</code>\", but it is more convenient for lemmas. The first lets you pass in hypotheses for P and Q one at a time. The conjunctive version wants the hypotheses at once (and assembled with And.intro)</p>",
        "id": 479973107,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730417036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/strange.20notation.3A.20P.20.E2.86.92.20Q.20.E2.86.92.20R/near/479972844\">said</a>:</p>\n<blockquote>\n<p><code>∀ m, 1 ≤ m ∧ m ≤ 5 ∧ m ∣ n</code>  says \"every number <strong>is</strong> between 1 and 5 <strong>and</strong> divides <code>n</code>\" not, \"every number <strong>that is</strong> between 1 and 5 divides <code>n</code>\"</p>\n</blockquote>\n<p>This was the conceptual root of my misunderstanding. Thanks.</p>\n<p>My reading of <code> ∀ m, 1 ≤ m → m ≤ 5 → m ∣ n</code> based on my possibly mistaken understanding of <strong>implication</strong> is:</p>\n<ul>\n<li>for all <code>m</code> the following is true</li>\n<li>if <code>1 ≤ m</code> true then <code>m ≤ 5</code> true</li>\n<li>if <code>m ≤ 5</code> true then <code>m ∣ n</code> true</li>\n</ul>\n<p>but this doesn't match \"every number <strong>that is</strong> between 1 and 5 divides <code>n</code>\"</p>",
        "id": 479973544,
        "sender_full_name": "rzeta0",
        "timestamp": 1730417320
    },
    {
        "content": "<p>I think what you're missing is that <code>∀ m, 1 ≤ m → m ≤ 5 → m ∣ n</code> means <code>∀ m, (1 ≤ m → (m ≤ 5 → m ∣ n))</code></p>",
        "id": 479973622,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730417393
    },
    {
        "content": "<p>Lean does not have python-style operation chaining</p>",
        "id": 479973729,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730417441
    },
    {
        "content": "<p>thanks Eric again for clarifying</p>\n<p>so is that chain always equivalent to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and not </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∣</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is that just the way it is, or is there a deeper logic or rationale I'm missing? It just seems arbitrary.</p>",
        "id": 479973937,
        "sender_full_name": "rzeta0",
        "timestamp": 1730417585
    },
    {
        "content": "<p>The first one is the common case, and also if <code>h : P -&gt; Q -&gt; R</code>, then given <code>x : P</code> and <code>y : Q</code>, you can write <code>h x y</code> to get a proof of <code>R</code>. It lines up nicely with application notation.</p>",
        "id": 479974043,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730417670
    },
    {
        "content": "<p>Similarly, <code>h x y</code> is <code>(h x) y</code> and not <code>h (x y)</code>. This is interestingly backwards from <code>-&gt;</code> associativity, but that's how it needs to work so that no parentheses are needed in the common case.</p>",
        "id": 479974119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730417748
    },
    {
        "content": "<blockquote>\n<p>It just seems arbitrary.</p>\n</blockquote>\n<p>While not the case here for the reasons Kyle explains, for things like <code>a + b + c</code> meaning <code>(a + b) + c</code> and not <code>a + (b + c)</code>, this choice basically <em>is</em> arbitrary; but the choice still has to be made, because forcing people to always write the <code>()</code>s explicitly would be very annoying.</p>",
        "id": 479974339,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1730417915
    }
]