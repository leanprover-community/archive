[
    {
        "content": "<p>Hi all, I'm new-ish to Lean, and I'm looking to use it as a general-purpose programming language where I can write some code and later prove correctness properties about it.</p>",
        "id": 525556170,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750782765
    },
    {
        "content": "<p>One thing I've been struggling with is how to program with sets.  (Edit: by this of course I mean finite sets, such as Python's frozenset or Haskell's Data.Set.)  I have some inductive type T (e.g. a basic algebraic datatype), and I can derive BEq and Ord on T, and then I can make <code>TreeSet T</code>.  But TreeSet doesn't expose some pretty basic operations such as intersection, and also doesn't have particularly many lemmas about it, especially compared to <code>Finset T</code>.  But <code>Finset T</code> depends on having a LinearOrder.  The automatically derived Ord instance ought to be a LinearOrder, but as far as I can tell the compiler won't derive LinearOrder for that type and it's a pain to prove for an inductive type with a few constructors.</p>",
        "id": 525556658,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750782952
    },
    {
        "content": "<p>Also it seems to me that <code>Finset</code>, since it's based on unordered lists, will be quite slow.  Eg it ought to take quadratic time for union and intersection, unless I'm missing something</p>",
        "id": 525556765,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750782994
    },
    {
        "content": "<p>Is there a set type that makes this easy, where I get the usual set operations like \\cap, \\cup, \\in etc, and can prove theorems about them, without having to write a lot of boilerplate?</p>",
        "id": 525557003,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750783098
    },
    {
        "content": "<p>The only other \"set\" I can remember off the top of my head is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashSet#doc\">docs#Std.HashSet</a></p>",
        "id": 525558234,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1750783554
    },
    {
        "content": "<p><code>Finset</code> doesn't depend on linear orders, it only needs equality on the type</p>",
        "id": 525560707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750784443
    },
    {
        "content": "<p>If you want better performance you need either a linear order (give or take) or a hash function on the key type</p>",
        "id": 525560837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750784490
    },
    {
        "content": "<p>You can use <code>RBSet</code> as an alternative to <code>TreeSet</code>, it has more lemmas</p>",
        "id": 525560956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1750784533
    },
    {
        "content": "<p>Yeah, RBTree could be another option, seems pretty similar to TreeSet.  Finset doesn't need linear orders by itself, but to get the answer out as a list, without running into <code>noncomputable</code>, you have to sort it which requires linear orders unless I'm missing something.</p>",
        "id": 525562028,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750784936
    },
    {
        "content": "<p>Out of curiosity, none of these \"practical\" sets implement <code>Inter</code> or have named intersection  or disjointness functions, do they?  Only <code>Finset</code> does?</p>",
        "id": 525562550,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750785146
    },
    {
        "content": "<p>Also is there a way to derive a <code>LinearOrder</code> for inductive types?  The derived <code>Ord</code> ought to induce a <code>LinearOrder</code> (if this is true for all of the fields, but it's true for common ones like Nat and Bool and String) and proving this should be more or less mechanical but also kind of a pain to do by hand</p>",
        "id": 525562822,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750785277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"932057\">@Mike Hamburg</span> I mean, you can't have everything, lol</p>",
        "id": 525563114,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750785416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"932057\">Mike Hamburg</span> <a href=\"#narrow/channel/113489-new-members/topic/Programming.20with.20sets/near/525562822\">schrieb</a>:</p>\n<blockquote>\n<p>derive a <code>LinearOrder</code> for inductive types</p>\n</blockquote>\n<p>That would need <code>deriving Std.TransOrd</code> and <code>deriving Std.LawfulEqOrd</code> which doesn't exist yet and also it's very weird to induce a linear order on a type that is not like, linear</p>",
        "id": 525563186,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750785445
    },
    {
        "content": "<p>Intersection would be <code>s1.filter s2.contains</code> btw and I would use <code>Std.ExtHashSet</code> instead <code>Std.TreeSet</code> for having <code>filter</code> lemmas and extensionality</p>",
        "id": 525563346,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750785506
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inter_comm</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulBEq</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s₁</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">ExtHashSet</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">s₁</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s₂</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">s₁</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>although we don't specifically have intersection on these as a function or operator</p>",
        "id": 525563715,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750785668
    },
    {
        "content": "<p>ah ok, that's not too  bad for the inter_comm lemma.</p>\n<p>I'm not sure what you mean about inducing a linear order on a type that's not linear?</p>",
        "id": 525565021,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750786257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"932057\">@Mike Hamburg</span> it might be worth asking this, what are you planning to do with sets?</p>",
        "id": 525568859,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750787955
    },
    {
        "content": "<p>I mean you usually have a linear order when <code>≤</code> \"makes sense\", e.g. for natural numbers, rationals, reals. Notably <code>α × β</code> has an <code>≤</code> which doesn't form a linear order (<code>x.1 ≤ y.1 ∧ x.2 ≤ y.2</code>). For the purposes described you would certainly use <code>Ord</code> instead which has a lot of lemmas under e.g. <code>Std.TransCmp</code> but no deriving handler currently (but I mean <code>LinearOrder</code> is not different in that regard).</p>",
        "id": 525572650,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750789382
    },
    {
        "content": "<p>Oh hey Kenny!  Long time no see, unless you're a different Kenny Lau.  Basically code generation, which uses sets for various analysis purposes.  The code generation doesn't have to be particularly fast, but being gratuitously quadratic would be a bummer</p>",
        "id": 525591366,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750797433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> I see.  I was thinking of using a lexicographic order for the types in question, as Ord does.  I guess that's why Lean doesn't auto-derive Ord for product types unless you use Lex... I was wondering why that would be the case</p>",
        "id": 525591667,
        "sender_full_name": "Mike Hamburg",
        "timestamp": 1750797561
    },
    {
        "content": "<p>You can find it under the name <code>lexOrd</code>. Not sure why it's not an instance but if you need it:<br>\n<code>attribute [instance] lexOrd</code></p>",
        "id": 525681954,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750847510
    },
    {
        "content": "<p>My guess is that it's not an instance because making it an instance would be tantamount to saying \"this is the only order you are allowed on a product\" which is certainly not true in general.</p>",
        "id": 525694504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1750852126
    },
    {
        "content": "<p>Products already have an order instance (the product order), it's just not a linear order for most of the time</p>",
        "id": 525697319,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750852954
    },
    {
        "content": "<p>Yeah right but there is no reason to make <code>Ord</code> compatible with <code>LE</code>. I'd say <code>Ord</code> is the programming order and <code>LE</code> is the mathematical order.</p>",
        "id": 525697611,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750853055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113489-new-members/topic/Programming.20with.20sets/near/525681954\">said</a>:</p>\n<blockquote>\n<p>You can find it under the name <code>lexOrd</code>. Not sure why it's not an instance but if you need it:<br>\n<code>attribute [instance] lexOrd</code></p>\n</blockquote>\n<p>Since it would conflict with the usual order instance. If you want it as an instance there is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Prod.Lex.instOrdLexProd#doc\">docs#Prod.Lex.instOrdLexProd</a></p>",
        "id": 525697639,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750853063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113489-new-members/topic/Programming.20with.20sets/near/525697611\">said</a>:</p>\n<blockquote>\n<p>Yeah right but there is no reason to make <code>Ord</code> compatible with <code>LE</code>. I'd say <code>Ord</code> is the programming order and <code>LE</code> is the mathematical order.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrder#doc\">docs#LinearOrder</a> bundles a compatible <code>Ord</code> instance</p>",
        "id": 525697788,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750853114
    },
    {
        "content": "<p>Yeah but the usual product order is not a linear order so there are no instance diamonds to worry about</p>",
        "id": 525697914,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750853159
    },
    {
        "content": "<p>I understand why you'd want <code>LE</code> and <code>LT</code> to be lexicograhical only on <code>Lex</code> but <code>Ord</code>?</p>",
        "id": 525698739,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750853470
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/113489-new-members/topic/Programming.20with.20sets/near/525697914\">said</a>:</p>\n<blockquote>\n<p>Yeah but the usual product order is not a linear order so there are no instance diamonds to worry about</p>\n</blockquote>\n<p>If either of the components is a subsingleton you get a linear order</p>",
        "id": 525698939,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750853562
    },
    {
        "content": "<p>Then it's equivalent to the lexicograhical order though..?</p>",
        "id": 525699193,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750853669
    },
    {
        "content": "<p>Also, we don't have that as an instance, do we?</p>",
        "id": 525699323,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1750853718
    }
]