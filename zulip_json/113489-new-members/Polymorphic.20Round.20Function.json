[
    {
        "content": "<p>I understand the <code>round</code> function in mathlib requires a LinearOrderedField to work, but is there a way to make it polymorphic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HSub</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">round</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>Specifically, is there a way to make this evaluate using Float.round when alpha is a Float, but still keep the flexibility of polymorphism?</p>",
        "id": 508986238,
        "sender_full_name": "Colin Jones ⚛️",
        "timestamp": 1743306370
    },
    {
        "content": "<p>Hi, I not an expert in this, but, I wanted to see where things start breaking down. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FloorRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">round</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddMonoid</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">add_assoc</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- IEEE 754 floats are not associative</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- the CS stack exchange has a workable example of non-associativity</span>\n<span class=\"c1\">-- https://cs.stackexchange.com/a/169153</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"n\">e9</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e9</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"n\">e</span><span class=\"bp\">-</span><span class=\"mi\">9</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\">  </span><span class=\"c1\">-- result: 1e-09, Lean doesn't show enough precision to see</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- result: 0.0</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- false</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">)</span><span class=\"w\">   </span><span class=\"c1\">-- failed to synthesize Decidable</span>\n</code></pre></div>\n<p>Here's a nice paragraph from the <a href=\"https://lean-lang.org/doc/reference/latest/Basic-Types/Floating-Point-Numbers/\">Lean language reference</a></p>\n<blockquote>\n<p>Lean exposes the underlying platform's floating-point values for use in<br>\n programming, but they are not encoded in Lean's logic. They are represented<br>\n by an opaque type. This means that the kernel is not capable of computing<br>\n with or reasoning about floating-point values without additional axioms. A<br>\n consequence of this is that equality of floating-point numbers is not<br>\n decidable...</p>\n</blockquote>\n<p>I've seen other discussion here on zulip regarding algebra and proofs on IEEE Floats, and they were not heartening.  </p>\n<p>However, I think it would be really cool to see what people <em>could</em> prove about them. For instance: bounds on error accumulation with sequences of machine instructions.  I would imagine that capability would be appreciated in robotics, aerospace, missile defense, machine learning, etc.  So, maybe there's already work done? As I said, I'm not an expert but am also interested in the answer to your question.</p>",
        "id": 509046509,
        "sender_full_name": "Derek Rhodes",
        "timestamp": 1743354042
    },
    {
        "content": "<p>Regarding <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.floor#doc\">docs#Int.floor</a>` etc, I think it would be reasonable to split the data-only parts of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FloorRing#doc\">docs#FloorRing</a> into a new base typeclass</p>",
        "id": 509052705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1743358958
    },
    {
        "content": "<p>Figured it out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">HasRound</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pround</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasRound</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pround</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"bp\">.</span><span class=\"n\">round</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrderedField</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FloorRing</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasRound</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">pround</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">round</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I didn't want to prove anything on floats; I know they are wacky. I just wanted a function that could do both round functions</p>",
        "id": 509347680,
        "sender_full_name": "Colin Jones ⚛️",
        "timestamp": 1743477122
    }
]