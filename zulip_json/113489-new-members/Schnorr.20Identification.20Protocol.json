[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n\n<p>Hi. I’m new to lean and am having some trouble with my code. I want to write proofs of completeness and soundness for the Schnorr identification protocol. But first I obviously need to implement the protocol, which is where I’m struggling. The Schnorr protocol is a sigma protocol, wherein a prover wants to prove to a verifier that they have knowledge of a witness w, without revealing the witness. g is the generator of a group G, h = g ^ w.   The protocol goes like this:</p>\n<p>Prover: picks a random number r. Sends a = g ^ r to verifier.  (r is not to be revealed to verifier)</p>\n<p>Verifier:  picks a random number e. Sends e to prover.</p>\n<p>Prover: Computes z = e * w + r. Sends z to verifier.</p>\n<p>Verifier: Checks if g ^ z = h ^ e * a. If true, prover has successfully proven that they know a witness.</p>\n<p>(g, e, a, z,h) are publicly available, but not r and w. r and e has to be chosen randomly each time the protocol is run.</p>\n<p>I have two questions. Firstly, I am wondering about which type the different variables should be. And secondly why  I get this error message “failed to synthesize HPow G (ℕ → ℕ → ℕ → ℕ) ?m.8259  Additional diagnostic information may be available using the <code>set_option diagnostics true</code> command.” in the line def generator_z := x where z := response; x := g ^ z.</p>\n<p>I’m taking inspiration from this implementation of elgamal  (<a href=\"https://github.com/JoeyLupo/cryptolib/blob/main/README.md\">https://github.com/JoeyLupo/cryptolib/blob/main/README.md</a>  ).</p>\n<p>I have written this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Creating global variables.</span>\n<span class=\"cm\">-- G is the group that the generator g generates over.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)[</span><span class=\"n\">inst_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommGroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DecidableEq</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g_gen_G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"bp\">.</span><span class=\"n\">zpowers</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">inst_5</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">](</span><span class=\"n\">G_card_q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span>\n\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">Creating a namespace prover.</span>\n\n<span class=\"cm\">The variables are unavailable outside the namespace, but the functions are accessable.</span>\n<span class=\"cm\">-- w is the witness,</span>\n<span class=\"cm\">-- r is  a random number</span>\n<span class=\"cm\">-- h is g ^ w</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">prover</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">commitment</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">response_gen</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"c1\">-- this works, but generator_z does not</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">return_h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">w</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">prover</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">prover</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">generator_z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"c1\">-- this is where I get an error! Specifically the error is under g ^ z</span>\n\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">failed to synthesize</span>\n\n<span class=\"cm\">  HPow G (ℕ → ℕ → ℕ → ℕ) ?m.8259</span>\n\n<span class=\"cm\">Additional diagnostic information may be available using the `set_option diagnostics true` command.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">´´´</span>\n</code></pre></div>",
        "id": 530167083,
        "sender_full_name": "minapw",
        "timestamp": 1753196811
    },
    {
        "content": "<p>response is a function that takes three arguments e, w, r. Hence z is also a function with three arguments. There is no instance defined that has a function in the exponent. You need to pass values for e, w and r to the definition of generator_z and into z.</p>",
        "id": 530280741,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753256996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"619540\">@Johannes Tantow</span>   that makes sense, thanks. I originally wanted w and r to be unobtainable outside of the namespace prover, is it possible to do this and also get the code to parse?</p>",
        "id": 530344261,
        "sender_full_name": "minapw",
        "timestamp": 1753277227
    },
    {
        "content": "<p>Why do you want them to be unobtainable in the first place</p>",
        "id": 530380952,
        "sender_full_name": "(deleted)",
        "timestamp": 1753286093
    },
    {
        "content": "<p>I feel this could indicate a misunderstanding of how proof assistants can be used to validate security properties</p>",
        "id": 530381067,
        "sender_full_name": "(deleted)",
        "timestamp": 1753286116
    },
    {
        "content": "<p>Its not really obvious to me what you are trying to do. For now r and w are just arbitrary numbers. You can add functions that calculate r and w from some values and hide this via private.</p>",
        "id": 530426656,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753302077
    },
    {
        "content": "<p>r is a random number, and is supposed to be secret. Which is why I wanted verifier to only have access to g ^ r and not r itself. w is also secret, which is why I wanted r and w to only be available to the prover. That is what I try to achieve with the namespace prover. I wanted to make the response function so that the z is calculated using the w and r variables that I have defined in the namespace. But I'm not sure if that's what I'm actually doing ..</p>",
        "id": 530506333,
        "sender_full_name": "minapw",
        "timestamp": 1753346723
    },
    {
        "content": "<p>but you aren't inputting the real values of r and w into lean right? you're just verifying the algorithm works, so there's no need to hide r and w</p>",
        "id": 530506751,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753346872
    },
    {
        "content": "<p>But then the function of the verifier could in principle only get a natural number and work with it. Then you could later prove that if this natural number has the form g^(z w r), then the algorithm/protocol is correct.</p>",
        "id": 530507424,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1753347081
    },
    {
        "content": "<p>You may be interested in <a href=\"https://github.com/Verified-zkEVM/ArkLib\">ArkLib</a>, a library for representing cryptographic proof systems &amp; proving their security properties</p>\n<p>As of right now, it is possible to use ArkLib for implementing Schnorr as a 3-message interactive argument, and prove completeness. Soundness is more tricky and we haven't defined rewinding extraction yet</p>",
        "id": 530650581,
        "sender_full_name": "Quang Dao",
        "timestamp": 1753392812
    }
]