[
    {
        "content": "<p>Hi there!  I'm exploring basic program verification in Lean, and I'm running into an issue related to reflection style proofs for basic functions.  Consider the following code snippet, which defines structures for representing snapshots of the price of a stock ticker, and then defines some methods for doing merge sort on lists of these structures</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Snapshot</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ticker</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"n\">time</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Snapshot</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">SnapshotsForTicker</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ticker</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"n\">snapshots</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Functions to merge sort a list of TickerSnapshots</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">l1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">      </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">      </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">bs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mergeSortList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Proofs/Examples</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"random string\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- DOESN'T WORK</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"random string\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- works!</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- DOESN'T WORK</span>\n</code></pre></div>\n<p>The lean error messages for the first and third example aren't super enlightening, but here you are for reference.</p>\n<p>EXAMPLE 1 ERROR MESSAGE</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">mismatch</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>EXAMPLE 3 ERROR MESSAGE</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">Possible</span><span class=\"w\"> </span><span class=\"n\">reasons</span><span class=\"o\">:</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">reflexive</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">neither</span><span class=\"w\"> </span><span class=\"bp\">`=`</span><span class=\"w\"> </span><span class=\"n\">nor</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kd\">@[</span><span class=\"n\">refl</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n<span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">arguments</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">equal</span><span class=\"bp\">.</span>\n<span class=\"n\">Try</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">reflexivity</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">your</span><span class=\"w\"> </span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"n\">explicitly</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"ss\">`exact</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"bp\">_`</span><span class=\"w\"> </span><span class=\"n\">or</span>\n<span class=\"ss\">`exact</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Question:</p>\n<p>There are three example propositions at the bottom of the code snippet, two of which work, and one of which does not.  Basically, I don't understand why each of these does or does not work.  I'm especially confused by why the second example would work, but the third wouldn't.  Also, normally a basic <code>rfl</code> has worked for me in similar situations -- is there something special I need to do here to make it work?</p>\n<p>It would also be great to know how I can accomplish this <em>without tactics</em>.  Reason being, I'm trying to get a better intuitive understanding for how Lean works, and tactics hide a lot of complexity that I'd like to be aware of while learning.</p>\n<p>Thanks!</p>",
        "id": 459500288,
        "sender_full_name": "Daniel Geisz",
        "timestamp": 1723216074
    },
    {
        "content": "<p>Unfolding recursive functions can have challenges, in particular if they use well-founded recursion. Lean is good at working out how to do well-founded recursion on its own, so it's easy to not be aware when it does, except when things fail to unfold or if you happen to do <code>#print mergeLists</code> and see <code>@[irreducible]</code>.</p>\n<p>Lean makes functions relying on well-founded recursion be irreducible since reduction isn't reliable. However, if you think you know better you can temporarily \"unseal\" them and locally remove the <code>@[irreducible]</code> attribute like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"random string\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"c1\">-- works</span>\n</code></pre></div>",
        "id": 459504974,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723217038
    },
    {
        "content": "<p>So, the mystery, why does <code>by rfl</code> work?</p>\n<p>The <code>rfl</code> tactic will, when there are no local variables, use kernel isDefEq rather than elaborator isDefEq, and the kernel doesn't know it shouldn't unfold <code>@[irreducible]</code> definitions. There's a Lean issue suggesting removing this feature.</p>",
        "id": 459505648,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723217155
    },
    {
        "content": "<p>Ah, found it, it's an open PR: <a href=\"https://github.com/leanprover/lean4/pull/3772\">lean4#3772</a></p>",
        "id": 459506623,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723217394
    },
    {
        "content": "<p>Gotcha, this is super helpful -- thanks!  </p>\n<p>I was playing with reducibility settings, and realized I could accomplish the same thing by using the <code>@[reducible]</code> flag (ie, writing <code>@[reducible] def mergeLists ...</code>)</p>\n<p>I was a little surprised this worked, but perhaps it's because I don't properly understand these flags.  For example, why would lean decide a fn is <code>@[irreducible]</code> when it seems totally fine with the function being <code>@[reducible]</code>?  When would I get into trouble flagging something as <code>@[reducible]</code>?  (And wouldn't lean let me know in an error message?)</p>",
        "id": 459509210,
        "sender_full_name": "Daniel Geisz",
        "timestamp": 1723218151
    },
    {
        "content": "<p>If you do <code>@[reducible]</code> then it appears that this overrides the <code>@[irreducible]</code> that would be added by the well-founded recursion compiler (I'm not familiar with this part of the code).</p>\n<p>There aren't any error messages with <code>@[reducible]</code> and <code>@[irreducible]</code> since it's just a directive for how the Lean elaborator will unfold the definition when type checking. It would be like checking whether <code>private</code> makes sense — it's a design decision on your part.</p>\n<p>What you can run into with <code>@[reducible]</code> is things unexpectedly reducing. Usually we don't try to make everything be true by <code>rfl</code>, and instead we build up \"API lemmas\" and rewrite. It tends to be better not to rely on reductions.</p>",
        "id": 459512075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723219089
    },
    {
        "content": "<p>This <code>unseal</code> is meant for writing these API lemmas, when it might be necessary to dig into a definition.</p>",
        "id": 459512319,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723219186
    },
    {
        "content": "<p>Ah, gotcha gotcha.  Is the reason to not rely on reductions because it increases computational bloat, or is there some deeper mathematical reason?  And makes sense about the analogy between <code>@[reducible]</code> and <code>private</code></p>",
        "id": 459513022,
        "sender_full_name": "Daniel Geisz",
        "timestamp": 1723219387
    },
    {
        "content": "<p>Also, was playing around a bit more, and realized that the following example doesn't work</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>Maybe there's just a better way to deal with program unfolding? (Or maybe just unfolding <code>match</code> terms?)</p>",
        "id": 459513935,
        "sender_full_name": "Daniel Geisz",
        "timestamp": 1723219644
    },
    {
        "content": "<p>Reducing functions defined using well-founded recursion depends on reducing proofs, and this can get stuck, so Lean 4 decided to just make it always get stuck rather than randomly.</p>",
        "id": 459516426,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723220346
    },
    {
        "content": "<p>In your example, the definition does case analysis on <code>l2</code>, so it's not unfolding. It only works if <code>l2</code> is <code>[]</code> or <code>List.cons ..</code>. (The equations you give in a <code>match</code> don't always end up being the exact equations used by Lean.)</p>\n<p>This is how you'd do it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mergeLists</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 459516814,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723220448
    },
    {
        "content": "<p>With this, you can see that it gets stuck on <code>Acc.rec</code>, meaning it got stuck trying to reduce a proof of <code>Acc</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unseal</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ticker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TickerSnapshot</span><span class=\"w\"> </span><span class=\"n\">ticker</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">conv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">lhs</span>\n<span class=\"w\">      </span><span class=\"n\">whnf</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 459517744,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723220718
    },
    {
        "content": "<p>The <code>...</code> at the end of <code>Acc.rec</code> in the goal state after <code>whnf</code> is the proof. Hovering over it, you see</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">WellFounded</span><span class=\"bp\">.</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">mergeLists</span><span class=\"bp\">._</span><span class=\"n\">unary</span><span class=\"bp\">.</span><span class=\"n\">proof_1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"bp\">✝⟩</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Acc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">invImage</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">PSigma</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">instWellFoundedRelation</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"bp\">✝⟩</span>\n</code></pre></div>\n<p>I'm guessing it doesn't unfold because <code>mergeLists._unary.proof_1</code> is a theorem, and theorems are irreducible.</p>",
        "id": 459518188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1723220845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433922\">Daniel Geisz</span> has marked this topic as resolved.</p>",
        "id": 459542873,
        "sender_full_name": "Notification Bot",
        "timestamp": 1723227284
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>!</p>",
        "id": 459542952,
        "sender_full_name": "Daniel Geisz",
        "timestamp": 1723227300
    }
]