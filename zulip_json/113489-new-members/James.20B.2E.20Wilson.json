[
    {
        "content": "<p>I'm math prof at Colorado State University doing computational algebra, developing fast algorithms for GAP/MAGMA/SAGE and the like.  My objectives with LEAN are to see theorems about efficient computation.  The catch is that data types in computational algebra are skeletal and nothing like what you write down when doing a math proof.  My goal is to close the gap (pun sorry) between what we program about a group or algebra and what we prove about it.  Happy to learn about projects others have going on in the space and a preemptive thanks to all those who help us along the way.</p>",
        "id": 365556464,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686575190
    },
    {
        "content": "<p>The idea behind Lean 4 is that it is supposed to be able to unlock this kind of thing: efficient algorithms coupled with proofs that the algorithms are bug-free (the proofs are optional, but are needed if you need to use the algorithms in other proofs of course). However we're yet to really see it in action. Do you have a good toy example to set as a challenge/benchmark? I think that even primality testing would be a good example right now; Lean currently has nothing more exotic than \"check all the numbers <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><msqrt><mi>N</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\leq \\sqrt{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.1133em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9267em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-2.8867em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1133em;\"><span></span></span></span></span></span></span></span></span>\".</p>",
        "id": 365560258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1686575930
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> did port the prime certificates from Isabelle to Lean 3 a long time ago, but it was pretty slow.</p>",
        "id": 365560839,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1686576045
    },
    {
        "content": "<p>The <code>miller-rabin</code> branch has an implementation of Miller-Rabin in Lean 3, it would be interesting to port to Lean 4 to see how it would perform.</p>",
        "id": 365562813,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1686576398
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/miller-rabin\">branch#miller-rabin</a></p>",
        "id": 365613608,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686586430
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>,  the example that seems best is the \"Hello World\" of computational algebra (the one that I assign to my first year students) is known as Schreier-Sims. It has its own Wikipedia page <a href=\"https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm\">here</a> . It has a couple things going for it. </p>\n<ul>\n<li>relatively simple data types (arrays/linked list suffice, though a stack is even easier)</li>\n<li>easy algorithms (its a transitive closure with book-keeping)</li>\n<li>requires only basic knowledge of group actions.</li>\n</ul>",
        "id": 365614271,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686586571
    },
    {
        "content": "<p>When you get it to work then it has some fun pedigogical applications such as having the computer output instructions to solve a Rubix cube.  I saw the LEAN4 samples include a Rubix cube visualizer so it probably would tie together nicely as a demo.</p>",
        "id": 365614564,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686586637
    },
    {
        "content": "<p>The challenge isn't to prove Schreier-Sims is correct, that's relatively trivial.  The challenge is to write the program and annotate the calculations in such a way that your result proves its performance.</p>",
        "id": 365614871,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686586710
    },
    {
        "content": "<p>This would be somewhat direct if LEAN had linear types, but I asked <a href=\"https://proofassistants.stackexchange.com/questions/2236/linear-types-in-lean\">here</a> and got a no on that one.</p>",
        "id": 365615426,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686586845
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> observed there I could add linear types myself, but is a bit of a project.  I'll look at some alternatives and open to suggestions.  The key problem is that you can't stop a system from making a horrible implementation of a function, such as branched recursion, from the signature of the function alone.  So the trick the linear types and other structural types give you is a way to insist data is used the amount of times you want.</p>",
        "id": 365616484,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686587088
    },
    {
        "content": "<hr>\n<p>As a side remark as to motive: while mostly it makes me happy, the real goal is that so much scientific software gets written by post-docs and students who leave and all that knowledge gets lost.  Impossible to maintain, sometimes hard to trust.  Its usually not a problem of the theory, but it is a problem to know if the implementation matches the theory.</p>",
        "id": 365616952,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686587185
    },
    {
        "content": "<p>There has been a lot of discussion about proving the complexity of algorithms on <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/Computational.20Complexity.20Theory\">#general &gt; Computational Complexity Theory</a>.</p>",
        "id": 365624112,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686588869
    },
    {
        "content": "<p>It seems pretty hard to me (and I'm not sure how much linear types would help). Generally I would be more than happy with proven-correct algorithms, that are also efficient in practice!</p>",
        "id": 365630091,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686590246
    },
    {
        "content": "<p>For me it is the opposite.  Nearly all the algorithms to be applied have semi-obvious definitions. Just about anyone can make a program that returns the correct answer even if all it does is brute-force search.  The art for my camp is a program that does it with proven complexity.</p>",
        "id": 365633964,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686591247
    },
    {
        "content": "<p>But I am not seeking to convert anyone just highlighting my motives.  Thanks for the link.</p>",
        "id": 365635408,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686591624
    },
    {
        "content": "<p>Linear types don't solve all the questions but they do make it possible to prevent errant back-tracking and branch and bounds which are an all to common guess at how to make a practical algorithm and which can fool random testing but ultimately mathematics (and humans) tend to ask questions in the hard regime.</p>",
        "id": 365635810,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686591740
    },
    {
        "content": "<p>I would love to see this happen, despite the fact that it is far outside my wheelhouse.</p>",
        "id": 365636049,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686591805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"624152\">@James B. Wilson</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20B.2E.20Wilson/near/365633964\">said</a>:</p>\n<blockquote>\n<p>For me it is the opposite.  Nearly all the algorithms to be applied have semi-obvious definitions. Just about anyone can make a program that returns the correct answer even if all it does is brute-force search.  The art for my camp is a program that does it with proven complexity.</p>\n</blockquote>\n<p>I think you are undervaluing the space of <em>proved correct</em> and (presumed or proved on paper) <em>efficient</em> algorithms. Most CAS's are built out of these things and it is an area we would really like to break into with lean 4. Just because you haven't proved that the algorithm is efficient in the system doesn't mean that it isn't still useful, and it doesn't make it a brute force search.</p>",
        "id": 365650669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686595540
    },
    {
        "content": "<p>If you think \"the algorithms to be applied have semi-obvious definitions\" then great, do it! These algorithms do require some not so common combination of expertise so just because you think it's easy doesn't mean that anyone can do it. Having a \"CAS insider\" would be a great boon to getting this stuff done</p>",
        "id": 365651293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686595706
    },
    {
        "content": "<p>Plus, adding the \"proved correct\" part is already a nontrivial value-add over the original algorithm as it would be implemented in a CAS without proofs. It often changes the character of the work when you have to be proof producing, making different approaches more or less viable.</p>",
        "id": 365651786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686595853
    },
    {
        "content": "<p>By contrast, if you want to have <em>proved efficiency</em> then it completely changes the goal to something which is more useful for algorithms researchers and not so much for users. Of course it is still an interesting research area, but for me that sucks a lot of the fun out if it doesn't put a tactic in the users' hands at the end of the day.</p>",
        "id": 365652351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686595998
    },
    {
        "content": "<p>Apologies that my remark appeared to place value.  Lots of people working on lots of important aspects, I have respect for them each.  I only mean to say that many question have on the surface a straight-forward algorithm that would easily be proved correct.   For example, find a solution so some equation, a discrete log, a prime factor, if you find it by brute-force searching you can rather easily prove it is correct.  But you might in fact miss the point of the exercise.  But I fully agree for complicated algorithms a certificate comes with great care and analysis.</p>",
        "id": 365652647,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596082
    },
    {
        "content": "<p>Yes, hence the proviso \"efficient in practice\".</p>",
        "id": 365652919,
        "sender_full_name": "Reid Barton",
        "timestamp": 1686596157
    },
    {
        "content": "<p>Well as a long time CAS builder I find that phrase has a rather short shelf-life.</p>",
        "id": 365653088,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596191
    },
    {
        "content": "<p>Release a package and within a year you hear about cases that don't work \"in practice\"</p>",
        "id": 365653132,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596207
    },
    {
        "content": "<p>well a good way to build efficient in practice algorithms is to use algorithms that are efficient in theory</p>",
        "id": 365653226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596232
    },
    {
        "content": "<p>because those are somewhat correlated</p>",
        "id": 365653359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596274
    },
    {
        "content": "<p>My view as well</p>",
        "id": 365653409,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596283
    },
    {
        "content": "<p>My colleagues and I always publish proofs of complexity along side correctness.  But the code goes into the CAS in whatever version it got implemented. It seems to me the obvious next step is to have the code carry with it a proof of both claims.</p>",
        "id": 365653700,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596357
    },
    {
        "content": "<p>The main point here is that lean does not lend itself naturally to complexity certificates, because it is essentially a denotational semantics, terms are equal when they are extensionally equal so performance is not a thing you can directly reason about with lean functions</p>",
        "id": 365654161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596473
    },
    {
        "content": "<p>On the other hand it does lend itself naturally to functional correctness proofs</p>",
        "id": 365654388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596524
    },
    {
        "content": "<p>Yeah, its one of the barriers for sure.  And I do have prototypes and such in other languages.  But the tactics and community in LEAN are attractive</p>",
        "id": 365654434,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596541
    },
    {
        "content": "<p>(just FYI, despite the L∃∀N text on the community website, it's Lean, not LEAN)</p>",
        "id": 365654608,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1686596589
    },
    {
        "content": "<p>I'd love to see what an implementation of Schreier–Sims actually looks like in lean. I suspect you are underestimating some aspects of the implementation</p>",
        "id": 365654622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596592
    },
    {
        "content": "<p>even designing the API for it looks nontrivial, what is the actual setting in which you would use it?</p>",
        "id": 365654859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596651
    },
    {
        "content": "<p>Well I made a stupid hack of it with limited checks such as ignoring array bounds  but its a test case.  I think its coming together rather as expected, but still don't have linear types so my idris inspired timing certificates are not in place</p>",
        "id": 365655298,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596765
    },
    {
        "content": "<p>the question is, can you actually verify it computes what it claims to?</p>",
        "id": 365655506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596824
    },
    {
        "content": "<p>yes.</p>",
        "id": 365655552,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596835
    },
    {
        "content": "<p>how does this work?</p>",
        "id": 365655635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596860
    },
    {
        "content": "<p>Again subject to some low-order things like putting in the proper bounds checking.</p>",
        "id": 365655642,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596861
    },
    {
        "content": "<p>I don't mean \"argue informally for the correctness of the algorithm\", I mean \"there is a lean proof of the properties of the results of the function\"</p>",
        "id": 365655776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596890
    },
    {
        "content": "<p>or alternatively \"it produces a proof that the results are as expected along with the answer\"</p>",
        "id": 365655880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596924
    },
    {
        "content": "<p>Right, yeah, that the return is what you say.  Most of that comes down to knowing what the mathematical abstraction is and making the type for that.</p>",
        "id": 365655893,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686596929
    },
    {
        "content": "<p>I'd love to see the code if you have something</p>",
        "id": 365655950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686596945
    },
    {
        "content": "<p>Sure, we have a git repo, we'll make it public soon I wager, I do have to ask the rest of the team.  Its meant as a learning exercise since most of us program in other languages so its a hit to our pride to put out what we know to be sloppy LEAN code.</p>",
        "id": 365656389,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597073
    },
    {
        "content": "<p>Yep, it's a learning process of course. I'm interested in the actual end goal statements / theorems, how are you phrasing this problem</p>",
        "id": 365657012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686597266
    },
    {
        "content": "<p>(And also, obviously ask here if you have any questions about how to do something in lean, what the efficiency of some primitive operations is, or what standard style is, we are very interested to support this work!)</p>",
        "id": 365657443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686597396
    },
    {
        "content": "<p>Take an orbit theorem</p>\n<blockquote>\n<p><strong>Theorem.</strong> If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a group acting on a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi><mo>∈</mo><mi mathvariant=\"normal\">Ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega\\in \\Omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Ω</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>G</mi><mi>ω</mi><mi mathvariant=\"normal\">∣</mi><mo>⋅</mo><mi mathvariant=\"normal\">∣</mi><msub><mi>G</mi><mi>ω</mi></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|G\\omega|\\cdot |G_{\\omega}|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>ω</mi><mo>=</mo><mo stretchy=\"false\">{</mo><mi>g</mi><mi>ω</mi><mo>∣</mo><mi>g</mi><mo>∈</mo><mi>G</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">G\\omega=\\{ g\\omega \\mid g\\in G\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">}</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>ω</mi></msub><mo>=</mo><mo stretchy=\"false\">{</mo><mi>g</mi><mo>∈</mo><mi>G</mi><mo>∣</mo><mi>g</mi><mi>ω</mi><mo>=</mo><mi>ω</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">G_{\\omega}=\\{g\\in G\\mid g\\omega=\\omega\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"mclose\">}</span></span></span></span>.</p>\n</blockquote>\n<p>To make this computational one obvious question: </p>\n<ul>\n<li><strong>Given:</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></li>\n<li><strong>Return:</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">G\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></li>\n</ul>\n<p>or return <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 365657865,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597522
    },
    {
        "content": "<p>That's all directly explained as types but you would struggle to make that a program as the groups are huge.  What CAS does is store generators, not the group.</p>",
        "id": 365658014,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597574
    },
    {
        "content": "<p>And what it does for the orbit is store a Schreier-tree (a spanning tree of the Cayley graph of the fixed generators).  And for generators of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> it uses what are called \"Schreier generators\" which are a data types build from the Schreier tree and generators for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>.</p>",
        "id": 365658266,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597638
    },
    {
        "content": "<p>All of these are different types than what one originally describes as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi>ω</mi></mrow><annotation encoding=\"application/x-tex\">G\\omega</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>G</mi><mi>ω</mi></msub></mrow><annotation encoding=\"application/x-tex\">G_{\\omega}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">ω</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> but individually you can see to prove they are equivalent.</p>",
        "id": 365658477,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597706
    },
    {
        "content": "<p>Do you write this using some relationship to e.g. groups and subgroups as described by mathlib? Or are these just data types like <code>GeneratorSet</code> with some operations on them</p>",
        "id": 365658659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686597757
    },
    {
        "content": "<p>for now just hand made dependent and inductive types but yeah the vision is to integrate.</p>",
        "id": 365658796,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686597802
    },
    {
        "content": "<p>How would you package this in a way that it would come up in the course of a regular-looking query?</p>",
        "id": 365662802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686597820
    },
    {
        "content": "<p>it seems a bit abstract to \"return a group\"</p>",
        "id": 365662928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686597855
    },
    {
        "content": "<p>Yep, in CAS this is always understood as something specific, usually a set of generators but sometimes a presentation or what is known as a black-box group.</p>",
        "id": 365666082,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686598819
    },
    {
        "content": "<p>and how do you interact with a \"black-box group\"?</p>",
        "id": 365666322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686598899
    },
    {
        "content": "<p>even the basic API for doing things with such groups would be a useful place to start</p>",
        "id": 365666492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686598950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20B.2E.20Wilson/near/365662802\">said</a>:</p>\n<blockquote>\n<p>How would you package this in a way that it would come up in the course of a regular-looking query?</p>\n</blockquote>\n<p>I didn't follow, but for example in many proofs you go through several cases and then are left with some calculation.  You then insert in your proof that you ran some code and it came back with 3 examples, you check them all and none of them are counter examples.  The end.  Well its that code you ran that matters to be right, but it can't simply be seen as exhaustively trying all things. The search spaces are huge.  But much of the CAS world has found ways to abstract the question of huge search spaces into small amounts of data given and returned.  But they drop off on providing certificates not because we don't know how, we have.  There is a whole industry of certified returns.  But its never been part of interactive proofs or proof checkers.  Instead it was Arthur Merlin and BPP and other complexity zoo things where each thing to certify provides its own certificates and its own certificate checker.  Its now possible to off load that last part to standard issue proof checkers.</p>",
        "id": 365667044,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686599121
    },
    {
        "content": "<p>I'm totally on board with the idea of holding some finite data which \"encodes\" a group in some sense, but I have no idea what concretely CASs generally use for such a data structure (generators? generators + relations? order?) or what questions are being posed of the groups (elementhood? order? listing subgroups?) and what mechanisms are used to answer those questions. I'm sure there is a book somewhere called something like Introduction to Computer Algebra which details some data structures, and real world CASs use something kind of like that but not quite because such and such works better. There is clearly a whole world here that one wouldn't know unless you have a friend who works on sage or magma or something</p>",
        "id": 365668681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1686599576
    },
    {
        "content": "<p>Right on all those points.  Well, I work with quite a number of the people who make those systems and been fussing about with Agda/Idris/Coq and now LEAN waiting for a system that ticked enough boxes to come off the side lines.  I look forward to sharing what we know and seeing how to build bridges.</p>\n<p>Books by the way for interested readers</p>\n<p>* Holt Eick O'Brien \"Handbook of computational Group Theory\" does a handsome job for many things.  <br>\n  * Seress \"Permutation group algorithms\" does more on optimal performance and randomization.</p>\n<hr>",
        "id": 365670452,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1686600101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20B.2E.20Wilson/near/365562813\">said</a>:</p>\n<blockquote>\n<p>The <code>miller-rabin</code> branch has an implementation of Miller-Rabin in Lean 3, it would be interesting to port to Lean 4 to see how it would perform.</p>\n</blockquote>\n<p>As a test, I did it from scratch in Lean 4 and performance was comparable to a Go version I had made for a cryptography course. (This is despite the fact I did everything with <code>Nat</code> and the Go version used native <code>int</code>, ie no big numbers.) Obviously next time I teach the course it will be in Lean :)</p>",
        "id": 366860986,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1686927595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"624152\">James B. Wilson</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20B.2E.20Wilson/near/365635810\">said</a>:</p>\n<blockquote>\n<p>Linear types don't solve all the questions but they do make it possible to prevent errant back-tracking and branch and bounds which are an all to common guess at how to make a practical algorithm and which can fool random testing but ultimately mathematics (and humans) tend to ask questions in the hard regime.</p>\n</blockquote>\n<p>Here's an Idris example demonstrating that linear types don't really prevent anything when applied to natural numbers (and presumably other inductive types). Basically, I can consume an argument linearly to build a copy of it which I can then use non-linearly. That means I can always turn any function which consumes a <code>Nat</code> into one that claims to use it linearly.</p>\n<div class=\"codehilite\" data-code-language=\"Idris\"><pre><span></span><code><span class=\"kr\">module</span><span class=\"w\"> </span><span class=\"nn\">Main</span>\n\n<span class=\"nf\">launder</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"kt\">Nat</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"ow\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span>n<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Nat</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"ow\">)</span>\nlaunder<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"kt\">Z</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"kt\">Z</span>\nlaunder<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"kt\">S</span><span class=\"w\"> </span>n<span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>launder<span class=\"w\"> </span><span class=\"ow\">(\\</span>k<span class=\"w\"> </span><span class=\"ow\">=&gt;</span><span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"ow\">+</span><span class=\"w\"> </span>k<span class=\"ow\">))</span><span class=\"w\"> </span>n\n\n<span class=\"nf\">unlaunder</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span>n<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Nat</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"kt\">Nat</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"ow\">)</span>\nunlaunder<span class=\"w\"> </span>g<span class=\"w\"> </span>n<span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>g<span class=\"w\"> </span>n\n\n<span class=\"nf\">launder_eq</span><span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"ow\">(</span>f<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Nat</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Bool</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"ow\">(</span>n<span class=\"w\"> </span><span class=\"ow\">:</span><span class=\"w\"> </span><span class=\"kt\">Nat</span><span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span>unlaunder<span class=\"w\"> </span><span class=\"ow\">(</span>launder<span class=\"w\"> </span>f<span class=\"ow\">)</span><span class=\"w\"> </span>n<span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>f<span class=\"w\"> </span>n\nlaunder_eq<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"kt\">Z</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kt\">Refl</span>\nlaunder_eq<span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"kt\">S</span><span class=\"w\"> </span>n<span class=\"ow\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span>launder_eq<span class=\"w\"> </span><span class=\"ow\">(\\</span>k<span class=\"w\"> </span><span class=\"ow\">=&gt;</span><span class=\"w\"> </span>f<span class=\"w\"> </span><span class=\"ow\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"ow\">+</span><span class=\"w\"> </span>k<span class=\"ow\">))</span><span class=\"w\"> </span>n\n</code></pre></div>",
        "id": 367812942,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687242215
    },
    {
        "content": "<p>My intuition is that more generally the notion of \"using linearly\" is meaningless in classical mathematics for all types and not just for inductive  types, though I don't have a precise formulation of that.</p>",
        "id": 367813137,
        "sender_full_name": "Reid Barton",
        "timestamp": 1687242285
    },
    {
        "content": "<p>That is an interesting example <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>.  I'll think on it.  I've considered a few similar cases of where you might leak time/resources.  I rather expect you can shoe-horn in undecidability into any claims, there is after all the halting problem directly in the path.  But I'm not after ways to cheat rather I'm after ways that someone who with good intent has made an algorithm and proved it has a fixed complexity can also write that proof down with the algorithm, or at least provide good circumstantial evidence for that claim within the program.  Its already possible to do this on Turing Machine directly, and Dal Lago and company's work features some progress towards translating that into untyped lambda calculus.  But its not really a programming reality, there are no clear idioms or tactics that I've come across to expose complexity through type annotations.  I want to investigate how current theorem provers can nevertheless do at some forms of proof of complexity, and to what extent interactive proofs can offer the right sort of guards to guide a program into the desired complexity.  Linear types do add some of this, you have to think a bit harder to leak resources when you've put up the condition to use it a limited number of times.</p>\n<p>So all in all, its not a broad claim I'm hoping to make that it will work on all functions.  That I don't believe.  Just a case study to see if some of the transparent techniques used often in CAS and whether if annotated and forced to comply with some programming paradigms they would infact communicated a proven complexity as part of their program description.</p>",
        "id": 367959132,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1687273226
    },
    {
        "content": "<p>But of course I may fail spectacularly!</p>",
        "id": 367960509,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1687273434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"624152\">James B. Wilson</span> <a href=\"#narrow/stream/113489-new-members/topic/James.20B.2E.20Wilson/near/365614271\">said</a>:</p>\n<blockquote>\n<p>Thanks <span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>,  the example that seems best is the \"Hello World\" of computational algebra (the one that I assign to my first year students) is known as Schreier-Sims. It has its own Wikipedia page <a href=\"https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm\">here</a> . It has a couple things going for it. </p>\n<ul>\n<li>relatively simple data types (arrays/linked list suffice, though a stack is even easier)</li>\n<li>easy algorithms (its a transitive closure with book-keeping)</li>\n<li>requires only basic knowledge of group actions.</li>\n</ul>\n</blockquote>\n<p>Wait, am I correct in reading this wiki page that the Monte-Carlo version of the algorithm has a quadratic speedup vs. the deterministic version? This is potentially another great example of the same problem that plagues Miller-Rabin and the <code>ring</code> tactic.</p>",
        "id": 408349539,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1702737374
    },
    {
        "content": "<p>There is a nearly linear time Monte Carlo algorithm and various Las Vegas adaptations.</p>",
        "id": 408633701,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1702913084
    },
    {
        "content": "<p>There are also more clever deterministic versions by Knuth and Jerrum.</p>",
        "id": 408633775,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1702913105
    },
    {
        "content": "<p>And finally there are versions using probabilistic data structures. </p>\n<p>So yes, all in all it get to explore a wide range of both algorithms and data types.  The hassle/goal is to operate in these regimes keeping all the performance but linking to the theory.</p>",
        "id": 408633958,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1702913162
    },
    {
        "content": "<p>(FYI nearly linear in a multitape TM, it wouldn't be interesting to say that in a RAM model)</p>",
        "id": 408634174,
        "sender_full_name": "James B. Wilson",
        "timestamp": 1702913220
    }
]