[
    {
        "content": "<p>I was able to get <a href=\"https://www.linkedin.com/pulse/chatgpt-finally-succeeds-writing-zfc-lean-4-wasnt-easy-ericson\">OpenAI ChatGPT to write ZFC axioms in Lean 4</a>.   This was after failed attempts for <a href=\"https://www.linkedin.com/pulse/perplexityai-zfc-lean-4-lars-warren-ericson\">Perplexity.AI</a> and for <a href=\"https://www.linkedin.com/pulse/i-ask-bing-chat-write-lean-4-zfc-part-1-lars-warren-ericson\">Bing Chat.</a></p>\n<p>In doing this, all I was really doing was feeding back the error messages from Lean.  It then used the error messages to search it's memory of the Internet for better solutions.  This seems like a loop that could be automated, given a starting point piece of code that it generated.</p>\n<p>I'm just doing this for fun.  So I'm not asking an actual question here, since ChatGPT finally closed the loop.  I do have some ambitions along the lines of stepwise refinement of ChatGPT-produced explanations of Fermat's Last Theorem combined with its ability to generate Lean scripts, to maybe stepwise refine my way to a Lean 4 version of the proof of Fermat's Last Theorem.  (Which you guys have probably already done, but again, this is just for fun.)   Here is a description of an <a href=\"https://www.linkedin.com/pulse/fermats-last-theorem-lars-warren-ericson\">initial dialog I had with the these GPT chatbots</a>  on this topic (but before I found out they could write code).</p>",
        "id": 355627176,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683158315
    },
    {
        "content": "<p>Can you share the code here?</p>",
        "id": 355628066,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1683158935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>, have you looked at my <code>sagredo</code> demo? <a href=\"https://youtu.be/CEwRMT0GpKo\">https://youtu.be/CEwRMT0GpKo</a> This automates the loop of feeding back error messages or new goals to GPT.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"CEwRMT0GpKo\" href=\"https://youtu.be/CEwRMT0GpKo\"><img src=\"https://uploads.zulipusercontent.net/334dd3177945ef6955a1e621087a23617632651b/68747470733a2f2f692e7974696d672e636f6d2f76692f434577524d543047704b6f2f64656661756c742e6a7067\"></a></div>",
        "id": 355633016,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683161775
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>, you are barking up the wrong tree if you expect to get anywhere with Fermat's Last Theorem in Lean without (or especially with) GPT's help. This is a massive undertaking well beyond current technology / available expertise. :-)</p>",
        "id": 355633116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683161846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/355628066\">said</a>:</p>\n<blockquote>\n<p>Can you share the code here?</p>\n</blockquote>\n<p>Here is the final code that ChatGPT produced which passed the Lean 4 type checker:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Define the type of sets</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">Set</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"c1\">-- Define the membership relation</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">ElementOf</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span> <span class=\"s2\">\" ∈ \"</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ElementOf</span>\n\n<span class=\"c1\">-- Define the empty set</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">Set</span>\n\n<span class=\"c1\">-- Define the axiom of extensionality</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">extensionality</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"c1\">-- Define the axiom of regularity</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">regularity</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">empty</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Define the axiom of pairing</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">pairing</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Define the axiom of union</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- Define the axiom of power set</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">power_set</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- Define the axiom of choice</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">choice</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 355787689,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683209556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  thanks for link to sagredo.  I will add a link to the video to my LinkedIn article.</p>\n<p>On Fermat's Last Theorem, I am somewhat familiar now with the process of drilling down to axiomatize mathematical ideas in Lean.  It helps to have a grander project that \"has an answer\" that people accept but find difficult to accept, as a focus of attention/mountain to climb.  I don't expect to get to the top of the mountain, but it is still fun to climb until it's not.  It is also fun to try to get ChatGPT to teach me.</p>",
        "id": 355789738,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683209966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I am watching <a href=\"https://www.youtube.com/watch?v=CEwRMT0GpKo\">your video</a> now  and it occurred to me that at 3:33 <br>\n<a href=\"/user_uploads/3121/bSdnceDXVJwqqfcNHdTGBBau/image.png\">image.png</a><br>\nwhat you are describing/implementing with the tactic is a kind of <a href=\"https://en.wikipedia.org/wiki/Generative_adversarial_network\">generative adversarial network.</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/bSdnceDXVJwqqfcNHdTGBBau/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/bSdnceDXVJwqqfcNHdTGBBau/image.png\"></a></div><div class=\"youtube-video message_inline_image\"><a data-id=\"CEwRMT0GpKo\" href=\"https://www.youtube.com/watch?v=CEwRMT0GpKo\"><img src=\"https://uploads.zulipusercontent.net/334dd3177945ef6955a1e621087a23617632651b/68747470733a2f2f692e7974696d672e636f6d2f76692f434577524d543047704b6f2f64656661756c742e6a7067\"></a></div>",
        "id": 355843420,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683221564
    },
    {
        "content": "<p>Anyway it's just a matter of filling this out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">fermat_last_theorem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>with a little help from my robot friends.  Attached is the first <br>\n<a href=\"/user_uploads/3121/gC0e9mRSn3-FpZIMrsyTtPR6/fmt.pdf\">fmt.pdf</a><br>\nof about 1000 passes, the game can be played for a while.</p>",
        "id": 355892592,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683237555
    },
    {
        "content": "<p>If this eventually succeeds, it will be because you have run it for however long it takes for humans to have already published the full proof in mathlib</p>",
        "id": 355898188,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683240281
    },
    {
        "content": "<p>Note that the output is already nonsense at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">algebraic_curve</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">is_algebraic</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">equation</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which allows only the entire plane to be an <code>algebraic_curve</code>.</p>",
        "id": 355898280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683240326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/355898280\">said</a>:</p>\n<blockquote>\n<p>Note that the output is already nonsense at:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">algebraic_curve</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">equation</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n <span class=\"o\">(</span><span class=\"n\">is_algebraic</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">equation</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which allows only the entire plane to be an <code>algebraic_curve</code>.</p>\n</blockquote>\n<p>already at the statement of FLT ;)</p>",
        "id": 355900983,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1683241634
    },
    {
        "content": "<p>Guess Kevin's going to have to cancel his funding application, FLT is false after all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_fermat_last_theorem</span> <span class=\"o\">:</span> <span class=\"bp\">¬∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">default</span> <span class=\"n\">default</span> <span class=\"n\">default</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>/s</p>",
        "id": 355901855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683242127
    },
    {
        "content": "<p>Let me try to make stone soup here. The entirely expected utter failure of having GPT \"think\" about FLT can be turned into an argument that we need to include better automation tooling in the loop with GPT (i.e. what sagredo attempts). If GPT knew about <code>slim_check</code>, and wanted to use it (or if the automation loop used it), then we might see better progress:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.SlimCheck</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">not_exactly_fermat_last_theorem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">slim_check</span>\n\n<span class=\"c1\">-- Prints something like:</span>\n\n<span class=\"bp\">===================</span>\n<span class=\"n\">Found</span> <span class=\"n\">problems</span><span class=\"bp\">!</span>\n<span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span>\n<span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"mi\">10</span>\n<span class=\"n\">guard</span><span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">10</span>\n<span class=\"n\">issue</span><span class=\"o\">:</span> <span class=\"mi\">1024</span> <span class=\"bp\">≠</span> <span class=\"mi\">1024</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">hold</span>\n<span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"n\">shrinks</span><span class=\"o\">)</span>\n<span class=\"c1\">-------------------</span>\n</code></pre></div>\n<p>(Assuming, of course, that someone gets around to merging <a href=\"https://github.com/leanprover-community/mathlib4/pull/3114\">https://github.com/leanprover-community/mathlib4/pull/3114</a>.)</p>",
        "id": 355902740,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683242658
    },
    {
        "content": "<p>Out of the blue, ChatGPT just threw this at me. Lean 4 fails on \"import tactic\".  Either it's cribbing an actual proof from mathlib or it's a \"hallucination\" (term of art in Scott's video):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">fermat_last_theorem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat.succ_le_of_lt</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">add_lt_add</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">pow_lt_pow_of_lt_left</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">pow_lt_pow_of_lt_left</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"n\">hn</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat.succ_le_of_lt</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_ne</span> <span class=\"o\">(</span><span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h3</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nat.pow_two</span><span class=\"o\">,</span> <span class=\"n\">nat.pow_two</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.succ_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">nat.le_of_not_gt</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">pow_pos</span> <span class=\"o\">(</span><span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h2</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.sub_add_cancel</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">nat.pow_add</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">nat.mul_sub_left_distrib</span><span class=\"o\">,</span> <span class=\"n\">nat.sub_lt_right_iff_lt_add</span> <span class=\"n\">h5</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h6</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">mul_le_mul_of_nonneg_left</span> <span class=\"o\">(</span><span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">nat.mul_le_mul_left</span> <span class=\"n\">_</span> <span class=\"n\">h4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nat.mul_le_mul_left</span> <span class=\"n\">_</span> <span class=\"n\">h4</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">linarith</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">],</span>\n      <span class=\"n\">apply</span> <span class=\"n\">nat.pow_lt_pow_of_lt_left</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">lt_of_le_of_lt</span> <span class=\"o\">(</span><span class=\"n\">nat.zero_le</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">2</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h6</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h7</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_pow</span><span class=\"o\">,</span> <span class=\"n\">mul_pow</span><span class=\"o\">,</span> <span class=\"n\">mul_pow</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.pow_two</span><span class=\"o\">,</span> <span class=\"n\">nat.pow_add</span><span class=\"o\">,</span> <span class=\"n\">nat.pow_add</span><span class=\"o\">,</span> <span class=\"n\">nat.pow_add</span><span class=\"o\">],</span>\n      <span class=\"k\">have</span> <span class=\"n\">h8</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_assoc</span> <span class=\"mi\">2</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.mul_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_assoc</span> <span class=\"mi\">2</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">nat.mul_succ</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">mul_assoc</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_assoc</span> <span class=\"n\">x</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span> <span class=\"n\">y</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span> <span class=\"n\">x</span><span class=\"o\">],</span>\n        <span class=\"n\">repeat</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span><span class=\"o\">}},</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h8</span><span class=\"o\">,</span> <span class=\"n\">h8</span><span class=\"o\">,</span> <span class=\"n\">h8</span><span class=\"o\">],</span>\n      <span class=\"n\">apply</span>\n</code></pre></div>\n<p>If I take out the \"import tactic\" then I get a raft of errors starting with \"failed to synthesize instance LT ℕ\".  I may nag ChatGPT about this for a while but what I was trying to do in pass 1 of 1000 was to do a breadth-first traversal (what are the main steps of the proof), then a depth-first traversal on every concept mentioned on that first version, rinse and repeat until I have the concepts well defined and then try to get the top level steps expressed as proprositions in terms of those concepts and then rinse and repeat on the steps.  So I wouldn't really want to drill down too much on the above hallucination because it is not clearly motivated by the 7 steps ChatGPT started with:</p>\n<ol>\n<li>\n<p>Elliptic Curves: Wiles made use of elliptic curves, which are a fundamental mathematical object in algebraic geometry. He studied certain types of elliptic curves called semi-stable elliptic curves, focusing on their properties and connections to number theory.</p>\n</li>\n<li>\n<p>Taniyama-Shimura-Weil Conjecture: One crucial aspect of Wiles' proof was the Taniyama-Shimura-Weil conjecture, which proposes a connection between elliptic curves and modular forms. Wiles showed that if Fermat's Last Theorem were false, there would exist an elliptic curve with specific properties that violated this conjecture.</p>\n</li>\n<li>\n<p>Modular Forms: Wiles delved into the theory of modular forms, which are complex functions with certain transformation properties. He established intricate connections between modular forms and elliptic curves, laying the groundwork for his subsequent arguments.</p>\n</li>\n<li>\n<p>Galois Representations: Wiles introduced Galois representations into the proof, which provide a way to study the symmetries of equations. He developed a deep understanding of these representations and their relation to modular forms and elliptic curves.</p>\n</li>\n<li>\n<p>Frey Curve: Wiles constructed what is known as the \"Frey curve,\" named after Jean-Pierre Serre's student, Ernst Frey. This curve had specific properties that allowed Wiles to reduce the problem of Fermat's Last Theorem to a contradiction in the framework of elliptic curves and modular forms.</p>\n</li>\n<li>\n<p>Selmer Groups and Descent: Wiles employed sophisticated mathematical tools, such as Selmer groups and descent theory, to analyze the properties of elliptic curves and modular forms further. These tools helped him establish crucial results related to the non-existence of certain solutions to the Fermat equation.</p>\n</li>\n<li>\n<p>Proof by Contradiction: Wiles ultimately showed that if a non-trivial solution to the Fermat equation existed, it would lead to a contradiction within the framework he established using elliptic curves, modular forms, and Galois representations. This contradiction demonstrated that the equation has no solutions, thus proving Fermat's Last Theorem.</p>\n</li>\n</ol>",
        "id": 355905452,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683244464
    },
    {
        "content": "<p>That entire output is Lean 3 code, so Lean4 will accept approximately none of it</p>",
        "id": 355905532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683244552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span>, it really seems you are not ready to listen to us saying that GPT4 is not a relevant tool for approaching FLT. I'm not sure why.</p>",
        "id": 355914479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683249190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/355901855\">said</a>:</p>\n<blockquote>\n<p>Guess Kevin's going to have to cancel his funding application, FLT is false after all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not_fermat_last_theorem</span> <span class=\"o\">:</span> <span class=\"bp\">¬∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">default</span> <span class=\"n\">default</span> <span class=\"n\">default</span> <span class=\"mi\">3</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>/s</p>\n</blockquote>\n<p>This is reminding me of when I graded for Jeremy's intro to lean class, there was an exercise about stating FLT and I must have written this disproof 15 or so times</p>",
        "id": 355917243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683250959
    },
    {
        "content": "<p>There are a lot of claimed \"proofs\" of FLT out there of the general form: do some trivial algebraic manipulations, do something that either has an algebraic mistake or isn't mathematics at all, do some more trivial algebraic manipulations, suddenly FLT drops out. I can certainly imagine that (a) various such false proofs are among the training material LLMs have read and (b) an LLM might suddenly decide to hallucinate an autoformalization of such a false proof that it once read instead of anything useful.</p>",
        "id": 355919273,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1683252306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> That outline you posted above claims that Wiles did this and Wiles did that, etc... But all of those steps were already done by others (Taniyama, Shimura, Serre, Frey, Ribet, and many, many others). What Wiles did, was prove the Taniyama-Shimura conjecture (step 2 in the outline). He didn't introduce Galois representations into the proof, others had already done that. Same for all the other steps ≠ 2.</p>",
        "id": 355942184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683264583
    },
    {
        "content": "<p>Besides that, I think you are aiming too low with this project. FLT is old news. You should really be extracting a proof of Langlands out of GPT. That's the real deal.</p>",
        "id": 355942305,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1683264632
    },
    {
        "content": "<p>(responding to Lars' points above) 2. Ribet showed that TSW=&gt;FLT, not Wiles, indeed it was Ribet's work which inspired Wiles to work on FLT. 4. Galois representations were introduced into the theory many years before Wiles. It was Mazur and Tilouine who proposed the R=T conjecture -- Wiles just proved it. 5. Frey introduced the Frey curve and his name is Gerhard Frey; he wasn't a student of Serre (indeed Serre famously had no PhD students).</p>",
        "id": 355962866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683270500
    },
    {
        "content": "<p>I could also add that the chances of getting a language model to do anything useful regarding formalising a proof of FLT (I don't mean proving it, I mean getting them to do anything remotely helpful which will aid the extremely long journey towards the proof) are right now zero.</p>",
        "id": 355963260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683270646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/355963260\">said</a>:</p>\n<blockquote>\n<p>I could also add that the chances of getting a language model to do anything useful regarding formalising a proof of FLT (I don't mean proving it, I mean getting them to do anything remotely helpful which will aid the extremely long journey towards the proof) are right now zero.</p>\n</blockquote>\n<p>I don't have evidence to back this yet, but \"something remotely helpful\" does not seem hopeless - partial autoformalization with few enough errors so that correcting these is significantly less work than formalizing from scratch seems not too far away (the <em>Draft, Sketch and Proof</em> paper is probably the furthest along these lines).</p>",
        "id": 355968096,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1683272114
    },
    {
        "content": "<p>Fair point. My first paragraph is facts, the second is my opinion.</p>",
        "id": 355968434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683272204
    },
    {
        "content": "<p>What are your opinions about these statements?</p>\n<ul>\n<li>\n<p>The <code>ring</code> tactic does something helpful which will aid the extremely long journey towards the proof of FLT.</p>\n</li>\n<li>\n<p>There is a nonzero chance right now of getting a large language model to automatically do something comparably useful to <code>ring</code>.</p>\n</li>\n</ul>",
        "id": 356017885,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683284312
    },
    {
        "content": "<p>Reid as you probably know I'm a sceptic -- I will only believe that LLMs are remotely useful for FLT or more generally for any mathematics which I'm interested in when I've actually seen it happening. Right now I've seen all kinds of \"oh look it wrote <code>list.append</code> automatically\" stuff but we already have <code>list.append</code>. I'm certainly watching and am well aware that people constantly talk about how these things are getting exponentially better but at present they have achieved nothing beyond school level mathematics. I am watching carefully though. Let me stress that I wrote <strong>right now</strong> zero.</p>",
        "id": 356051821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683292028
    },
    {
        "content": "<p>Have they even achieved school-level mathematics? I hear they've passed some standardised tests but isn't that just because our tests at that level are largely memorisation?</p>",
        "id": 356058443,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1683293289
    },
    {
        "content": "<p>The sagredo demo I was the most impressed with was the one that wrote the proof for some equation having some finite set of solutions - those kind of proofs are often tedious to write in Lean but also trivial in real life. I'm sure some of those cases will come up in the proof of FLT somehow, and therefore that's already somewhere that LLMs can help</p>",
        "id": 356065965,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1683294740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/356051821\">said</a>:</p>\n<blockquote>\n<p>Reid as you probably know I'm a sceptic -- I will only believe that LLMs are remotely useful for FLT or more generally for any mathematics which I'm interested in when I've actually seen it happening. Right now I've seen all kinds of \"oh look it wrote <code>list.append</code> automatically\" stuff but we already have <code>list.append</code>. I'm certainly watching and am well aware that people constantly talk about how these things are getting exponentially better but at present they have achieved nothing beyond school level mathematics. I am watching carefully though. Let me stress that I wrote <strong>right now</strong> zero.</p>\n</blockquote>\n<ul>\n<li>The <code>ring</code> tactic also cannot do any non-trivial mathematics by itself. But it is certainly useful.</li>\n<li>Personally I find copilot (which is LLM based) pretty useful, as do my students.</li>\n</ul>\n<p>Even if the core of formalizing say FLT is people doing it, if there productivity is doubled the time needed is halved.</p>",
        "id": 356067459,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1683295070
    },
    {
        "content": "<p><code>lean-gptf</code> already did some pretty neat stuff, though I guess the \"right now\" clause disqualifies it because afaik it is not possible to use it any more.</p>",
        "id": 356069812,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683295491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , I'm not not hearing you.   I hear you.  However, I have experienced ChatGPT as being a useful tool for summarizing research, finding relevant papers, and even sourcing poorly explained or motivated equations presented in talks.  You can just type the LaTeX form of an equation at it, without any context, and it will tell you where it's from and how it's applied.   I understand that it may not be as helpful for FMT and Lean4 being bare bones (no mathlib?) may not be as helpful.  I'm still enjoying the exercise though.</p>\n<p>Here is what I see from ChatGPT:</p>\n<ol>\n<li>It doesn't know the difference between Lean 3 and Lean 4, at all</li>\n<li>It will repeat itself, so it doesn't have that much memory or ability to keep track of the contents of its prior responses in the same dialogue.  So it will cycle through wrong answers with repeated prompts.</li>\n<li>It apologizes endlessly, even if you tell it not to</li>\n<li>If you ask the same question twice, there is a degree of randomness in the generation, so it won't give you the same response twice.</li>\n<li>It can be biased</li>\n<li>It is not reliable</li>\n<li>It will incorporate immediate feedback</li>\n<li>As set up, it may be learning on the go from the feedback it receives</li>\n</ol>\n<p>Regarding point 1, this is what ChatGPT says are the differences between Lean 3 and Lean 4:</p>\n<p>\"There are several major differences between Lean 3 and Lean 4, both syntactic and semantic. Here are some of the most significant differences:</p>\n<p>\"Syntax: The syntax of Lean 4 has been redesigned to be more consistent and easier to read. The notation for defining functions, for example, has been changed to use the def keyword instead of definition or theorem.</p>\n<p>\"Type system: Lean 4 has a more expressive type system than Lean 3. It features a dependent type system, which allows for more precise types that can depend on values. Additionally, the system supports type classes, which allow for overloading of functions based on the types of their arguments.</p>\n<p>\"Metaprogramming: Lean 4 introduces a new, more powerful metaprogramming system based on tactics. This allows for more advanced automation and proof search.</p>\n<p>\"Libraries: Lean 4 has a new standard library that is designed to be more modular and extensible than the one in Lean 3. Additionally, many of the standard tactics and functions have been redesigned or renamed to be more consistent and easier to use.</p>\n<p>\"Compiler: Lean 4 uses a new, faster and more efficient compiler than Lean 3. The new compiler is designed to be more incremental and interactive, which makes it easier to work with.</p>\n<p>\"Overall, Lean 4 represents a significant improvement over Lean 3 in many ways. While there is some backward compatibility between the two versions, it may take some effort to migrate code from Lean 3 to Lean 4.\"</p>\n<p>I can try to get it to generate the above list of steps of FMT, and then feed back the corrections above.   The initial prompt is</p>\n<p>\"Please give the detailed steps for the proof of Fermat's Last Theorem, in sufficient detail to be checked by a human mathematician.\"</p>\n<p>ChatGPT says</p>\n<p>\"The proof of Fermat's Last Theorem is a complex and technical argument that spans several different areas of mathematics, including number theory, algebraic geometry, and modular forms. It was first published in 1994 by Andrew Wiles, and it has been widely regarded as one of the greatest achievements in the history of mathematics. Here is an overview of the main steps involved in the proof, presented at a high level of abstraction:</p>\n<ol>\n<li>\n<p>Elliptic Curves and Modular Forms: The proof of Fermat's Last Theorem relies heavily on the theory of elliptic curves, which are algebraic curves defined by polynomial equations with coefficients in a field. One of the key insights of the proof is the connection between elliptic curves and modular forms, which are analytic functions that satisfy certain transformation properties under modular transformations. In particular, there is a deep connection between the modular forms of weight 2 and the elliptic curves over the complex numbers.</p>\n</li>\n<li>\n<p>Modularity Theorem: The Modularity Theorem, also known as the Taniyama-Shimura-Weil Conjecture, is a deep result in number theory that asserts that every elliptic curve over the rational numbers is modular, meaning that it can be associated with a certain modular form of weight 2. This theorem was first proposed by Yutaka Taniyama and Goro Shimura in the 1950s, and it was later proved by Andrew Wiles and Richard Taylor in the 1990s, using a combination of methods from algebraic geometry, modular forms, and Galois representations.</p>\n</li>\n<li>\n<p>Frey Curve: One of the key insights of the proof of Fermat's Last Theorem is the construction of a certain elliptic curve, called the Frey curve, that arises from a hypothetical counterexample to Fermat's equation. This curve is defined over the rational numbers and has certain properties that are crucial for the proof.</p>\n</li>\n<li>\n<p>Modularity Lifting Theorem: The Modularity Lifting Theorem, also known as the Taylor-Wiles Theorem, is a deep result in algebraic geometry that provides a way to lift the modularity of an elliptic curve over the rational numbers to a modular form over a certain ring of integers. This theorem was first proved by Andrew Wiles and Richard Taylor in the 1990s, using a combination of methods from algebraic geometry, modular forms, and Galois representations.</p>\n</li>\n<li>\n<p>Selmer Groups: Selmer groups are certain cohomology groups associated with an elliptic curve over the rational numbers, and they play a crucial role in the proof of Fermat's Last Theorem. The Selmer groups are related to the Galois representations associated with the elliptic curve, and they provide a way to measure the failure of the elliptic curve to satisfy certain local conditions.</p>\n</li>\n<li>\n<p>Main Theorem: The Main Theorem of the proof of Fermat's Last Theorem is a deep result in number theory that asserts that certain Selmer groups associated with the Frey curve are trivial, meaning that they have no non-trivial elements. This theorem was proved by Andrew Wiles in the 1990s, using a combination of methods from algebraic geometry, modular forms, and Galois representations.</p>\n</li>\n<li>\n<p>Proof of the Main Theorem: The proof of the Main Theorem is a complex and technical argument that involves a number of different steps. One of the key steps is the construction of certain Galois representations, called modular Galois representations, that are associated with the modular form of weight 2 associated with the elliptic curve. Another key step is the use of the Langlands program, a far-reaching conjecture that provides a framework for studying the connections between different areas of mathematics.</p>\n</li>\n<li>\n<p>Conclusion: The proof of the Main Theorem\"</p>\n</li>\n</ol>\n<p>I then put in the comments above, we'll see what it says:</p>\n<p>\"What Wiles did, was prove the Taniyama-Shimura conjecture.  He didn't introduce Galois representations into the proof, others had already done that.    Ribet showed that TSW=&gt;FLT, not Wiles, indeed it was Ribet's work which inspired Wiles to work on FLT.  Galois representations were introduced into the theory many years before Wiles. It was Mazur and Tilouine who proposed the R=T conjecture -- Wiles just proved it. Frey introduced the Frey curve and his name is Gerhard Frey; he wasn't a student of Serre (indeed Serre famously had no PhD students).\"</p>\n<p>ChaGPT responds</p>\n<p>\"Thank you for pointing out those inaccuracies in my previous response. You are correct that Wiles' contribution to the proof of Fermat's Last Theorem was the proof of the Taniyama-Shimura conjecture, and that Galois representations were introduced into the theory before Wiles' work. Ribet's work showed that the Taniyama-Shimura conjecture implies Fermat's Last Theorem, not Wiles' work.</p>\n<p>\"Additionally, Frey introduced the Frey curve, and he was not a student of Serre. Thank you for bringing these errors to my attention.\"</p>\n<p>Then I ask it to put it together:</p>\n<p>\"Please give the detailed steps for the proof of Fermat's Last Theorem, in sufficient detail to be checked by a human mathematician, incorporating this additional information.\"</p>\n<p>It comes back with:</p>\n<p>\"Certainly, here are the detailed steps for the proof of Fermat's Last Theorem, incorporating the additional information you mentioned:</p>\n<p>Step 1: Assume that there exists a solution to Fermat's Last Theorem, i.e., there exist integers a, b, c, and n &gt; 2 such that a^n + b^n = c^n.</p>\n<p>Step 2: Show that if there exists a solution to Fermat's Last Theorem, then there exists a corresponding elliptic curve, E, given by the equation y^2 = x(x-a^n)(x+b^n), and a modular form f of weight 2 and level N, where N is a positive integer.</p>\n<p>Step 3: Prove the Taniyama-Shimura conjecture, which states that every elliptic curve over Q is modular, meaning it corresponds to a modular form. This was a major achievement of Andrew Wiles and Richard Taylor in the 1990s.</p>\n<p>Step 4: Deduce that the elliptic curve corresponding to a solution of Fermat's Last Theorem is modular.</p>\n<p>Step 5: Use the modularity of E to prove that the Frey curve, a certain elliptic curve over Q constructed by Gerhard Frey, is also modular.</p>\n<p>Step 6: Use the modularity of the Frey curve to prove the conjecture R=T, where R is a certain condition on Galois representations and T is a condition on modular forms. This was first proposed by Mazur and Tilouine.</p>\n<p>Step 7: Conclude that there are no solutions to Fermat's Last Theorem, since the existence of a solution would lead to a contradiction with the R=T conjecture.</p>\n<p>In summary, the proof of Fermat's Last Theorem relied heavily on the Taniyama-Shimura conjecture, which was proven by Wiles and Taylor, and the R=T conjecture, which was first proposed by Mazur and Tilouine. The proof also used concepts from number theory, algebraic geometry, and analysis, and involved a deep understanding of elliptic curves, modular forms, Galois representations, and their interplay.\"</p>\n<p>At first glance it seems like it is getting more technical and precise.</p>",
        "id": 356069910,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683295507
    },
    {
        "content": "<p>It's clear that ChatGPT does not \"know\" how to prove FLT. Why not start your experiments from something much much easier, where there is some chance of success? Like even FLT for n=4?</p>",
        "id": 356071807,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683295847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, ChatGPT in the end is a search engine which has ingested a giant corpus and has <a href=\"https://medium.com/wisio/a-gentle-introduction-to-doc2vec-db3e8c0cce5e\">embedded it into a vector space</a> that can be searched with the right prompts which are themselves translated into vectors.  It reassembles the information into English or code as requested.  The reassemblies are more or less competent.  They are apt to be far less competent in an area requiring very high skill or an area where there is a low level of training material and the differences are subtle, like with Lean 3 versus Lean 4.  I should have done this with Lean 3 as the baseline, but  I am curious about Lean 4.   I'm not trying to be the first kid on the block to automate a proof of FLT.  I enjoy chasing definitions.  Like compact subset to open cover to open set to set to ZFC.  I got ChatGPT to eventually randomly generate a form of ZFC that Lean 4 would typecheck.  So, following this particuilar game of Solitaire, I would then work my way back from set to open set to open cover to compact subset.</p>",
        "id": 356150606,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683315230
    },
    {
        "content": "<blockquote>\n<p>I got ChatGPT to eventually randomly generate a form of ZFC that Lean 4 would typecheck.</p>\n</blockquote>\n<p>This is a pretty low bar, expecially if you allow it to use <code>axiom</code>. Did you check if the axioms were contradictory? The fact it type-checks doesn't tell you that.</p>",
        "id": 356171525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683323834
    },
    {
        "content": "<p>Chewing on \"every elliptic curve over the rational numbers is modular, meaning that it can be associated with a certain modular form of weight 2\":</p>\n<p>Elliptic curves:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/archive/stream/116395-maths/topic/thoughts.20on.20elliptic.20curves.html\">Topic: thoughts on elliptic curves</a></li>\n<li><a href=\"https://arxiv.org/pdf/2302.10640.pdf\">An Elementary Formal Proof of the Group Law on Weierstrass Elliptic Curves in any Characteristic</a></li>\n<li><a href=\"https://github.com/alreadydone/mathlib/blob/associativity/src/algebraic_geometry/elliptic_curve/weierstrass.lean\">weierstrass_curve in Lean 3</a></li>\n</ul>\n<p>Modular forms:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/blog/posts/modular-forms/\">Topic: Modular forms in Lean 3</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/number_theory/modular_forms/basic.html#top\">Documentation: Modular forms in Lean 3</a></li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/tree/master/src/number_theory/modular_forms\">Code: Modular forms in Lean 3</a></li>\n<li>\n<p><a href=\"https://math.vanderbilt.edu/rolenl/ModularFormsLecture1.pdf\">MODULAR FORMS LECTURE 1: INTRODUCTION AND MOTIVATING EXAMPLES</a><br>\n<a href=\"/user_uploads/3121/AM4at0alRpT3pDW7KMTmSHh3/Ant_Brontosaurus_Cat.png\">Ant_Brontosaurus_Cat.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/AM4at0alRpT3pDW7KMTmSHh3/Ant_Brontosaurus_Cat.png\" title=\"Ant_Brontosaurus_Cat.png\"><img src=\"/user_uploads/3121/AM4at0alRpT3pDW7KMTmSHh3/Ant_Brontosaurus_Cat.png\"></a></div></li>\n<li>\n<p><a href=\"https://youtu.be/MG66ZQ2680c\">Modular forms, Eisenstein series and modularity conj, by Christopher Birkbeck</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"MG66ZQ2680c\" href=\"https://youtu.be/MG66ZQ2680c\"><img src=\"https://uploads.zulipusercontent.net/35059bf505cb5394717ec1ca920ff7db98e0aae8/68747470733a2f2f692e7974696d672e636f6d2f76692f4d4736365a5132363830632f64656661756c742e6a7067\"></a></div></li>\n</ul>\n<p>NB: Forecasters assess that t<a href=\"https://manifold.markets/BoltonBailey/will-we-have-a-formalized-proof-of-2cd9009abb82\">here is a 72% likelihood that there we be a formal proof of the Modularity Theorem by 2029-05-01</a>.</p>",
        "id": 356516187,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683475612
    },
    {
        "content": "<p>That forecast is a weighted average of six individuals' guesses. It would be possible to interview every single one of them in less than an hour and figure out whether they knew anything about formal theorem proving. Frankly I'd be willing to bet at least 3 have no idea what the modularity theorem says or what the proof looks like. The number 72% means <em>nothing.</em><br>\nIt would be silly to listen to half a dozen random speculators over the <em>practitioners</em> in formal verification you are talking to <em>here</em>, some of whom also have experience in number theory.</p>",
        "id": 356585444,
        "sender_full_name": "Patrick Nicodemus",
        "timestamp": 1683517464
    },
    {
        "content": "<p>Indeed, I happily bet that of those 6, (one of whom is a bot), exactly one knows anything about theorem proving, interactive or otherwise. <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>.</p>",
        "id": 356586003,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683517794
    },
    {
        "content": "<p>As the creator of that market, I can confirm I absolutely could not even give a rough description of what the modularity theorem says <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span>.</p>",
        "id": 356617164,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1683531136
    },
    {
        "content": "<p>Definitely recommend some arbitrage with the formalized proof of FLT market!</p>",
        "id": 356800974,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683575598
    },
    {
        "content": "<p>The modularity theorem doesn't give you FLT for free -- you'll also need Mazur's theorem on torsion and also more, e.g. Ribet's level-lowering (and these won't be done in 6 years either ;-) ). There are ways of proving FLT without Ribet nowadays though (but you always need Mazur)</p>",
        "id": 356809528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683578303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/356800974\">said</a>:</p>\n<blockquote>\n<p>Definitely recommend some arbitrage with the formalized proof of FLT market!</p>\n</blockquote>\n<p>Yes, creating an arbitrage opportunity to make the price of the FLT market a bit more accurate was part of the motivation to make the modularity theorem market. I think I misunderstood it a bit at the time - I thought that FLT was originally proved by proving the modularity theorem and proving that the modularity theorem implies FLT. I guess in actuality it's only a special case of the modularity theorem that's needed, I don't know how much harder the full modularity theorem would be to formalize.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/Getting.20GPT3.20chatbots.20to.20write.20ZFC.20in.20Lean4/near/356809528\">said</a>:</p>\n<blockquote>\n<p>The modularity theorem doesn't give you FLT for free -- you'll also need Mazur's theorem on torsion and also more, e.g. Ribet's level-lowering (and these won't be done in 6 years either ;-) ). There are ways of proving FLT without Ribet nowadays though (but you always need Mazur)</p>\n</blockquote>\n<p>I was also totally unaware of these \"other ways\". Do they seem like the pathway of least resistance for an eventual formal proof?</p>",
        "id": 356872362,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1683611566
    },
    {
        "content": "<p>Of FLT? Yes. But all proofs are still super long and technical and seem to need some trace formula in the noncompact case, that's one of many reasons why we won't have it by 2029</p>",
        "id": 356892681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683617469
    },
    {
        "content": "<p><a href=\"https://people.math.wisc.edu/~nboston/869.pdf\">Nigel Boston: The proof of Fermat's Last Theorem</a>: \"An interested reader wanting a simple overview of the proof should consult Gouvea [13], Ribet [25], Rubin and Silverberg [26], or my article [1]. A much more detailed overview of the proof is the one given by Darmon, Diamond, and Taylor [6], and the Boston conference volume [5] contains much useful elaboration on ideas used in the proof. The Seminaire Bourbaki article by Oesterl´e and Serre [22] is also very enlightening. Of course, one should not overlook the original proof itself [38], [34] .\"</p>\n<ul>\n<li>Gouvea [13]. <a href=\"https://www.math.stonybrook.edu/~moira/mat331-spr10/papers/1994%20Gouvea%22A%20Marvelous%20Proof%22.pdf\">F. Gouvea. A marvelous proof. American Mathematical Monthly, 101:203–222, 1994.</a></li>\n<li>Ribet [25]. <a href=\"https://people.math.wisc.edu/~nboston/10.1.1.125.6114.pdf\">K. Ribet. Galois representations and modular forms. Bulletin of AMS, 32:375–402, 1995.</a></li>\n<li>Rubin and Silverberg [26].  <a href=\"https://www.ams.org/journals/bull/1994-31-01/S0273-0979-1994-00512-9/S0273-0979-1994-00512-9.pdf\">K. Rubin and A. Silverberg. A report on Wiles’ Cambridge lectures. Bulletin of AMS, 31:15–38, 1994.</a></li>\n<li>Boston  [1]. <a href=\"https://people.math.wisc.edu/~nboston/boston1.pdf\">N. Boston. A Taylor-made plug for Wiles’ proof. College Mathematics Journal, 26:100–105, 1995.</a></li>\n<li>Darmon, Diamond, and Taylor [6]. <a href=\"https://www.math.mcgill.ca/darmon/pub/Articles/Expository/05.DDT/paper.pdf\">H. Darmon, F. Diamond, and R. Taylor. Fermat’s last theorem. Elliptic curves, modular forms and Fermat’s last theorem (Hong Kong, 1993):2–140, 1997.</a></li>\n<li>The Boston conference volume [5]. <a href=\"https://www.google.com/books/edition/Modular_Forms_and_Fermat_s_Last_Theorem/Va-quzVwtMsC?hl=en\">G. Cornell, J. Silverman, and G. Stevens. Modular forms and Fermat’s last theorem. Springer-Verlag, 1997.</a></li>\n<li>Seminaire Bourbaki article by Oesterl´e and Serre [22] . <a href=\"http://archive.numdam.org/article/SB_1994-1995__37__319_0.pdf\">J. Oesterl´e and J.-P. Serre. Travaux de Wiles (et Taylor, . . .). Ast´erisque, 237:319–355, 1996.</a></li>\n<li>The original proof  [38].  <a href=\"http://www.scienzamedia.uniroma2.it/~eal/Wiles-Fermat.pdf\">A. Wiles. Modular elliptic curves and Fermat’s last theorem. Ann. of Math., 141:443–551, 1995.</a></li>\n<li>The original proof [34]. <a href=\"https://staff.fnwi.uva.nl/a.l.kret/Galoistheorie/taylor-wiles.pdf\">R. Taylor and A. Wiles. Ring-theoretic properties of certain Hecke algebras. Ann. of Math., 141:553–572, 1995.</a></li>\n</ul>",
        "id": 357095911,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683665228
    },
    {
        "content": "<p>Google Bard went into wide release today.  <a href=\"https://www.linkedin.com/pulse/google-bard-here-talk-fermats-last-theorem-lean-lars-warren-ericson/\">Here it is on FLT and Lean.</a>  Performance seems to be worse than Perplexity.AI, Bing Chat and ChatGPT.  Google Bard says it is memoryless with respect to queries so it can't incorporate information and results from prior queries.</p>",
        "id": 357420975,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1683761303
    },
    {
        "content": "<p>Does anyone in ML research know how systems like ChatGPT or Google Bard are trained to answer questions about themselves? It seems like if they were simply trained on the internet they would not be able to answer that kind of question at all and would just hallucinate something.</p>",
        "id": 357421439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1683761603
    },
    {
        "content": "<p>If Bard is saying that it is memoryless between queries in the same conversation, that is clearly hallucinating...</p>\n<p>During the reinforcement-learning-on-human-feedback stage there is plenty of scope for it to \"learn about itself\".</p>",
        "id": 357424890,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1683763817
    },
    {
        "content": "<p>Note that between unsupervised pre-training and RLHF, there is an intermediate phase of training called \"instruction tuning\". During instruction tuning the model is trained on dialogue-formatted samples of desired behavior: for example, saying it's a language model trained by openai, saying it doesn't know the answer to a question, and refusing to say naughty things. Then, the purpose of RLHF is to make sure that the model is calibrated (i.e says \"I don't know\" iff it doesn't know) and knows the precise boundary of what is and isn't allowed to say.</p>",
        "id": 357452817,
        "sender_full_name": "Zhangir Azerbayev",
        "timestamp": 1683777011
    },
    {
        "content": "<p>And also there is a system prompt saying something like: \"The following is a conversation between NAME, a friendly, helpful and harmless AI assistant trained by COMPANY which ...\"</p>",
        "id": 357504602,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1683793167
    },
    {
        "content": "<p>Some problem space reductions:</p>\n<ul>\n<li><a href=\"https://www.degruyter.com/document/doi/10.1515/jmc-2016-0018/html?lang=en\">An elementary proof of Fermat’s last theorem for all even exponents</a></li>\n<li><a href=\"https://www.mathematicaljournal.com/article/9/1-1-17-231.pdf\">A simple proof on Fermat’s last theorem in case of n=3</a></li>\n<li><a href=\"https://webusers.imj-prg.fr/~riccardo.brasca/files/pres.pdf\">Fermat's Last Theorem for regular primes in Lean</a></li>\n</ul>\n<p><a href=\"https://en.wikipedia.org/wiki/Regular_prime\">3 is  a regular prime</a> so the n=3 proof is subsumed by the regular prime proof, when it is available.  Given  the regular prime proof in Lean, the remaining work in Lean would be on FLT for irregular primes.</p>\n<p>I guess from the slides that  <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> 's project is ongoing.  The project was also mentioned by <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> in <a href=\"https://arxiv.org/pdf/2112.11598.pdf\">this paper</a> on how computers can help us with reasoning.</p>",
        "id": 358148740,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1684000879
    },
    {
        "content": "<p>Wiles' proof does not distinguish between the regular and irregular case. He proves semistable Taniyama-Shiumura, which doesn't have a prime in its statement.</p>",
        "id": 358155724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1684004838
    },
    {
        "content": "<p>2 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Using.20the.20LEM.20in.20a.20proof\">#new members &gt; Using the LEM in a proof</a> by <span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span>.</p>",
        "id": 358199111,
        "sender_full_name": "Notification Bot",
        "timestamp": 1684036517
    }
]