[
    {
        "content": "<p>Hello all,</p>\n<p>I am trying to create an instance of a category whose objects are True and False and whose morphisms are identity and \"not\". Here is what I tried, with some help from ChatGPT:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Cat</span>\n\n<span class=\"c1\">-- Define the morphisms (arrows) between objects</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BoolCatHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\">  </span><span class=\"c1\">-- Identity morphism</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">   </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\">  </span><span class=\"c1\">-- Identity morphism</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\">  </span><span class=\"c1\">-- A morphism representing 'not'</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"c1\">-- No morphism from True to False</span>\n\n<span class=\"c1\">-- Now declare the category instance</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CategoryStruct</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">BoolCatHom</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"w\">  </span><span class=\"c1\">-- Identity morphism is trivial (only one element in Unit)</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span><span class=\"w\">  </span><span class=\"c1\">-- Composition is trivial since morphisms are unique</span>\n\n<span class=\"c1\">-- Now we extend the Category structure by showing that the axioms hold</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">id_comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\">  </span><span class=\"c1\">-- The identity morphism is a left identity</span>\n<span class=\"w\">  </span><span class=\"n\">comp_id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\">  </span><span class=\"c1\">-- The identity morphism is a right identity</span>\n<span class=\"w\">  </span><span class=\"n\">assoc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">intros</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\">  </span><span class=\"c1\">-- Associativity of composition</span>\n</code></pre></div>\n<p>However, <code>CategoryStruct Bool</code> and <code>Category Bool</code> have error messages saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"k\">at</span>\n<span class=\"w\">  </span><span class=\"n\">CategoryStruct</span>\n<span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"bp\">?</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"m\">153</span>\n</code></pre></div>\n<p>I do not know how to fix them. I suppose Category is a class that takes in a type as a parameter, and that should be enough? I would appreciate it if anyone can answer this.</p>",
        "id": 476498711,
        "sender_full_name": "Hank",
        "timestamp": 1728714650
    },
    {
        "content": "<p>Try <code>set_option autoImplicit false</code> at the top of your file. Does the error change?</p>",
        "id": 476514443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728729533
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, <code>CategoryStruct Bool</code> and <code>Category Bool</code> no longer cause errors after adding that. Thank you!</p>",
        "id": 476569302,
        "sender_full_name": "Hank",
        "timestamp": 1728787114
    },
    {
        "content": "<p>Are you sure? No errors reported by VS Code at all?</p>",
        "id": 476583631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728803905
    },
    {
        "content": "<p>Yes, there are other errors, but I will try to fix them myself before asking further questions. I guess some of those errors are about LEAN 3 syntax that is not compatible with LEAN 4. I noticed that ChatGPT only generates LEAN 3.</p>",
        "id": 476606609,
        "sender_full_name": "Hank",
        "timestamp": 1728826214
    },
    {
        "content": "<p>I thought that the problem with your code was that you did not have <code>open CategoryTheory</code> or whatever namespace the things you're trying to use, are in.</p>",
        "id": 476607028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728826584
    },
    {
        "content": "<p>So far I have the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">CategoryTheory</span><span class=\"bp\">.</span><span class=\"n\">Category</span><span class=\"bp\">.</span><span class=\"n\">Cat</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">CategoryTheory</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">BoolCatHom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"c1\">-- Unit is a type with exactly one element, Unit.unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Category</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">Hom</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">BoolCatHom</span>\n<span class=\"w\">  </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">  </span><span class=\"c1\">-- why can I not write fun X =&gt; Unit.unit?</span>\n<span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>I currently implement <code>comp</code> by considering all cases of X, Y, and Z. But I have trouble continuing at the line before the <code>sorry</code>. The goals there are<br>\n<a href=\"/user_uploads/3121/IoUKqUIxqvQFTv4ZJNSUdU2O/image.png\">image.png</a><br>\nI believe the first goal <code>true --&gt; false</code> means <code>BoolCatHom true false</code>, which is of type Empty. So I guess this is an impossible case, but how do I close this goal?</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/IoUKqUIxqvQFTv4ZJNSUdU2O/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"537x438\" src=\"/user_uploads/thumbnail/3121/IoUKqUIxqvQFTv4ZJNSUdU2O/image.png/840x560.webp\"></a></div><p>Also, for <code>id</code>, I wonder why I cannot simply write <code>fun X =&gt; Unit.unit</code>.</p>\n<p>Any help will be appreciated.<br>\nAnd yes, I need <code>open CategoryTheory</code> so that I can use <code>Category</code> in the subsequent code. Thanks to Kevin Buzzard for pointing that out.</p>",
        "id": 495199676,
        "sender_full_name": "Hank",
        "timestamp": 1737522516
    },
    {
        "content": "<p>Just do cases on Y?</p>",
        "id": 495216671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737531621
    },
    {
        "content": "<p>By the way, reading your first post, the morphisms you're making here are not \"the identity and not\" as you can see from your definition. In fact I can't really make sense of this goal, \"not\" is a function from Bool to Bool, not a function from an element of Bool to an element of Bool</p>",
        "id": 495216892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737531720
    },
    {
        "content": "<p>Ah, I have changed my definition of morphisms here to the imply relation. </p>\n<p>The following now works</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">X</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Y</span>\n<span class=\"w\">    </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"c1\">-- since f is of type BoolCatHom false true, so f : Empty</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Z</span>\n<span class=\"w\">    </span><span class=\"k\">nomatch</span><span class=\"w\"> </span><span class=\"n\">g</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>Indeed, I need <code>cases Y</code> to turn <code>f</code> into a case like <code>true --&gt; false</code>, which is of type Empty and needs to be eliminated beforehand.</p>\n<p>If there is a better way of implementing this Bool category with \"imply\" as morphisms, please let me know. I am not sure if using <code>Unit</code> and <code>Empty</code>in <code>BoolCatHom</code> to denote which morphisms are allowed or not is the right way.</p>",
        "id": 495230981,
        "sender_full_name": "Hank",
        "timestamp": 1737536929
    },
    {
        "content": "<p><del>It looks fine to me</del>actually you're constructing data in tactic mode which is probably not good, for the data fields you should probably be using <code>match</code> rather than <code>by</code>. I guess the acid test is whether you can prove the axioms. If you can it's probably ok.</p>",
        "id": 495250596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737542611
    }
]