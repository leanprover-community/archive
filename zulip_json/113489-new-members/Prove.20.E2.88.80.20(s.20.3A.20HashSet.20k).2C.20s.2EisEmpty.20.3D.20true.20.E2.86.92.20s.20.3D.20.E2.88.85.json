[
    {
        "content": "<p>I've been able to prove some theorems about HashSets. But there is one theorem I can't work out how to prove, without which I can't prove some further theorems, namely: <code>∀(s : HashSet k), s.isEmpty = true → s = ∅</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHash</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">insert_not_empty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">congr_fun</span><span class=\"w\"> </span><span class=\"bp\">∘</span><span class=\"w\"> </span><span class=\"n\">congr_arg</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">specialize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">item</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">empty_isEmpty_eq_true</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_false_neq_empty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hempty</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">empty_isEmpty_eq_true</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hempty</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_true_eq_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hh</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hh</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">exfalso</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">eq_empty_isEmpty_true</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_empty</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">nempty_isEmpty_eq_false</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">hsize</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ssize_ne_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hsize</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ssize_zero_false</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ssize_ne_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_eq_size_eq_zero</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ssize_zero_false</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_eq_size_eq_zero</span>\n<span class=\"w\">    </span><span class=\"n\">contrapose</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_true_eq_empty</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">only_nempty_isEmpty_eq_false</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">nempty_isEmpty_eq_false</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_false_neq_empty</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">only_empty_isEmpty</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">eq_empty_isEmpty_true</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_true_eq_empty</span><span class=\"w\"> </span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 520027779,
        "sender_full_name": "aron",
        "timestamp": 1747998643
    },
    {
        "content": "<p>It's not true. <code>s := HashSet.emptyWithCapacity 1000</code> satisfies <code>s.isEmpty = true</code> but <code>s ≠ ∅</code>. <code>∅</code> is defined as <code>HashSet.emptyWithCapacity 8</code>.</p>",
        "id": 520028798,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747998983
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.ExtHashSet#doc\">docs#Std.ExtHashSet</a> if you need a hash set whose equality coincides with equality as finite sets. There we have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.ExtHashSet.isEmpty_iff#doc\">docs#Std.ExtHashSet.isEmpty_iff</a> .</p>",
        "id": 520028928,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1747999032
    },
    {
        "content": "<p>Oh ok. What's the difference between a regular <code>HashSet</code> and an <code>ExtHashSet</code> then? Do they behave more or less the same at runtime?</p>\n<p>From the <a href=\"https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtHashSet/Basic.html#Std.ExtHashSet\">docs#Std.ExtHashSet</a>:</p>\n<blockquote>\n<p>In contrast to regular hash sets, <code>[Std.ExtHashSet](https://leanprover-community.github.io/mathlib4_docs/Std/Data/ExtHashSet/Basic.html#Std.ExtHashSet)</code> offers several extensionality lemmas and therefore has more lemmas about equality of hash maps. This however also makes it lose the ability to iterate freely over hash sets.</p>\n</blockquote>\n<p>Is this the only difference? more equality lemmas and not being able to iterate over items one at a time? does the latter mean you can't fold over them either?</p>",
        "id": 520059925,
        "sender_full_name": "aron",
        "timestamp": 1748008512
    },
    {
        "content": "<p>Yes, folding over them isn't possible at the moment. In principle it's possible to fold as long as you can prove that the result of your fold doesn't depend on the order you encounter the elements in, but we don't provide this function at the moment.</p>",
        "id": 520060294,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1748008616
    },
    {
        "content": "<p>At runtime, <code>HashSet</code> and <code>ExtHashSet</code> are the same thing.</p>",
        "id": 520060434,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1748008663
    },
    {
        "content": "<p>mm ok. so what's the actual difference between them? now I feel silly having spent so much time trying to work with <code>HashSet</code>s when there was an almost identical version of it I didn't know about and don't know why I'd pick one over the other <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 520060919,
        "sender_full_name": "aron",
        "timestamp": 1748008801
    },
    {
        "content": "<p>The difference is what <code>=</code> means</p>",
        "id": 520061773,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748009007
    },
    {
        "content": "<p><code>ExtHashSet</code> is the quotient of <code>HashSet</code> by equivalence of hash sets, where two hash sets are considered equivalent if they represent the same finite set.</p>\n<p>A hash set is internally represented as an array of buckets. An array of 8 empty buckets and an array of 1024 empty buckets both represent an empty set. They are not equal as <code>HashSet</code>s, but they are equal as <code>ExtHashSet</code>s.</p>",
        "id": 520062006,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1748009072
    },
    {
        "content": "<p>All (safe) functions in Lean must respect equality, so if you use <code>ExtHashSet</code>, you get more equalities, but you cannot have functions that are able to detect the internal representation of the hash set in any way. All kinds of iteration are examples of this, because the iteration order depends on the exact way the data is represented.</p>",
        "id": 520062343,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1748009159
    },
    {
        "content": "<p>I've just realised that <code>ExtHashSet</code> doesn't have a <code>toList</code> or <code>toArray</code> function, presumably for the same reason that those would reveal its internal ordering. Which also means I can't make a <code>Hashable</code> instance for it either <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span> I don't think this is going to be usable for my needs unfortunately</p>",
        "id": 520068427,
        "sender_full_name": "aron",
        "timestamp": 1748010986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/113489-new-members/topic/Prove.20.E2.88.80.20.28s.20.3A.20HashSet.20k.29.2C.20s.2EisEmpty.20.3D.20true.20.E2.86.92.20s.20.3D.20.E2.88.85/near/520062343\">said</a>:</p>\n<blockquote>\n<p>because the iteration order depends on the exact way the data is represented.</p>\n</blockquote>\n<p>Presumably the internal ordering would depend on the hashed value, so couldn't the iteration order similarly use that hashed value ordering? since <code>ExtHashSet</code> already requires a <code>Hashable</code> instance, could that not be used to implement <code>fold</code>/<code>toList</code>/<code>toArray</code>/etc?</p>",
        "id": 520068951,
        "sender_full_name": "aron",
        "timestamp": 1748011157
    },
    {
        "content": "<p>no, the internal ordering in hash tables is not a pure function of the hashed value, it also has to do with insertion order</p>",
        "id": 520089269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748017455
    },
    {
        "content": "<p>if you have two elements with the same hash and which compare unequal, there is nothing in a hashmap's available typeclasses to be able to consistently order those two elements</p>",
        "id": 520089440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748017531
    },
    {
        "content": "<p>I think there should be a function <code>ExtHashSet.toMultiset</code> but this will have to be in mathlib</p>",
        "id": 520089596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748017574
    },
    {
        "content": "<p>There is another alternative, probably much simpler for your application, which is to use the extensional equality relation on <code>HashSet</code> spelled <code>~m</code> but without actually doing the quotient to get <code>ExtHashSet</code>. So the theorem becomes <code>∀ (s : HashSet k), s.isEmpty = true → s ~m ∅</code> which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.HashSet.equiv_empty_iff_isEmpty#doc\">docs#Std.HashSet.equiv_empty_iff_isEmpty</a></p>",
        "id": 520090341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748017859
    },
    {
        "content": "<p>in other words, just never talk about the <code>=</code> relation on HashSets, use <code>~m</code> where you would have used <code>=</code> normally and then it's as if you are using <code>ExtHashSet</code> but you can still call <code>fold</code> later</p>",
        "id": 520090750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1748018013
    },
    {
        "content": "<p>Mm ok interesting! That might do the trick. But hm this <code>~m</code> syntax doesn't seem to work for me?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_true_eq_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 520097592,
        "sender_full_name": "aron",
        "timestamp": 1748020581
    },
    {
        "content": "<p>ah nvm it works when I open the <code>Std.HashSet</code> namespace</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">HashSet</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty_true_eq_empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">~</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 520097873,
        "sender_full_name": "aron",
        "timestamp": 1748020688
    }
]