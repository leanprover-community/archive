[
    {
        "content": "<p>I previously worked through Heather MacBeth's <strong>Mechanics of Proof</strong> course completing all exercises (except 3).</p>\n<p>I am currently working through <strong>Type Theory &amp; Formal Proof</strong> by Nederpelt - my aim is to better understand how and why proof assistants work, centred around the idea of \"terms as proofs, types as propositions\".</p>\n<p>As I work through the exercises, a few voices have suggested I try writing <strong>Agda</strong> proofs to check if my own solutions are correct.</p>\n<p>I'm too old to learn YetAnotherLanguage(tm) so wondered about doing it in Lean.</p>\n<p>Previously I used Lean to do very simple proofs, mostly algebraic in nature, eg algebraic identities, and maybe include some logic eg disjunctions in the hypotheses or goals.</p>\n<p>Now I am starting to ask how to prove more general things like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi mathvariant=\"normal\">∀</mi><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>Q</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⇒</mo><msub><mi mathvariant=\"normal\">∀</mi><mrow><mi>y</mi><mo>∈</mo><mi>S</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>Q</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">∀_{x∈S} (Q(x)) ⇒ ∀_{y∈S}(P(y) ⇒Q(y))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">∀</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\">∀</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">))</span></span></span></span></span></p>\n<p>I expect I would establish a context <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>:</mo><mo>∗</mo><mo separator=\"true\">,</mo><mi>Q</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo>∗</mo><mo separator=\"true\">,</mo><mi>P</mi><mo>:</mo><mi>S</mi><mo>→</mo><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">S:*, Q:S \\to *, P:S \\to *</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∗</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord\">∗</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord\">∗</span></span></span></span> and type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi><mi>a</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>x</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>Q</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>y</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>b</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>Q</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Pi a:(\\Pi x:S . (Qx)) . ( \\Pi y:S.(\\Pi b:(Py). Qy))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">))</span></span></span></span> in Lean, somehow, and then show there is an inhabitant of the type eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>λ</mi><mi>a</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>y</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>λ</mi><mi>b</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>a</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\lambda a:(\\lambda x:S.ax).(\\lambda y:S . (\\lambda b:(Py).ay ))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">λa</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λ</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">λb</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">))</span></span></span></span>.</p>\n<p><strong>Question:</strong> Is there a beginner-friendly intro that will help me check that the inhabitants I come up with are actually of the correct type (and perhaps also check the type corresponds to the logical statement) ?</p>\n<p>In MacBeth's course,  more abstract \"sets\" were only briefly introduced.</p>",
        "id": 540038986,
        "sender_full_name": "rzeta0",
        "timestamp": 1758121245
    },
    {
        "content": "<p>you use <code>variable (term : type)</code> to set up a context, and use <code>#check (term : type)</code> to check that a term has a given type</p>",
        "id": 540043037,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758122275
    },
    {
        "content": "<p>Thanks Kenny. I'm not familiar enough to know where these 'variable' and 'check' go in a lean program. Is there anywhere I can read simple examples?</p>",
        "id": 540050184,
        "sender_full_name": "rzeta0",
        "timestamp": 1758124130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> they just go on their own lines.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">fib</span><span class=\"w\"> </span><span class=\"mi\">1000</span>\n</code></pre></div>",
        "id": 540051585,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758124490
    },
    {
        "content": "<p>to run the example program above, click the button on the top right corner of the textbox when your mouse hovers over it</p>",
        "id": 540051676,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758124517
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/MHfj7bHY6kWGRHWSE6WQ4lyr/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/MHfj7bHY6kWGRHWSE6WQ4lyr/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"943x211\" src=\"/user_uploads/thumbnail/3121/MHfj7bHY6kWGRHWSE6WQ4lyr/image.png/840x560.webp\"></a></div>",
        "id": 540051743,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758124535
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/advice.20on.20learning.20to.20prove.20inhabitant.20has.20given.20type/near/540038986\">said</a>:</p>\n<blockquote>\n<p>Now I am starting to ask how to prove more general things like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msub><mi mathvariant=\"normal\">∀</mi><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>Q</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>⇒</mo><msub><mi mathvariant=\"normal\">∀</mi><mrow><mi>y</mi><mo>∈</mo><mi>S</mi></mrow></msub><mo stretchy=\"false\">(</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>⇒</mo><mi>Q</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">∀_{x∈S} (Q(x)) ⇒ ∀_{y∈S}(P(y) ⇒Q(y))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">∀</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1774em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord\">∀</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⇒</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">))</span></span></span></span></span><br>\n</p>\n</blockquote>\n<p>Your first step should be \"how do I _state_ this in Lean\", because until you do that Lean has no way to check the proof</p>",
        "id": 540079055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758133940
    },
    {
        "content": "<p>I would hope that Mechanics of Proof has prepared you for such a task, but if it hasn't this <em>statement</em> seems like something you could ask any remotely competent language model to translate, which should hopefully remind you how to do this kind of translation in future</p>",
        "id": 540079280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1758134020
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> </p>\n<p>I'll try what you suggest. How do you write * in Lean? </p>\n<p>The following doesn't work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Thanks in advance for your patience with a beginner !</p>",
        "id": 540088999,
        "sender_full_name": "rzeta0",
        "timestamp": 1758137612
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> <code>*</code> is indeed not a valid Lean syntax. What does it mean?</p>",
        "id": 540089094,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758137644
    },
    {
        "content": "<p>I suppose it means <code>Unit</code>?</p>",
        "id": 540089125,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758137658
    },
    {
        "content": "<p>it means <code>Type</code></p>",
        "id": 540089507,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758137809
    },
    {
        "content": "<p>or maybe it means <code>Prop</code></p>",
        "id": 540089572,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758137838
    },
    {
        "content": "<p>note that Prop in Agda behaves differently from Lean</p>",
        "id": 540089665,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758137883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  It is the \"type of types\".</p>\n<p>So 3 has type \"Int\" and \"Int\" has type *. (And * has type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">□</mi></mrow><annotation encoding=\"application/x-tex\">\\Box</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.675em;\"></span><span class=\"mord amsrm\">□</span></span></span></span>)</p>\n<p>In the textbook I'm following the idea is that propositions have type * too, and inhabitants of such types are proofs. So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>:</mo><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">S:*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord\">∗</span></span></span></span> corresponds to a set and $$$P:S \\to *$$ corresponds to a proposition on that set.</p>\n<p>(I'm still new to this so might bit a bit imprecise)</p>",
        "id": 540089813,
        "sender_full_name": "rzeta0",
        "timestamp": 1758137942
    },
    {
        "content": "<p>propositions and Int can't have the same type</p>",
        "id": 540089869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758137965
    },
    {
        "content": "<p>in Lean <code>3 : Int</code> and <code>Int : Type</code></p>",
        "id": 540089896,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758137975
    },
    {
        "content": "<p>(and <code>Type : Type 1</code>)</p>",
        "id": 540089913,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758137983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>  is this related to <code>u_1</code> and <code>u_2</code> that I once saw?</p>\n<p>I will try <code>Type</code> as you suggest.</p>",
        "id": 540090043,
        "sender_full_name": "rzeta0",
        "timestamp": 1758138025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/advice.20on.20learning.20to.20prove.20inhabitant.20has.20given.20type/near/540089813\">said</a>:</p>\n<blockquote>\n<p>In the textbook I'm following the idea is that propositions have type * too, and inhabitants of such types are proofs. So <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>:</mo><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">S:*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord\">∗</span></span></span></span> corresponds to a set and $$$P:S \\to *$$ corresponds to a proposition on that set.</p>\n</blockquote>\n<p>in Lean what makes propositions different from all the other types is that any two proofs are definitionally equal (and also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=propext#doc\">docs#propext</a> but that's an <code>axiom</code>) (and also impredicativity but that's not relevant right now)</p>",
        "id": 540090181,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758138074
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> .. I'm sure as I progress through the book I will better understand and see the implementation decisions in Lean like this one you suggest about definitional equality.</p>",
        "id": 540090405,
        "sender_full_name": "rzeta0",
        "timestamp": 1758138155
    },
    {
        "content": "<p>I would say something like this would be an equivalent of your statement in Lean?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 540090675,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758138254
    },
    {
        "content": "<p>And the proof is probably also equivalent to what you have written at the beginning (without explicit type annotations):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 540090977,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758138365
    },
    {
        "content": "<p>In Lean there's no type of all types, hence those <code>u_1</code> <code>u_2</code> you mentioned were invented. These are called universes. I'm sure you'll understand it as you progress through tutorials. If you want to avoid them, then I think you can state what you want just like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>",
        "id": 540093726,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758139342
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span>  your code examples are ideal for me to study.</p>\n<p>I think I understand most of the code, the exception is <code>fun</code> which I've not seen before so will explore that.</p>",
        "id": 540106395,
        "sender_full_name": "rzeta0",
        "timestamp": 1758145009
    },
    {
        "content": "<p>it's a lambda abstraction</p>",
        "id": 540106417,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758145025
    },
    {
        "content": "<p>it's the same as what you wrote as λ</p>",
        "id": 540106425,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758145036
    },
    {
        "content": "<p>thanks Aaron and Kenny.</p>\n<p>Is there a way to check with Lean that the logical statement :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is in fact the type :</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi><mi>a</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>x</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi>Q</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>y</mi><mo>:</mo><mi>S</mi><mi mathvariant=\"normal\">.</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Π</mi><mi>b</mi><mo>:</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi><mi>Q</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\Pi a:(\\Pi x:S . (Qx)) . ( \\Pi y:S.(\\Pi b:(Py). Qy))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord\">.</span><span class=\"mopen\">(</span><span class=\"mord\">Π</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">Q</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">))</span></span></span></span></span></p>",
        "id": 540106604,
        "sender_full_name": "rzeta0",
        "timestamp": 1758145144
    },
    {
        "content": "<p>well just look at it</p>",
        "id": 540106632,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758145161
    },
    {
        "content": "<p>no, there is currently no way to go from Lean code to an arbitrary language that you just specified</p>",
        "id": 540106702,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1758145196
    },
    {
        "content": "<p>you can also write this as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>this is the same type to Lean</p>",
        "id": 540106919,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1758145302
    },
    {
        "content": "<p>That's one of the disadvantages of any formal language. You can write some definitions in this language (e.g Lean) and prove some statements about these definitions. But the only way to relate those formal definitions and statements with anything that doesn't have a formal computer specification is to do manual review by humans. And for this the human has to understand semantics of both the formal language and the pen-and-paper definition.</p>",
        "id": 540111776,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1758148181
    }
]