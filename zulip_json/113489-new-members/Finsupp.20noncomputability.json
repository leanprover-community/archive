[
    {
        "content": "<p>I am trying to work with <code>Finsupp</code> over a <code>DecidableEq</code> target. However, many of my definitions end up being <code>noncomputable</code> because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.single#doc\">docs#Finsupp.single</a> is. I'd <em>like</em> to have as much of my (very finite) theory to be as computable as possible, since I don't see a good reason for it not to be, and I enjoy being able to #eval on occasion.</p>\n<p>I've been getting round this by just using functions from my finite base set to the target, but then when I want to talk about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Basis#doc\">docs#Module.Basis</a> I have to restate a lot of my work. It would be nicer if I could just define the basis and work with it, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Module.Basis.instFunLike#doc\">docs#Module.Basis.instFunLike</a> is not computable for this reason.</p>\n<p>Have others come across this? What is the recommended way to think about functions from finite types (functions or Finsupps?) Am I asking too much for a computable theory (e.g. I have my own computable version of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.equivFunOnFinite#doc\">docs#Finsupp.equivFunOnFinite</a>)?</p>\n<p>On a more technical level, this feels like function specialisation: if we have <code>DecidableEq M</code> then we can use a computable version of <code>Finsupp.single</code> but if not, we could fall back. However, I vaguely know that this is a whole can of confusion and debugging troubles in other languages. Does lean4 do it?</p>",
        "id": 576412101,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772274913
    },
    {
        "content": "<p>Well, there's also <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DFinsupp#doc\">docs#DFinsupp</a> which <em>does</em> have computable API.</p>",
        "id": 576412830,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1772275570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span></p>",
        "id": 576412842,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1772275582
    },
    {
        "content": "<p>I've recently though about this exact same problem, improving <code>Finsupp.single</code> and I come up to the conclusion that in principle is doable, but it may be very annoying and I stopped as at the end it was not exactly what I needed. Something that I don't understand is why <code>Finsupp</code> and <code>DFinsupp</code> have different designs, but maybe it is just beacuse of historical reasons.</p>",
        "id": 576413164,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772275895
    },
    {
        "content": "<p>The easiest thing to do is probably just to use <code>DFinsupp</code>.</p>",
        "id": 576413182,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772275912
    },
    {
        "content": "<p>Hmm. I think the ripple effect to Module.Basis means there isn't much of a point for me</p>",
        "id": 576413417,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772276131
    },
    {
        "content": "<p>When you say it was annoying, what was the reason for that? Lots of downstream updates needed? Presumably some applications don't want to enforce <code>DecidableEq</code></p>",
        "id": 576413464,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772276171
    },
    {
        "content": "<p>Yes, that's the point. noncomputable stuff is so embedded into mathlib that it is basically impossible to get something computable unless it is very very basic.</p>",
        "id": 576413493,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772276209
    },
    {
        "content": "<p>We cannot assume <code>DefidableEq M</code> in <code>Finsupp.single</code> as this is used for polynomials (for example), and we surely want polynomials over the reals. We can of course have two versions, but it's a nightmare to maintain a parallel library if you need things that are quite advanced in the library.</p>",
        "id": 576413605,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772276313
    },
    {
        "content": "<p>What we, as human beings, do is to use <code>DecidableEq</code>if this is available for obvious reasons, and ignore it (i.e. we use choice and in our brain we know that we moved in the world where we can prove things but not evaluating stuff). I guess we just don't know how to teach a computer to do that yet</p>",
        "id": 576413860,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772276540
    },
    {
        "content": "<p>Yeah, that makes sense, but is unfortunate. I think I was hoping that there was a way to override definitions, such as \"use this one if we have decidability, otherwise fall back to this noncomputable theory\" as you describe us doing manually. However, I also see that having two definitions (one for computable and one for noncomputable theory) would be a nightmare.</p>\n<p>Is the implicit conclusion that the mathlib ecosystem is comfortable with things being needlessly noncomputable?</p>\n<p>(aside, do I misunderstand <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Real.decidableEq%3F#doc\">docs#Real.decidableEq?</a> I also thought it was undecidable)</p>",
        "id": 576414128,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772276768
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Real/Basic.html#Real.decidableEq\">link</a>, because the docs go 404)</p>",
        "id": 576414222,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772276838
    },
    {
        "content": "<p>Ah sorry, I didn't realize we have that. Anyway it comes from</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">linearOrder</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Lattice</span><span class=\"bp\">.</span><span class=\"n\">toLinearOrder</span><span class=\"w\"> </span><span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>so using choice under the hood and in practice it cannot be used.</p>",
        "id": 576414620,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772277178
    },
    {
        "content": "<p>This can work in practice, add <code>DecidableEq</code> (using choice) on all concrete types that don't have it. Anyway you can just try to open a PR improving <code>Finsupp.single</code> and see what happens. I didn't spend a lot of time with it because the first file broke quite badly, but maybe the rest is OK.</p>",
        "id": 576414773,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772277327
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib4/pull/25273\">#25273</a> is a prerequisite to unifying <code>Finsupp</code> and <code>DFinsupp</code> painlessly. I am actively working on it</p>",
        "id": 576414789,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1772277346
    },
    {
        "content": "<p>I was pinging you asking exactly this, but you were faster :)</p>",
        "id": 576414822,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772277383
    },
    {
        "content": "<p>Is it possible to make \"leaf\" definitions of the API computable, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.zipWith#doc\">docs#Finsupp.zipWith</a> ?</p>",
        "id": 576415013,
        "sender_full_name": "Snir Broshi",
        "timestamp": 1772277555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"933054\">Snir Broshi</span> <a href=\"#narrow/channel/113489-new-members/topic/Finsupp.20noncomputability/near/576415013\">said</a>:</p>\n<blockquote>\n<p>Is it possible to make \"leaf\" definitions of the API computable, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finsupp.zipWith#doc\">docs#Finsupp.zipWith</a> ?</p>\n</blockquote>\n<p>If you want to make something computable you need to find the source of noncomputability, so you should more go in the opposite direction. Something else that can be done is to replace a noncomputable def <code>X</code> with a computable <code>X'</code> and prove that <code>X = X'</code>, but this works only if defining <code>X'</code> is possible without using all the machinery used in <code>X</code> (maybe because we want <code>X'</code> in a more specific situation).</p>",
        "id": 576415186,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772277699
    },
    {
        "content": "<p>Ok, I'll have a go in my little project (amusingly, a different type of MonoidAlgebra to <a href=\"https://github.com/leanprover-community/mathlib4/pull/25273\">#25273</a>) at seeing how bad it would be to improve Finsupp.single.</p>\n<p>However, I'm not even sure what \"improve\" means in this case, since we want both theories. Would it look like having both <code>X</code> and <code>X'</code>?</p>",
        "id": 576415303,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772277806
    },
    {
        "content": "<p>I mean to make the current <code>Finsupp.single</code> computable. If you look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/DFinsupp/Defs.html#DFinsupp.single\">DFinsupp.single</a> you see that one has to assume that the source has decidable equality, but not the target. But if <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> is already doing that in making all the <code>Finsupp</code> API a special case of the <code>DFinsupp</code> API maybe it's better to just wait</p>",
        "id": 576415656,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772278070
    },
    {
        "content": "<p>There is work which can be done now, which is to switch basis to use DFinsupp instead of Finsupp; I have a stale PR somewhere that attempts this</p>",
        "id": 576415916,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1772278269
    },
    {
        "content": "<p>If finsupp becomes a special case of dfinsupp, then presumably its ok to leave the basis definition as-is? Am I reading it wrong that we'd want to define basis as something like <code>M ≃ₗ[R] Π₀ ι, R</code>?</p>",
        "id": 576416331,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772278655
    },
    {
        "content": "<p>Morally <code>Finsupp</code> is a special case of <code>DFinsupp</code>, so there is no need to have two separate APIs (we can always specialize theorems to the <code>Finsupp</code> case) and the most natural thing to do is to make everything for <code>Finsupp</code> and adding specialized version only when something goes wrong (sometimes Lean struggles to understand how to specialize a dependent version of something to the non-dependent version). <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> do you plan to work on this after the monoid algebra thing?</p>\n<p>What Eric is suggesting is to start removing uses of <code>Finsupp</code> and replacing them with <code>DFinsupp</code>.</p>\n<p>Both approaches look reasonable to me, and they can also be done in parallel.</p>",
        "id": 576416734,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772278985
    },
    {
        "content": "<p>I see. So we'll write the definition of a basis in terms of a dependent finite support where there is actually no dependency?</p>",
        "id": 576417050,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772279228
    },
    {
        "content": "<p>Yes, letting <code>β</code> in <code>DFinsupp</code> be the constant function <code>fun _ ↦ M</code> should give exactly <code>Finsupp</code>.  The PR mentioned by <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is I think <a href=\"https://github.com/leanprover-community/mathlib4/pull/25170\">#25170</a>.</p>",
        "id": 576417974,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772279908
    },
    {
        "content": "<p>Great. Makes sense, thanks</p>",
        "id": 576418114,
        "sender_full_name": "Robert Spencer",
        "timestamp": 1772280003
    },
    {
        "content": "<p>If you believe the script Claude wrote for me the following is the graph of noncomputable declarations <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Basis/Defs.html#Module.Basis.instFunLike\">Module.Basis.instFunLike</a> depends on.<br>\n<a href=\"/user_uploads/3121/BT8O5O7TWQf1WSLOumcEripR/graphviz.jpeg\">graphviz.jpeg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/BT8O5O7TWQf1WSLOumcEripR/graphviz.jpeg\" title=\"graphviz.jpeg\"><img data-original-content-type=\"image/jpeg\" data-original-dimensions=\"2479x3183\" src=\"/user_uploads/thumbnail/3121/BT8O5O7TWQf1WSLOumcEripR/graphviz.jpeg/840x560.webp\"></a></div>",
        "id": 576419169,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772280784
    },
    {
        "content": "<p>In particular it seems making <code>Finsupp.single</code> computable is not enough.</p>",
        "id": 576419213,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772280831
    },
    {
        "content": "<p>to be clear, is the eventual goal to phase out Finsupp in favor of DFinsupp? I recall this document about all the different possible approaches to Finsupp computability, I'm not sure if we ever concluded DFinsupp was the \"correct\" one.</p>",
        "id": 576419382,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772280995
    },
    {
        "content": "<p>I think there is no eventual goal, this discussion started like 2 hours ago :)</p>",
        "id": 576419561,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1772281183
    },
    {
        "content": "<p>Yaël has clearly been thinking about this for like a year at this point, that wider discussion is what I'm asking about</p>",
        "id": 576420442,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1772282030
    }
]