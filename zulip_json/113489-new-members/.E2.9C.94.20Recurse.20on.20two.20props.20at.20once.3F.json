[
    {
        "content": "<p>I have an inductive prop called <code>UnificationRelation</code> whose constructors contains many recursive instances of itself. I'd like to prove this theorem about it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">UnificationRelation</span><span class=\"bp\">.</span><span class=\"n\">uniqueness</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">ctx₁</span><span class=\"w\"> </span><span class=\"n\">ctx₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TyMaybe</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">res₁</span><span class=\"w\"> </span><span class=\"n\">res₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TyMaybe</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UnificationRelation</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">res₁</span><span class=\"w\"> </span><span class=\"n\">ctx₁</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UnificationRelation</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">res₂</span><span class=\"w\"> </span><span class=\"n\">ctx₂</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">res₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">res₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ctx₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ctx₂</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I.e. I'd like to prove a property based on two <code>UnificationRelation</code>s as input. I originally tried to prove this using straightforward <code>cases</code> and calling the theorem recursively for nested instances of the relation but this resulted in me having a very rough time trying to prove termination.</p>\n<p>So I am now trying to do this using the <code>UnificationRelation.rec</code> recursor with this motive</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"bp\">@</span><span class=\"n\">UnificationRelation</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">res₁</span><span class=\"w\"> </span><span class=\"n\">ctx₁</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">UnificationRelation</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">res₂</span><span class=\"w\"> </span><span class=\"n\">ctx₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">res₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">res₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ctx₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ctx₂</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but this isn't giving me the hypotheses I need to prove that the property holds. I suspect that this is because it's treating the 2nd prop as a black box.</p>\n<p>So in order to fix this I think I'd need to recurse over both <code>h₁</code> and <code>h₂</code> at the same time. Is that something you can do in Lean?</p>",
        "id": 526233296,
        "sender_full_name": "aron",
        "timestamp": 1751152350
    },
    {
        "content": "<p>Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 526233314,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751152382
    },
    {
        "content": "<p><code>revert h\\2; induction h\\1</code></p>",
        "id": 526233324,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751152386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> not without either dumping a ton of context or alternatively spending an huge amount of time trying to cut my code down to a smaller amount that still captures all the problems I've got in my actual code <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 526233364,
        "sender_full_name": "aron",
        "timestamp": 1751152471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> sorry what is this? a tactic? what do I do with this?</p>",
        "id": 526233379,
        "sender_full_name": "aron",
        "timestamp": 1751152502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>, that's better spelt <code>induction h1 generalizing h2</code>, though generalizing a prop seems pointless</p>",
        "id": 526234063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1751153652
    },
    {
        "content": "<p>Probably what you actually want is <code>induction h₁ generalizing res₂ ctx₂</code></p>",
        "id": 526234090,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751153704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Recurse.20on.20two.20props.20at.20once.3F/near/526233296\">said</a>:</p>\n<blockquote>\n<p>I originally tried to prove this using straightforward <code>cases</code> and calling the theorem recursively for nested instances of the relation but this resulted in me having a very rough time trying to prove termination.</p>\n</blockquote>\n<p>Usually if you are recursing on a proof this technique <em>doesn't</em> work</p>",
        "id": 526234127,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751153768
    },
    {
        "content": "<p>I disagree, there's definitely times where you need bi-induction</p>",
        "id": 526234530,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751154469
    },
    {
        "content": "<p>Yes, but recursively calling the theorem inside itself will always leave you with an impossible termination proof</p>",
        "id": 526234546,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751154508
    },
    {
        "content": "<p>You have to get bi-induction a different way</p>",
        "id": 526234552,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751154523
    },
    {
        "content": "<p>oh, I missed the \"calling the theorem recursively\".... yes I agree, never call the theorem please</p>",
        "id": 526234557,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751154534
    },
    {
        "content": "<p>(why not?)</p>",
        "id": 526234620,
        "sender_full_name": "aron",
        "timestamp": 1751154639
    },
    {
        "content": "<p>but either way, that's fine. but what <em>do</em> i need to do to prove a theorem that requires doing induction on two props at the same time?</p>",
        "id": 526234622,
        "sender_full_name": "aron",
        "timestamp": 1751154643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Recurse.20on.20two.20props.20at.20once.3F/near/526234620\">said</a>:</p>\n<blockquote>\n<p>(why not?)</p>\n</blockquote>\n<p>just don't, lol</p>",
        "id": 526234638,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751154669
    },
    {
        "content": "<p>there's already the tactic <code>induction</code></p>",
        "id": 526234646,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1751154681
    },
    {
        "content": "<p>but induction almost never lets me do what I want to do. It only gives me very specific inductive functions that don't actually let me create the propositions I want to create</p>",
        "id": 526235534,
        "sender_full_name": "aron",
        "timestamp": 1751155938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Recurse.20on.20two.20props.20at.20once.3F/near/526235534\">said</a>:</p>\n<blockquote>\n<p>but induction almost never lets me do what I want to do. It only gives me very specific inductive functions that don't actually let me create the propositions I want to create</p>\n</blockquote>\n<p>I find that that's often not the case</p>",
        "id": 526235914,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751156560
    },
    {
        "content": "<p>can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 526235922,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751156581
    },
    {
        "content": "<p>I managed to do it!! Indeed by doing <code>induction h₁ generalizing res₂ ctx₂</code> which let me prove everything I needed to! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p><a href=\"/user_uploads/3121/_jg41uzI0dK-x0Yd0M-WIJdC/Screenshot-2025-06-29-at-01.58.51.png\">Screenshot 2025-06-29 at 01.58.51.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/_jg41uzI0dK-x0Yd0M-WIJdC/Screenshot-2025-06-29-at-01.58.51.png\" title=\"Screenshot 2025-06-29 at 01.58.51.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"989x405\" src=\"/user_uploads/thumbnail/3121/_jg41uzI0dK-x0Yd0M-WIJdC/Screenshot-2025-06-29-at-01.58.51.png/840x560.webp\"></a></div>",
        "id": 526237499,
        "sender_full_name": "aron",
        "timestamp": 1751158958
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> has marked this topic as resolved.</p>",
        "id": 526237537,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751159014
    },
    {
        "content": "<p>Thanks everyone for your help! now I've got another technique in my toolbelt for proving theorems on two props at once: induction with generalizing on the right variables + doing a <code>cases</code> split inside each induction case to narrow in on the right constructor for both props at once</p>",
        "id": 526237604,
        "sender_full_name": "aron",
        "timestamp": 1751159116
    }
]