[
    {
        "content": "<p>I'm teaching a course on logic to first year computer engineering students.  One of the topics is formalizing English sentences in logic.  To do this, we construct some uninterpreted types and functions, then write additional formulas in terms of these uninterpreted types and functions.</p>\n<p>Sometimes we need to define an ordering relation (e.g., ≤) on the uninterpreted type.  I would like the students to be able to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Rank</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">Overload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Rank</span>\n</code></pre></div>\n<p>and have <code>Overload (≤) Rank</code> expand to:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">LE_Rank</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Rank</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Rank</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Rank</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LE_Rank</span>\n</code></pre></div>\n<p>The macro I have written is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">macro</span><span class=\"w\"> </span><span class=\"s2\">\"Overload\"</span><span class=\"w\"> </span><span class=\"s2\">\"(≤)\"</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">LE_foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">    </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">LE_foo</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which works, except that the name of the definition <code>LE_foo</code> is hard coded.  I would like to construct a  name based on <code>$ty</code>.</p>\n<p>-mark</p>",
        "id": 501936709,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740530295
    },
    {
        "content": "<p>How's this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"s2\">\"Overload\"</span><span class=\"w\"> </span><span class=\"s2\">\"(≤)\"</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span><span class=\"bp\">.</span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">whnf</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">throwErrorAt</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"s2\">\"Could not guess name\"</span>\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">name</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkIdentFromRef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`LE</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span><span class=\"bp\">.</span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">    </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">      </span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ident</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">addConstInfo</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`LE</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Rank</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">Overload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Rank</span>\n</code></pre></div>",
        "id": 501940061,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740532303
    },
    {
        "content": "<p>Though <code>axiom</code> is not a great pattern here</p>",
        "id": 501940257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740532402
    },
    {
        "content": "<p>If you do really want <code>axiom</code>, you could also skip the <code>Overload</code> syntax with <code>@[instance] axiom Rank.instLE : LE Rank</code></p>",
        "id": 501940374,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740532454
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> - thanks.</p>\n<p>One question, you wrote \"<code>axiom</code> is not a great pattern here\".  What would be a better alternative?  I chose <code>axiom</code>simply because it was the first idea I had that worked.</p>\n<p>-mark</p>",
        "id": 501944936,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740534952
    },
    {
        "content": "<p>You can use <code>variable</code></p>",
        "id": 501946957,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740536078
    },
    {
        "content": "<p>I originally tried <code>variable</code>, but ran into problems:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>gives an error on <code>q x</code>, because Lean expects the first argument of <code>q</code> to be an instantiation of <code>p</code>.</p>\n<p>If either <code>Ty</code> or <code>x</code> is a variable, I get an error with the <code>q x</code> in the definition of <code>r</code>.  For <code>Ty</code>, I could use either <code>inductive Ty</code> or <code>axiom Ty : Type</code>.  For <code>p</code>, the only solution I've found is <code>axiom</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ty</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>-mark</p>",
        "id": 502083449,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740585589
    },
    {
        "content": "<p>Another option is to use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyContext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">export</span><span class=\"w\"> </span><span class=\"n\">MyContext</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MyContext</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>This has the big advantage over <code>axiom</code> that you can go back and apply these results to some concrete <code>Ty</code></p>",
        "id": 502086194,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1740586237
    },
    {
        "content": "<p>If you don't care about which relation you get, you can use <code>opaque</code> instead of <code>axiom</code> (the rhs is just to show that <code>LE $id</code> is inhabited):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Command</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"k\">in</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">:</span><span class=\"s2\">\"Overload\"</span><span class=\"w\"> </span><span class=\"s2\">\"(≤)\"</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">liftCoreM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">realizeGlobalConstNoOverload</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkIdentFromRef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`LE</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">elabCommand</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">addConstInfo</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"ss\">`LE</span><span class=\"o\">)</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">MyType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"n\">Overload</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">MyType</span>\n</code></pre></div>\n<p>Although I'm not quite sure why you'd want an LE relation without any knowledge about its properties.</p>",
        "id": 502088475,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740586856
    },
    {
        "content": "<p>Aaron, Eric, Robin -<br>\nThanks for the insightful answers.  It's very helpful to see a variety of alternatives.</p>\n<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> : I'm teaching students to formalize English sentences into logic.  The first step is to define an environment of uninterpreted types, functions, relations, etc.  Hence, I want <code>&lt;</code> as uninterpreted.</p>\n<p>-mark</p>",
        "id": 502091111,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740587503
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> I would do it in exactly the opposite way: define <code>opaque MyType : Type</code> and then set up <code>LE MyType</code> as an axiom</p>",
        "id": 502166645,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740613722
    },
    {
        "content": "<p>but maybe it's just a question of personal style</p>",
        "id": 502166848,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740613839
    },
    {
        "content": "<p><code>opaque</code> is good because it prevents the introduction of a proof of <code>false</code> (or at least that's my understanding)</p>",
        "id": 502167054,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1740613948
    },
    {
        "content": "<p>Or both <code>opaque</code>! And yes, axioms by nature can introduce proofs of <code>False</code> if you are not careful enough. That, and it's slightly weird to see a ton of obscure axioms when you look at <code>#print axioms</code> (which is probably not relevant here but I just wanted to note).</p>",
        "id": 502609678,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1740757987
    },
    {
        "content": "<p>I like the idea of making both the type and LE function <code>opaque</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"873547\">@Robin Arnez</span> -  I'm having difficulty understanding your elaboration function.  Superficially, it looks like it is the equivalent of:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">Ty1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kd\">@[</span><span class=\"n\">instance</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">LE_Ty1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"n\">Ty1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>But, the above doesn't typecheck because <code>fun _ _ =&gt; True</code> doesn't have the type <code>LE Ty1</code>.  What am I missing?</p>",
        "id": 502630370,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740763905
    },
    {
        "content": "<p>Not <code>(fun _ _ =&gt; True)</code>, but <code>⟨fun _ _ =&gt; True⟩</code>.</p>",
        "id": 502634128,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740765151
    },
    {
        "content": "<p>(note the brackets)</p>",
        "id": 502634156,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1740765164
    },
    {
        "content": "<p>Ah, ok.  Thanks.  I've been bitten by that before when transcribing code.  I should have thought of the brackets.</p>",
        "id": 502638152,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1740766327
    }
]