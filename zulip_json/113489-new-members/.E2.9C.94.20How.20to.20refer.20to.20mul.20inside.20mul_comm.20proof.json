[
    {
        "content": "<p>Hello,</p>\n<p>I have defined an operation in a CommMagma, and I need to prove that the multiplication is commutative. At some point I need to unfold the definition of <code>*</code> to be able to reason about it, but I just get <code>unknown constant 'mul'</code>. How should I refer to mul?</p>\n<p>Here's a mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The linear heap is just a finite map from Integers to values -/</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">LinearHeap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Val</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Val</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommMagma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearHeap</span><span class=\"w\"> </span><span class=\"n\">Val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">                  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">                  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">                  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">Disjoint</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"bp\">∪</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"n\">mul_comm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"c1\">-- unknown constant 'mul' ??</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I did manage to get the exact same proof working outside of the instance though</p>",
        "id": 468402427,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725712622
    },
    {
        "content": "<p>You can use <code>change</code>, i.e. <code>change ite .. = ite ..</code></p>",
        "id": 468402919,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725712814
    },
    {
        "content": "<p>Oh that did work, thank you very much!</p>",
        "id": 468414164,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725716811
    },
    {
        "content": "<p>Do you have any documentation on what change does? I can't find it</p>",
        "id": 468414346,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725716925
    },
    {
        "content": "<p>But also, is there no way to refer to the function <code>mul</code> that is used in my current goal?</p>",
        "id": 468414759,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725717175
    },
    {
        "content": "<p>Hmm.. I'm still stuck, but now with another goal (mul_assoc...). Again, I need to unfold the definition of the multiplication but I have no idea how to do it. I'm surprised it's impossible to reference the operator I'm proving properties about within the proof.</p>",
        "id": 468447750,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725731060
    },
    {
        "content": "<p>You can hover over a tactic to see its docstring</p>",
        "id": 468507566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1725768568
    },
    {
        "content": "<p>Use command <code>set_option pp.notation false</code> to turn off notation and <code>*</code> will be displayed as a function application. I'm suspecting that it is not called <code>mul</code>.</p>\n<p>Likely <code>simp[HMul.hMul]</code> will work.</p>",
        "id": 468527796,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725781368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> yes this did work! I realised I could also hover on the <code>*</code> symbol in the lean view to see the real name of the definition.</p>",
        "id": 468835351,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725895758
    },
    {
        "content": "<p>Thank you for your help!</p>",
        "id": 468835383,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725895764
    },
    {
        "content": "<p>One last question maybe. In my class I proved <code>mul_comm</code> and <code>one_mul</code>, and I would like to re-use these two results to prove <code>mul_one</code> without rewriting a proof from scratch. Is there a way to refer to <code>mul_comm</code> and <code>one_mul</code> from within the <code>mul_one</code> proof, or do I have to give them proper names outside my class definition?</p>",
        "id": 468835914,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725895868
    },
    {
        "content": "<p>likely <code>ClassName.mul_comm</code> should work</p>",
        "id": 468836792,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725896018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20refer.20to.20mul.20inside.20mul_comm.20proof/near/468836792\">said</a>:</p>\n<blockquote>\n<p>likely <code>ClassName.mul_comm</code> should work</p>\n</blockquote>\n<p>Hmm if I do this it tells me that it failed to synthesie <code>ClassName</code> for this type. Which makes sense, I'm currently instantiating this class</p>",
        "id": 468839886,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725896547
    },
    {
        "content": "<p>I think you do need to give them proper names first</p>",
        "id": 468851716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725898877
    },
    {
        "content": "<p>In your example, a good solution would be to write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">YourType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommMagma</span><span class=\"w\"> </span><span class=\"n\">YourType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"n\">mul_comm</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CommMonoid</span><span class=\"w\"> </span><span class=\"n\">YourType</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">   </span><span class=\"c1\">-- can use `mul_comm` here</span>\n</code></pre></div>",
        "id": 468852270,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725898953
    },
    {
        "content": "<p>Thank you! Yes this makes sense.<br>\nIn my case I need both <code>mul_comm</code> and <code>one_mul</code> to prove <code>mul_one</code>, but just giving it an outside name works</p>",
        "id": 469044715,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725961479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"752473\">Sacha Ayoun</span> has marked this topic as resolved.</p>",
        "id": 469044735,
        "sender_full_name": "Notification Bot",
        "timestamp": 1725961484
    },
    {
        "content": "<p><del>You might also want <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommMonoid.ofMinimalAxioms#doc\">docs#CommMonoid.ofMinimalAxioms</a> </del> edit: doesn't exist!</p>",
        "id": 469048450,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1725962403
    },
    {
        "content": "<p>This is in the process of defining partial commutative monoids, i.e. commutative monoids where the multiplication is partial.<br>\nI'm new to theorem provers, but I know that it is common in Coq to define it as a commutative monoid, together with a validity function, such that if the multiplication <code>a * b</code> is undefined, it produces an invalid value</p>",
        "id": 469057439,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725965528
    },
    {
        "content": "<p>The Mathlib <code>Monoid</code> class is not well adapted here, since for most PCMs, a * a is already undefined, so defining a^n  is not very relevant</p>",
        "id": 469057579,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725965590
    },
    {
        "content": "<p>So currently I defined it as </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PartialMagma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Mul</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">valid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"w\">  </span><span class=\"n\">valid_mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">PartialCommMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">Semigroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">CommMagma</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">PartialMagma</span><span class=\"w\"> </span><span class=\"n\">M</span>\n</code></pre></div>",
        "id": 469057838,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725965676
    },
    {
        "content": "<p>I'm not sure if this is the right approach</p>",
        "id": 469057907,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725965701
    },
    {
        "content": "<p>If you only have a single invalid element this is just a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommMonoidWithZero#doc\">docs#CommMonoidWithZero</a></p>",
        "id": 469058687,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725965976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"752473\">Sacha Ayoun</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20to.20refer.20to.20mul.20inside.20mul_comm.20proof/near/469057579\">said</a>:</p>\n<blockquote>\n<p>The Mathlib <code>Monoid</code> class is not well adapted here, since for most PCMs, a * a is already undefined, so defining a^n  is not very relevant</p>\n</blockquote>\n<p>You can just set <code>npow</code> to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=npowRec#doc\">docs#npowRec</a></p>",
        "id": 469059062,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1725966091
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Partial.20Commutative.20Monoids\">#Is there code for X? &gt; Partial Commutative Monoids</a> for cross reference, in the unlikely event that you're not already connected.</p>",
        "id": 469059864,
        "sender_full_name": "Julian Berman",
        "timestamp": 1725966329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20to.20refer.20to.20mul.20inside.20mul_comm.20proof/near/469059864\">said</a>:</p>\n<blockquote>\n<p><a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Partial.20Commutative.20Monoids\">#Is there code for X? &gt; Partial Commutative Monoids</a> for cross reference, in the unlikely event that you're not already connected.</p>\n</blockquote>\n<p>Oh thank you I did not know about this!</p>",
        "id": 469060859,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725966627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20to.20refer.20to.20mul.20inside.20mul_comm.20proof/near/469058687\">said</a>:</p>\n<blockquote>\n<p>If you only have a single invalid element this is just a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommMonoidWithZero#doc\">docs#CommMonoidWithZero</a></p>\n</blockquote>\n<p>Hmm, that's the thing, there might be several invalid elements, as it's easier to formalise. I'm just experimenting with things on my free time, but what I would probably need if I continue is <a href=\"https://cs.au.dk/~birke/papers/iris-journal.pdf\">Resource Algebras</a>, which are not exactly PCMs either, as there might not be a single unit element</p>\n<p><a href=\"/user_uploads/3121/WmqwLNnqTKeCTZWFuGYqHORF/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WmqwLNnqTKeCTZWFuGYqHORF/image.png\" title=\"image.png\"><img data-original-dimensions=\"1141x666\" src=\"/user_uploads/thumbnail/3121/WmqwLNnqTKeCTZWFuGYqHORF/image.png/840x560.webp\"></a></div>",
        "id": 469062070,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725966981
    },
    {
        "content": "<p>And I am now noticing that there exist a port of Iris to Lean <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 469062726,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725967230
    },
    {
        "content": "<p>I believe, the port currently does not feature either RAs or CMRAs. Its mostly MoSeL and not Iris.</p>",
        "id": 469063097,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1725967356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"571277\">Ira Fesefeldt</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20How.20to.20refer.20to.20mul.20inside.20mul_comm.20proof/near/469063097\">said</a>:</p>\n<blockquote>\n<p>I believe, the port currently does not feature either RAs or CMRAs. Its mostly MoSeL and not Iris.</p>\n</blockquote>\n<p>Yes, I just saw this unfortunately</p>",
        "id": 469072758,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725970376
    },
    {
        "content": "<p>Anyway, this is just a side project for me to learn Lean and play with a few ideas, so I'm happy building things from scratch, it's a good learning exercise</p>",
        "id": 469073124,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725970450
    },
    {
        "content": "<p>I am not involved in maintaining the port - but the port would probably benefit from a formalization of RAs or CMRAs.</p>",
        "id": 469087378,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1725973926
    },
    {
        "content": "<p>I'll be happy to contribute what I have, if I ever get something useful. But my primary goal is not to re-implement Iris, and in particular I have no need for the higher-order part of Iris, so I do not need step-indexing. I'm not sure RAs are actually necessary in lean-Iris, I'm expecting only CMRAs would be</p>",
        "id": 469092765,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725975181
    },
    {
        "content": "<p>But I'm also not an Iris expert hahaha</p>",
        "id": 469092829,
        "sender_full_name": "Sacha Ayoun",
        "timestamp": 1725975195
    },
    {
        "content": "<p>As I said, there is currently no support for step-indexing (besides OFEs) in the Iris port anyway. No proof with Iris-lean will be made using step-indexing in the near future. So in the current form of the port, RAs are already nice to have. Whether in the form of a PR or as a separate project aiming to be compatible - thats of course your choice (I don't think the hurdle to be compatible is high)</p>\n<p>Also, I think adapting RAs to CMRAs is probably easier than implementing CMRAs from scratch.</p>",
        "id": 469094323,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1725975530
    }
]