[
    {
        "content": "<p>I'm want to use a well behaved linear order on a Fintype, but I'm confused about what typeclasses would ensure that. (Basically, I'd like to have an ordered indexing type that has the properties the integers from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, like referring to smallest and largest elements.) I tried something, but I seem to have run into diamond issues in the typeclass hierarchy. Here's a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompletePartialOrder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">order_problem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- or this: (hm : ∀ i, m ≤ i)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hιclo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hι</span><span class=\"bp\">.</span><span class=\"n\">toCompleteLinearOrderOfNonempty</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Ms</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"bp\">.</span><span class=\"n\">not_isMax</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\">  </span><span class=\"c1\">-- typeclass inference clash; interference from hιclo?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- really, I would like to show that m ∈ Msᶜ, but without hιclo already the definition of</span>\n<span class=\"w\">  </span><span class=\"c1\">-- M complains about not being able to infer [SupSet ι]</span>\n</code></pre></div>\n<p>What is the right combination of typeclasses to use in this case?</p>",
        "id": 523878644,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1749795635
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompletePartialOrder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">order_problem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hne</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">exists_ne</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_isMax_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lt_of_ne</span><span class=\"w\"> </span><span class=\"n\">hne</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 523883705,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749798251
    },
    {
        "content": "<p>Thanks for the quick reply! However, it doesn't really help me with the problem that I described in the comments in my mwe. If I had deleted <code>hιclo</code> and <code>M</code>, the code would have worked as is anyway. This is what I really want to do, but the typeclass inference system complains already at the attempt of specifying the goal type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompletePartialOrder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">order_problem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> SupSet ι can't be inferred -/</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>My original mwe, I admit, was a bit artificially unfolded to show where the different problems appear.</p>",
        "id": 523887903,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1749800156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674314\">@Igor Khavkine</span> what you wrote makes no sense in pen-and-paper mathematics; what do you actually want to express?</p>",
        "id": 523898531,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749803961
    },
    {
        "content": "<p>uh... it looks like you just want to write <code>\\ne</code>?</p>",
        "id": 523898701,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749804021
    },
    {
        "content": "<p>What I want is to work (in a larger context) with indexed objects, say <code>E : ι -&gt; Type</code>, where there are only finitely many index values <code>i : ι</code> and so that they have an order on them. Then I'd like do things like choose the least <code>i</code> (that would be <code>m := ⨅ i, i</code>), choose the greatest <code>i</code> (that would be <code>M := ⨆ i, i</code>), group the <code>E i</code> into subsets like {i &lt;= k} and {i &gt; k} for some <code>k : ι</code>, prove that these index subsets don't overlap, etc.</p>\n<p>Now, a canonical choice for <code>ι</code> could be the integers from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (<code>Fin n</code> I guess), but as <code>ι</code> would appear in the hypotheses of a theorem, I'd like to abstract it to some <code>Fintype ι</code> with appropriate order properties. What I can't figure out is what typeclasses describe these order properties.</p>\n<p>Intuitvely, <code>Fintype ι</code> and <code>LinearOrder ι</code> should be enough, because existence of minima, maxima, comparability should follow from that. I did find <code>Fintype.toCompleteLinearOrderOfNonempty</code>, which also uses <code>Nonempty  ι</code>, but I had to invoke it manually as in my first mwe, and that also lead to incompatible typeclass inferences for simple expressions like <code>⨅ i, i</code> and <code>⨆ i, i</code>, or <code>IsBot</code> and <code>IsMax</code>.</p>\n<p>The proposition <code>m ∈ {M}ᶜ</code>, where <code>m</code> is the minimum index, while <code>M</code> is the maximum index (when the index set has at least two elements) is just one of the simplest statements that I think I should be able to express and prove. Now all of this seems rather too complicated for what I'd like to do, so I'm quite certain that I'm taking a wrong approach somewhere...</p>",
        "id": 523903684,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1749805692
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674314\">@Igor Khavkine</span> my question is, here <code>m</code> and <code>M</code> are two elements of <code>ι</code> right? so doesn't \"<code>m ∈ {M}ᶜ</code>\" just say <code>m ≠ M</code>?</p>",
        "id": 523907463,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749806995
    },
    {
        "content": "<p>Yes, they are even definitionally equal, if I'm not mistaken. Sorry for the possibly over-complicated notation, I had reasons to use it where I copied it from, which are irrelevant here.</p>",
        "id": 523908526,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1749807356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674314\">@Igor Khavkine</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">Order</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CompletePartialOrder</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">order_problem</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nontrivial</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LinearOrder</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsBot</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hι</span><span class=\"bp\">.</span><span class=\"n\">toCompleteLinearOrderOfNonempty</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"bp\">⨆</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">}</span><span class=\"bp\">ᶜ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hι</span><span class=\"bp\">.</span><span class=\"n\">toCompleteLinearOrderOfNonempty</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">iSup</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">range_id'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sSup_univ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"bp\">.</span><span class=\"n\">eq_bot</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">bot_ne_top</span>\n</code></pre></div>",
        "id": 523909296,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749807660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  Your example seems to be working for what I wanted to do. Thanks a lot!</p>\n<p>The difference seems to be in using <code>letI := hι.toCompleteLinearOrderOfNonempty</code>(or wih <code>let</code>) vs <code>have := hι.toCompleteLinearOrderOfNonempty</code> as I was using. I didn't realize that it would make a difference here!</p>",
        "id": 523914209,
        "sender_full_name": "Igor Khavkine",
        "timestamp": 1749809561
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"674314\">@Igor Khavkine</span> <code>have</code> forgets the proof</p>",
        "id": 523916326,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749810424
    },
    {
        "content": "<p>which you don't want</p>",
        "id": 523916337,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749810430
    },
    {
        "content": "<p>because then you have no way to ensure that the two linear orders are the same</p>",
        "id": 523916371,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1749810443
    },
    {
        "content": "<p>You mean \"<code>have</code> forgets the data\"</p>",
        "id": 523919642,
        "sender_full_name": "Jz Pan",
        "timestamp": 1749811708
    }
]