[
    {
        "content": "<p>Problem source: <a href=\"https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_2_2.lean\">https://github.com/teorth/analysis/blob/main/analysis/Analysis/Section_2_2.lean</a><br>\nThere was a hint to use one of a few provided APIs, but I am not sure what the correct way to do that is. I attempted the following: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\">The following API for ∃! may be useful for the next problem.  Also, the `obtain` tactic is useful</span>\n\n<span class=\"cm\">for extracting witnesses from existential statements; for instance, `obtain ⟨ x, hx ⟩ := h`</span>\n\n<span class=\"cm\">extracts a witness `x` and a proof `hx : P x` of the property from a hypothesis `h : ∃ x, P x`.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">existsUnique_of_exists_of_unique</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ExistsUnique</span><span class=\"bp\">.</span><span class=\"n\">exists</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ExistsUnique</span><span class=\"bp\">.</span><span class=\"n\">unique</span>\n\n<span class=\"sd\">/-- Lemma 2.2.10 (unique predecessor) / Exercise 2.2.2 -/</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">uniq_succ_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">isPos</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">existsUnique_of_exists_of_unique</span>\n\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But  that resulted in an error: \"<code>by tac</code> constructs a term of the expected type by running the tactic(s) <code>tac</code>.\" The online documentation for existsUnique_of_exists_of_unique didn't include any plain English examples of how to use it. In this example problem, what are the Sort and Prop, and why do there need to be new variables y1 and y2? existsUnique_of_exists_of_unique.{u_1} {α : Sort u_1} {p : α → Prop} (hex : ∃ x, p x)</p>\n<p>(hunique : ∀ (y₁ y₂ : α), p y₁ → p y₂ → y₁ = y₂) : ∃! x, p x</p>",
        "id": 525591894,
        "sender_full_name": "D A L",
        "timestamp": 1750797663
    },
    {
        "content": "<p>Are you sure it's not just <code>unsolved goals</code>?</p>",
        "id": 525592833,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750798052
    },
    {
        "content": "<p><code>apply existsUnique_of_exists_of_unique</code> gives you two new goals.</p>",
        "id": 525592866,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750798072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20goals.20with.20.E2.88.83!.20.28ExistsUnique.20predicate.29/near/525592866\">said</a>:</p>\n<blockquote>\n<p><code>apply existsUnique_of_exists_of_unique</code> gives you two new goals.</p>\n</blockquote>\n<p>I assumed that there was some issue, because one of the new goals is a near exact copy of the original goal: <strong>case</strong> hex<br>\n<strong>a</strong> : Nat<br>\n<strong>ha</strong> : a.isPos<br>\n<strong>⊢</strong> ∃ x, x++ = a<br>\nIf applying that theorem doesn't change the goal, then how is it possible to make progress on it?</p>",
        "id": 525624674,
        "sender_full_name": "D A L",
        "timestamp": 1750818034
    },
    {
        "content": "<p>That's a different goal, you changed the <code>ExistsUnique</code> to just <code>Exists</code></p>",
        "id": 525624752,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750818108
    },
    {
        "content": "<p><code>existsUnique_of_exists_of_unique</code> will in fact require you to prove existence (and also uniqueness, separately)</p>",
        "id": 525624796,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750818150
    },
    {
        "content": "<p>that's why it gives you two goals, one for existence, and one for uniqueness</p>",
        "id": 525624919,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750818258
    },
    {
        "content": "<p>Thank you so much, that is the clearest description of that tactic that I was able to find. So, I'm guessing that I would use <code>ExistsUnique.exists</code> and <code>ExistsUnique.unique</code> if I just want to prove existence (former) or just uniqueness (latter) and disregard the other for now?</p>",
        "id": 525634580,
        "sender_full_name": "D A L",
        "timestamp": 1750827279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928152\">D A L</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20goals.20with.20.E2.88.83!.20.28ExistsUnique.20predicate.29/near/525634580\">said</a>:</p>\n<blockquote>\n<p>Thank you so much, that is the clearest description of that tactic that I was able to find.</p>\n</blockquote>\n<p>It is actually very clear from the name, if you know about Lean's naming convention.</p>\n<p>The \"of\" in a naming convention means B implies A (in the opposite direction), so <code>existsUnique_of_exists_of_unique</code> means that it will prove <code>existsUnique</code> (the first part of the name), provided that you give it a proof of <code>exists</code> (the middle part), and a proof of <code>unique</code> (the last part).</p>\n<p>In more symbols, <code>existsUnique_of_exists_of_unique</code> is literally translating the implication:</p>\n<ul>\n<li>Exists → Unique → ExistsUnique</li>\n</ul>\n<p>using Lean's naming convention</p>",
        "id": 525655275,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1750838509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"928152\">D A L</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20prove.20goals.20with.20.E2.88.83!.20.28ExistsUnique.20predicate.29/near/525634580\">said</a>:</p>\n<blockquote>\n<p>Thank you so much, that is the clearest description of that tactic that I was able to find. So, I'm guessing that I would use <code>ExistsUnique.exists</code> and <code>ExistsUnique.unique</code> if I just want to prove existence (former) or just uniqueness (latter) and disregard the other for now?</p>\n</blockquote>\n<p>Unique existence will always require both existence and uniqueness. You can't skip one or the other. The lemmas <code>ExistsUnique.exists</code> and <code>ExistsUnique.unique</code> are actually how you <em>use</em> a statement of unique existence. <code>ExistsUnique.exists</code> let you prove existence from unique existence, and <code>ExistsUnique.unique</code> lets you prove uniqueness.</p>",
        "id": 525678531,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1750846212
    }
]