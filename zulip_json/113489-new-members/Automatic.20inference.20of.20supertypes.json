[
    {
        "content": "<p>Hi all, I find myself in situations where I gradually extend types with subtypes with the original type remaining within a <code>val</code> and the added property under <code>property</code>. This is especially useful when I am discovering new properties of a type and incrementally adding them one by one rather than using a structure with more than one property is not possible.</p>\n<p>However, after a while I find myself in a situation where I have to access <code>x.val.val</code> in order to use a partial order defined on the super-super-type or even have to propagate <code>x ⊓ y</code> from the <code>.val.val</code> all the way to the subtype with the added property. So here is what I wonder now - can Lean 4 infer properties of the supertype like shared ones from type classes? If a property <code>x.property</code> holds for a supertype <code>x : X</code>then doesn't it also hold for a subtype <code>{ x : X // property2 }</code> where the subtype is essentially a type X with both properties 1 and 2?</p>",
        "id": 532920551,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754401626
    },
    {
        "content": "<p>What sort of properties are you using?</p>",
        "id": 532920758,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401692
    },
    {
        "content": "<p>Properties like equality of a length of a list, partial order, joins/unions of a lattice, etc. For instance, can I somehow do <code>x ≤ y</code> if I have only defined the LE on a supertype without the <code>.val.val...</code> access?</p>",
        "id": 532920930,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754401753
    },
    {
        "content": "<p>It's not always the case that if you have a lattice then a subtype will also be a lattice</p>",
        "id": 532921101,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401809
    },
    {
        "content": "<p>Yeah if this <em>is</em> the case though it might be worth adding the instances you need yourself</p>",
        "id": 532921219,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1754401853
    },
    {
        "content": "<p>for example <code>Fin 2 × Fin 2</code> is a lattice but <code>{ i : Fin 2 × Fin 2 // i &lt; ⊤ }</code> is not a lattice since <code>⟨(1, 0), by decide⟩</code> and <code>⟨(0, 1), by decide⟩</code> don't have a supremum</p>",
        "id": 532921381,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401915
    },
    {
        "content": "<p>subtypes do inherit an order, though</p>",
        "id": 532921418,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401925
    },
    {
        "content": "<p>the ordering is in mathlib</p>",
        "id": 532921493,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401951
    },
    {
        "content": "<p>and you can do <code>x ≤ y</code> even if the order is only on a supertype by importing <code>Mathlib.Order.Basic</code></p>",
        "id": 532921607,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754401991
    },
    {
        "content": "<p>I assume there is no easy way to simplify the syntax in the case of purely additive properties? For instance if I have a valid <code>x ⊓ y</code> on a lattice of a type where the subtype also has a property that doesn't affect the lattice structure is there an easy way to simply \"inherit\" the simple notation instead of having to use <code>(x.val ⊓ y.val).val</code>?</p>",
        "id": 532921623,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754401998
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sublattice#doc\">docs#Sublattice</a></p>",
        "id": 532921722,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754402030
    },
    {
        "content": "<p>what do you mean by \"property that doesn't affect the lattice structure\"?</p>",
        "id": 532921976,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754402106
    },
    {
        "content": "<p>For example if I define a lattice on hypercube vertices with elementwise max and min for join/meet and want to add the property that the dimension I want to consider is &lt; 100 as in <code>{ x : Fin n → ℝ // n ≤ 100 }</code>. We can produce a lattice in any dimension <code>n</code> here but if I restrict its value I get into a subtype and a lot of the lattice goodies are no longer accessible unless I use <code>.val</code>.</p>",
        "id": 532924476,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754402810
    },
    {
        "content": "<blockquote>\n<p>and you can do <code>x ≤ y</code> even if the order is only on a supertype by importing <code>Mathlib.Order.Basic</code></p>\n</blockquote>\n<p>Indeed a good point and it clarifies a lot - so it seems that certain properties are inherited while others are not based on what could be translated to a substructure. In the case of partial order for instance I managed to inherit this into the subtype but not the decidability of it.</p>",
        "id": 532926256,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754403210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"897334\">Plamen Dimitrov</span> <a href=\"#narrow/channel/113489-new-members/topic/Automatic.20inference.20of.20supertypes/near/532924476\">said</a>:</p>\n<blockquote>\n<p>For example if I define a lattice on hypercube vertices with elementwise max and min for join/meet and want to add the property that the dimension I want to consider is &lt; 100 as in <code>{ x : Fin n → ℝ // n ≤ 100 }</code>. We can produce a lattice in any dimension <code>n</code> here but if I restrict its value I get into a subtype and a lot of the lattice goodies are no longer accessible unless I use <code>.val</code>.</p>\n</blockquote>\n<p>Is this example good enough to illustrate what I mean?</p>",
        "id": 533033795,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754462187
    },
    {
        "content": "<p>Or is is possible to somehow customize what properties are inherited and what properties are not inherited e.g. via a proof about the inheritance?</p>",
        "id": 533043063,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1754466232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"897334\">Plamen Dimitrov</span> <a href=\"#narrow/channel/113489-new-members/topic/Automatic.20inference.20of.20supertypes/near/533033795\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"897334\">Plamen Dimitrov</span> <a href=\"#narrow/channel/113489-new-members/topic/Automatic.20inference.20of.20supertypes/near/532924476\">said</a>:</p>\n<blockquote>\n<p>For example if I define a lattice on hypercube vertices with elementwise max and min for join/meet and want to add the property that the dimension I want to consider is &lt; 100 as in <code>{ x : Fin n → ℝ // n ≤ 100 }</code>. We can produce a lattice in any dimension <code>n</code> here but if I restrict its value I get into a subtype and a lot of the lattice goodies are no longer accessible unless I use <code>.val</code>.</p>\n</blockquote>\n<p>Is this example good enough to illustrate what I mean?</p>\n</blockquote>\n<p>Why are you using a subtype for this?</p>",
        "id": 533072916,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754476531
    },
    {
        "content": "<p>the subtype isn't putting any constraints on <code>x</code> (only on <code>n</code>)</p>",
        "id": 533072951,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754476546
    },
    {
        "content": "<p>I think you should put a subtype on <code>n</code> instead (make it <code>Fin</code> or something) instead of on <code>x</code></p>",
        "id": 533073010,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754476570
    },
    {
        "content": "<p>unless you have a good reason?</p>",
        "id": 533073039,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754476581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Automatic.20inference.20of.20supertypes/near/533073039\">said</a>:</p>\n<blockquote>\n<p>unless you have a good reason?</p>\n</blockquote>\n<p>This was just a contrived example to illustrate that one might want to have a subtype and transfer the lattice structure there and I hope it served its purpose.</p>\n<p>Let me reiterate the actual question in case someone has any suggestions:</p>\n<p>Is it possible to somehow customize what properties are inherited and what properties are not inherited e.g. via a proof about the inheritance? In other words, is it possible to avoid writing <code>(x.val ⊓ y.val).val</code> and simply write <code>x ⊓ y</code> if <code>x.val</code> and <code>y.val</code> are lattice elements and we could prove (but it is not trivial for Lean to automatically prove) that the subtype also forms a lattice?</p>",
        "id": 533974023,
        "sender_full_name": "Plamen Dimitrov",
        "timestamp": 1755003036
    },
    {
        "content": "<p>Make a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Sublattice#doc\">docs#Sublattice</a></p>",
        "id": 533978603,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755004474
    }
]