[
    {
        "content": "<p>I'm going through Tao's partial formalization of his book, specifically <a href=\"https://github.com/teorth/analysis/blob/49e13aacb03e76a4d0af304c3e72292bb05e6ccb/analysis/Analysis/Section_2_epilogue.lean#L59\">this part</a> where the exercise is to show that our custom <code>Nat</code> is equivalent to Mathlib's <code>Nat</code>.</p>\n<p>I found <code>map_add</code> and <code>map_mul</code> relatively striaghtforward but <code>map_le_map_iff</code> seems more of a PITA. Here is my current code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Chapter2</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">map_le_map_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a'</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">haa'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">haa'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">ha'</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">symm</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">map_add</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">congr</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">dsimp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hf</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">map_add</span>\n</code></pre></div>\n<p>And here is the <a href=\"https://gist.githubusercontent.com/gaearon/4dd918104044a6e4192eccc05efa8f46/raw/bf9de318edf8e9bbb161a08f121231eb8b274e4f/repro2.lean\">surrounding code</a> ready to be pasted into the <a href=\"https://live.lean-lang.org/\">repl</a>. The <code>map_le_map_iff</code> function starts at line <code>1006</code>.</p>\n<p>My questions are:</p>\n<ol>\n<li>Is there a less clunky way to implement this? I spent several hours on it and I suspect it's neither idiomatic nor the shortest way to do it. I found the inner part very tricky because I had to \"carry\" the <code>+</code> through the type coercions. I ended up writing it as a series of <code>have</code>s because otherwise I was getting lost completely.</li>\n<li>Is there a better way to \"think\" about this type of problem that would help me write it faster? Was there some insight I miss that would help?</li>\n</ol>\n<p>Thanks.</p>",
        "id": 526681114,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751403135
    },
    {
        "content": "<p>What if you go through le iff exists add</p>",
        "id": 526681225,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751403186
    },
    {
        "content": "<p>oh I see you have already done that, maybe it's just a matter of how you write the code</p>",
        "id": 526681302,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751403225
    },
    {
        "content": "<p>Yeah the part that's messy is later on where I start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">a'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">ha'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">a'</span>\n<span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a'</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span>\n</code></pre></div>\n<p>and I need to turn <code>m = n + a</code> in one system into <code>m = n + a</code> in the other system.</p>",
        "id": 526681415,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751403286
    },
    {
        "content": "<p>I made it a bit shorter</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Chapter2</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">map_le_map_iff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">equivNat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">map_add</span>\n</code></pre></div>",
        "id": 526681995,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751403611
    },
    {
        "content": "<p>Ohhh I didn't know that equivalence has its own built-in <code>injective.eq_iff</code>!</p>",
        "id": 526682578,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751403850
    },
    {
        "content": "<p>it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.injective#doc\">docs#Equiv.injective</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Function.Injective.eq_iff#doc\">docs#Function.Injective.eq_iff</a></p>",
        "id": 526682718,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751403905
    },
    {
        "content": "<p>Is there any way to rewrite without relying on <code>simp</code>? I try to be cautious when learning because I don't fully understand the chain of transformations. I see it unfolded to <code>simp only [Equiv.coe_fn_mk, ha, map_add, Nat.add_left_cancel_iff]</code> but I'm not sure what <code>coe_fn_mk</code> does, and I'm a bit confused why cancellation comes up here.</p>",
        "id": 526683217,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751404123
    },
    {
        "content": "<p>Ah I see you're making the two sides equal, and <code>add_left_cancel_iff</code> helps get rid of the other term so we're only left with the cast...</p>",
        "id": 526683559,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751404289
    },
    {
        "content": "<p>This seems to be the minimal explicit version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Chapter2</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">map_le_map_iff2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rw [Equiv.coe_fn_mk]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">map_add</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_iff_exists_add</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">map_add</span>\n</code></pre></div>\n<p>I want to get rid of <code>Equiv.coe_fn_mk</code> (because I don't understand it) but seemingly I can't. This is because</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"bp\">.</span><span class=\"n\">eq_iff</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>gives us</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">equivNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but what we want is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toNat</span>\n</code></pre></div>\n<p>What is the magic that <code>coe_fn_mk</code> does and is there some way to do it in a single step?</p>",
        "id": 526684803,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751404923
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.coe_fn_mk#doc\">docs#Equiv.coe_fn_mk</a> says that if you have an equivalence where <code>toFun</code> is defined as <code>f</code>, then coercing the equivalence to a function gives you a function that is equal to <code>f</code></p>",
        "id": 526685054,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751405049
    },
    {
        "content": "<p>idk if that helps but that's how I understand it</p>",
        "id": 526685108,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751405076
    },
    {
        "content": "<p>if you're working with an equiv and applying it directly to something as if it's a function, then <code>coe_fn_mk</code> allows you to rewrite so that you're working with the underlying function instead of a coerced equivalence</p>",
        "id": 526685378,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751405198
    },
    {
        "content": "<p>I see. I guess we got into this because <code>.injective</code> is on the equivalence itself, and we kind of started treating it as a function then. I wonder if there's something like <code>rw [← equivNat.injective.eq_iff]</code> but that wouldn't lead us down this pathway?</p>",
        "id": 526686019,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751405469
    },
    {
        "content": "<p>Basically, I want to know whether we get from <code>⊢ m = n + ↑a</code> directly to <code>⊢ m.toNat = (n + ↑a).toNat</code>​without doing <code>⊢ equivNat m = equivNat (n + ↑a)</code> along the way</p>",
        "id": 526686221,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751405567
    },
    {
        "content": "<p>ah, it sounds like you're asking if you can just get a proof that <code>toNat</code> is injective without having to use the fact that it's the <code>toFun</code> of <code>equivNat</code></p>",
        "id": 526686461,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751405709
    },
    {
        "content": "<p>I don't mind using that fact but I'm wondering if there's something like <code>apply equivNat.toFun_injective</code> if that makes sense. I guess maybe not.</p>",
        "id": 526686589,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1751405773
    },
    {
        "content": "<p>well, even if that existed, you'd probably end up with <code>⊢ equivNat.toFun m = equivNat.toFun (n + ↑a)</code> and you'd still need to finesse it a bit</p>",
        "id": 526687101,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1751406069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 526688359,
        "sender_full_name": "Notification Bot",
        "timestamp": 1751406858
    },
    {
        "content": "<p>I am also going through these exercises this week, so sharing my solution to this problem:<br>\n<a href=\"https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_2_epilogue.lean#L78-L98\">https://github.com/rkirov/analysis/blob/main/analysis/Analysis/Section_2_epilogue.lean#L78-L98</a><br>\nSimilarly, I am learning Lean, so can't speak to what's the best or most idiomatic way to do this and I am definitely not showing as much restraint with <code>simp</code> as <span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> .</p>\n<p>One neat thing I noticed is <code>apply_fun</code> on an Equiv.toFun or Equiv.invFun removes automatically the injective goal, which makes it cleaner than <code>rw [← equivNat.injective.eq_iff]</code>.</p>\n<p>Generally, after finishing all of chapter 2 and 3.1, dealing with Equiv and casts surprisingly has been the most frustrating part of all of the exercises. Lean tries to be helpful with hiding the casts with ↑ (or nothing for casting a numeral constant to say custom Nat), but then it all falls apart when a <code>rw</code> fails and I have to hunt though them in the InfoView (thank god for the recursive hover overs).</p>",
        "id": 526728303,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1751437805
    }
]