[
    {
        "content": "<p>I'm going through exercises in Tao's Analysis, and at some point there's a custom Setoid instance set up via Set cardinality equality:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">EqualCard</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Bijective</span><span class=\"w\"> </span><span class=\"n\">f</span>\n\n<span class=\"c1\">-- ...</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">EqualCard</span><span class=\"bp\">.</span><span class=\"n\">inst_setoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Setoid</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">EqualCard</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">symm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">trans</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Later in exercises, we sometimes use <code>≃</code>  to set up bijections between sets (which I understand to be <code>Equiv</code>), and sometimes we use <code>≈</code> (which I understand to be <code>Setoid</code>). Due to similar notation, I often confuse these.</p>\n<p>I was wondering if there's a good mental model for whether one is more \"powerful\" than the other in some way. At least in the exercises in that chapter, I'm able to freely convert between the two. For example, this typechecks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hequiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't matter</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsetoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">hequiv</span><span class=\"w\"> </span><span class=\"c1\">-- can rely on this one</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">bijective</span>\n</code></pre></div>\n<p>But this <em>also</em> typechecks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hsetoid</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≈</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't matter</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hequiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×ˢ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Permutations</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Equiv</span><span class=\"bp\">.</span><span class=\"n\">ofBijective</span><span class=\"w\"> </span><span class=\"n\">hsetoid</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hsetoid</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"c1\">-- can rely on this one</span>\n</code></pre></div>\n<p>So they seem to be \"equally powerful\" concepts in this case (and just mean a bijection).</p>\n<p>Is this because of how my <code>instance</code> is set up, and not true in general? If it's not true in general, is there some mental model for how to think when to \"reach for\" <code>Equiv</code> vs <code>Setoid</code>?</p>\n<p>Thanks.</p>",
        "id": 538287145,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757354615
    },
    {
        "content": "<p>I guess maybe <code>Equiv</code> generally represents a bijection between two types, whereas <code>Setoid</code> in general is just an equality-shaped relationship, and in this case the relation happens to be \"having equal cardinality\" which corresponds to a bijection.</p>\n<p>I'm still not sure what this says about <code>Equiv</code> vs <code>Setoid</code> in general, e.g. in other cases is it possible to get one from the other, or are these unrelated concepts that happen to overlap here.</p>",
        "id": 538287848,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757354867
    },
    {
        "content": "<p><code>Equiv</code> is data: it is a bijective function to convert from a term of one type<code>x : A</code> to another type <code>n : B</code>. <code>Setoid</code> is also data: is a relation between <code>x y : A</code> such that <code>x</code> and <code>y</code> are fuzzy-equal.</p>",
        "id": 538287871,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757354874
    },
    {
        "content": "<p>Ah, you just said that.</p>",
        "id": 538287888,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757354881
    },
    {
        "content": "<p>Is it possible to turn one into the other in the general case? Or are they orthogonal and just happen to overlap in my specific instance?</p>",
        "id": 538287956,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757354907
    },
    {
        "content": "<p>One would say <code>x ≈ y</code> (term-level), the notation is a relation between terms.</p>",
        "id": 538287998,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757354922
    },
    {
        "content": "<p>In your case, you have a \"relationship\" between types. So an Equiv is \"more\" informative because not only does it say that the two types are kinda the same, it even says how to convert a <code>p : Perm (n + 1)</code> to <code>pair : Fin (n + 1) x Perm n</code></p>",
        "id": 538288124,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757354980
    },
    {
        "content": "<p>It's fuzzier in the Analysis context since you're building up set theory, which is a bit muddled when doing via type theory.</p>",
        "id": 538288281,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1757355035
    },
    {
        "content": "<p><code>Setoid</code> is more general since it describes some equivalence relation; the main point of it is to build a quotient type later, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal#doc\">docs#Cardinal</a> using the type setoid or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset#doc\">docs#Multiset</a> using the list setoid. In this case <code>α ≈ β</code> happens to defined as <code>Nonempty (α ≃ β)</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.isEquivalent#doc\">docs#Cardinal.isEquivalent</a>).</p>",
        "id": 538288946,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757355272
    },
    {
        "content": "<p>Ah ok, so <code>Setoid</code> doesn't have to represent a bijection because it's often used to \"crunch\" things into being equal (via quotients).</p>",
        "id": 538289131,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757355337
    },
    {
        "content": "<p>If I have <code>X Y : Set</code> and I have <code>hxy : X ≈ Y</code> then I know that there exists a function <code>f : X → Y</code> such that <code>f</code> is bijective (but I don't know which one).<br>\nIf I have <code>X Y : Set</code> and I have <code>equivXY : X ≃ Y</code>, then that means I have a function <code>⇑equivXY : X → Y</code> and I have a function <code>⇑equivXY.symm : Y → X</code> and I know these are two-sided inverses.</p>",
        "id": 538289141,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757355342
    },
    {
        "content": "<p>if I define an <code>Equiv</code> and then use it later, I know the function I get out is the same function I put in</p>",
        "id": 538289405,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1757355445
    },
    {
        "content": "<p>So one can go from Setoid to Equiv with classical.choose?</p>",
        "id": 538295325,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757357661
    },
    {
        "content": "<p>A better alternative in proofs would be <code>obtain ⟨eqv⟩ := h</code> though</p>",
        "id": 538295851,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1757357875
    },
    {
        "content": "<p>Obtain only works for getting Props out (I have gotten this error a few times)</p>",
        "id": 538299778,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757359403
    },
    {
        "content": "<p>maybe this is obvious, but I didn't see anyone mention the fact that Setoid is a relation <em>within</em> a type, whereas Equiv is a relation <em>between</em> types</p>",
        "id": 538301526,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757360014
    },
    {
        "content": "<p>Ah interesting, I guess in this formalization it kinda works both ways because we have <code>Set</code>s but they're also treated as <code>Type</code>s (there's a coe).</p>",
        "id": 538301989,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757360178
    },
    {
        "content": "<p>also, types themselves are members of a type (<code>Type</code>), which explains why an Equiv can be viewed as the basis of a Setoid for the type <code>Type</code> (which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Cardinal.isEquivalent#doc\">docs#Cardinal.isEquivalent</a>)</p>",
        "id": 538302186,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757360239
    },
    {
        "content": "<p>but that's a whole other thing</p>",
        "id": 538302513,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757360356
    },
    {
        "content": "<p>For me Equiv is a way to say two different types have a bijection between them, while Setoid says two instances of a type have a weak equality that you can make into an equality by using a quotient.</p>",
        "id": 538304020,
        "sender_full_name": "Alfredo Moreira-Rosa",
        "timestamp": 1757360983
    },
    {
        "content": "<p>yeah, like you could have a Setoid on the natural numbers by saying odd numbers are equivalent and even numbers are equivalent, but it wouldn't make sense to say that a bijection exists between two numbers... a Setoid is about relating terms, not (necessarily) types</p>",
        "id": 538304432,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757361156
    },
    {
        "content": "<p>Thanks, this is all very helpful, I think it makes sense to me now.</p>",
        "id": 538531369,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1757451575
    }
]