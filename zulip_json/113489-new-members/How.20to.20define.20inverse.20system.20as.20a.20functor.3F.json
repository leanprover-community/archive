[
    {
        "content": "<p>The inverse system takes type (f : ⦃i j : ι⦄ → i ≤ j → F j → F i), which is not a functor. How can we define a functor F that is an inverse system?</p>",
        "id": 563502055,
        "sender_full_name": "Jiayang Hong",
        "timestamp": 1765553579
    },
    {
        "content": "<p>can you give more context on what you're doing and why you want this?</p>",
        "id": 563552431,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765569838
    },
    {
        "content": "<p>I want to formalize <a href=\"https://stacks.math.columbia.edu/tag/0597\">https://stacks.math.columbia.edu/tag/0597</a>. How can I state this lemma?</p>",
        "id": 563592238,
        "sender_full_name": "Jiayang Hong",
        "timestamp": 1765600531
    },
    {
        "content": "<p>I guess first you would have to define the mittag-leffler condition</p>",
        "id": 563592523,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765600922
    },
    {
        "content": "<p>oh I see it already exists in mathlib as <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Functor.IsMittagLeffler#doc\">docs#CategoryTheory.Functor.IsMittagLeffler</a></p>",
        "id": 563592554,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765600947
    },
    {
        "content": "<p>The Mittag-Leffler condition is defined for a functor, but the inverse system is not defined for a functor. How can I solve this problem?</p>",
        "id": 563594885,
        "sender_full_name": "Jiayang Hong",
        "timestamp": 1765603647
    },
    {
        "content": "<p>I suspect it's possible to define it as a cofunctor from <code>I</code> to category of sets (or of modules). By <code>I</code>, I mean typical category of a preorder, where there is a morphism between <code>i j : I</code> iff <code>i ≤ j</code>. And if it's a cofunctor, then it is a functor from the <code>Iᵒᵖ</code> category.</p>",
        "id": 563596999,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765606106
    },
    {
        "content": "<p>Is the typical category of preorder already in lean, or I need to define it by myself? I did not find it.</p>",
        "id": 563599811,
        "sender_full_name": "Jiayang Hong",
        "timestamp": 1765609449
    },
    {
        "content": "<p>are you looking for <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Preorder.html#Preorder.smallCategory\">Preorder.smallCategory</a>?</p>",
        "id": 563599952,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765609625
    },
    {
        "content": "<p>or the Category of Preorders, which is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Preord#doc\">docs#Preord</a></p>",
        "id": 563600017,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765609706
    },
    {
        "content": "<p>Thank you. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Preorder.html#Preorder.smallCategory\">Preorder.smallCategory</a> is what I want.</p>",
        "id": 563600450,
        "sender_full_name": "Jiayang Hong",
        "timestamp": 1765610266
    },
    {
        "content": "<p>Although if you want to make sure that the statement you write in Lean coincides with the one defined in the link you given, you should define systems/inverted systems and Mittag-Leffler condition independently of what's in mathlib. And optionally define embedding of systems into functors, and prove that the Mittag-Leffler condition you wrote is equivalent to the one in mathlib.</p>",
        "id": 563610433,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765622725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"918954\">Jiayang Hong</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20define.20inverse.20system.20as.20a.20functor.3F/near/563594885\">said</a>:</p>\n<blockquote>\n<p>The Mittag-Leffler condition is defined for a functor, but the inverse system is not defined for a functor. How can I solve this problem?</p>\n</blockquote>\n<p>Is an \"inverse system\" is just a functor where the source is a directed category?</p>",
        "id": 563611343,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765623824
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20define.20inverse.20system.20as.20a.20functor.3F/near/563611343\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"918954\">Jiayang Hong</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20define.20inverse.20system.20as.20a.20functor.3F/near/563594885\">said</a>:</p>\n<blockquote>\n<p>The Mittag-Leffler condition is defined for a functor, but the inverse system is not defined for a functor. How can I solve this problem?</p>\n</blockquote>\n<p>Is an \"inverse system\" is just a functor where the source is a directed category?</p>\n</blockquote>\n<p>A contravariant functor maybe?</p>",
        "id": 563612344,
        "sender_full_name": "Edison Xie",
        "timestamp": 1765624774
    },
    {
        "content": "<p>then it's a functor from the opposite category of a directed category?</p>",
        "id": 563612411,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765624835
    },
    {
        "content": "<p>or a functor from the order dual of a directed category?</p>",
        "id": 563612720,
        "sender_full_name": "Edison Xie",
        "timestamp": 1765625136
    },
    {
        "content": "<p>or does it make sense to talk about co-directed sets?</p>",
        "id": 563613288,
        "sender_full_name": "Edison Xie",
        "timestamp": 1765625592
    },
    {
        "content": "<p>Isn't dual a different name for the opposite?</p>",
        "id": 563616891,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765629039
    },
    {
        "content": "<p>yes it is</p>",
        "id": 563617005,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765629132
    },
    {
        "content": "<p>but we have both <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Opposite#doc\">docs#Opposite</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual#doc\">docs#OrderDual</a> and they're not the same</p>",
        "id": 563617029,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765629153
    },
    {
        "content": "<p>Huh? What's the point of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=OrderDual#doc\">docs#OrderDual</a> ?</p>",
        "id": 563617117,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765629220
    },
    {
        "content": "<p>so you can talk about the opposite order</p>",
        "id": 563617178,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765629256
    },
    {
        "content": "<p>Ah, okay, so like <code>LT αᵒᵈ</code> is <code>GT α</code>. There's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.orderDualEquivalence\">CategoryTheory.orderDualEquivalence</a> and I guess in the context of category theory it probably makes more sense to use Opposite.</p>",
        "id": 563617403,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765629415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20define.20inverse.20system.20as.20a.20functor.3F/near/563616891\">said</a>:</p>\n<blockquote>\n<p>Isn't dual a different name for the opposite?</p>\n</blockquote>\n<p>we have <code>OrderDual.instLE</code> but we don't have <code>LE</code> instance for <code>Opposite</code> if your original type has an order</p>",
        "id": 563618539,
        "sender_full_name": "Edison Xie",
        "timestamp": 1765630322
    },
    {
        "content": "<p>I never used OrderDual, but I suspect it might be confusing, at least for me, because now every time you see symbol <code>&lt;</code>, you have to check the type of things being compared to know whether it means <code>&lt;</code> or <code>&gt;</code> in your original order.</p>",
        "id": 563619711,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765631253
    },
    {
        "content": "<p>But you can see the types of things in the infoview, and we have explicit functions passing from an element in the type to an element in the dual type (we don't abuse defeq) so in practice I've not found it confusing (in contrast to when we used to abuse defeq in the early days and didn't have infoview hover, when it was indeed very confusing).</p>",
        "id": 563620617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765632088
    },
    {
        "content": "<p>For contravariant functors the current practice is indeed to use Opposite instead of OrderDual, see e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf\">TopCat.Presheaf</a>.</p>",
        "id": 563620982,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1765632487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20define.20inverse.20system.20as.20a.20functor.3F/near/563620617\">said</a>:</p>\n<blockquote>\n<p>But you can see the types of things in the infoview, and we have explicit functions passing from an element in the type to an element in the dual type (we don't abuse defeq) so in practice I've not found it confusing (in contrast to when we used to abuse defeq in the early days and didn't have infoview hover, when it was indeed very confusing).</p>\n</blockquote>\n<p>Yeah, so by what you described it currently works as I though it does. You still have to hover to see the type. I think it would be nice if delabolator used different symbol for <code>&lt;</code> in OrderDual. But maybe I'm too pedantic.<br>\nAlso, going back to the context of the systems. I don't currently see any use for the dual order, we only need dual homomorphism. And Opposite works exactly the same as OrderDual, you also have to explicitly convert between original type and the opposite, the only difference being, that Opposite doesn't have order (which we don't need), and I think Opposite is used more commonly in mathlib.</p>",
        "id": 563621991,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765633510
    },
    {
        "content": "<p>Maybe because of how things are defined in mathlib it would be simpler to restate the lemma <a href=\"https://stacks.math.columbia.edu/tag/0597\">https://stacks.math.columbia.edu/tag/0597</a> in terms of systems instead of inverse systems and colimit instead of limit?</p>",
        "id": 563622661,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765634154
    },
    {
        "content": "<p>And one can get the original lemma by applying the new lemma to the Opposite category.</p>",
        "id": 563622709,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765634191
    },
    {
        "content": "<p>Opposite and OrderDual are used for different things: Opposite is for categories, OrderDual is for orders. I don't think we can have different notation for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding=\"application/x-tex\">&lt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&lt;</span></span></span></span>, it's just <code>LT</code> in each case.</p>",
        "id": 563623107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765634572
    },
    {
        "content": "<p>For category theorist order is just a special case of category. .-.<br>\nI think it is technically possible for delabolator to display a different symbol, it could inspect the type of arguments and check if it's an application of OrderDual.</p>",
        "id": 563623361,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1765634836
    }
]