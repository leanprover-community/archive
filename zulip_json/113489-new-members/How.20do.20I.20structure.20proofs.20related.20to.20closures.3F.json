[
    {
        "content": "<p>In programming I use closures (including nested functions) quite a lot.</p>\n<p>So it feels natural to write nested code like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(The exact code is not the point, I'm talking more about the structure.)</p>\n<p>I have a function called <code>power</code> declared outside that does something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">SA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as_subset</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">SB</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as_subset</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"n\">SA</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">SB</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>(I know it's probably wrong or doesn't make sense, that's not my point)</p>\n<p>The reason I extracted it to top level is so I can try to prove something about it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">power_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">powerset_axiom</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>And the reason I did that is to give myself at least some chance to unpack the structure of the nested thing I had in the beginning. So maybe I'll write some mock proofs that try to extract things out of that structure.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">power_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ...</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Set up some garbage to get to the construction</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hS</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS'</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS'</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hT</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS'</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hT</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hT</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">power_spec</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n</code></pre></div>\n<p>And you can see I use <code>power_spec</code> at the end.</p>\n<p>Don't think too hard about this specific code, it's probably garbage, my question is more about the principle.</p>\n<p>In programming, the way I'd initially want to approach this would be to modularize related things. I.e. I kind of want to prove things related to the union close to taking union, related to the replacement next to that replacement, and somehow compose those smaller proofs alongside the composition of the statement.</p>\n<p>With a function definition, I understand how to nest structure (it's just a chain of nested functions, kind of like <code>.map(foo =&gt; foo.map(...))</code>. I'm not sure how to do the same for proofs <em>about</em> them. Is that even possible? Is that a bad idea? Is that trivial? Should I really be thinking about these things separately? Or should I try to extract those things at the top level as much as I can, sort of like I do in this <a href=\"https://gist.github.com/gaearon/25a437a7b1773f4af94146af13d4fbd2\">other exercise</a>? Are there different styles of doing this, or is there one recommended way?</p>\n<p>Thanks!</p>",
        "id": 531239259,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753661544
    },
    {
        "content": "<p>Full (long and broken) code snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Exercise 3.4.7 -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">partial_functions'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">as_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"bp\">.</span><span class=\"n\">prop</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">SA</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as_subset</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">SB</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as_subset</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"w\">    </span><span class=\"n\">SA</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">SB</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">power_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">F</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">powerset_axiom</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">union_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hS</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS'</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS'</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">T</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hT</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS'</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hT</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hT</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">replacement_axiom</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EmbeddingLike</span><span class=\"bp\">.</span><span class=\"n\">apply_eq_iff_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">power_spec</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hF</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hF</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Not runnable because it's nowhere close to being runnable, and my question is about the general structure of a proof rather than about its behavior.</p>",
        "id": 531239448,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753661615
    },
    {
        "content": "<p>It's hard to work without an actual working example, but generally speaking, you prove things from the outside in -- you show that, I don't know, <code>power_spec</code> on <code>union</code> actually reduces <code>power_spec</code> on each <code>_.powerset.replace</code>, and then that <code>power_spec</code> on <code>_.powerset.replace</code> reduces to <code>power_spec</code> on <code>_.powerset</code> + some side condition, and then .... etc, etc.</p>",
        "id": 531241537,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753662437
    },
    {
        "content": "<p>Yeah, I'd love to create a working example, the problem is precisely that I don't know what to write. :D</p>",
        "id": 531241824,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753662550
    },
    {
        "content": "<p>It's generally pretty tough to hoist things out of the middle of a nested structure; in simple cases you can do it, but once you encounter something with a dependent type, you (usually) stop being able to do 'localized' rewrites and are forced to do larger, distributed rewrites that change the structure of the whole expression in some correlated way, which <code>rw</code> and <code>simp_rw</code> are significantly less good at.</p>",
        "id": 531241886,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753662580
    },
    {
        "content": "<p>OK, so the best alternative is just a flat sequence of proofs that follow the nesting order of the nested structure, maybe written before it? (Or after it?) Or would you recommend flattening the structure itself, by declaring each chain link separately?</p>",
        "id": 531242160,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753662690
    },
    {
        "content": "<p>Well, you can bundle your flat sequence of proofs into a single lemma (arguably you're basically just creating a nested proof whose structure parallels the data structure, but that probably won't be how it <em>looks</em> if you're using tactics to build it)<br>\nThe structure itself doesn't <em>need</em> to be flattened, but if it's complicated or again involves dependent types it's a good idea to factor it into bits<br>\nThat's kinda true in general coding but it's <em>really</em> true in a dependently typed language</p>",
        "id": 531242431,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753662801
    },
    {
        "content": "<p>I guess I'm still fuzzy about the structure (i.e. how will this lemma be different from my random <code>rw [specification_axiom]</code>, <code>rw [blabla]</code> descent in the messy part of the snippet). I think you're saying these would be divided into steps with explicit goals? Or maybe presented in a different order?</p>",
        "id": 531243618,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753663307
    },
    {
        "content": "<p>Thanks for sharing the point about dependent types. I'm not familiar enough with how this comes up in practice to fully appreciate the insight but it's good to know there are some fundamental constraints that help guide the choices.</p>",
        "id": 531243725,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753663350
    },
    {
        "content": "<p>Is there anything here that's specifically about nested functions? I'm not sure I understand the question exactly, but I see that you have a nested object, and maybe it's that you're wondering about creating a proof that somehow reflects the structure?</p>\n<p>Sometimes it can work out. For example, if you have a predicate like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite#doc\">docs#Set.Finite</a>, then there are operations on predicates that reflect the corresponding set operations, e.g. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.Finite.union#doc\">docs#Set.Finite.union</a>. That way if you have <code>hs : Set.Finite s</code> and <code>ht : Set.Finite t</code>, you can write <code>hs.union ht</code> to get that the union is finite.</p>\n<p>Proof note: <code>power_spec</code> is suspect, since it doesn't include the conclusion, and poking around I see that it's really hard to state the conclusion. Maybe there's missing API here around powersets? Somehow you want to have a set of sets, rather than a set of objects that can be reinterpreted as sets. Needing to write <code>(as_subset A').choose</code> is seems a bit painful...</p>\n<p>(Side note: I'm not sure exactly why people call functions \"closures\" — this is something that's mildly bugged me for a long time in programming languages. Maybe when lexical closures came from Scheme everyone was excited, and because the main focus was implementation, people started calling [lambda] functions by the word that has to do with implementation details? I guess it could also be that the runtime value is many systems is represented as a closure, so in a bit of synecdoche, the function (which is the syntax) is referred to as if it were the closure. There are no closures here in proofs by the way. Any computations with functions are being done purely syntactically using the greek-letter reduction rules.)</p>",
        "id": 531249590,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753665724
    },
    {
        "content": "<p>Re: side note, I usually say \"closure\" when I mean lexical scoping in nested functions (which in runnable languages does usually need some mechanism to store the \"closed over\" values, which is not a thing here, I guess). I haven't learned whether the word strictly refers to a particular implementation. I probably wouldn't use it for every case of nested functions, but only when the inner one accesses something from the parent lexical scope. (My understanding is that the parent scope \"closes\" the binding, hence it's a \"closure\", so I use it in this structural sense rather than meaning a particular implementation trick.)</p>",
        "id": 531252218,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753666766
    },
    {
        "content": "<blockquote>\n<p>Proof note: <code>power_spec</code> is suspect, since it doesn't include the conclusion, and poking around I see that it's really hard to state the conclusion. Maybe there's missing API here around powersets? Somehow you want to have a set of sets, rather than a set of objects that can be reinterpreted as sets. Needing to write <code>(as_subset A').choose</code> is seems a bit painful...</p>\n</blockquote>\n<p>I'm not sure about this unfortunately! I know fact a fact that it is at least <em>doable</em> to solve it, but the solution I've <a href=\"https://github.com/rkirov/analysis/blob/afd615fdac5796bb9632d9f0c71d4bc69678c19c/analysis/Analysis/Section_3_4.lean#L888C23-L888C40\">looked at</a> is pretty hard to read through and could probably be streamlined. How exactly to streamline this argument is exactly what I'm struggling with.</p>",
        "id": 531253443,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753667231
    },
    {
        "content": "<p>I started writing this instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">partial_functions'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">Object</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">:</span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X'</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Y'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">asSubset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">asSubset_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">      </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">asSubset</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">asSubset</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">((</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">    </span><span class=\"n\">oX'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"bp\">.</span><span class=\"n\">replace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">      </span><span class=\"n\">oY'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"n\">asSubset</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">asSubset</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and then I immediately got lost again because I'm not sure how to layer on more lemmas.</p>",
        "id": 531253946,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753667425
    },
    {
        "content": "<p>This is a bit of theory building, but maybe something like this could help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">powerset</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">coe_eq_iff</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">exists_eq_left'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">IsSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">IsSet</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">isSet_get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">IsSet</span><span class=\"bp\">.</span><span class=\"n\">get_mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsSet</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">coe_eq_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">coe_get</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">isSet_powerset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSet</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_powerset</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"bp\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">get_isSet_powerset_subset</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">isSet_powerset</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mem_powerset'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">coe_get</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n</code></pre></div>\n<p>The idea is to build up this <code>IsSet.get</code> theory rather than use <code>Exists.choose</code> directly.</p>",
        "id": 531254435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753667615
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">power</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"bp\">.</span><span class=\"n\">powerset</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">isSet_powerset</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isSet_powerset</span><span class=\"w\"> </span><span class=\"n\">B'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">get</span>\n</code></pre></div>\n<p>With some more work, you could make</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SetTheory</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">powerset'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">}</span>\n</code></pre></div>\n<p>and use that instead, so that <code>.val</code> <em>is</em> a <code>Set</code> already, and then link this up into this <code>IsSet</code> stuff if it helps.</p>",
        "id": 531254885,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753667779
    },
    {
        "content": "<p>Ah, this is an interesting approach. I'll need some time to digest this because I haven't seen quite similar in the book so far.</p>",
        "id": 531254994,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753667824
    },
    {
        "content": "<p>But I guess there's also a general idea of having very small \"if this then that\" and having a clear language to state them.</p>",
        "id": 531255109,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753667864
    },
    {
        "content": "<p>We also haven't gotten to quotients yet by that point so I'm trying to stay within the machinery I've seen used before. Though probably not super important.</p>",
        "id": 531255427,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753667986
    },
    {
        "content": "<p>I don't expect you to use this for the exercises, but I thought you'd like something that illustrates how in practice we tend to build up theories to make it easy to express things and then having small lemmas that specify all the equations that the things satisfy.</p>\n<p>(By the way, <code>{_ // _}</code> is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subtype#doc\">docs#Subtype</a>, not quotients. The <code>powerset'</code> definition is creating a type of all sets that are a subset of <code>X</code>. This is an alternative to <code>powerset</code>; the function <code>SetTheory.Set.toSubtype</code> uses <code>Subtype</code> to convert <code>Set</code> into a Lean <code>Type</code>.)</p>",
        "id": 531261574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753670992
    },
    {
        "content": "<p>One thought I had here is that it could be useful to have a <code>IsSetSet</code> (or have <code>IsSet n X</code> mean that <code>X</code> is a set of sets of sets of ... of sets of objects) and then have operations like <code>SetTheory.Set.replace</code> have a specialization that works with <code>IsSetSet</code>, where from within the function you receive the additional fact that the object is a set.</p>\n<p>In the core library, there are functions like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a> that attach the fact that the elements of the list are elements of the list, which is used in conjunction with <code>List.map</code> for example, in case knowing that the elements are elements is essential to creating the new values. Maybe this is getting toward your question? I don't see a good way to do this sort of thing with <code>SetTheory.Set</code> though.</p>\n<p>I think one way of saying the issue is that usually in Lean we try to express things in a way where we know what the things are (we have a really strong type system after all!) but with <code>SetTheory.Set</code> it's more on the dynamic typing end of things — we don't know whether objects are sets or not, and we have to write these existentials to do \"runtime\" typechecking.</p>",
        "id": 531262094,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753671269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20structure.20proofs.20related.20to.20closures.3F/near/531243618\">said</a>:</p>\n<blockquote>\n<p>I guess I'm still fuzzy about the structure (i.e. how will this lemma be different from my random <code>rw [specification_axiom]</code>, <code>rw [blabla]</code> descent in the messy part of the snippet). I think you're saying these would be divided into steps with explicit goals? Or maybe presented in a different order?</p>\n</blockquote>\n<p>It probably won't (actually look different). One of the (many) reasons we have the infoview is, it's often pretty tough to intuit the structure of a proof just by looking at the code; most proofs will be lists of <code>rw</code>s, <code>simp</code>s, and the occasional <code>have</code>/<code>let</code> no matter what it's doing, with blocks only occurring when a single goal splits into multiple.</p>",
        "id": 531273739,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753678186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20structure.20proofs.20related.20to.20closures.3F/near/531243725\">said</a>:</p>\n<blockquote>\n<p>Thanks for sharing the point about dependent types. I'm not familiar enough with how this comes up in practice to fully appreciate the insight but it's good to know there are some fundamental constraints that help guide the choices.</p>\n</blockquote>\n<p>Key example: Suppose I have a function of dependent type <code>f : (a : α) → β a → ...</code>, appearing in a proof as <code>f x y ...</code>. I have a hypothesis <code>h : x = x'</code>, so I try to rewrite by <code>h</code>. </p>\n<p>But when I do that, I <em>change the expected type</em> of <code>y</code>; it used to be <code>β x</code>, and now it's <code>β x'</code>. Unless <code>h</code> is a definitional equality, <code>y</code> cannot be both a <code>β x</code> and a <code>β x'</code> at the same time, so at least one of these statements do not typecheck. </p>\n<p>There are three general solutions to this problem.</p>\n<ol>\n<li>If <code>y</code> is actually secretly determined by <code>x</code> anyway, if <code>y = g x</code> for some function <code>g</code>, then I can consolidate my dependencies, I can rewrite by <code>h</code> everywhere at once and the expression will now still typecheck. <code>rw</code> is now smart enough to do this a lot of the time and <code>simp_rw</code> will generally catch the rest.</li>\n<li>If I'm not that lucky, I might consider inserting a cast at the same time, replacing <code>f x y</code> with <code>f x' (h ▸ y)</code>. This is often a bad idea, always awkward, and at any rate is generally considered beyond the scope of low-level rewriting tactics; if you want to take this approach you will either need specialized lemmas, specialized <em>tactics</em> and API, or 'manual' rewriting with <code>change</code> and <code>convert_to</code>.</li>\n<li>As an alternative to 2, I can break up the structure and the proof. When the proof is sufficiently simple and the parameters are similarly low-level/atomic or nearly-atomic types, I can simply recurse on my equality <code>h</code> (using <code>cases</code>), which basically forces the compiler to unify <code>x</code> and <code>x'</code> everywhere; it's a superpowered version of 1. But for Reasons (TM) this <em>only works</em> when the type of <code>x, x'</code> are essentially atomic, which means you have to prove simple lemmas about non-composite cases and then apply them separately in a more complex use case.</li>\n</ol>",
        "id": 531275442,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753679202
    },
    {
        "content": "<p>(Reasons (TM), if you're curious and want to read ahead a bit:</p>\n<p>The key thing here is that equality is an inductive type in Lean, and like any inductive type it has a recursor. Equality's recursor says that, if I have a term of type <code>x = x'</code> and I want to prove something about <code>x</code>, I can just prove it about <code>x'</code> instead; in other words, it's the primary mechanism by which you can \"execute a substitution\" in Lean, rather than just inserting a cast function that you then have to work around. The <em>problem</em> is that recursing on equality gets more complicated with composite types: most \"type constructors\" -- including things you might not think of as such, like the function-type constructor <code>→ : Type u -&gt; Type v -&gt; Type max u v := fun α β ↦ (α → β)</code> -- turn out not to be injective, so knowing that two composite types are equal doesn't let you conclude that their  individual parameters are equal, which introduces an ambiguity in the structure that makes explicit substitution impossible. So you have to prove the lemmas in simple cases, rather than performing the substitution 'on the fly' later; so you have to break up your structures and your proofs. )</p>",
        "id": 531275897,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753679484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20structure.20proofs.20related.20to.20closures.3F/near/531252218\">said</a>:</p>\n<blockquote>\n<p>Re: side note, I usually say \"closure\" when I mean lexical scoping in nested functions (which in runnable languages does usually need some mechanism to store the \"closed over\" values, which is not a thing here, I guess). I haven't learned whether the word strictly refers to a particular implementation. I probably wouldn't use it for every case of nested functions, but only when the inner one accesses something from the parent lexical scope. (My understanding is that the parent scope \"closes\" the binding, hence it's a \"closure\", so I use it in this structural sense rather than meaning a particular implementation trick.)</p>\n</blockquote>\n<p>As a side note, if the specific thing you want is very literally \"to work with locally-scoped variables in Lean\", what you probably want are the tactics <code>lift_lets</code> and <code>intro</code>. <code>lift_lets</code>, as the name implies, takes all <code>let :=</code> and <code>have :=</code> statements in the internals of a term and lifts them out as far as possible, hopefully all the way to the top; <code>intro</code> can then add those definitions to the context directly.)</p>",
        "id": 531276194,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753679641
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> <code>extract_lets</code> does both at once, and even works on local hypotheses, which <code>intro</code> can't do anything about.)</p>",
        "id": 531280404,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1753681921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20do.20I.20structure.20proofs.20related.20to.20closures.3F/near/531280404\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <code>extract_lets</code> does both at once, and even works on local hypotheses, which <code>intro</code> can't do anything about.)</p>\n</blockquote>\n<p>(Ooh. I'll have to keep that in mind, thanks!)</p>",
        "id": 531280444,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1753681939
    },
    {
        "content": "<p>For the record, I ended up approaching this exercise in a relatively simple way: <a href=\"#narrow/stream/514017-Analysis-I/topic/.5BExercise.203.2E4.2E7.5D.20How.20to.20work.20with.20Props.20that.20have.20.60let_fun.60/near/531466204\">https://leanprover.zulipchat.com/#narrow/stream/514017-Analysis-I/topic/.5BExercise.203.2E4.2E7.5D.20How.20to.20work.20with.20Props.20that.20have.20.60let_fun.60/near/531466204</a></p>\n<p>The trick was to keep an existential in the construction (instead of using choice), and then methodically unwrap the construction outside-in.</p>\n<p>I’m still digesting why this worked (and why I used to get stuck previously) but it does show I was overthinking the problem.</p>",
        "id": 531466791,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1753738612
    }
]