[
    {
        "content": "<p>Hi. Could anyone please explain why instance resolution works in the first case (<code>stabilizer.submonoid</code>)  but not in the second one (<code>stabilizer</code>) ? (The strange thing is that the same lines in a bigger file compile without any error, but the problem appeared when I tried to incorporate them in <code>group_theory.group_action.sub_mul_action.lean</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Stabilizer of sub_mul_action</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.sub_mul_action</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u'</span> <span class=\"n\">u''</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u''</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_action</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">S</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">S</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Stabilizers in monoid sub_mul_action coincide with stabilizer -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_action.mem_stabilizer_submonoid_iff</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">sub_mul_action.coe_smul</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_eq_coe</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer</span> <span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">subgroup.to_submonoid_eq</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_submonoid</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_submonoid</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 270981996,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644242571
    },
    {
        "content": "<p>Can you find out what the instance is that is found in the bigger file? (By clicking around in the info-view, drilling down the widgets.)</p>",
        "id": 270982249,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644242680
    },
    {
        "content": "<p>Because it sounds like you might just need an extra <code>import</code>.</p>",
        "id": 270982281,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644242694
    },
    {
        "content": "<p>It doesn't work on master with <code>import all</code></p>",
        "id": 270984046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243403
    },
    {
        "content": "<p>What is the bigger file, and does it have any instances or local instances in it?</p>",
        "id": 270984166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243474
    },
    {
        "content": "<p>waitwaitwait, your problem is that R is both a group and a monoid; your tactic state has <code>_inst_1 : monoid R</code> and also <code>_inst_7 : group R</code> so you have two unrelated multiplications on R. If you want to prove lemmas about monoids and then later on lemmas about groups then either use a different letter or use sections.</p>",
        "id": 270984507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243638
    },
    {
        "content": "<p>Yeah, the lemma statement compiles if you change <code>[monoid R]</code> to <code>[group R]</code> right at the top so you might have to put the first lemma in a section and then restate all the variables in a second section but with R being a group not a monoid.</p>",
        "id": 270984747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243756
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Stabilizer of sub_mul_action</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.sub_mul_action</span>\n<span class=\"kn\">import</span> <span class=\"n\">all</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">u'</span> <span class=\"n\">u''</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u''</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_action</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">monoidy_stuff</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">S</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">S</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Stabilizers in monoid sub_mul_action coincide with stabilizer -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_action.mem_stabilizer_submonoid_iff</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">sub_mul_action.coe_smul</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_eq_coe</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">monoidy_stuff</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">groupy_stuff</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">S</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">S</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer</span> <span class=\"n\">R</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">subgroup.to_submonoid_eq</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_submonoid</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">this</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_submonoid</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">groupy_stuff</span>\n</code></pre></div>",
        "id": 270984904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Can't.20find.20instance/near/270984747\">said</a>:</p>\n<blockquote>\n<p>Yeah, the lemma statement compiles if you change <code>[monoid R]</code> to <code>[group R]</code> right at the top so you might have to put the first lemma in a section and then restate all the variables in a second section but with R being a group not a monoid.</p>\n</blockquote>\n<p>It seems that you're right : the file that worked had sections :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.sub_mul_action</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">sub_mul_action</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_action</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">monoid</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Stabilizers in monoid sub_mul_action coincide with stabilizer -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"o\">{</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer.submonoid</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_stabilizer_submonoid_iff</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">sub_mul_action.coe_smul</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_eq_coe</span><span class=\"o\">]</span>\n  <span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Orbits in sub_mul_action coincide with orbits -/</span>\n<span class=\"c1\">-- useful ?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">orbit_of_sub_mul</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">orbit</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">orbit</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">monoid</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">group</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mul_action</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Stabilizers in sub_mul_action coincide with stabilizer -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">stabilizer_of_sub_mul</span> <span class=\"o\">{</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">sub_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">stabilizer</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">subgroup.to_submonoid_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">stabilizer_of_sub_mul.submonoid</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">group</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">sub_mul_action</span>\n</code></pre></div>",
        "id": 270984972,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644243849
    },
    {
        "content": "<p>So: what is the impact of those sections?</p>",
        "id": 270985015,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644243868
    },
    {
        "content": "<p><code>variable [monoid R] [group R]</code> is always bad. But variables defined within a section disappear at the end of the section.</p>",
        "id": 270985053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243893
    },
    {
        "content": "<p>Something I do personally is that I always make my section names not equal to namespace names, because then when I see <code>end groupy_stuff</code> I know that this is the end of a section and not a namespace.</p>",
        "id": 270985142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644243941
    },
    {
        "content": "<p>I just saw that you had explained it already !<br>\nThere should be a way to say — up to now, <code>R</code>was a monoid, but from now on we assume that it is a group.</p>",
        "id": 270985161,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644243948
    },
    {
        "content": "<p>The problem in your case is that <code>mul_action R M</code> and <code>is_scalar_tower S R M</code> already all used <code>_inst_1</code> so you have to restate them to use <code>_inst_7</code>.</p>",
        "id": 270985313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644244016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/113489-new-members/topic/Can't.20find.20instance/near/270985161\">said</a>:</p>\n<blockquote>\n<p>I just saw that you had explained it already !<br>\nThere should be a way to say — up to now, <code>R</code>was a monoid, but from now on we assume that it is a group.</p>\n</blockquote>\n<p>I agree, it would be pretty cool to have <code>unvariables [monoid R]</code>.</p>",
        "id": 270985439,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644244080
    },
    {
        "content": "<p>We think of group as a propositional extension of a monoid but Lean doesn't because it wants to know the inverse function; we know one exists uniquely but my guess is that this would be a can of worms for Lean. Similarly we think of fields as being a predicate on rings but Lean doesn't.</p>",
        "id": 270985554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644244113
    },
    {
        "content": "<p>I worked out an example of this with a student recently; he had a ring which he wanted to promote to a field at some point so we used <code>is_field</code> and it's a bit of a minefield; in the end we went with <code>[fact (is_field R)]</code> and made the (noncomputable) field instance using type class inference, which worked.</p>",
        "id": 270985719,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644244185
    },
    {
        "content": "<p>We can make a similar remark from model theory : the language of Rings has 0, 1, +, - and * — it has subtraction as an elementary law — and the language of Fields is the same : division is not put in. So that basic formulas, even written in fields, have no division. This is not necessarily annoying because you can emulate them with existential quantifiers. But when one proves quantifier elimination in (algebraically closed, say) fields, this implies that you can really remove all division signs.</p>",
        "id": 270987723,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644245061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/113489-new-members/topic/Can't.20find.20instance/near/270985439\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130609\">Antoine Chambert-Loir</span> <a href=\"#narrow/stream/113489-new-members/topic/Can't.20find.20instance/near/270985161\">said</a>:</p>\n<blockquote>\n<p>I just saw that you had explained it already !<br>\nThere should be a way to say — up to now, <code>R</code>was a monoid, but from now on we assume that it is a group.</p>\n</blockquote>\n<p>I agree, it would be pretty cool to have <code>unvariables [monoid R]</code>.</p>\n</blockquote>\n<p>I would rather have <code>upgrade [group R] from [monoid R]</code> so that we are not forced to rewrite all the intermediate variables (from types such as <code>mul_action R M</code>) that already depended on <code>R </code>.</p>",
        "id": 270987904,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644245157
    },
    {
        "content": "<p>Yeah, that's certainly better.</p>",
        "id": 270988132,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644245237
    },
    {
        "content": "<p>No idea how feasible it would be to do that Lean-wise. But I suppose it can easily be done in Lean 4.</p>",
        "id": 270988201,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644245269
    },
    {
        "content": "<p>Anyway, the PR is now done ! <a href=\"https://github.com/leanprover-community/mathlib/pull/11899\">#11899</a></p>",
        "id": 270988434,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644245359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130609\">@Antoine Chambert-Loir</span> I left two comments about the docstrings (and renamed the PR)</p>",
        "id": 270989909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644245983
    },
    {
        "content": "<p>Thanks, and I committed them at once ! Eric made an important comment as well. And Rob removed the <em>easy</em> tag!</p>",
        "id": 271121872,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1644324616
    },
    {
        "content": "<p>Hi, I'm trying to refactor the <code>quiver</code> code a bit and got into some instance troubles.<br>\n<a href=\"https://github.com/bottine/mathlib/blob/3263f73f5f6d243f38f8bf64ce886739d23bd6ad/src/combinatorics/quiver/connected_component.lean#L57\">here</a>, lean doesn't find the necessary <code>quiver</code> instance on <code>V</code>, even though I have an instance as a variable.<br>\nI'm pretty sure it's related to universe incompatibilities, but can't really figure out where they come from.<br>\nI can't really get a MWE out of that: what kind of approach should I take to debug this?</p>",
        "id": 304201094,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665840546
    },
    {
        "content": "<p>Try <code>set_option pp.universes true</code></p>",
        "id": 304201966,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665841038
    },
    {
        "content": "<p>OK, I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"n\">u_1</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">wide_subquiver.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">symmetrify.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">quiver.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">l_2</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">V</span>\n</code></pre></div>\n<p>which I guess is related to the transition to <code>psum</code>, maybe?</p>",
        "id": 304202191,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665841149
    },
    {
        "content": "<p>Yeah, very possible...</p>",
        "id": 304202286,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665841198
    },
    {
        "content": "<p>Alright… I'm a bit clueless as to how to fix that so I might leave that aside for a while. Thanks!</p>",
        "id": 304203103,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665841527
    },
    {
        "content": "<p>This feels like a <code>Type</code> vs <code>Sort</code> issue</p>",
        "id": 304203480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665841744
    },
    {
        "content": "<p>Indeed, but no idea what's the cause</p>",
        "id": 304204534,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842341
    },
    {
        "content": "<p>Do things become more obvious if you use <code>[quiver.{v} V]</code> for a new universe <code>v</code>?</p>",
        "id": 304205025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665842555
    },
    {
        "content": "<p>I would guess that <code>quiver.{v+1} V</code> solves the issue</p>",
        "id": 304205286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665842700
    },
    {
        "content": "<p>let me see</p>",
        "id": 304205357,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842726
    },
    {
        "content": "<p>lol, it does…</p>",
        "id": 304205391,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842745
    },
    {
        "content": "<p>But am I risking a kind of domino effect here where the <code>+1</code> has to be appended everytime?</p>",
        "id": 304205472,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665842771
    },
    {
        "content": "<p>I expect the real solution is to change a <code>Type</code> to a <code>Sort</code> somewhere</p>",
        "id": 304206009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843045
    },
    {
        "content": "<p>One of the thing I did was change <code>symmetrify</code> from being defined as  <code>sum (x --&gt; y) (y --&gt; X)</code> to <code>psum …</code>, so that I can symmetrify a <code>Prop</code>ositional quiver. This could mean that this is simply incompatible with doing things cleanly?</p>",
        "id": 304206492,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843286
    },
    {
        "content": "<p>Does <code>V : Sort*</code> work?</p>",
        "id": 304206957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843558
    },
    {
        "content": "<p>quivers take <code>V : Type*</code>, so doing that would imply redefining quivers themselves, no?</p>",
        "id": 304207352,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843763
    },
    {
        "content": "<p>I'm trying, but it's not entirely mechanical afaict</p>",
        "id": 304207377,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843777
    },
    {
        "content": "<p>(and redefining quivers would redefine categories I guess… which looks quite dangerous to me)</p>",
        "id": 304207467,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843821
    },
    {
        "content": "<p>Do they? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quiver\">docs#quiver</a></p>",
        "id": 304207469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843823
    },
    {
        "content": "<p>Yes, there's a difference between the index type and the return type of the homs.</p>",
        "id": 304207556,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665843849
    },
    {
        "content": "<p>Yes. Then my <code>Sort</code> suggestion is a bad idea!</p>",
        "id": 304207574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665843857
    },
    {
        "content": "<p>(haha I'm relieved I don't have to go there :) )</p>",
        "id": 304207642,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665843898
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/wide_subquiver\">docs#wide_subquiver</a> is the issue?</p>",
        "id": 304207869,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1665844016
    },
    {
        "content": "<p>Mmh, that would make sense, and then I'd only have to \"up\" the level there, but I actually get other errors somewhere else also related to bad universes.</p>\n<p>To be more precise: now it's <code>category_theory/groupoid/free_groupoid.lean</code> that complains: the abbreviations at the beginning fail already.</p>",
        "id": 304208523,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844367
    },
    {
        "content": "<p>Doesn't <code>set</code> support <code>Prop</code> types?</p>",
        "id": 304208760,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844493
    },
    {
        "content": "<p>Bargh, got to go, thanks for the help debugging this!</p>",
        "id": 304209357,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665844758
    },
    {
        "content": "<p>Scott Morrison once tried to generalise the category theory library so that it allowed morphisms to take values in Sort u rather than Type u and after some struggling he gave up on the idea and reverted. This feels like the same sort of thing</p>",
        "id": 304210595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665845382
    },
    {
        "content": "<p>... which is really a shame, because that would allow us to unify orders and categories.</p>",
        "id": 304210780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665845488
    },
    {
        "content": "<p>mmh, that's sad indeed</p>",
        "id": 304217797,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665849252
    },
    {
        "content": "<p>The <code>symmetrify</code> code has been ported to mathlib4, and it seems the universe problem disappears, so that one should be able to take <code>symmetrify V</code> as a <code>PSum</code> rather than a <code>Sum</code>. Is making such a change incompatible with the port having to be kind of 1-1 ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Copyright (c) 2021 David Wärn. All rights reserved.</span>\n<span class=\"cm\">Released under Apache 2.0 license as described in the file LICENSE.</span>\n<span class=\"cm\">Authors: David Wärn</span>\n<span class=\"cm\">Ported by: Joël Riou</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Subquiver</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.Quiver.Path</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Sum.Basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">## Weakly connected components</span>\n\n<span class=\"cm\">For a quiver `V`, we build a quiver `Symmetrify V` by adding a reversal of every edge.</span>\n<span class=\"cm\">Informally, a path in `Symmetrify V` corresponds to a 'zigzag' in `V`. This lets us</span>\n<span class=\"cm\">define the type `WeaklyConnectedComponent V` as the quotient of `V` by the relation which</span>\n<span class=\"cm\">identifies `a` with `b` if there is a path from `a` to `b` in `Symmetrify V`. (These</span>\n<span class=\"cm\">zigzags can be seen as a proof-relevant analogue of `EqvGen`.)</span>\n\n<span class=\"cm\">Strongly connected components have not yet been defined.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Quiver</span>\n\n<span class=\"sd\">/-- A type synonym for the symmetrized quiver (with an arrow both ways for each original arrow).</span>\n<span class=\"sd\">    NB: this does not work for `Prop`-valued quivers. It requires `[Quiver.{v+1} V]`. -/</span>\n<span class=\"c1\">-- Porting note: no hasNonemptyInstnace linter yet</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">V</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">symmetrifyQuiver</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Quiver</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">↦</span> <span class=\"n\">PSum</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- A quiver `HasReverse` if we can reverse an arrow `p` from `a` to `b` to get an arrow</span>\n<span class=\"sd\">    `p.reverse` from `b` to `a`.-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasReverse</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- the map which sends an arrow to its reverse -/</span>\n  <span class=\"n\">reverse'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Reverse the direction of an arrow. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reverse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">⟶</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">HasReverse.reverse'</span>\n\n<span class=\"sd\">/-- A quiver `HasInvolutiveReverse` if reversing twice is the identity.`-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"kd\">extends</span> <span class=\"n\">HasReverse</span> <span class=\"n\">V</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- `reverse` is involutive -/</span>\n  <span class=\"n\">inv'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">reverse_reverse</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">h.inv'</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">HasReverse</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">f</span>\n            <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span>\n    <span class=\"n\">HasInvolutiveReverse</span>\n      <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toHasReverse</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">↦</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">f</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">f</span><span class=\"o\">⟩</span>\n  <span class=\"n\">inv'</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- Reverse the direction of a path. -/</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">Path.reverse</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">Path</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Path.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Path.nil</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">Path.cons</span> <span class=\"n\">p</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath.comp</span> <span class=\"n\">p.reverse</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_toPath</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">f.toPath.reverse</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">toPath</span> <span class=\"o\">:=</span>\n  <span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">quiver.path.reverse_to_path</span> <span class=\"n\">Quiver.Path.reverse_toPath</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_comp</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reverse</span> <span class=\"bp\">=</span> <span class=\"n\">q.reverse.comp</span> <span class=\"n\">p.reverse</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">q</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Path.reverse_reverse</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Path</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">p.reverse.reverse</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Path.reverse</span><span class=\"o\">,</span> <span class=\"n\">Path.reverse_comp</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">Path.reverse_toPath</span><span class=\"o\">,</span> <span class=\"n\">Quiver.reverse_reverse</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- The inclusion of a quiver in its symmetrification -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify.of</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"n\">PSum.inl</span>\n\n<span class=\"sd\">/-- Given a quiver `V'` with reversible arrows, a prefunctor to `V'` can be lifted to one from</span>\n<span class=\"sd\">    `Symmetrify V` to `V'` -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">Symmetrify.lift</span> <span class=\"o\">{</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Prefunctor</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">V'</span> <span class=\"n\">where</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">φ.obj</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">f</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inl</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">φ.map</span> <span class=\"n\">g</span>\n  <span class=\"bp\">|</span> <span class=\"n\">PSum.inr</span> <span class=\"n\">g</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">φ.map</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_spec</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Symmetrify.of.comp</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">Prefunctor.ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_reverse</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">HasInvolutiveReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Quiver.reverse</span> <span class=\"o\">((</span><span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Symmetrify.lift</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">f</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">only</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h.inv'</span><span class=\"o\">]</span>\n    <span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- `lift φ` is the only prefunctor extending `φ` and preserving reverses. -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Symmetrify.lift_unique</span> <span class=\"o\">(</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Quiver</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">HasReverse</span> <span class=\"n\">V'</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"n\">V</span> <span class=\"n\">V'</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">Prefunctor</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">V'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Φ</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify.of.comp</span> <span class=\"bp\">Φ</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">Φ</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n      <span class=\"bp\">Φ.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Quiver.reverse</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">Quiver.reverse</span> <span class=\"o\">(</span><span class=\"bp\">Φ.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"bp\">Φ</span> <span class=\"bp\">=</span> <span class=\"n\">Symmetrify.lift</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">subst_vars</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">Prefunctor.ext</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span>\n    <span class=\"n\">rfl</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span>\n    <span class=\"n\">cases</span> <span class=\"n\">f</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">Φ</span><span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">align</span> <span class=\"n\">quiver.symmetrify.lift_unique</span> <span class=\"n\">Quiver.Symmetrify.lift_unique</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Two vertices are related in the zigzag setoid if there is a</span>\n<span class=\"sd\">    zigzag of arrows from one to the other. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">zigzagSetoid</span> <span class=\"o\">:</span> <span class=\"n\">Setoid</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↦</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">),</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">Path.nil</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n    <span class=\"o\">⟨</span><span class=\"n\">p.reverse</span><span class=\"o\">⟩,</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">p.comp</span> <span class=\"n\">q</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"sd\">/-- The type of weakly connected components of a directed graph. Two vertices are</span>\n<span class=\"sd\">    in the same weakly connected component if there is a zigzag of arrows from one</span>\n<span class=\"sd\">    to the other. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient</span> <span class=\"o\">(</span><span class=\"n\">zigzagSetoid</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">WeaklyConnectedComponent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The weakly connected component corresponding to a vertex. -/</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">Quotient.mk'</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zigzagSetoid</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CoeTC</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">WeaklyConnectedComponent.mk</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">Inhabited</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Inhabited</span> <span class=\"o\">(</span><span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">show</span> <span class=\"n\">V</span> <span class=\"k\">from</span> <span class=\"n\">default</span><span class=\"o\">⟩</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">WeaklyConnectedComponent</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">Nonempty</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Path</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Quotient.eq'</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">WeaklyConnectedComponent</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Without the explicit universe level in `Quiver.{v+1}` Lean comes up with</span>\n<span class=\"c1\">-- `Quiver.{max u_2 u_3 + 1}`. This causes problems elsewhere, so we write `Quiver.{v+1}`.</span>\n<span class=\"sd\">/-- A wide subquiver `H` of `Symmetrify V` determines a wide subquiver of `V`, containing an</span>\n<span class=\"sd\">    an arrow `e` if either `e` or its reversal is in `H`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">wideSubquiverSymmetrify</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"o\">(</span><span class=\"n\">Symmetrify</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">WideSubquiver</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">↦</span> <span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">PSum.inl</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">PSum.inr</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Quiver</span>\n</code></pre></div>",
        "id": 315305321,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670831112
    },
    {
        "content": "<p>My instinct is that the port should be 1-1 and any refractors should be done after it's complete.</p>",
        "id": 315308404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670832386
    }
]