[
    {
        "content": "<p>Hi, I have a project with one main theorem and many others. I need to identify which theorems were actually used in the proof of the main theorem (i.e. which ones will make the main theorem break removed). Is there a linter for that?</p>",
        "id": 571521852,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1770065264
    },
    {
        "content": "<p>This idea has come up in the past --- I'm not aware of any tooling to help you with this, sadly. It would be nice to have it!</p>",
        "id": 571533988,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1770069846
    },
    {
        "content": "<p>If I’m understanding the tool you are looking for correctly, this thread might be relevant, though I don't think there is a one shot tool for the requested task:<br>\n<a href=\"#narrow/channel/113488-general/topic/Extracting.20proof.20dependencies/with/465860819\">Extracting proof dependencies</a></p>",
        "id": 571549663,
        "sender_full_name": "Evan Wang",
        "timestamp": 1770078035
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">ImportGraph</span><span class=\"bp\">.</span><span class=\"n\">RequiredModules</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">CoreM</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"ss\">`Nat.add_comm</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">deps</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">transitivelyUsedConstants</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">depsNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">deps</span><span class=\"bp\">.</span><span class=\"n\">toArray</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"ss\">`Nat</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isPrefixOf</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">IO</span><span class=\"bp\">.</span><span class=\"n\">println</span><span class=\"w\"> </span><span class=\"n\">s!</span><span class=\"s2\">\"Nat-prefixed transitive deps of {n}: {depsNat}\"</span>\n</code></pre></div>\n<p>This outputs</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Nat-prefixed transitive deps of Nat.add_comm: #[Nat.brecOn.go, Nat.rec, Nat.brecOn, Nat.below, Nat, Nat.zero, Nat.add.match_1, Nat.zero_add, Nat.succ_add, Nat.succ, Nat.add, Nat.casesOn, Nat.add_comm]\n</code></pre></div>\n<p>Should be what you are looking for</p>",
        "id": 571551919,
        "sender_full_name": "Evan Wang",
        "timestamp": 1770079835
    }
]