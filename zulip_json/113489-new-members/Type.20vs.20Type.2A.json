[
    {
        "content": "<p>I've just written out this question : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">open_set_for_each</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">⊂</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>When I look at the topology api I see this: <a href=\"/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/WJ3mXdGYyDIs1pc_0fTImo-9/image.png\"></a></div><p>How does <code>is_open</code> know I'm talking about X ?</p>\n<p>Also, what does it mean when I write <code>X : Type</code> ? Am I just stating that it's an aribitrary type? I have trouble understanding <code>Type u</code> and all that stuff.</p>",
        "id": 272563452,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329393
    },
    {
        "content": "<p>When writing code for mathlib you usually want to use <code>X : Type*</code> instead of <code>X : Type</code></p>",
        "id": 272563477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329455
    },
    {
        "content": "<p><code>X : Type</code> means <code>X</code> is a type in the lowest universe; <code>X : Type*</code> means <code>X</code> is a type in any universe</p>",
        "id": 272563527,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329492
    },
    {
        "content": "<p>you don't need to know much about universes other than to know there is more than one and so <code>X : Type</code> is putting a restriction on users of your theorem. In 98% of cases you can just write <code>Type*</code> instead of <code>Type</code> and pay no more heed to it</p>",
        "id": 272563554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329583
    },
    {
        "content": "<p>I am a little curious about the universes, I'm not sure what those are but I know that there are different type levels, like <code>Type 0</code>, <code>Type 1</code> and so on, why are there so many?</p>",
        "id": 272563685,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329639
    },
    {
        "content": "<p>Also what is the difference between <code>X : Type*</code> and <code>X : Type u</code></p>",
        "id": 272563705,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329669
    },
    {
        "content": "<p>Ideally there would be only one universe, the type of all types. Unfortunately Russell and Girard proved this is inconsistent, so the type of all types has to live in a bigger type</p>",
        "id": 272563719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329699
    },
    {
        "content": "<p>So in lean <code>Type 0 : Type 1</code> and <code>Type 1 : Type 2</code> and so on</p>",
        "id": 272563731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329719
    },
    {
        "content": "<p>You will almost never see the higher universes show up in practice, but they are theoretically important</p>",
        "id": 272563775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329746
    },
    {
        "content": "<p><code>X : Type*</code> is the same as <code>X : Type _</code>, which is to say X has Type \"lean figure it out\"</p>",
        "id": 272563796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329787
    },
    {
        "content": "<p>Ok, so the goal is that we want to say that <code>X</code> is an arbitrary type, but there's no type we can put on the underscore <code>X : _</code> to make that happen (based on Russel and Girard) ?</p>",
        "id": 272563800,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329790
    },
    {
        "content": "<p>usually it will end up being a universe variable, so you get <code>X : Type u</code> with <code>u</code> being a universe parameter to the theorem</p>",
        "id": 272563818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329818
    },
    {
        "content": "<p>So instead we build a tower of types that are increasing and then let it be one of the levels in the tower?</p>",
        "id": 272563859,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329843
    },
    {
        "content": "<p>Right, we get a family of theorems, one for each universe we want to instantiate X to</p>",
        "id": 272563868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329846
    },
    {
        "content": "<p>Do we ever use specific levels?</p>",
        "id": 272563913,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329878
    },
    {
        "content": "<p>it seems like we have infinite of them just to solve the paradox.</p>",
        "id": 272563918,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329891
    },
    {
        "content": "<p>Concrete types usually have the lowest possible level we can assign to them. So for example <code>nat : Type 0</code></p>",
        "id": 272563944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329905
    },
    {
        "content": "<p>What would have gone wrong if we did <code>nat : Type *</code> ?</p>",
        "id": 272563954,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645329925
    },
    {
        "content": "<p>and if <code>A : Type u</code> and <code>B : Type v</code> then <code>A ⊕ B : Type (max u v)</code></p>",
        "id": 272563965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645329948
    },
    {
        "content": "<p>If we did <code>nat : Type u</code>, then it wouldn't really be one type, it would be a family of types, denoted <code>nat.{u} : Type u</code>. This is fine, but lean will often not be able to solve for <code>u</code> when you use <code>nat</code> in a theorem so users will have to pay closer attention to the universes</p>",
        "id": 272564043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330021
    },
    {
        "content": "<p>So <code>Type u</code> is the type of families of <code>Type u</code> ??</p>",
        "id": 272564065,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330072
    },
    {
        "content": "<p>so as a result, this technique is generally reserved to cases where universes really are important, like <code>ordinal.{u}</code> and <code>cardinal.{u}</code>, or they might be available as variants of an existing definition, for example <code>empty : Type 0</code> and <code>pempty.{u} : Type u</code></p>",
        "id": 272564112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330095
    },
    {
        "content": "<p><code>Type u</code> is the type of all types in universe u</p>",
        "id": 272564117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330107
    },
    {
        "content": "<p><code>Type u</code> is equal to <code>Sort (u+1)</code>, which extends the universe hierarchy one step downward to the universe <code>Prop = Sort 0</code>, which is special in a few ways</p>",
        "id": 272564129,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330148
    },
    {
        "content": "<p>So then <code>nat : Type u</code> makes <code>nat</code> a type in universe <code>u</code>?</p>",
        "id": 272564132,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330151
    },
    {
        "content": "<p>You mean in the definition? Normally if you write <code>nat : Type u</code> you get a type error because <code>nat</code> doesn't have type <code>Type u</code>, it has type <code>Type 0</code></p>",
        "id": 272564196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330204
    },
    {
        "content": "<p>if you put that in the definition then it would become a family of types <code>nat.{u}</code> as mentioned, so you would have <code>nat.{0} : Type 0</code>, <code>nat.{1} : Type 1</code> and so on</p>",
        "id": 272564212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330244
    },
    {
        "content": "<p>Ok, and since we only need one version of the naturals we just do <code>nat : Type 0</code> ?</p>",
        "id": 272564231,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330276
    },
    {
        "content": "<p>exactly</p>",
        "id": 272564233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330282
    },
    {
        "content": "<p>Would integers also reside in <code>Type 0</code> ?</p>",
        "id": 272564246,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330309
    },
    {
        "content": "<p>yep</p>",
        "id": 272564249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330314
    },
    {
        "content": "<p>Or would it be a larger number?</p>",
        "id": 272564250,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330316
    },
    {
        "content": "<p>Oh ok</p>",
        "id": 272564289,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330326
    },
    {
        "content": "<p>it is occasionally technically useful to have a copy of the natural numbers in higher universes, and we use <code>ulift.{u v} : Type u -&gt; Type (max u v)</code> for that</p>",
        "id": 272564296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330333
    },
    {
        "content": "<p>I understand why we needed infinite types, because of the paradox, but what are the point of the <code>Sort</code>'s ?</p>",
        "id": 272564315,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330387
    },
    {
        "content": "<p>Some theorems are true for both <code>Prop</code> and <code>Type u</code></p>",
        "id": 272564324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330409
    },
    {
        "content": "<p>and it is useful to be able to prove them only once and have the theorem apply in both contexts</p>",
        "id": 272564335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330436
    },
    {
        "content": "<p>Why do we need both ?</p>",
        "id": 272564336,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330441
    },
    {
        "content": "<p>why have propositions? or why have types? Both are useful</p>",
        "id": 272564383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330463
    },
    {
        "content": "<p>obviously we need <code>nat</code> and we need <code>2 + 2 = 4</code></p>",
        "id": 272564391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330484
    },
    {
        "content": "<p>So it's to do with the types as propositions mindset thing right?</p>",
        "id": 272564395,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330486
    },
    {
        "content": "<p>yeah, basically</p>",
        "id": 272564398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330494
    },
    {
        "content": "<p>So why not set them equal? Like : <code>Type u</code> is equal to <code>Sort u</code> if they represent the same thing?</p>",
        "id": 272564416,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330525
    },
    {
        "content": "<p>That's the way it used to be, but inductive types that have type <code>Sort u</code> are really badly behaved so we usually have them in <code>Type u</code> or <code>Prop</code></p>",
        "id": 272564475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330577
    },
    {
        "content": "<p>I suppose we could write <code>Sort (u+1)</code> but that's a really common case</p>",
        "id": 272564489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330610
    },
    {
        "content": "<p>and <code>Type = Type 0</code> is especially common since it's the type of all your favorite types</p>",
        "id": 272564496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330636
    },
    {
        "content": "<p>Ok, so it's due to some implementation thing in Lean not due to some conceptual thing like, <code>we need infinite types to dodge the paradox</code> ?</p>",
        "id": 272564505,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330651
    },
    {
        "content": "<p>No this is just a design question. Coq does it differently, there is no <code>Sort</code> but there is <code>Prop</code>, <code>Set</code> and <code>Type u</code> and don't ask me why they need two base universes</p>",
        "id": 272564573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330722
    },
    {
        "content": "<p>oh and <code>SProp</code></p>",
        "id": 272564578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330733
    },
    {
        "content": "<p>Agda has <code>Prop u</code> and <code>Type u</code> IIRC</p>",
        "id": 272564600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330788
    },
    {
        "content": "<p>Ok, I think I came out of this understanding a little more (at least why there are infinite of them).</p>",
        "id": 272564652,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330824
    },
    {
        "content": "<p>Thank you</p>",
        "id": 272564656,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330839
    },
    {
        "content": "<p>Oh and of course ZFC just has one universe</p>",
        "id": 272564667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330866
    },
    {
        "content": "<p>Because everything is a set?</p>",
        "id": 272564677,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330885
    },
    {
        "content": "<p>everything except the set of all sets</p>",
        "id": 272564681,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330895
    },
    {
        "content": "<p>there are sets and classes and some classes can't be sets</p>",
        "id": 272564685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330910
    },
    {
        "content": "<p>That doesn't exist right?</p>",
        "id": 272564688,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645330912
    },
    {
        "content": "<p>and the universe itself is one of them</p>",
        "id": 272564740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330925
    },
    {
        "content": "<p>so roughly speaking ZFC loses the type theory ability to say that everything expressible in the system has some type</p>",
        "id": 272564776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645330974
    },
    {
        "content": "<p>that's what really forces the infinite hierarchy</p>",
        "id": 272564786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331000
    },
    {
        "content": "<p>Right</p>",
        "id": 272564790,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331017
    },
    {
        "content": "<p>Using types we still can't say \"a : &lt;type of all types&gt;\", but we can say <code>a : Type*</code> to say that it resides in of the layers which is equivalent ?</p>",
        "id": 272564858,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331094
    },
    {
        "content": "<p>Well, <code>Type*</code> isn't really a type, it's notation for <code>Type &lt;something that lean will deduce from context&gt;</code></p>",
        "id": 272564888,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331143
    },
    {
        "content": "<p>What about in a situation like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">open_set_for_each</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">⊂</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272564943,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331191
    },
    {
        "content": "<p>If you say <code>X : Type*</code> in an assumption, then lean will deduce that you want it to live in a universe named by a fresh universe variable</p>",
        "id": 272564956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331211
    },
    {
        "content": "<p>so lean turns your theorem into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">open_set_for_each.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">⊂</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272564968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331229
    },
    {
        "content": "<p>(the lean 3 syntax for that is actually a little different BTW, <code>theorem {u} open_set_for_each</code>, but this is weird and has been changed to be the sensible thing in lean 4)</p>",
        "id": 272565014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331279
    },
    {
        "content": "<p>And the only way we can actually use that theorem is by specifying an <em>actual</em> number ?</p>",
        "id": 272565054,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331287
    },
    {
        "content": "<p>no, we can specify a universe expression as well</p>",
        "id": 272565061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331305
    },
    {
        "content": "<p>What would that look like?</p>",
        "id": 272565080,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331341
    },
    {
        "content": "<p>for example if you are proving some other theorem with a <code>{u}</code> in it then you might use <code>open_set_for_each.{u}</code>, or maybe <code>open_set_for_each.{u+1}</code> or <code>open_set_for_each.{max u 3}</code></p>",
        "id": 272565086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331350
    },
    {
        "content": "<p>lean is very good at figuring the right indexes out so you almost never have to specify</p>",
        "id": 272565098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331382
    },
    {
        "content": "<p>In that situation is <code>u : nat</code> ?</p>",
        "id": 272565100,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331384
    },
    {
        "content": "<p>not exactly. You can think of it that way, it represents a natural number, but not in a way that lean itself has access to. You can't write <code>def foo (n : nat) : Type n := ...</code></p>",
        "id": 272565167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331450
    },
    {
        "content": "<p>So how do I say <code>u</code> is a universe variable thing?</p>",
        "id": 272565184,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645331483
    },
    {
        "content": "<p>This is also on pain of contradiction, because if such a <code>foo</code> existed then the type of <code>foo</code> itself would have to live in <code>Type ω</code></p>",
        "id": 272565193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331492
    },
    {
        "content": "<p>You use <code>universe(s) u</code>  to declare universe variables, analogous to <code>variable(s) n : nat</code> statements</p>",
        "id": 272565241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331534
    },
    {
        "content": "<p>and to declare universe variables in a theorem statement you put the names in braces <em>before</em> the theorem name, like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">open_set_for_each</span>\n  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">⊂</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272565275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331588
    },
    {
        "content": "<p>Or you can use <code>Type*</code> which implicitly declares an anonymous universe variable for the statement</p>",
        "id": 272565338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331670
    },
    {
        "content": "<p>Another trick I like is to just use <code>(X)</code> which declares <code>X : Sort*</code>, which lean will solve to <code>Sort u</code> or <code>Prop</code> or <code>Type u</code> as appropriate based on how it is used</p>",
        "id": 272565373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331728
    },
    {
        "content": "<p>it's short and very difficult to get wrong</p>",
        "id": 272565408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645331763
    }
]