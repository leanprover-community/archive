[
    {
        "content": "<p>Generally speaking I was thinking I understood coercions, specifically from <code>ℕ</code> to <code>ℤ</code>; <strong>Theorem Proving in Lean 4</strong> has a section on Coercions with examples, but only involving additions. I tried similar things with subtractions, and was a bis surprised at the result.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">+</span><span class=\"n\">i</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- 1</span>\n</code></pre></div>\n<p>I was not surprised that <code>(m-n)+i</code>  was typed as <code>ℤ</code>: this is similar to the case with additions in <strong>TPIL</strong>. But I was somehow expecting Lean to insert the coercion to <code>ℤ</code> after the subtraction, where it becomes clear that what is expected is a term of type <code>ℤ</code> and not <code>ℕ</code>; so <code>3-4</code> would be evaluated as <code>0:ℕ</code>, then coerced to <code>0:ℤ</code>, for a final value of <code>2</code>.</p>\n<p>So what I understand is that, somehow, Lean decides that natural numbers should be converted to integers as early as possible. I can see how this will be less confusing to a person not used to thinking in terms of having different types, but I don't understand why and how this works.</p>\n<p>Is this somehow linked to the <code>-</code> notation? Does Lean somehow decide it wants to apply <code>Int.sub</code> and not <code>Nat.sub</code>, triggering coercions at this level? If I explicitly use <code>Nat.sub</code> in the expression instead, I do get the expected (by me) result <code>2:ℤ</code></p>",
        "id": 490163385,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1734702212
    },
    {
        "content": "<p>Coercions are pushed out toward the leaves of the expression tree; the expected type of the expression is the sort of \"goal\" that gets propagated out during elaboration. Without having to understand how all of the parts of the elaborator are working together, I think the heuristic you can use is just \"which possible coercion is further toward the leaves\", which in this case is <code>(↑3) - (↑4)</code> rather than <code>↑(3 - 4)</code>.</p>",
        "id": 490165734,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734702997
    },
    {
        "content": "<p>OK, thanks. So \"expect coercions to be applied as early as possible\" seems like a good mantra.</p>",
        "id": 490166176,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1734703132
    },
    {
        "content": "<p>No, that's not exactly right, Chris</p>",
        "id": 490166186,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1734703135
    },
    {
        "content": "<p>Enlighten me then, I'm going off what I got <a href=\"#narrow/channel/287929-mathlib4/topic/Aggressiveness.20of.20nat.20literal.20conversion/near/267546431\">here</a></p>",
        "id": 490166324,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734703185
    },
    {
        "content": "<p>Arithmetic operators like <code>+</code>, <code>-</code>, <code>*</code> (but currently <em>not</em> <code>∑</code> nor <code>∏</code>) have special elaborator support to push the coercion inside as you describe. However, other operators follow the usual rule which is to have the coercion outside</p>",
        "id": 490166585,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1734703257
    },
    {
        "content": "<p>OK, so my new mantra looks like it will be \"it's not that simple\". Which, in turn, is a good overall mantra with proof assistants.</p>",
        "id": 490167374,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1734703497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> What's the actual definition of \"arithmetic\" in this context/can you give an example that doesn't follow the \"coerce at the leaves\" pattern? The first one I thought of that doesn't seem arithmetic is the List.cons notation, but that seems to want to coerce at the leaves even when an alternative is possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Coe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">[])</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">def xs : List.{0} Int :=</span>\n<span class=\"cm\">@List.cons.{0} Int (@Nat.cast.{0} Int instNatCastInt Nat.zero) (@List.nil.{0} Int)</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">def ys : List.{0} Int :=</span>\n<span class=\"cm\">@List.cons.{0} Int (@Nat.cast.{0} Int instNatCastInt Nat.zero) (@List.map.{0, 0} Nat Int Int.ofNat (@List.nil.{0} Nat))</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">([]:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">ys</span>\n</code></pre></div>",
        "id": 490169838,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734704308
    },
    {
        "content": "<p>I can get the other one to fire if I annotate it at the top:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">def zs : List.{0} Int :=</span>\n<span class=\"cm\">@List.map.{0, 0} Nat Int Int.ofNat (@List.cons.{0} Nat Nat.zero (@List.nil.{0} Nat))</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">zs</span>\n</code></pre></div>",
        "id": 490170114,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734704407
    },
    {
        "content": "<p>\"arithmetic\" means \"is one of the few elaborators to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.Term.binop#doc\">docs#Lean.Parser.Term.binop</a>\"</p>",
        "id": 490170510,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1734704558
    },
    {
        "content": "<p>I don't think List.cons uses that, and using <code>List.cons</code> without the notation also seems to coerce at the leaves. I found <a href=\"#narrow/channel/270676-lean4/topic/.E2.9C.94.20Regression.20in.20coercion.20inference/near/281739274\">this</a>;  I'll take a closer look into this when I get some time.</p>",
        "id": 490172878,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1734705282
    },
    {
        "content": "<p>The expression tree elaborator has a module docstring here: <a href=\"https://github.com/leanprover/lean4/blob/39eaa214d464bac67696e7ee1279232f5e199164/src/Lean/Elab/Extra.lean#L83\">https://github.com/leanprover/lean4/blob/39eaa214d464bac67696e7ee1279232f5e199164/src/Lean/Elab/Extra.lean#L83</a></p>\n<p>There are a handful of other elaborators that participate, including <code>unop%</code>, etc. Any syntax that is a macro that expands to one of these elaborators is part of the expression tree. Parentheses count as being part of the expression tree too.</p>\n<p>I found a couple messages where I tried to explain a bit about it (below). The core issue is that the basic arithmetic operations are completely heterogenous, so they can't propagate types from the expected type to the arguments (the output type is an outParam after all). For normally defined homogenous operators, like <code>List.cons</code>, then a natural consequence of the basic elaboration algorithm is that the expected type propagates inwards, causing coercions to be inserted as far inward as possible. The expression tree elaborator attempts to simulate this, but it will only ever be able to put coercions at its own synthetic notion of a leaf (sub-expressions that aren't one of these <code>binop%</code>/<code>unop%</code>/... elaborators).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/116395-maths/topic/Glitch.3F/near/433157307\">said</a>:</p>\n<blockquote>\n<p>Yeah, to first approximation it's outside-in, and it's wrong to say that \"the rule is reversed\".</p>\n<p>Basic operation: it locates the entire tree of arithmetic expressions (the ones that participate in the <code>binop%</code>/<code>unop%</code>/<code>rightact%</code>/etc protocol), elaborates each leaf without an expected type, computes a type that everything can coerce to (the \"maximal type\"), then drops coercions at the leaves wherever they're needed. Just like for the Lean 3 \"outside-in\" description, coercions are at the leaves, but unlike pure \"outside-in\", (1) leaves can influence the type of the entire expression and (2) coercions can't be dropped <em>inside</em> the leaves, since elaboration is already completed.</p>\n<p>If it weren't expensive, the way it could work instead is, rather than inserting coercions at leaves, is to re-elaborate each leaf with the computed maximal type. That would let the types propagate coercions deeper into subexpressions, like <code>Finset.sum</code>.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/287929-mathlib4/topic/Avoiding.20type.20annotation/near/406809225\">said</a>:</p>\n<blockquote>\n<p>Outside-in vs inside-out isn't completely accurate. It elaborates each leaf in a full arithmetic expression without an expected type, then it computes a type that everything can be coerced to, and then it inserts coercions where needed.</p>\n<p>A difference one can observe is that coercions don't get sunk into the leaves in expression trees -- they're stuck right at a leaf -- where if there were no such elaborator then coercions can get sunk arbitrarily deep based on expected types.</p>\n</blockquote>",
        "id": 490213188,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1734720259
    }
]