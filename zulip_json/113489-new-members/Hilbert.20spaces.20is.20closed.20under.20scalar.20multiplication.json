[
    {
        "content": "<p>Dear all, I am looking into lean and trying to understand whether it is usable to formalize my research. I installed lean locally, it seems to work in VScode and now I ma trying to prove a simple lemma that for any finite-dimensional complex Hilbert space <code>\\mathcal{H}</code> and for any <code>\\psi \\in \\mathcal{H}</code> we have <code>2 * \\psi \\in \\mathcal{H}</code>. The goal is of course not to set in stone this groundbreaking result, but to finally figure out how to actually use lean beyond those in-browser games where everything is somehow already done.</p>\n<p>So far I figured out the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Complex</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">FiniteDimensional</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"c1\">-- Define a Hilbert space (finite-dimensional complex inner product space)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ℋ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and the lemma I am trying to prove should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">scalar_mult_closed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>But this returns an error. Could you please point me to why?</p>",
        "id": 485054102,
        "sender_full_name": "Martin Plávala",
        "timestamp": 1732871872
    },
    {
        "content": "<p>Because you're using set notation for a type. You could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">scalar_mult_closed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the proof is <code>Set.mem_univ (2 • ψ)</code>. Now this doesn't use the structure of your space at all, because in type theory, the fact that the result of scalar multiplication lands in the same type (\"set\") is built into the type of the scalar multiplication function</p>",
        "id": 485056061,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732872466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/Beginner.20Projects/near/485056061\">said</a>:</p>\n<blockquote>\n<p>Because you're using set notation for a type. You could write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">scalar_mult_closed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and the proof is <code>Set.mem_univ (2 • ψ)</code>. Now this doesn't use the structure of your space at all, because in type theory, the fact that the result of scalar multiplication lands in the same type (\"set\") is built into the type of the scalar multiplication function</p>\n</blockquote>\n<p>I'm sorry but could you explain that? Clearly I can have subsets of any Hilbert space which have scalar multiplication defined on them but are not closed under all possible multiples (e.g. take a cone closed only under positive multiples). Does that mean these do not exist in lean?</p>\n<p>Also, should not  the Hilbert space H be a set by definition?</p>",
        "id": 485056642,
        "sender_full_name": "Martin Plávala",
        "timestamp": 1732872645
    },
    {
        "content": "<p>No, I think you do want your space H to be a type - you can then look at the <code>Set</code> that contains all the elements in your space (that's Set.univ), or at subsets</p>",
        "id": 485057094,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732872800
    },
    {
        "content": "<p>The <code>2 • ψ</code> you use is defined as <code>ψ + ψ</code>, where the addition comes from the <code>NormedAddCommGroup H</code> assumption, which defines addition as a function <code>H → H → H</code></p>",
        "id": 485057309,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732872867
    },
    {
        "content": "<p>That is, if you ever construct a specific Hilbert space, you'll have to define what addition means, and at that point prove that adding two elements of your space still lands inside the space</p>",
        "id": 485057487,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732872938
    },
    {
        "content": "<p>But then <code>(ψ : ℋ)</code> means that <code>ψ</code> is a Hilbert space itself?</p>",
        "id": 485057636,
        "sender_full_name": "Martin Plávala",
        "timestamp": 1732872977
    },
    {
        "content": "<p>No, <code>ψ</code> is any element of H</p>",
        "id": 485057825,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732873043
    },
    {
        "content": "<p>You could do something like this with subsets:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">({</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_all</span>\n</code></pre></div>",
        "id": 485057883,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732873065
    },
    {
        "content": "<p>Thanks for the explanations. Could you please recommend some working level and not overtly theoretical introduction to lean then? It seems I am missing the points.</p>",
        "id": 485058308,
        "sender_full_name": "Martin Plávala",
        "timestamp": 1732873205
    },
    {
        "content": "<p>In this case, <code>2 • ψ</code> is an element of H by definition of scalar multiplication (and addition), but not of the <em>subset</em> <code>{0}</code>, so there's something (not much) to prove</p>",
        "id": 485058366,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732873233
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">#mil</a> is a good start</p>",
        "id": 485058398,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732873247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308657\">@Martin Plávala</span> the question in your original post does not make any sense in Lean because multiplication by 2 on an additive abelian group <code>A</code> is <strong>defined to be</strong> a map from <code>A</code> to <code>A</code> so <code>2 • ψ</code> is what you like to call an \"element of A\" automatically. Type theory is different to set theory. In set theory you can have a \"thing\" which is an element of many sets all at once. In type theory every term has exactly one type -- distinct types are disjoint. It is not possible to <em>prove</em> that <code>2 • ψ</code> is a term of type <code>ℋ</code> -- every term has a type, and the type of <code>2 • ψ</code> is <code>ℋ</code> because <code>2 • _</code> is a map from <code>ℋ</code> to <code>ℋ</code> so that's the end of it. You can do <code>#check (2 • ψ)</code> to make sure that this is the case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- Let `ℋ` be  a finite-dimensional complex inner product space</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ℋ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Let `ψ` be an element of `ℋ`.</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Then 2ψ is also an element of `ℋ`.</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"c1\">-- 2 • ψ : ℋ</span>\n</code></pre></div>\n<p><a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/formalising-mathematics-2024/Part_B/typesandterms.html\">Here</a> is what I tell my maths undergrads about type theory. There is also this <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">old blog post</a> of mine.</p>",
        "id": 485147855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732906501
    },
    {
        "content": "<p>Thanks for the reply! I am starting to understand what is going on here and it seems a lot like object oriented programming. In the end I discovered I can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Complex</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">InnerProductSpace</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">Normed</span><span class=\"bp\">.</span><span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">FiniteDimensional</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">LinearAlgebra</span><span class=\"bp\">.</span><span class=\"n\">TensorProduct</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"c1\">-- Define a Hilbert space (finite-dimensional complex inner product space)</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ℋ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">InnerProductSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">scalar_mult_closed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">ℋ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">•</span><span class=\"w\"> </span><span class=\"n\">ψ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which actually works as intended.</p>",
        "id": 485619166,
        "sender_full_name": "Martin Plávala",
        "timestamp": 1733144393
    }
]