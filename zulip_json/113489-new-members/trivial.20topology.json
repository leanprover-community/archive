[
    {
        "content": "<p>Hello, this is another easy exercise that I got stuck on. Any hints on solving the sorry? It boils down to doing cases on <code>S ⊆ {∅, univ}</code> I think, but I don't know how to go about it in Lean.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">topology</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">has_univ</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_sUnion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">τ</span><span class=\"o\">,</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_inter</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U₁</span> <span class=\"n\">U₂</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">,</span> <span class=\"n\">U₁</span> <span class=\"bp\">∩</span> <span class=\"n\">U₂</span> <span class=\"bp\">∈</span> <span class=\"n\">τ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">trivial_topology</span> <span class=\"o\">:</span> <span class=\"n\">topology</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℚ</span><span class=\"o\">,</span>\n  <span class=\"n\">τ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span>\n  <span class=\"n\">has_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">has_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">has_inter</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 214049183,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603286961
    },
    {
        "content": "<p>This might be considered overkill but I think I would first prove a lemma like <code>s ∈ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code></p>",
        "id": 214050133,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603287387
    },
    {
        "content": "<p>I'd probably use a structure like <code> has_sUnion := by { rintros S hs, by_cases univ ∈ S, sorry },</code></p>",
        "id": 214050994,
        "sender_full_name": "Andreas Steiger",
        "timestamp": 1603287790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/trivial.20topology/near/214050133\">said</a>:</p>\n<blockquote>\n<p>This might be considered overkill but I think I would first prove a lemma like <code>s ∈ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code></p>\n</blockquote>\n<p>Did you mean <code>s ⊆ {∅, univ} &lt;-&gt; \\ex p, (\\all x, (x ∈ s) &lt;-&gt; p)</code>? Cuz it doesn't check out haha</p>",
        "id": 214052013,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603288247
    },
    {
        "content": "<p>No</p>",
        "id": 214052107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603288313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303635\">Andreas Steiger</span> <a href=\"#narrow/stream/113489-new-members/topic/trivial.20topology/near/214050994\">said</a>:</p>\n<blockquote>\n<p>I'd probably use a structure like <code> has_sUnion := by { rintros S hs, by_cases univ ∈ S, sorry },</code></p>\n</blockquote>\n<p>I got as far as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">has_sUnion</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">S</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n</code></pre></div>\n\n<p>left with the goal, which seems sooo close. but im completely lost</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span>\n<span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">},</span>\n<span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n<span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">},</span>\n<span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">univ</span><span class=\"o\">},</span>\n<span class=\"n\">h₄</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">false</span>\n</code></pre></div>",
        "id": 214052337,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603288423
    },
    {
        "content": "<p>Reid is suggesting that an arbitrary union of subsets corresponding to constant predicates is also a subset corresponding to a constant predicate.</p>",
        "id": 214052851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603288634
    },
    {
        "content": "<p>Using <code>by_cases</code> you shouldn't need to do all 4, because every <code>by_cases</code> splits up in 2 anyway. If you do <code>by_cases univ ∈ S</code>, you get two goals: Prove the statement if <code>univ \\in S</code>, and prove the statement if <code>univ \\notin S</code>. These should suffice, no need to split up further.</p>",
        "id": 214052894,
        "sender_full_name": "Andreas Steiger",
        "timestamp": 1603288658
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">∨</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"bp\">;</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n    <span class=\"n\">finish</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hS</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">finish</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 214055628,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603289811
    },
    {
        "content": "<p>Of course it would be rather less fun doing this for a set of size 4. For some stuff like this there are tactics, e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#fin_cases\">tactic#fin_cases</a>, but I'm not sure about this one.</p>",
        "id": 214055871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603289925
    },
    {
        "content": "<p>Omg this is awesome! Thank you all so much, now I got two ways to prove it!</p>\n<p>Also, what I meant by 'couldn't check out' was I didn't know how to fix the error that lean kept giving. Turns out that it just couldn't guess the type of {∅, univ}, not that I doubted your lemma hahah no idea how you came up with it but it's amazing.</p>",
        "id": 214056432,
        "sender_full_name": "Jia Ming",
        "timestamp": 1603290193
    },
    {
        "content": "<p>Just came across this old thread, and relatedly:</p>\n<p>I know the trivial topology on <code>Fin 2</code> exists by the name of  <code>⊤</code>, but I wasn't able to use it to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>So I rolled my own, dropping it here in case it's useful (or someone knows how to avoid it):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">MeasureTheory</span><span class=\"bp\">.</span><span class=\"n\">Measure</span><span class=\"bp\">.</span><span class=\"n\">Hausdorff</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Topology</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mytop</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n<span class=\"w\">  </span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen_univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen_inter</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"n\">hT</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"n\">left</span><span class=\"bp\">;</span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hT</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"n\">left</span><span class=\"bp\">;</span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"n\">right</span><span class=\"bp\">;</span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">isOpen_sUnion</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hS</span>\n<span class=\"w\">    </span><span class=\"n\">by_cases</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"bp\">;</span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">sUnion_eq_univ_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_;</span>\n<span class=\"w\">      </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">;</span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">left</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"n\">ht</span>\n<span class=\"w\">        </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n<span class=\"w\">        </span><span class=\"bp\">|</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">;</span><span class=\"n\">tauto</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">sUnion_eq_empty</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 451236626,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1720911962
    },
    {
        "content": "<p>Here's a proof of the original statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"bp\">¬@</span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⊤</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\">  </span><span class=\"c1\">-- fix the weird spelling so that we can use lemmas</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"bp\">.</span><span class=\"n\">isOpen_top_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">singleton_ne_empty</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_or</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 451238466,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720913781
    },
    {
        "content": "<p>Your mistake was writing  <code>(⊤ : TopologicalSpace (Fin 2)).IsOpen</code> instead of <code>¬IsOpen (Fin 2) ⊤</code></p>",
        "id": 451238485,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720913801
    },
    {
        "content": "<p>It's the same mistake as writing <code>Nat.add n 1</code> instead of <code>n + 1</code>, since all the lemmas are only about the latter</p>",
        "id": 451238507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720913829
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=TopologicalSpace.isOpen_top_iff#doc\">docs#TopologicalSpace.isOpen_top_iff</a> is obviously the key here, but it's hard to tell what its statement really is without looking at the source</p>",
        "id": 451238596,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720913920
    },
    {
        "content": "<p>OK great... sorry for the \"weird spelling\" :)</p>",
        "id": 451239205,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1720914602
    },
    {
        "content": "<p>No worries, clearly we have a documentation failure here</p>",
        "id": 451239461,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720914873
    },
    {
        "content": "<p>Maybe your spelling should be the preferred one after all? We could add <code>export TopologicalSpace (IsOpen)</code>, and then the two spellings would mean the same thing</p>",
        "id": 451239499,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720914916
    },
    {
        "content": "<p>Perhaps <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> or <span class=\"user-mention\" data-user-id=\"110050\">@Sébastien Gouëzel</span> or <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> have opinions here?</p>",
        "id": 451239512,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720914938
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  For what it's worth, I probably wrote it that way because I was trying (and now succeeded) to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"bp\">.</span><span class=\"n\">IsOpen</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">τ</span><span class=\"bp\">.</span><span class=\"n\">IsOpen</span>\n</code></pre></div>",
        "id": 451243585,
        "sender_full_name": "Bjørn Kjos-Hanssen",
        "timestamp": 1720918912
    },
    {
        "content": "<p>Yes, you shouldn't write that either!</p>",
        "id": 451251687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720925847
    },
    {
        "content": "<p><code>∃ ( σ τ : TopologicalSpace (Fin 2)), @IsOpen _ σ ≠ @IsOpen _ τ</code></p>",
        "id": 451251702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1720925868
    },
    {
        "content": "<p>If we export, then we need to use the prefix <code>TopologicalSpace.IsOpen</code> for dot notation theorems.</p>",
        "id": 451312123,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720932321
    },
    {
        "content": "<p>We have notation <code>IsOpen[t]</code></p>",
        "id": 451314190,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1720932381
    },
    {
        "content": "<p>Yes, the solution is to use the notation.</p>",
        "id": 451329847,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1720941984
    }
]