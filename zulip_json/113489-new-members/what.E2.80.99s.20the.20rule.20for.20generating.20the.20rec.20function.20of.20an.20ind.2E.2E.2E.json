[
    {
        "content": "<p>Hi I am a layman in type theory but I am curious in how is the rec function generated given a inductive families defined with the form </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">constructor₁</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">constructor₂</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span>\n  <span class=\"bp\">...</span>\n  <span class=\"bp\">|</span> <span class=\"n\">constructorₙ</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"bp\">→</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>mentioned in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html\">https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html</a></p>",
        "id": 431757500,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1712486756
    },
    {
        "content": "<p>For example why <code>Eq.rec</code> has a signature like <code>@Eq.rec : {α : Sort u} → {a : α} → {motive : (x : α) → a = x → Sort v}\n                  → motive a rfl → {b : α} → (h : a = b) → motive b h)</code>?</p>",
        "id": 431757628,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1712486821
    },
    {
        "content": "<p>For<code>Nat.rec</code> it seems intuitive since it restates the inductive principle. But <code>Eq.rec</code> seems not containing such intuition</p>",
        "id": 431757931,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1712487093
    },
    {
        "content": "<p>I have the same question. I hope someone could shed some light.</p>",
        "id": 449898261,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720451373
    },
    {
        "content": "<p>I am still not getting the exact rule or impl but now I got a feeling that <code>rec</code> is like \"proof by cases\" intuitively.  Each constructor in the def of <code>inductive foo</code> contributes \"a case\".  Btw I found <a href=\"https://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf\">https://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf</a> quite helpful</p>",
        "id": 449903842,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1720452376
    },
    {
        "content": "<p>I'm not a type theory expert but AFAIK the intuition is that the constructors are the only way to construct an element of that type*, and thus to show some fact about a value it sufficies to show that it holds for every way could have possibly been constructed with. For <code>Eq</code> the only way to construct it is with <code>refl a</code>, getting a <code>Eq a a</code>, for some <code>a</code> given as argument to <code>refl</code>, hence the requirement for <code>motive a rfl</code> (which can also be written as <code>motive a (refl a)</code>).</p>\n<p>You can also find a nice explanation of this in the Homotopy Type Theory book, at page 51.</p>\n<p>*technically this is not completly true as noncomputable functions can create instances of types without explicitly using one of the constructors, but they still need to be consistent with this.</p>\n<hr>\n<p>That said, the recursor produced by Lean is the one I would expect for an equality type defined with path induction i.e. generic over the left side of the equality but indexed over the right side, but Lean's equality type is indexed over both, so I would expect a recursor with the following signature (notice how <code>motive</code> takes two <code>a</code> parameters, one for each index).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a_0</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a_0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a_0</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a_0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">a_0</span><span class=\"w\"> </span><span class=\"n\">a_1</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>For completeness, an equality type defined with path induction would be the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I guess Lean is doing some transformation due to seeing that the first index is not really constrained?</p>",
        "id": 449917476,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1720455183
    },
    {
        "content": "<p>If <code>T</code> is an inductive type, the associated function <code>T.rec</code> can be used to construct dependent functions <em>out of</em> <code>T</code>. This means that, given a type family <code>F : T -&gt; Type</code>, we can construct a dependent function <code>f : (t : T) -&gt; F t</code> by applying <code>T.rec (motive := fun t =&gt; F t)</code>.  As a special case, if <code>F</code> is the constant family <code>F t = X</code>, we can apply <code>T.rec (motive := fun _ =&gt; X)</code> to construct functions from <code>T</code> to <code>X</code>.</p>\n<p>Since <code>T</code> is inductively defined, we can construct a function out of <code>T</code> by pattern-matching, meaning by case analysis on the constructors of <code>T</code>. For instance, if <code>c (p1 : P1) ... (pn : Pn) (t1 : T) ... (tm : T) : T</code> is a term of type <code>T</code> (the function <code>c</code> here is a constructor with <code>n</code> parameters of type <code>P1</code> ... <code>Pn</code> and <code>m</code> parameters <code>ti : T</code>), then in order to define <code>f t</code> for <code>t = c p1 ... pn t1 ... tm</code> it suffices to have a term <code>h (p1 : P1) ... (pn : Pn) (t1 : T) ... (tm : T) (f t1 : F t1) ... (f tm : F tm)</code> of type <code>F t</code>. By definition, that long term <code>h ...</code> will be <code>f t</code> in our definition of <code>f</code> by pattern-matching.</p>\n<p>In this example, the auxiliary function <code>h</code> is a dependent function of type signature <code>(p1 : P1) -&gt; ... -&gt; (pn : Pn) -&gt; (t1 : T) -&gt; ... -&gt; (tm : T) -&gt; (P t1) -&gt; ... -&gt; (P tm) -&gt; P (c p1 ... pn f1 ... fm)</code>. We get one of these for each constructor of the inductive type <code>T</code>, and we curry them to get the full recursor (encapsulating each one between brackets appropriately). </p>\n<p>For <code>List R</code> for instance, the recursor <code>List.rec</code> has type signature <code>{R : Type} -&gt; {F : List R -&gt; Type} -&gt; F nil -&gt; ((a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l)) -&gt; (L : List R) -&gt; F L</code>. The first <code>{R : Type}</code> is only there because <code>List</code> takes a type as a parameter. But then we get <code>h1 : F nil</code> for the constructor <code>List.nil : List R</code> and <code>h2 : ((a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l))</code> for the constructor <code>List.cons : R -&gt; List R -&gt; List R</code>.</p>\n<p>Indeed, with such a function <code>List.rec</code>, we can construct a dependent function <code>f : {R : List} -&gt; (L : List R) -&gt; F L</code> using just a term <code>h1 : F nil</code> and a function <code>h2 : (a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l) </code> as inputs, by setting <code>f [] = h1</code> if <code>L = nil</code> and <code>f (a :: l) = h2 a l (f l)</code> if <code>L = (a :: l)</code>. This is exactly the induction principle for lists. The general formula for the function <code>f</code> associated to <code>h1</code> and <code>h2</code> is then <code>f := fun L =&gt; List.rec (motive := fun L =&gt; F L) h1 h2 L</code>.</p>",
        "id": 449980048,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720472379
    },
    {
        "content": "<p>The details for this w.r.t. Lean's type theory are described in Mario Carneiro's thesis (section 2.6.0) (<a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a>), and Lean's inductive types come from a paper by Peter Dybjer called \"Inductive Families\" (Formal aspects of computing, 6(4):440–465, 1994). You can also read the source for the kernel, but the inclusion of mutual and nested inductives adds quite a bit of noise.</p>",
        "id": 449996888,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1720478205
    },
    {
        "content": "<p>Thanks for all these great insights and information!</p>",
        "id": 450066530,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1720503014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"513540\">Flo (Florent Schaffhauser)</span> <a href=\"#narrow/stream/113489-new-members/topic/what.E2.80.99s.20the.20rule.20for.20generating.20the.20rec.20function.20of.20an.20ind.2E.2E.2E/near/449980048\">said</a>:</p>\n<blockquote>\n<p>If <code>T</code> is an inductive type, the associated function <code>T.rec</code> can be used to construct dependent functions <em>out of</em> <code>T</code>. This means that, given a type family <code>F : T -&gt; Type</code>, we can construct a dependent function <code>f : (t : T) -&gt; F t</code> by applying <code>T.rec (motive := fun t =&gt; F t)</code>.  As a special case, if <code>F</code> is the constant family <code>F t = X</code>, we can apply <code>T.rec (motive := fun _ =&gt; X)</code> to construct functions from <code>T</code> to <code>X</code>.</p>\n<p>Since <code>T</code> is inductively defined, we can construct a function out of <code>T</code> by pattern-matching, meaning by case analysis on the constructors of <code>T</code>. For instance, if <code>c (p1 : P1) ... (pn : Pn) (t1 : T) ... (tm : T) : T</code> is a term of type <code>T</code> (the function <code>c</code> here is a constructor with <code>n</code> parameters of type <code>P1</code> ... <code>Pn</code> and <code>m</code> parameters <code>ti : T</code>), then in order to define <code>f t</code> for <code>t = c p1 ... pn t1 ... tm</code> it suffices to have a term <code>h (p1 : P1) ... (pn : Pn) (t1 : T) ... (tm : T) (f t1 : F t1) ... (f tm : F tm)</code> of type <code>F t</code>. By definition, that long term <code>h ...</code> will be <code>f t</code> in our definition of <code>f</code> by pattern-matching.</p>\n<p>In this example, the auxiliary function <code>h</code> is a dependent function of type signature <code>(p1 : P1) -&gt; ... -&gt; (pn : Pn) -&gt; (t1 : T) -&gt; ... -&gt; (tm : T) -&gt; (P t1) -&gt; ... -&gt; (P tm) -&gt; P (c p1 ... pn f1 ... fm)</code>. We get one of these for each constructor of the inductive type <code>T</code>, and we curry them to get the full recursor (encapsulating each one between brackets appropriately). </p>\n<p>For <code>List R</code> for instance, the recursor <code>List.rec</code> has type signature <code>{R : Type} -&gt; {F : List R -&gt; Type} -&gt; F nil -&gt; ((a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l)) -&gt; (L : List R) -&gt; F L</code>. The first <code>{R : Type}</code> is only there because <code>List</code> takes a type as a parameter. But then we get <code>h1 : F nil</code> for the constructor <code>List.nil : List R</code> and <code>h2 : ((a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l))</code> for the constructor <code>List.cons : R -&gt; List R -&gt; List R</code>.</p>\n<p>Indeed, with such a function <code>List.rec</code>, we can construct a dependent function <code>f : {R : List} -&gt; (L : List R) -&gt; F L</code> using just a term <code>h1 : F nil</code> and a function <code>h2 : (a : R) -&gt; (l : List R) -&gt; F l -&gt; F (a :: l) </code> as inputs, by setting <code>f [] = h1</code> if <code>L = nil</code> and <code>f (a :: l) = h2 a l (f l)</code> if <code>L = (a :: l)</code>. This is exactly the induction principle for lists. The general formula for the function <code>f</code> associated to <code>h1</code> and <code>h2</code> is then <code>f := fun L =&gt; List.rec (motive := fun L =&gt; F L) h1 h2 L</code>.</p>\n</blockquote>\n<p>What about indexed type families though? This doesn't seem to cover them (e.g. all your <code>motive</code>/<code>F</code>s take only one parameter, but clearly <code>Eq.rec</code>'s takes two).</p>",
        "id": 450124167,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1720520030
    },
    {
        "content": "<p>Right, so for <code>Eq : {A : Type} -&gt; (a a' : A) -&gt; Type</code> , the constructor <code>Eq.refl : (a : A) -&gt; Eq a a</code> is itself a dependent function. A type family over <code>Eq</code> is a function <code>F : (a a' : A) -&gt; Eq a a' -&gt; Type</code> and, in order to define a dependent function <code>f : (a a' : A)  -&gt; (t : Eq a a') -&gt; F t</code>, it suffices to cover the case when <code>a = a'</code> and <code>t = Eq.refl a</code>. </p>\n<p>This means that it suffices to have a dependent function <code>h : (a : A) -&gt; F a a (Eq.refl a)</code>(and to define <code>f a a (Eq.refl a)</code> as <code>h a</code>). So <code>Eq.rec</code> should have type signature <code>{A : Type} -&gt; {F : (a a' : A) -&gt; Eq a a' -&gt; Type} -&gt; ((a : A) -&gt; F a a (Eq.refl a)) -&gt; (a a' : A) -&gt; (t : Eq a a') -&gt; F a a' t</code>. In this case, the induction principle is more complicated to state than to use. Also, there might be variants in the implementation (check out for instance the type signature of <code>Eq.rec</code> in Lean). </p>\n<p>The point is that the induction principle for <code>Eq a a'</code> tells us that the only case to check for <code>t : Eq a a'</code> is when <code>a = a'</code> and <code>t = Eq.refl a</code>, which is how one proves that for all <code>{A : Type}</code> and all <code>(a a' : A)</code>, <code>(a = a') -&gt; a' = a </code>, for instance. In tactic mode, one can use <code>induction</code> or <code>cases</code> indifferently for <code>Eq</code> (because <code>Eq.refl</code> does not take terms of the form <code>t : Eq a a'</code> as inputs).</p>",
        "id": 450176727,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1720532560
    }
]