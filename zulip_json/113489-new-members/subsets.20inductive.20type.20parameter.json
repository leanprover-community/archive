[
    {
        "content": "<p>Hi all,<br>\nim trying to declare this inductive type I</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n</code></pre></div>\n<p>that can nest subsets via the .B constructor. Trying to do this seems conceptually wrong because the type parameter has to match set. Maybe someone can out why this would not work and what to do instead :)</p>",
        "id": 453101498,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1721633189
    },
    {
        "content": "<p>the problem is that while defining a (dependent) inductive lean does't know about what <code>I subset</code> means. it only knows <code>I set</code>.</p>",
        "id": 453122617,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721639283
    },
    {
        "content": "<p>what is the structure you want to capture?</p>",
        "id": 453122676,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721639307
    },
    {
        "content": "<p>if i understand correctly, some sort of list of sets which are ordered by inclusion?</p>",
        "id": 453122932,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721639406
    },
    {
        "content": "<p>one constructor is supposed to contain a expression built out of elements from the set. the other constructor is supposed to allow expressions on a subset of these elements.<br>\nSomething like<br>\n(1+2) can be of type I {1,2} but also I {1,2,3,...}<br>\nmaybe it is more like type casting?</p>",
        "id": 453127889,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1721640966
    },
    {
        "content": "<p>i don't think that an inductive type is what you're looking for then...</p>",
        "id": 453129017,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721641278
    },
    {
        "content": "<p>could you maybe give more detail about how you're (planning on) storing expressions?</p>",
        "id": 453129256,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721641337
    },
    {
        "content": "<p>or tell more generally what kind of project this is for?</p>",
        "id": 453129961,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721641526
    },
    {
        "content": "<p>because this is probably an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem</p>",
        "id": 453130031,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1721641540
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n</code></pre></div>\n<p>works, but I agree that this seems like a possible xy</p>",
        "id": 453133520,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1721642468
    },
    {
        "content": "<p>i try to strip down my problem, this is what (i think) I want to accomplish:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Broadcast</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">caster</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">@</span><span class=\"n\">caster</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"c1\">-- @ means only accessible to caster node</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Sub</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">subset</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"bp\">⊆</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">subset</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">End</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">set</span>\n</code></pre></div>\n<p>The genereall problem is, that i want to model a program that operates on set of nodes (Finset α).<br>\nNodes can broadcast to all nodes in the set.<br>\nThere are some cases where subprograms only operate on a subset of nodes and should not broadcast to everyone (that is what i try to do via the .Sub constructor).</p>",
        "id": 453134848,
        "sender_full_name": "Simon Daniel",
        "timestamp": 1721642846
    }
]