[
    {
        "content": "<p>The following code fails to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">AssocList</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Dict</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">AssocList</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">abs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">clos</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">env</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Dict</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The error message is very scary and bad (<a href=\"https://github.com/leanprover/lean4/issues/8960\">https://github.com/leanprover/lean4/issues/8960</a>) but what's important to know is that Lean takes a problem with the <code>(env : Dict String Value)</code> in the <code>inductive Value</code> declaration. It does not take a problem, however, if the env is written as <code>(env : Lean.AssocList String Value)</code>, and indeed that code compiles fine.</p>\n<p>Is this expected behavior? I am confused about why Lean cannot infer that <code>Value</code> is a well-founded inductive type when the <code>Dict</code> abbreviation is present, because I would expect it to function exactly as an abbreviation. Thanks for any help in understanding.</p>",
        "id": 534616314,
        "sender_full_name": "JJ",
        "timestamp": 1755245987
    },
    {
        "content": "<p>I might open this as a bug then, if this looks weird to other people.</p>",
        "id": 534688304,
        "sender_full_name": "JJ",
        "timestamp": 1755279236
    },
    {
        "content": "<p><code>abbrev</code>s are the same thing as reducible, inline definitions. The kernel doesn't actually know about what reducible means, so my best guess is that the kernel just sees <code>Dict</code> as a regular definition (although I'm not completely sure the kernel is actually involved here). I think if we wanted to get the kernel to accept this definition, we would either have to modify the kernel to reduce all expressions, which is likely a bad idea, or reduce it before sending it to the kernel, which means that if you do <code>#check Value.clos</code> you will see <code>Lean.AssocList</code> instead of <code>Dict</code>.</p>",
        "id": 534689291,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755279770
    },
    {
        "content": "<p>I think the way that you get \"true\" abbreviations is by using <code>notation</code> or <code>macro</code></p>",
        "id": 534689363,
        "sender_full_name": "Niels Voss",
        "timestamp": 1755279820
    },
    {
        "content": "<p>abbrevs also do something to the kernel I think</p>",
        "id": 534690388,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755280342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Use.20typeclasses.20of.20coerced.20type.3F/near/531316807\">said</a>:</p>\n<blockquote>\n<p>(I just checked the kernel code: <code>abbrev</code> only affects tie-breaking when you have <code>f x1 ... xn =?= g y1 ... yn</code> and something needs to be unfolded. Normally, regular definitions use the heuristic that the more-or-less newer definition gets unfolded. Using <code>abbrev</code> causes the definition to be \"newer\" than even definitions that haven't been defined yet. There are definitely cases where this is the wrong heuristic, but that doesn't mean that <code>abbrev</code> itself is incorrect. It's worth getting some examples to see what's going on.)</p>\n</blockquote>",
        "id": 534690526,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755280420
    },
    {
        "content": "<p>The behavior is expected (I remember some discussions a couple years ago about how nested inductives be nested through definitions), but I'm not sure if it needs to be a necessary restriction for some reason.</p>\n<p>The positivity check itself unfolds definitions. For example, using</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Dict</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>is OK.</p>\n<p>Looking at the source code, the nested inductive type elimination process doesn't unfold anything. (When there are nested inductive types, the kernel creates a new equivalent recursive inductive type and checks that instead.) This is <code>lean::elim_nested_inductive_fn</code> in <code>src/kernel/inductive.cpp</code>.</p>",
        "id": 534693846,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755282005
    },
    {
        "content": "<p>Hm, okay. Sorry Kyle, but I don't think I understand what you said... <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 534733144,
        "sender_full_name": "JJ",
        "timestamp": 1755312495
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"521331\">Niels Voss</span> <a href=\"#narrow/channel/113489-new-members/topic/is.20abbrev.20supposed.20to.20break.20type.20positivity.20checking.3F/near/534689291\">said</a>:</p>\n<blockquote>\n<p><code>abbrev</code>s are the same thing as reducible, inline definitions.</p>\n</blockquote>\n<p>Well, I've had a bit of a question about this, actually. Why are <code>abbrev</code>s disallowed in <code>mutual</code> declarations? Just by virtue of no one implementing them or would this cause other issues?</p>",
        "id": 534733189,
        "sender_full_name": "JJ",
        "timestamp": 1755312547
    }
]