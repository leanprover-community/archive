[
    {
        "content": "<p>Suppose I define inductive structure for basic logical expression of two boolean variables (A and B, operations AND, OR, IMPLIES, etc.). They have precedence levels and sometimes associativity (left or right) that allows to skip brackets sometimes, if one wants.</p>\n<p>Converting from this inductive type to string, taking precedence levels and associativity into account, - that I could manage somehow, I believe. But it seems harder to do the opposite direction - from a string to inductive type.</p>\n<p>Is there anything related to this problem (how to write parsers with, ideally, proven correctness or something like that) in Lean?</p>",
        "id": 539169366,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757714767
    },
    {
        "content": "<blockquote>\n<p>Converting from this inductive type to string, taking precedence levels and associativity into account, - that I could manage somehow, I believe.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Repr.reprPrec#doc\">docs#Repr.reprPrec</a> tries to give you the machinery to do this</p>",
        "id": 539169619,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757714900
    },
    {
        "content": "<blockquote>\n<p>Is there anything related to this problem (how to write parsers with, ideally, proven correctness or something like that) in Lean?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Std.Internal.Parsec#doc\">docs#Std.Internal.Parsec</a> is one way, I think</p>",
        "id": 539169696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757714939
    },
    {
        "content": "<p>Do you care about converting from string (command line input, a text file), or would you be happy with syntax within lean source code?</p>",
        "id": 539169753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757714983
    },
    {
        "content": "<p>Some time ago I used Javascript library nearley.js that generates parsers, but it has kinda weird way to define language/grammar. (To make a tiny html page that generates Venn diagram of the two variable logical expression. :D)</p>",
        "id": 539169912,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757715073
    },
    {
        "content": "<p>Converting from the string.</p>",
        "id": 539169944,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757715085
    },
    {
        "content": "<p>I should take myself to some library and get necessary literature to learn basics and maybe more, probably.</p>",
        "id": 539170376,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757715268
    },
    {
        "content": "<p>I think the standard library is enough for you here, as linked above</p>",
        "id": 539170594,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1757715382
    },
    {
        "content": "<p>One weird idea/goal is to make a parser, prove it correct and then \"extract\" to Javascript, where I can use it on the web.</p>",
        "id": 539172718,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757716500
    },
    {
        "content": "<p>That's <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem (I believe now), because I find it difficult to make an BNF for expressions which are made of operators with different precedence levels and some with specific associativity. So, I thought that it would be nice to find a way to do it automatically, then I daydreamed even further. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 539362036,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1757797868
    }
]