[
    {
        "content": "<p>Without <code>omega</code> by most recent and first non-trivial proof in lean would've been basically impossible. Was such a life saver.</p>\n<p>I've heard about <code>aesop</code> but it doesn't seem to work very well, always applying <code>simp</code> and getting stuck because it can't find anything to simplify. I tried <code>linarith</code> a few times and also no help at all.</p>\n<p>Wonder if there's any powerful tactic I've been missing out on that people frequently use. My proofs mainly consist of <code>simp</code>, <code>rw</code>, <code>have</code>, <code>intro</code>, <code>apply</code>, <code>simp_rw</code> and of course <code>omega</code>.</p>\n<p>Because my first takeaway from writing a larger proof is \"omg this is so tedious\", I had to prove a lot of \"obvious\" lemmas just so I could <code>rw</code> / <code>simp</code> parts away like <code>x / (x + 1) = 0</code> and wonder if it's the way of lean or just a skill issue on my part.</p>",
        "id": 479791609,
        "sender_full_name": "Philogy",
        "timestamp": 1730339938
    },
    {
        "content": "<blockquote>\n<p>My proofs mainly consist of <code>simp</code>, <code>rw</code>, <code>have</code>, <code>intro</code>, <code>apply</code>, <code>simp_rw</code> and of course <code>omega</code>.</p>\n</blockquote>\n<p>I think the difference between novices and seasoned lean/mathlib power-users is more about the <em>lemmas</em> in their vocabulary, not the <em>tactics</em>. Most of the proofs I write are also using those same basic tactics (although I would also add <code>refine</code> to the list). But most of those tactics are just ways of using lemmas; so the more lemmas you know, the more you can achieve with the tactics.</p>",
        "id": 479829418,
        "sender_full_name": "David Loeffler",
        "timestamp": 1730364476
    },
    {
        "content": "<p>Though even more than using lemmas, I think it's about knowing what kind of lemmas you can and can't expect to find in the library, and how to find them (either by guessing the name of using the search tools)</p>",
        "id": 479829733,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1730364580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479829418\">said</a>:</p>\n<blockquote>\n<p>I think the difference between novices and seasoned lean/mathlib power-users is more about the <em>lemmas</em> in their vocabulary, not the <em>tactics</em>.</p>\n</blockquote>\n<p>I believe Heather would (like to) strongly disagree</p>",
        "id": 479829855,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730364616
    },
    {
        "content": "<ul>\n<li>A very useful \"basic\" skill: know which tactic could apply when. (For instance, do you already know when to apply rw vs apply/refine? How about simp? There is also the norm_num tactic; do you know when to use omega vs norm_num?)</li>\n<li>Depending on what kinds of results you'd like to prove, some more specialized tactics can be useful.<br>\nFor analysis proofs, the tactics <code>norm_num</code>, <code>linarith</code>, <code>gcongr</code> and <code>positivity</code> are useful. <code>fun_prop</code>/<code>continuity</code>/<code>measurability</code> can also be pretty useful there. For \"simple logic\" arguments, <code>tauto</code> can be useful.</li>\n</ul>",
        "id": 479839970,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1730368314
    },
    {
        "content": "<p>Aesop at base is not much more powerful than simp, can do basic splitting and such, but doesn't even know about <code>tauto</code> or much more lemmas than <code>simp</code>. You can however tag the stuff you need a lot (your own or imported) and have it fill in the gaps in the proof structure for you.</p>",
        "id": 479840801,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730368613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"481963\">David Loeffler</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479829418\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>My proofs mainly consist of <code>simp</code>, <code>rw</code>, <code>have</code>, <code>intro</code>, <code>apply</code>, <code>simp_rw</code> and of course <code>omega</code>.</p>\n</blockquote>\n<p>I think the difference between novices and seasoned lean/mathlib power-users is more about the <em>lemmas</em> in their vocabulary, not the <em>tactics</em>. Most of the proofs I write are also using those same basic tactics (although I would also add <code>refine</code> to the list). But most of those tactics are just ways of using lemmas; so the more lemmas you know, the more you can achieve with the tactics.</p>\n</blockquote>\n<p>Interesting, I suppose that's why, I spent a lot of time searching for simple lemmas in the list of <code>Nat</code> lemmas that I had to end up creating myself via just <code>by omega</code>. Sometimes I think it'd be useful to see what <code>omega</code> did, similar to how aesop has <code>aesop?</code> to see what lemmas it used and learn from it.</p>",
        "id": 479855017,
        "sender_full_name": "Philogy",
        "timestamp": 1730373712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634338\">Michael Rothgang</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479839970\">said</a>:</p>\n<blockquote>\n<ul>\n<li>A very useful \"basic\" skill: know which tactic could apply when. (For instance, do you already know when to apply rw vs apply/refine? How about simp? There is also the norm_num tactic; do you know when to use omega vs norm_num?)</li>\n<li>Depending on what kinds of results you'd like to prove, some more specialized tactics can be useful.<br>\nFor analysis proofs, the tactics <code>norm_num</code>, <code>linarith</code>, <code>gcongr</code> and <code>positivity</code> are useful. <code>fun_prop</code>/<code>continuity</code>/<code>measurability</code> can also be pretty useful there. For \"simple logic\" arguments, <code>tauto</code> can be useful.</li>\n</ul>\n</blockquote>\n<p>Interesting, I did not know about <code>norm_num</code>, where do I learn?</p>",
        "id": 479855120,
        "sender_full_name": "Philogy",
        "timestamp": 1730373738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"739332\">Philogy</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479855017\">said</a>:</p>\n<blockquote>\n<p>Sometimes I think it'd be useful to see what <code>omega</code> did, similar to how aesop has <code>aesop?</code> to see what lemmas it used and learn from it.</p>\n</blockquote>\n<p><code>omega</code> does not really use lemmas, so your idea can't really work</p>",
        "id": 479855188,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730373771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479855188\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"739332\">Philogy</span> <a href=\"#narrow/channel/113489-new-members/topic/Any.20powerful.20tactics.20I.20should.20know.20about.20besides.20.60omega.60.3F/near/479855017\">said</a>:</p>\n<blockquote>\n<p>Sometimes I think it'd be useful to see what <code>omega</code> did, similar to how aesop has <code>aesop?</code> to see what lemmas it used and learn from it.</p>\n</blockquote>\n<p><code>omega</code> does not really use lemmas, so your idea can't really work</p>\n</blockquote>\n<p>Oh I see.</p>",
        "id": 479855315,
        "sender_full_name": "Philogy",
        "timestamp": 1730373824
    },
    {
        "content": "<p>... by which I mean that the proof term generated by <code>omega</code> will be a mumble-jumble of applications of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.succ_le_iff#doc\">docs#Nat.succ_le_iff</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.lt_succ_iff#doc\">docs#Nat.lt_succ_iff</a> and various other things</p>",
        "id": 479855398,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730373844
    },
    {
        "content": "<p>If you want to inspect it <span class=\"user-mention\" data-user-id=\"739332\">@Philogy</span>, you can do <code>show_term omega</code> to see the proof term it creates.</p>",
        "id": 479920581,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730393514
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">fun n a =&gt;</span>\n<span class=\"cm\">  Decidable.byContradiction fun a_1 =&gt;</span>\n<span class=\"cm\">    Omega.Constraint.not_sat'_of_isImpossible (of_decide_eq_true (id (Eq.refl true)))</span>\n<span class=\"cm\">      (Omega.Constraint.combine_sat'</span>\n<span class=\"cm\">        (Omega.Constraint.addInequality_sat</span>\n<span class=\"cm\">          (le_of_le_of_eq (Int.sub_nonneg_of_le (Omega.Int.ofNat_le_of_le (Nat.le_of_not_lt a_1)))</span>\n<span class=\"cm\">            (Eq.trans (Omega.Int.sub_congr (Eq.symm Omega.LinearCombo.coordinate_eval_0) (id (Eq.refl ↑3)))</span>\n<span class=\"cm\">              (Eq.symm</span>\n<span class=\"cm\">                (Omega.LinearCombo.sub_eval { const := 0, coeffs := [1] } { const := 3, coeffs := [] }</span>\n<span class=\"cm\">                  (Omega.Coeffs.ofList [↑n]))))))</span>\n<span class=\"cm\">        (Omega.Constraint.combine_sat'</span>\n<span class=\"cm\">          (Omega.Constraint.addInequality_sat</span>\n<span class=\"cm\">            (le_of_le_of_eq (Int.ofNat_nonneg n) (Eq.symm Omega.LinearCombo.coordinate_eval_0)))</span>\n<span class=\"cm\">          (Omega.tidy_sat</span>\n<span class=\"cm\">            (Omega.Constraint.addInequality_sat</span>\n<span class=\"cm\">              (le_of_le_of_eq (Int.sub_nonneg_of_le (Int.add_one_le_of_lt (Omega.Int.ofNat_lt_of_lt a)))</span>\n<span class=\"cm\">                (Eq.trans</span>\n<span class=\"cm\">                  (Omega.Int.sub_congr (id (Eq.refl ↑2))</span>\n<span class=\"cm\">                    (Eq.trans (Omega.Int.add_congr (Eq.symm Omega.LinearCombo.coordinate_eval_0) (id (Eq.refl 1)))</span>\n<span class=\"cm\">                      (Eq.symm</span>\n<span class=\"cm\">                        (Omega.LinearCombo.add_eval { const := 0, coeffs := [1] } { const := 1, coeffs := [] }</span>\n<span class=\"cm\">                          (Omega.Coeffs.ofList [↑n])))))</span>\n<span class=\"cm\">                  (Eq.symm</span>\n<span class=\"cm\">                    (Omega.LinearCombo.sub_eval { const := 2, coeffs := [] } { const := 1, coeffs := [1] }</span>\n<span class=\"cm\">                      (Omega.Coeffs.ofList [↑n])))))))))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>\n<p>(<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I'm not sure what it means to use or not use lemmas, but certainly omega uses omega-specific theory.)</p>",
        "id": 479920792,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730393584
    },
    {
        "content": "<p>I mean that it doesn't use library lemmas the way <span class=\"user-mention silent\" data-user-id=\"739332\">Philogy</span> is expecting</p>",
        "id": 479921393,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1730393777
    }
]