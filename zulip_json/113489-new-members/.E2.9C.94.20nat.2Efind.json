[
    {
        "content": "<p>I am a bit unsure about the best way to phrase a lemma about <code>nat.find</code>.  Consider something like the following. Which formulation of the lemma about <code>nat.find</code> is best?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">green_are_followed_by_red</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.</span> <span class=\"n\">is_red</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"bp\">…</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_red_after_green_is_joe1</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.</span> <span class=\"n\">is_red</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n  <span class=\"n\">nat.find</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">joe</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_red_after_green_is_joe2</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">&gt;</span> <span class=\"n\">n.</span> <span class=\"n\">is_red</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">green_are_followed_by_red</span> <span class=\"n\">n</span> <span class=\"n\">hG</span> <span class=\"k\">in</span>\n  <span class=\"n\">nat.find</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">joe</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_red_after_green_is_joe3</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">green_are_followed_by_red</span> <span class=\"n\">n</span> <span class=\"n\">hG</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">joe</span>\n</code></pre></div>\n<p>The first is most readable, but annoying to use – you have to provide a proof for <code>h</code> when you want to use the lemma.<br>\nThe last is compact, but it somehow look silly to me to give a _specific_ proof term for that existential here (and indeed later lean prints this as <code>nat.find _ = joe</code>, because the proof term doesn’t matter…).<br>\nThe middle one might be a compromise.</p>\n<p>Or maybe I am approaching this the wrong way?</p>\n<p>(If you want a more real example; this comes up when <a href=\"https://github.com/leanprover-community/mathlib/pull/11540\">proving that various possible nilpotency class definitions are equivalent</a>.)</p>",
        "id": 268463671,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1642544097
    },
    {
        "content": "<p>(Not answering your question, if you do <code>set_option pp.proofs true</code> you can coax the pretty printer into showing the proof. This can sometimes be useful.)</p>",
        "id": 268464555,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642544494
    },
    {
        "content": "<p>Mathlib generally doesn't use <code>let</code> statements in lemma statements like the middle option, although there are probably a few exceptions. Your third option is fine. Since all proofs of the existential are definitionally equal it doesn't matter which one is there, and tactics like <code>simp</code> and <code>rw</code> won't care.</p>",
        "id": 268464769,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1642544630
    },
    {
        "content": "<p>But another option, if it makes sense in context, is to give a name to <code>nat.find h</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_green.next_red</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat.find</span> <span class=\"o\">(</span><span class=\"n\">green_are_followed_by_red</span> <span class=\"n\">n</span> <span class=\"n\">hg</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">first_red_after_green_is_joe1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hG</span> <span class=\"o\">:</span> <span class=\"n\">is_green</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">hG.next_red</span> <span class=\"bp\">=</span> <span class=\"n\">joe</span>\n</code></pre></div>",
        "id": 268464857,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1642544656
    },
    {
        "content": "<p>Yet another option is to use <code>Inf</code> (see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.Inf_def\">docs#nat.Inf_def</a>). It's not computable, but it doesn't need a proof -- if nothing satisfies the predicate, it is equal to zero.</p>",
        "id": 268465089,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642544790
    },
    {
        "content": "<p>For example, the <a href=\"https://github.com/leanprover-community/mathlib/blob/5a1cbe362c17318315a7c3d1cfc9d694ec15ef12/src/combinatorics/simple_graph/coloring.lean#L155\">chromatic number</a> of a graph.</p>",
        "id": 268465247,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1642544904
    },
    {
        "content": "<p>Thanks! Then I'll maybe stick to the third variant for this PR.</p>",
        "id": 268465423,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1642545007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> has marked this topic as resolved.</p>",
        "id": 268466041,
        "sender_full_name": "Notification Bot",
        "timestamp": 1642545381
    },
    {
        "content": "<p>Yet another yet another option is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_least\">docs#is_least</a></p>",
        "id": 268522700,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1642590167
    }
]