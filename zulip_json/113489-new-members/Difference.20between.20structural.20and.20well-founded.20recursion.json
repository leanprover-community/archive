[
    {
        "content": "<p>While reading TPIL chapter 8 (Induction and recursion), I came across this example of well-founded recursion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">div_lemma</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">sub_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_lt_of_le</span> <span class=\"n\">h.left</span> <span class=\"n\">h.right</span><span class=\"o\">)</span> <span class=\"n\">h.left</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">div.F</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x₁</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">x₁</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"k\">then</span>\n    <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">div_lemma</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">else</span>\n    <span class=\"n\">zero</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">div</span> <span class=\"o\">:=</span> <span class=\"n\">WellFounded.fix</span> <span class=\"o\">(</span><span class=\"n\">measure</span> <span class=\"n\">id</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wf</span> <span class=\"n\">div.F</span>\n</code></pre></div>\n<p>Although it's a bit hard for me to figure out what is going on here, I can see that <code>div</code> is a well-founded recursive function, since it is defined in terms of the arguments for <code>WellFounded.fix</code> . However, in the next definition, I don't understand the role that well-foundedness of <code>&lt;</code> plays:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"k\">then</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.sub_lt</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_lt_of_le</span> <span class=\"n\">h.1</span> <span class=\"n\">h.2</span><span class=\"o\">)</span> <span class=\"n\">h.1</span>\n    <span class=\"n\">div</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n  <span class=\"k\">else</span>\n    <span class=\"mi\">0</span>\n</code></pre></div>\n<p>This definition seems to be the same as a structurally recursive definition. What is the difference between the two? Why does Lean not use structural recursion to compile this definition?</p>",
        "id": 409098265,
        "sender_full_name": "Vivek Rajesh Joshi",
        "timestamp": 1703052991
    },
    {
        "content": "<p>In structural recursion the proof of termination works out as follows: We can see that for some argument, each time that we make a recursive call, there is at least one constructor of that argument removed. This allows Lean to do a translation to a more basic concept called recursors. Recursors is how the kernel actually thinks about recursive pattern matching function, it doesn't have a built in notion of matches and stuff like that.</p>\n<p>Then with well founded recursion you can basically do whatever you want with an argument as long as some function on your arguments decreases by  some well founded relation (sometimes you even have to tell lean yourself which one that is). This makes a translation to recursors much harder because they very closely represent the idea of structural recursion and only that. So now you need some way to tell the underlying type theory about what you are doing and that way is WellFounded.fix</p>\n<p>Now if you look at the definition of div. From the POV of the thing that handles pattern matching it cannot really tell that x - y makes the 1st argument structurally smaller. Sure we know that since y &gt; 0 it <em>must</em> do that (and that x cannot be 0 due to the additiobal condition in the if) because we know about how - works but that is not something that this part of the system can figure out on its own.</p>",
        "id": 409112585,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1703057846
    }
]