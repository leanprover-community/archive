[
    {
        "content": "<p>Hi, I noticed that  <code>unfold id at h</code> pattern only works if <code>h</code> is a single variable, but sometimes I want to use it at a term.  What works here is <code>let foo := TERM; unfold id at foo; exact foo</code> which seems kinda clumsy, is there a simpler way?</p>\n<p>for example here</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">eq'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"c1\">-- this is not working!</span>\n<span class=\"c1\">-- def eq'' := by unfold a b at (congrArg double eq)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">eq''</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">double</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>\n<p><code>eq'</code> has type <code>double a = double b</code> and <code>eq''</code> has type <code>double 3 = double 3</code>.</p>",
        "id": 533954752,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754996165
    },
    {
        "content": "<p>What do you expect this to do?</p>",
        "id": 533955014,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1754996263
    },
    {
        "content": "<p>don't use def for theorems, and don't use tactic for def</p>",
        "id": 533955116,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754996304
    },
    {
        "content": "<p>and don't use let for theorems</p>",
        "id": 533955176,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754996324
    },
    {
        "content": "<p>and don't define anything without specifying the type</p>",
        "id": 533955214,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1754996339
    },
    {
        "content": "<p>ah ok <code>def eq'' := by simpa only [a,b] using (congrArg double eq)</code> does work</p>",
        "id": 533955258,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754996355
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> my usecase was inside a proof where i didnt state any type, and the types are long winded, which is why i wanted lean to unfold them so that i dont have to write them out</p>",
        "id": 533955349,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754996396
    },
    {
        "content": "<p>there is no way to create an abbrev or notation inside a proof context, right?  i feel it would be nice being able to write a transparent <code>let</code> which is really just shorthand and never needs to be unfolded or simplified.</p>",
        "id": 534187777,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1755075888
    },
    {
        "content": "<p>maybe it's time to split your proof into lemmas</p>",
        "id": 534189102,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1755076365
    },
    {
        "content": "<p>Hmm, <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> said the same in another thread (which I didn't want to hijack), and I'm sure you have a point. But do you never just want to abbreviate a term inside a proof context for sake of abbreviation?  For example, I started a proof like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">singleton_is_mono</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Mono</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">singleton</span><span class=\"w\"> </span><span class=\"n\">hPB</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">⟶</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">B_sub</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Subobject</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmdiag</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subobject</span><span class=\"bp\">.</span><span class=\"n\">pullback</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">B_sub</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">P'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subobject</span><span class=\"bp\">.</span><span class=\"n\">pullback</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"bp\">◁</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"n\">B_sub</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">PeqP'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">P'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It just fits my mental image to call those pullbacks <code>P</code> and <code>P'</code>, but I don't want to manually unfold them later, ideally I'd like that <code>PeqP'</code> has actually type <code>(Subobject.pullback (B ◁ b)).obj B_sub = (Subobject.pullback (B ◁ b')).obj B_sub</code> and <code>P = P'</code> is just shorthand. This feels to me very close to writing an actual math proof.</p>",
        "id": 534477593,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1755176131
    },
    {
        "content": "<p>you can just treat it as if it's a term of type <code>(Subobject.pullback (B ◁ b)).obj B_sub = (Subobject.pullback (B ◁ b')).obj B_sub</code>, because the <code>let</code>s can be definitionally unfolded</p>",
        "id": 534481842,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755177465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> yes, I do unfold them later via <code>unfold P P'</code>, but wouldn't it be nice if we had reducibles in proof context?  Something like <code>rdef P := ...</code> for creating a transparent / reducible definitions / macros?</p>",
        "id": 534511357,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1755186751
    },
    {
        "content": "<p>that's what <code>let</code> does</p>",
        "id": 534511422,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755186773
    },
    {
        "content": "<p>I think <code>let</code> has reducible zeta-delta</p>",
        "id": 534511588,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755186823
    },
    {
        "content": "<p>Awesome!  I could swear that I tripped over this before, but now I can't reconstruct it, so it must have been some other mistake, thank you!</p>",
        "id": 534513431,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1755187403
    },
    {
        "content": "<p>You can also use <code>letI</code> (the <code>I</code> means \"inline\") which is reasonable for <code>def</code>s because there are no actual <code>let</code>s inside the expression.</p>",
        "id": 534519856,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1755189211
    },
    {
        "content": "<p>I guess you could write <code>value_of% P = value_of% P'</code> if you really wanted <code>P</code> and <code>P'</code> to not appear, though that doesn't look very nice.</p>",
        "id": 534573008,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755213223
    },
    {
        "content": "<p>By the way, <code>simp</code> by default doesn't unfold local variables unless either you specify which variables you want to be unfolded (e.g. <code>simp [a,b]</code>) or by using the option <code>simp +zetaDelta</code>.</p>",
        "id": 534573182,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1755213343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/unfold.20at.20.5BTERM.5D/near/534511588\">said</a>:</p>\n<blockquote>\n<p>I think <code>let</code> has reducible zeta-delta</p>\n</blockquote>\n<p>Hm, I could now reproduce my case, but maybe I'm also misunderstanding what you meant.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"w\">  </span><span class=\"c1\">--this is not working</span>\n<span class=\"w\">  </span><span class=\"c1\">--have : (⟨ x ⟩ : Foo) = (⟨ y ⟩ : Foo) := by simp</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This is still not a perfect example, since <code>rfl</code> here would work, but imagine something with an actual simp lemma where rfl won't suffice (which is the case in my current project).</p>\n<p>Unfortunately, <code>letI</code> instead of <code>let</code> is also not working without unfolding. </p>\n<p>This does work (thank you <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> !):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">value_of</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">value_of</span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>but I'd like to have it the other way around, make <code>x</code> and <code>y</code> transparent at the point where I introduce them, and then not having to think about that extra layer anymore.</p>",
        "id": 534798123,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1755401684
    }
]