[
    {
        "content": "<p>Hello, I'd like to define a function like who's domain are the positive reals, I asked the other day if <code>preal</code> existed, but it looked like it didn't, in that case how can I define a function like that? So far I've best I've done is <code>f : R -&gt; R</code>and <code>f : nnreal -&gt; R</code></p>\n<p>On that same thread I was trying to define a function which takes in two elements from <code>R</code> and sends them to <code>R</code>, is the best way of doing that having <code>f : R -&gt; R -&gt; R</code> or is there an easier way of writing the repeated mapping like that. If that's the way we have to write it then how would we notate a function which takes in <code>n</code> arguments from <code>R</code> and maps it elsewhere?</p>",
        "id": 273014649,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645652187
    },
    {
        "content": "<p>One suggestion is that you just use the reals and return junk values for &lt;= 0. This works really well, this is how things like <code>real.sqrt</code> works (I don't know what <code>real.sqrt (-1)</code> is but I do know it's a real number and I suspect there are no lemmas about it). Otherwise make the subtype (and then live with the pain that this causes). </p>\n<p>As for R -&gt; R -&gt; R, that's exactly the way that e.g. addition and multiplication in groups and rings etc are done, it's definitely the least painful way in dependent type theory. If you want n arguments and n is a variable then it's <code>(fin n -&gt; R) -&gt; R</code>, but remember that if <code>n = 2</code> then <code>fin 2 -&gt; R</code> is not defeq to <code>R \\times R</code> and neither of those are as convenient as <code>R -&gt; R -&gt; R</code> anyway.</p>",
        "id": 273015203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645652503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">Callum Cassidy-Nolan</span> has marked this topic as resolved.</p>",
        "id": 273015350,
        "sender_full_name": "Notification Bot",
        "timestamp": 1645652583
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">Callum Cassidy-Nolan</span> has marked this topic as unresolved.</p>",
        "id": 273317270,
        "sender_full_name": "Notification Bot",
        "timestamp": 1645850122
    },
    {
        "content": "<p>If I had a function defined on <code>R \\to \\R</code> then how could I state that that function is increasing only for <code>3 &lt; x</code> ? I'm using <code>strict_mono</code> for increasing function.</p>",
        "id": 273317324,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645850198
    },
    {
        "content": "<p>I think strict_mono is quantified over the whole type. So, you could roll your own strictly increasing statement for 3 &lt; x, or you could use a subtype (the former will be preferable).</p>",
        "id": 273317528,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645850548
    },
    {
        "content": "<p>What about if I simply wanted a function who's domain was all reals except zero? Is there a way to encode this in the functions type itself?</p>",
        "id": 273317712,
        "sender_full_name": "Callum Cassidy-Nolan",
        "timestamp": 1645850868
    },
    {
        "content": "<p>Subtypes: <code>{ x : real // x ≠ 0}</code>. The downside is that you don't get all the theorems about real numbers because this subtype isn't the real numbers. Often it's better to just give your function a \"garbage value\" where you don't have a definition. Then the function is still total, and it's still defined on the real numbers. Then, in your theorems about that function, you just add the hypothesis <code>x≠0</code>.</p>",
        "id": 273317916,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645851189
    },
    {
        "content": "<p>A great example is the inverse function on the reals sending <code>x</code> to <code>x⁻¹</code>. In lean we have <code>0⁻¹ = 0</code> rather than defining inverse only on nonzero elements. It turns out to be much less painful this way.</p>",
        "id": 273325846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645862406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">Callum Cassidy-Nolan</span> <a href=\"#narrow/stream/113489-new-members/topic/Functions.20with.20various.20.20real.20domains/near/273317324\">said</a>:</p>\n<blockquote>\n<p>If I had a function defined on <code>R → \\R</code> then how could I state that that function is increasing only for <code>3 &lt; x</code> ? I'm using <code>strict_mono</code> for increasing function.</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/strict_mono_on\">docs#strict_mono_on</a></p>",
        "id": 273327882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645865005
    },
    {
        "content": "<p>Oh, I forgot about that. Nice.</p>",
        "id": 273342537,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645884044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"367659\">Callum Cassidy-Nolan</span> has marked this topic as resolved.</p>",
        "id": 273919413,
        "sender_full_name": "Notification Bot",
        "timestamp": 1646280194
    }
]