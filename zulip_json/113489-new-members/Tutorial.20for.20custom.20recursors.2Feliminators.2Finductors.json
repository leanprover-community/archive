[
    {
        "content": "<p>I've came across several of these things, e.g.</p>\n<ul>\n<li><code>ReflTransGen.head_induction_on</code> is a custom reduction principle (which I understand somewhat)</li>\n<li><code>Batteries.Vector.elimAsArray</code> is a custom eliminator, which I'm not sure how to apply. (again using <code>induction using</code>?)</li>\n<li>Docs also mention \"cases eliminators\" and \"induction eliminators\", seem to be a way to override the default eliminators for types, am I correct?<br>\nIf there's documentation on this, I'd be much pleased to be informed of it.</li>\n</ul>",
        "id": 479173205,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730071086
    },
    {
        "content": "<p>There are three kinds of things you can define:</p>\n<ul>\n<li>\n<p>If you give a declaration <code>@[cases_eliminator]</code>, then that changes the default eliminator to use for the <code>cases</code> tactic.  This way you don't have to write <code>cases val using customCasesEliminator</code>. A <code>cases</code> eliminator should not introduce induction hypotheses. That means the <code>motive</code> argument shouldn't appear as a hypothesis to any of the premises. (The default cases eliminator is the <code>MyType.casesOn</code> function.)</p>\n</li>\n<li>\n<p>If you give a declaration <code>@[induction_eliminator]</code>, then that changes the default eliminator to use for the <code>induction</code> tactic. An induction eliminator can have induction hypotheses. (The default induction eliminator is <code>MyType.recOn</code>.)</p>\n</li>\n<li>\n<p>If you give a declaration the <code>@[elab_as_elim]</code> attribute, then this changes how it elaborates, using a special procedure that makes use of the expected type to solve for a motive argument. The definition of an \"eliminator\" here is fairly broad, but basically, if you have a theorem <code>myInduction {motive : MyType -&gt; Prop} (hyp1 : hypothesis) (hyp2 : hypothesis) (x : MyType) : motive x</code>, then if you use it with <code>refine</code> like <code>refine myInduction ?_ ?_ val</code>, it'll generalize <code>val</code> out of the goal automatically and create the correct <code>motive</code>, leaving you with two goals. A declaration given this attribute <em>must</em> have an expected type available, otherwise during elaboration you get an error message.</p>\n</li>\n</ul>\n<p>The third one does not affect <code>induction</code> or <code>cases</code>. If you want to use <code>*_eliminator</code>s with <code>refine</code>, you can add <code>elab_as_elim</code>. Often you can use <code>apply</code> without needing to add <code>elab_as_elim</code> since it has some capacity for the higher-order unification that <code>elab_as_elim</code> is performing.</p>",
        "id": 479173771,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730071678
    },
    {
        "content": "<p>(<code>cases_eliminator</code> and <code>induction_eliminator</code> are why it is that when you do cases/induction on <code>Nat</code> that everything is in terms of <code>0</code> and <code>n + 1</code> rather than <code>Nat.zero</code> and <code>Nat.succ n</code>.)</p>",
        "id": 479174191,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730072081
    },
    {
        "content": "<p>Thanks a lot.</p>\n<ul>\n<li>Judging by <a href=\"https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/App.html#Lean.Elab.Term.elabAsElim\">https://leanprover-community.github.io/mathlib4_docs/Lean/Elab/App.html#Lean.Elab.Term.elabAsElim</a>, the first two cases also require that the return type is a motive applied to other parameters - I'm guessing it makes for a simple unification?</li>\n<li>Can you also clarify what exactly is meant by \"must have an expected type available\" in the third case? That's the error I got hen trying to use <code>Vector.elimAsArray</code>with <code>apply</code>. <code>refine</code> also doesn't seem to work:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vec_set_local</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">\\/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">elimAsArray</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"c1\">-- failed to elaborate eliminator, motive is not type correct: fun x y =&gt; ...</span>\n</code></pre></div>\n<ul>\n<li>If I understand correctly, the names of the parameters become my subgoal tags, and if they have a shape of forall/arrow, then that becomes my case hypotheses. Does <code>match</code> also use cases eliminator (TPIL mentions match procedures using <code>casesOn</code>)? What happens with explicit arguments that aren't motive applications? It seems that one of them can match with <code>p</code> at <code>induction p using</code>.</li>\n</ul>",
        "id": 479175104,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730072929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479175104\">said</a>:</p>\n<blockquote>\n<ul>\n<li>the first two cases also require that the return type is a motive applied to other parameters - I'm guessing it makes for a simple unification?</li>\n</ul>\n</blockquote>\n<p>Yeah, all three cases require that the return type be an applied motive. The <code>induction_eliminator</code> and <code>cases_eliminator</code> need the arguments to be other parameters (these are \"targets\", the things that are arguments in the induction tactic, like <code>induction x, y, z</code> — this is how the targets are identified). You may need to way for a future release of Lean, but <code>elab_as_elim</code> doesn't require that the arguments be parameters, since it has no concept of targets.</p>",
        "id": 479176119,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730073857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479175104\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Can you also clarify what exactly is meant by \"must have an expected type available\" in the third case?</li>\n</ul>\n</blockquote>\n<p>The elaboration procedure is at a high level a function <code>Syntax -&gt; (expectedType? : Option Expr) -&gt; TermElabM Expr</code>. There can be an expected type that comes from context, and it is a hint for what type would be great to get back — though elaboration doesn't need to respect the expected type. For example, the <code>(... : Ty)</code> notation sets the expected type to <code>Ty</code>, and then inserts a coercion if the type doesn't match.</p>\n<p>The <code>apply</code> tactic elaborates its argument without an expected type, and the <code>refine</code> tactic elaborates using the goal as the expected type.</p>",
        "id": 479176322,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730074044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479175104\">said</a>:</p>\n<blockquote>\n<p><code>failed to elaborate eliminator, motive is not type correct: fun x y =&gt; ...</code></p>\n</blockquote>\n<p>If this happens, it means that generalizing failed. It's similar to the \"motive not type correct\" error in <code>rw</code>. It looks like if you revert <code>i</code> and <code>j</code> first it should work, since these depend on <code>n</code>. Notice that <code>n</code> is one of the motive arguments — that means it's very likely to get a type incorrect motive if you let anything depend on <code>n</code> in the goal expression.</p>",
        "id": 479176608,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730074319
    },
    {
        "content": "<p>Yeah, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vec_set_local</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">\\/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">elimAsArray</span><span class=\"w\"> </span><span class=\"bp\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 479176670,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730074356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479175104\">said</a>:</p>\n<blockquote>\n<ul>\n<li>If I understand correctly, the names of the parameters become my subgoal tags, and if they have a shape of forall/arrow, then that becomes my case hypotheses. Does <code>match</code> also use cases eliminator (TPIL mentions match procedures using <code>casesOn</code>)?</li>\n</ul>\n</blockquote>\n<p>Yes, names of hypotheses become subgoal tags. These are the tags you can use in <code>induction ... with | tag1 ... =&gt; ... | ...</code> notation too.</p>\n<p>Regarding <code>match</code>, no, you can't override anything about <code>match</code>. The best you can do is create new patterns with <code>@[pattern]</code>. All <code>@[pattern]</code> does is let <code>match</code> unfold it.</p>\n<blockquote>\n<p>What happens with explicit arguments that aren't motive applications? It seems that one of them can match with <code>p</code> at <code>induction p using</code>.</p>\n</blockquote>\n<p>These are \"major premises\". They're the parameters that are supposed to appear as arguments to the motive in the whole eliminator's return type. (See the <code>induction x, y, z</code> message a few before this one.)</p>",
        "id": 479176969,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730074596
    },
    {
        "content": "<blockquote>\n<p>Yeah, all three cases require that the return type be an applied motive. The <code>induction_eliminator</code> and <code>cases_eliminator</code> need the arguments to be other parameters (these are \"targets\", the things that are arguments in the induction tactic, like <code>induction x, y, z</code> — this is how the targets are identified). You may need to way for a future release of Lean, but <code>elab_as_elim</code> doesn't require that the arguments be parameters, since it has no concept of targets.<br>\nso, to clarify, <code>induction x using</code> uses <code>induction_eliminator</code> rules too.<br>\nIf this happens, it means that generalizing failed.<br>\nCuriously, <code>induction</code> does just fine:</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">vec_set_local</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">\\/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">elimAsArray</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p><code>i j</code> get rewritten to type <code>Fin .(toArray).size</code>, but <code>n</code> doesn't. It seems that it's able to treat <code>N</code> as an output parameter there and infer its value from <code>rfl</code>. (Which is interesting, because <code>n</code> should indeed be a \"major parameter\" here?)<br>\nI'm guessing it's because <code>induction</code> can generalize/specialize hypotheses, and <code>refine</code> only targets and motive?<br>\n<code>generalize n=m at *</code> fails with a cryptic error <code>failed to generalize vec_set_local, which is an internal definition</code>; guessig that has to do with lacking an explicit <code>forall n</code>.</p>",
        "id": 479180773,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730077800
    },
    {
        "content": "<p>Yes, <code>induction</code> auto-generalizes variables that appear in the goal.</p>",
        "id": 479181505,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730078397
    },
    {
        "content": "<p>I see; is that an effect reproducible by other means?</p>",
        "id": 479181620,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730078469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479180773\">said</a>:</p>\n<blockquote>\n<p><code>generalize n=m at *</code> fails with a cryptic error <code>failed to generalize vec_set_local, which is an internal definition</code></p>\n</blockquote>\n<p>That one seems like it might be a bug in <code>generalize</code> — there are some auxiliary local definitions that tactics are not supposed to see, but it's easy to get this wrong.</p>",
        "id": 479181623,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730078471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"767265\">Alex Mobius</span> <a href=\"#narrow/channel/113489-new-members/topic/Tutorial.20for.20custom.20recursors.2Feliminators.2Finductors/near/479181620\">said</a>:</p>\n<blockquote>\n<p>I see; is that an effect reproducible by other means?</p>\n</blockquote>\n<p>Sometimes I wish there were a <code>revert</code> tactic that just reverted the variables appearing in the goal, but there isn't one as far as I know.</p>",
        "id": 479181699,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730078537
    },
    {
        "content": "<p>I think <code>generalize</code> here is referring to the fact that if I were use a name <code>vec_set_local</code> in this context, it would refer to <code>vec_set_local</code> specialized to specific <code>n</code> and <code>v</code>, since they're to the left of colon. But yeah, it either shouldn't try, or should succeed.</p>",
        "id": 479181867,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1730078720
    },
    {
        "content": "<p>Yes, <code>vec_set_local</code> is an auxiliary local definition that's in the local context but hidden. It's used for elaborating recursive declarations, and tactics are supposed to pay no attention to it.</p>",
        "id": 479182026,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1730078853
    }
]