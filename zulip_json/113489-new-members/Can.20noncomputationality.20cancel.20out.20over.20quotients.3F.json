[
    {
        "content": "<p>i noticed that the definition of <code>CategoryTheory.Subobject.pullback</code> is noncomputational because it uses <code>CategoryTheory.MonoOver.pullback</code>, which works by choosing pullbacks from existence. But isomorphic pullbacks give equal subobjects, so is this a limitation of Lean itself or a limitation of the implementation? In other words, could we theoretically have a computational version of <code>CategoryTheory.Subobject.pullback</code> (or similar patterns), where all noncomputational choices lead to the same result?</p>",
        "id": 531903900,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753899962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245772\">@Klaus Gy</span> in Lean unique choice is still noncomputable.</p>",
        "id": 531949693,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917932
    },
    {
        "content": "<p>there's no algorithm to construct the unique pullback, even if it's unique</p>",
        "id": 531949704,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917942
    },
    {
        "content": "<p>it is not a \"limitation\" of any kind, it is just noncomputable</p>",
        "id": 531949742,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917959
    },
    {
        "content": "<p>it was a choice ever since we made all <code>limit</code> noncomputable</p>",
        "id": 531949757,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1753917972
    },
    {
        "content": "<p>i see, thank you!</p>",
        "id": 531979856,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1753937367
    }
]