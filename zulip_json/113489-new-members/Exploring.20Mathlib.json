[
    {
        "content": "<p>Hi -- I'm new here and exploring how Mathlib is structured, out of personal interest in how mathematics (or at least, this definition of it) is composed/layered. To get started, I exported the import graph from the <code>Mathlib/</code> directory so I could study it in Python -- in this case, just looking at the depth of imports within that directory. Quite a lot! And perhaps unsurprisingly, clustered around the middle-depths.</p>\n<p><a href=\"/user_uploads/3121/P3fY-Lb9IwRKGtxOFbsj42JA/modules_by_rank_bins.png\">modules_by_rank_bins.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/P3fY-Lb9IwRKGtxOFbsj42JA/modules_by_rank_bins.png\" title=\"modules_by_rank_bins.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"3000x1800\" src=\"/user_uploads/thumbnail/3121/P3fY-Lb9IwRKGtxOFbsj42JA/modules_by_rank_bins.png/840x560.webp\"></a></div><p>I'm curious if anyone has a dependency analysis they'd like to see, any thoughts of what I could explore besides the dependency graph (eg, maybe typeclasses?), or suggestions on how to improve my (highly suspect) Lean code.</p>\n<p>I don't plan to open a PR, since I doubt anyone else would find this useful -- but code viewable here:<br>\n<a href=\"https://github.com/zmgehlke/mathlib4/tree/master/scripts/visualizer\">https://github.com/zmgehlke/mathlib4/tree/master/scripts/visualizer</a></p>",
        "id": 543891852,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1759996195
    },
    {
        "content": "<p>Whilst I can't give you any concrete links, I know that there are ways out there to visualise the import graph graphically, find the longest chain of imports etc etc; the community has already written such software (but I don't know how to use it or where to find it). Hopefully someone else will chime in.</p>",
        "id": 543894238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1759996981
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/actions/runs/18369898030\">https://github.com/leanprover-community/mathlib4/actions/runs/18369898030</a> every build of the Mathlib repo builds an \"import-graph\" artifact which is a .dot file, so you can essentially download that and visualize it</p>",
        "id": 543902769,
        "sender_full_name": "Julian Berman",
        "timestamp": 1759999470
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/import-graph\">https://github.com/leanprover-community/import-graph</a> is the underlying Lean project</p>",
        "id": 543902843,
        "sender_full_name": "Julian Berman",
        "timestamp": 1759999489
    },
    {
        "content": "<p>Neat! -- curiously, <code>import-graph</code> seems to require a build but my version didn't. Presumably because it's looking at something like the <code>.olean</code> files rather than <code>.lean</code> imports statements.</p>",
        "id": 543907763,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760000919
    },
    {
        "content": "<p>I suspect I'm doing something wrong, because I'm getting order of magnitude differences between parsing files to export and using <code>import-graph</code>. Is there a way to compile <code>import-graph</code> or something I'm missing?</p>\n<p>After having run <code>lake build</code> for <code>mathlib4</code> (untimed), then using <code>import-graph</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>lake exe graph  9.92s user 5.38s system 29% cpu 51.273 total\n</code></pre></div>\n<p>Running a Python script that only exports with a compiled Lean helper and reimports to Python:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>python3 scripts/visualizer/demo_mathlib_graph.py  2.28s user 0.29s system 62% cpu 4.143 total\n</code></pre></div>",
        "id": 543937875,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760010577
    },
    {
        "content": "<p>For PhysLean I (well, really, github copilot) recently made a java-script version of part of the implementation of import-graph. In particular it takes the '.dot' file output from <code>import-graph</code> which only has to be run once, and then lets you specify the source nodes and target nodes online, to make different graphs: e.g.</p>\n<p><a href=\"https://physlean.com/Dependencies.html?sources=PhysLean.SpaceAndTime.SpaceTime.Basic,PhysLean.Mathematics.List.InsertIdx,PhysLean.Mathematics.Fin,PhysLean.QFT.PerturbationTheory.CreateAnnihilate&amp;targets=PhysLean.QFT.PerturbationTheory.WickAlgebra.WicksTheorem\">https://physlean.com/Dependencies.html?sources=PhysLean.SpaceAndTime.SpaceTime.Basic,PhysLean.Mathematics.List.InsertIdx,PhysLean.Mathematics.Fin,PhysLean.QFT.PerturbationTheory.CreateAnnihilate&amp;targets=PhysLean.QFT.PerturbationTheory.WickAlgebra.WicksTheorem</a></p>",
        "id": 543940866,
        "sender_full_name": "Joseph Tooby-Smith",
        "timestamp": 1760011460
    },
    {
        "content": "<p>That's cool!</p>\n<p>My motivation is that I'm looking for ways to address the graph complexity by analyzing further structures and extract something meaningful -- eg, the everything graph for PhysLean highlights the problem:</p>\n<p><a href=\"https://physlean.com/Dependencies.html?sources=&amp;targets=PhysLean\">https://physlean.com/Dependencies.html?sources=&amp;targets=PhysLean</a></p>\n<p>One way is by looking at patterns (such as the above histogram) which tell us how the graph clusters (eg, 55% of Mathlib modules cluster in the rank 40-80 range); another is using deeper graph analysis to look at topic clustering or highly utilized modules.</p>",
        "id": 544065366,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760055608
    },
    {
        "content": "<p>Today I added a radial graph drawing where the nodes are colored by rank. Please excuse the faintness of the edges -- they completely wash out in the center if you turn it up higher.</p>\n<p><a href=\"/user_uploads/3121/eRP5kRsrMj3hibsluKhEi7-h/radial_optimized.png\">radial_optimized.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/eRP5kRsrMj3hibsluKhEi7-h/radial_optimized.png\" title=\"radial_optimized.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"2000x1997\" src=\"/user_uploads/thumbnail/3121/eRP5kRsrMj3hibsluKhEi7-h/radial_optimized.png/840x560.webp\"></a></div><p>What is interesting to me is two things: </p>\n<ul>\n<li>the spike module that has a high rank, but is deeply connected to the center; and,</li>\n<li>the banding where you have rings that are connected by towers.<br>\nMy next questions are about what causes that in the repo (eg, identifying the spike module and looking at examples of bands vs towers).</li>\n</ul>",
        "id": 544095192,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760077731
    },
    {
        "content": "<p>Is it Mathlib.lean?</p>",
        "id": 544096555,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1760078431
    },
    {
        "content": "<p>I believe that <code>Mathlib.lean</code> is excluded because I start parsing in the <code>Mathlib/</code>directory (rather than project root). I'm also missing stuff like <code>Archive/</code>, <code>Cache/</code>, <code>Counterexamples/</code>, etc.</p>\n<p>So it's something that's within that directory (and subdirectories) that depends on at least 1 high ranked file (there's a faint edge going up and to the right to another yellow node), yet has strong links to lower rank content.</p>",
        "id": 544097510,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760078882
    },
    {
        "content": "<p>After investigating, it seems like the spike is <code>Mathlib/Tactics.lean</code>; which makes sense for both why it has such a high number of imports and a link to many low rank modules.</p>\n<p>Next up, figuring out why the density rings form!</p>",
        "id": 544402265,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760277154
    },
    {
        "content": "<p>I was also looking at something similar for PhysLean, you can see the code I wrote <a href=\"https://github.com/HEPLean/PhysLean/blob/master/scripts/import-graph.py\">here</a>, and some discussion of tests I ran <a href=\"#narrow/channel/479953-PhysLean/topic/Visual.20representation.20of.20the.20content.20in.20PhysLean.3F\">here</a>.</p>\n<p>It reads the import graph in <code>.xdot_json</code> format from <code>import-graph</code>into a dataframe and finds some basic information:</p>\n<ul>\n<li>what I called \"subject\" is the folder the file is in which is directly under the main folder</li>\n<li>List of direct imports and dependents</li>\n<li>List of transitive imports and dependents (files that are imported/dependents indirectly by some intermediate files)</li>\n</ul>\n<p>My reason for doing this is I was/am interested in seeing if there's a way to see which files are a good place to start learning PhysLean/Mathlib/other projects. The issue being if you're just starting you maybe don't want to all the way back to the beginning but you also can't skip all the background files. My crude measure of what I called \"importance\" which is the fraction of files transitively imported multiplied by the fraction of files which are transitively dependents. The files in PhysLean with the largest \"importance\" were almost all .Basic files of the more filled out folders in PhysLean so it seemed to be doing something right.</p>\n<p>I had hoped to run this on Mathlib but was having trouble getting the import-graph to generate on my computer and then never got around to it. I would be interested in seeing how it does on a significantly larger project like mathlib.</p>",
        "id": 544645551,
        "sender_full_name": "Daniel Morrison",
        "timestamp": 1760407846
    },
    {
        "content": "<p>I'll have to give your example a look, sounds like we're working on similar ideas.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"622397\">Daniel Morrison</span> <a href=\"#narrow/channel/113489-new-members/topic/Exploring.20Mathlib/near/544645551\">said</a>:</p>\n<blockquote>\n<p>The issue being if you're just starting you maybe don't want to all the way back to the beginning but you also can't skip all the background files. My crude measure of what I called \"importance\" which is the fraction of files transitively imported multiplied by the fraction of files which are transitively dependents. The files in PhysLean with the largest \"importance\" were almost all .Basic files of the more filled out folders in PhysLean so it seemed to be doing something right.</p>\n</blockquote>\n<p>Huh -- I expect something similar to happen in Mathlib. I think the biggest outcome of my preliminary work is that it really looks like an onion: there's some really core things (basic types, tactics, etc); there's a heavy shell (rank 40 to 80) with over half the modules; and there's a sprawl (including an outer ring of activity).</p>\n<p>Naively, this confirms your framing: we don't really need to chase all the way down (or up) for most mathematics -- and accordingly, people would probably be happier ignoring those files at first. Next up I'll be exploring more structure than just the import graph, but one last image highlighted by histogram.</p>\n<p><a href=\"/user_uploads/3121/JmoYMCxcDTofY5C2Bu3mii4h/rank_histogram_by_count_v2.png\">rank_histogram_by_count_v2.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/JmoYMCxcDTofY5C2Bu3mii4h/rank_histogram_by_count_v2.png\" title=\"rank_histogram_by_count_v2.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"5100x3600\" src=\"/user_uploads/thumbnail/3121/JmoYMCxcDTofY5C2Bu3mii4h/rank_histogram_by_count_v2.png/840x560.webp\"></a></div>",
        "id": 545146499,
        "sender_full_name": "Michael Gehlke",
        "timestamp": 1760573892
    }
]