[
    {
        "content": "<p>This is a question about categories, not really about groups as such:</p>\n<p>Say I want to formalise the group SO(n)</p>\n<p>So just like an element x of SO(n) I would write x:SO(n)<br>\nBut I also want to express that SO(n), SP(n), etc. are lie groups. So I would want to write SO(n):LieGroup.  Would LieGroup then be a Type 2?</p>\n<p>But I don't think this is how it's done in Lean? Instead would I write a function<br>\n<code>isLieGroup:Type-&gt;Prop</code>  </p>\n<p>In other words, I'm just trying to understand how you formalise a hierachy such as A is_a B is_a C is_a D.<br>\ne.g. cat is_a mammal is_a animal is_a lifeform.</p>\n<p>Secondly if I am defining an \"is_a\" function which I can define any way I like. I might accidentally add a circular definition e.g. A is_a B is_a C is_a A. And then it's Russel's paradox all over again. And wasn't the whole point of Type theory to avoid such paradoxes? </p>\n<p>Perhaps the confusion is that : means \"instance of\" while \"is_a\" could also mean \"member_of\" or \"subcategory_of\". e.g. my pet cat is an instance of Cat. But Cat is a sub-category of Animal. But Cat is also an instance of the set of Animals.</p>",
        "id": 451120114,
        "sender_full_name": "Mr Proof",
        "timestamp": 1720842002
    },
    {
        "content": "<p>a partial answer is that you can make a class and prove <code>instance MyClass MyType</code>.</p>\n<p>I haven't yet been able to determine whether you can make one class imply (i.e, be a subclass of) another. my attempts so far have failed, but i remain hopeful. :)</p>",
        "id": 451124013,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720844971
    },
    {
        "content": "<p>oh, actually <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LieGroup#doc\">docs#LieGroup</a> seems to answer both our questions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">LieGroup</span><span class=\"o\">{</span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span>\n<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedSpace</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModelWithCorners</span><span class=\"w\"> </span><span class=\"n\">ùïú</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_4</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ChartedSpace</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">SmoothMul</span>\n<span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 451124217,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720845156
    },
    {
        "content": "<p>I have to be honest and say the Mathlib docs are largely impenetrable to me. <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span><br>\nI assume they are autogenerated from comments in the code. <br>\nMainly I learn things from examples and the docs are just a list of definitions. Hopefully they will be updated at some point with fleshed out examples for each topic.</p>\n<p>I sort of get the idea with classes. I'm just wondering how that's implemented behind the scenes so-to-speak. As I assume the classes are syntactic sugar for something else.</p>",
        "id": 451125700,
        "sender_full_name": "Mr Proof",
        "timestamp": 1720846397
    },
    {
        "content": "<p>This definition is mostly impenetrable to me, too, but basically everything in parens is something you explicitly supply, and the ones in curly braces and brackets are like prerequisites that have to be true about the explicit ones.</p>\n<p>For classes, you can click on the \"Instances\" expander thing underneath the definition in the docs, and then click the source link in the upper right to see the actual code.</p>",
        "id": 451127252,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1720847974
    },
    {
        "content": "<p>I find that the online docs are good as a reference, but I would not try to understand how the code works by looking at the docs.</p>",
        "id": 451130290,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720850426
    },
    {
        "content": "<p>For mathematical concepts, such as a Lie group, the docs give you information about the concept, not so much the code.</p>",
        "id": 451130399,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720850503
    },
    {
        "content": "<p>In fact, looking at the code alone that Michal posted, already gives me a good idea:</p>",
        "id": 451130468,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720850543
    },
    {
        "content": "<p><code>G</code> is \"the\" Lie group.  Since it is manifold, it has charts, and the charts are modelled using some topological space <code>H</code> (likely ‚Ñù^n or some other normed vector space), and since I mentioned ‚Ñù, there had better be some normed field.  That is k.</p>",
        "id": 451130622,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720850699
    },
    {
        "content": "<p>The actual def Is hidden in the fact that the type is <code>Prop</code>: this is going to be some compatibility of all these structures.</p>",
        "id": 451130678,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1720850761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423842\">Michal Wallace (tangentstorm)</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20you.20formalise.20hierachies.3F/near/451124013\">said</a>:</p>\n<blockquote>\n<p>I haven't yet been able to determine whether you can make one class imply (i.e, be a subclass of) another. my attempts so far have failed, but i remain hopeful. :)</p>\n</blockquote>\n<p>there are generally three ways:</p>\n<ol>\n<li>\n<p>use <code>extends</code>, i.e. <code>class MyClass extends YourClass</code>. </p>\n<ul>\n<li>you can use this when all non-automatic parameters in <code>MyClass</code> also occur in <code>YourClass</code>. Looking at the mathlib doc you sent, you can't just extend <code>Group G</code> because <code>Group G</code> doesn't depend on <code>ùïú</code>, while <code>LieGroup</code> does, meaning <code>ùïú</code> is not automatic</li>\n</ul>\n</li>\n<li>\n<p>use an instance parameter</p>\n<ul>\n<li>I can't think of anything that could go <em>wrong</em> with this from the top of my head, but the type signature can get very unwieldy this way.</li>\n</ul>\n</li>\n<li>\n<p>make an explicit instance.</p>\n<ul>\n<li>this is very similar to option 1, but can be used to make a combination of classes imply another, meaning it is slightly more general. i <em>believe</em> this also has the parameter restriction of that option, but i'm not certain.</li>\n</ul>\n</li>\n</ol>",
        "id": 451141401,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1720858597
    }
]