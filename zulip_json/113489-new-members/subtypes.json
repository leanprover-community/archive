[
    {
        "content": "<p>How does one create subtypes? Say I want a function  of two parameters one is an arbitrary natural number, the other is a natural number &lt; 100.</p>",
        "id": 196071923,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588456628
    },
    {
        "content": "<p>In this case I would just use <code>fin</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>In general, <code>{a // P a}</code> where <code>α : Type</code> and <code>P : α → Prop</code> is notation for the subtype of terms of type <code>α</code> that satisfy <code>P</code>. Subtypes are mentioned briefly in TPiL <a href=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\" title=\"https://leanprover.github.io/theorem_proving_in_lean/inductive_types.html#inductively-defined-propositions\">in chapter 7</a>. See also <a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/theories/sets.md#datasetbasic\">this mathlib doc page</a>.</p>",
        "id": 196072236,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588457225
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 196072433,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457602
    },
    {
        "content": "<p>Why doesn't this work?</p>",
        "id": 196072434,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457606
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"c1\">-- ok</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"mi\">4</span> <span class=\"c1\">--error</span>\n</code></pre></div>",
        "id": 196072437,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588457611
    },
    {
        "content": "<p>Because <code>4</code> is not a term of that subtype. You can construct a term like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">100</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">norm_num</span><span class=\"bp\">⟩</span>\n<span class=\"c1\">-- dec_trivial also works and doesn&#39;t require any import</span>\n</code></pre></div>",
        "id": 196072649,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588458004
    },
    {
        "content": "<p>But <code>example : fin 100 := 4</code> works</p>",
        "id": 196072787,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588458262
    },
    {
        "content": "<p>That's because <code>4</code> is a term of type <code>fin 100</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">set_option</span> <span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">numerals</span> <span class=\"n\">false</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"o\">(</span><span class=\"mi\">4</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">100</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">bit0 (bit0 has_one.one) : fin (bit0 (bit0 (bit1 (bit0 (bit0 (bit1 has_one.one))))))</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n\n\n<p>See <a href=\"https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56\" title=\"https://github.com/leanprover-community/lean/blob/ec1613aef1eee72e601f192b16740629c6d49690/library/init/data/fin/ops.lean#L56\">here</a>. Note how Lean interprets numerals in terms of <code>bit0</code>, <code>bit1</code> and <code>has_one.one</code> and <code>has_zero.zero</code>.</p>",
        "id": 196073091,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1588458810
    },
    {
        "content": "<p>Just because the thing you defined, <code>{n : ℕ // n ≤ 100}</code> is \"pretty much exactly the same thing as\" <code>fin 100</code>, doesn't mean that everything that works for <code>fin 100</code> will work for <code>{n : ℕ // n ≤ 100}</code>. There are lots of extra definitions which have been put on top of <code>fin n</code>, e.g. it has a 0, a 1, an add, and so on. If you want the same for your type you'll have to give it a name and put all these structure on it yourself.</p>",
        "id": 196074984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588462201
    },
    {
        "content": "<p>Deleted</p>",
        "id": 196076427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1588464940
    },
    {
        "content": "<p>I want to implement a function that adds two lists of the same length element-wise, but I don't know how to make sure the lists are the same size. Should I instead return an <code>option list</code> so that if they're the same size (using <code>if..then..else</code>) then I can do some computation and return <code>some list</code> otherwise <code>none</code> ?</p>",
        "id": 196078391,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588468479
    },
    {
        "content": "<p>If you want lists of fixed length, you could use vectors :P<br>\nIf you're doing it with lists, you probably want something like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">length_eq</span> <span class=\"o\">:</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">length</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 196081150,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1588473856
    },
    {
        "content": "<p>If you want to define it for vectors, it'd look something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">vector</span>\n\n<span class=\"n\">def</span> <span class=\"n\">add_vecs</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">vector</span> <span class=\"n\">α</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 196081359,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588474316
    },
    {
        "content": "<p>Yeah I should do this with vectors I don't know why I'm using lists</p>",
        "id": 196081415,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588474393
    },
    {
        "content": "<p>Although if you want to define your function by pattern matching/recursion, it may be a bit more complicated than by just using lists.</p>",
        "id": 196081530,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588474574
    },
    {
        "content": "<p>and when you try to call the function,  <code>vector</code>s is not as nice to use compared to <code>list</code>s.</p>",
        "id": 196081658,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588474908
    },
    {
        "content": "<p>Actually this works pretty well even for non-equal lists. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">list_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"n\">l2</span> <span class=\"o\">:=</span> <span class=\"n\">l2</span>\n<span class=\"bp\">|</span> <span class=\"n\">l1</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">nil</span> <span class=\"o\">:=</span> <span class=\"n\">l1</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"bp\">::</span> <span class=\"n\">t1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"bp\">::</span> <span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"bp\">+</span> <span class=\"n\">h2</span><span class=\"o\">)</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">list_add</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"n\">list_add</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">5</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"c1\">-- [10, 3]</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"n\">list_add</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">3</span><span class=\"o\">]</span> <span class=\"c1\">-- [3, 6, 3]</span>\n</code></pre></div>",
        "id": 196081698,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588474959
    },
    {
        "content": "<p>I can create a type class instance for it</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">list_add</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"bp\">+</span> <span class=\"o\">[</span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"mi\">4</span><span class=\"o\">]</span> <span class=\"c1\">-- [4,6]</span>\n</code></pre></div>\n\n\n<p>I don't know what the brackets for <code>⟨list_add⟩</code> are doing. I'm familiar with the angle brackets being used to create sigma types and and-conjunction but not sure what it means in this context</p>",
        "id": 196081897,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588475376
    },
    {
        "content": "<p>It's the short version for </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">list_has_add</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">list_add</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 196081953,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588475512
    },
    {
        "content": "<p>Oh so <code>{add := list_add}</code> is a structure</p>",
        "id": 196082119,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588475834
    },
    {
        "content": "<p><code>has_add</code> is a class, but I think so? </p>\n<p>Better wait for an expert to chime in. In the mean time, I think this is the correct section of TPIL.</p>\n<p><a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#type-classes-and-instances\" title=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#type-classes-and-instances\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#type-classes-and-instances</a></p>\n<blockquote>\n<p>Let us start with the first step of the program above, declaring an appropriate class:</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<blockquote>\n<p>The command <code>class</code> above is shorthand for</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"kn\">structure</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">default</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 196082209,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588476004
    },
    {
        "content": "<p>Ah I didn't catch that. So a type class _is_ a structure</p>",
        "id": 196082258,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588476141
    },
    {
        "content": "<p>(I think there might be a difference? But I'm not sure about this myself, so this is probably when you wait for an expert to come by, most are probably asleep right now)</p>",
        "id": 196082311,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1588476271
    },
    {
        "content": "<p>Fair enough, I'm in Chicago so I'm off to bed soon - hopefully will wake to some more clarification. But thanks for your help!</p>",
        "id": 196082382,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588476384
    },
    {
        "content": "<p>there is no difference</p>",
        "id": 196082550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588476823
    },
    {
        "content": "<p><code>class</code> is sugar for <code>@[class] structure</code></p>",
        "id": 196082653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588476973
    },
    {
        "content": "<p>Thanks for clarifying. Then what is an <code>instance</code> ? Is that also syntactic sugar for something I'm familiar with already?</p>",
        "id": 196082765,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588477308
    },
    {
        "content": "<p><code>instance</code> is sugar for <code>@[instance] def</code></p>",
        "id": 196083005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588477809
    },
    {
        "content": "<p>except that with <code>instance</code> the name is optional (else it makes a name by a simple heuristic), while <code>def</code> requires a name</p>",
        "id": 196083020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588477868
    },
    {
        "content": "<p>However, the <code>@[class]</code> and <code>@[instance]</code> attributes add additional behavior in conjunction with the <code>[foo x]</code> instance binder to trigger type class inference</p>",
        "id": 196083061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588477927
    },
    {
        "content": "<p>but from a foundational standpoint, an <code>instance</code> is just a <code>def</code> and a <code>class</code> is just a <code>structure</code> (and a <code>structure</code> is just an <code>inductive</code>)</p>",
        "id": 196083064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588477969
    },
    {
        "content": "<p>Thanks! That makes things much clearer.</p>",
        "id": 196083193,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588478231
    },
    {
        "content": "<p>Just found this definition of vector in the standard library<br>\n<code>def vector (α : Type u) (n : ℕ) := { l : list α // l.length = n }</code><br>\nThat seems quite elegant compared to the one in TPIL</p>",
        "id": 196084363,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588480993
    },
    {
        "content": "<p>a lot of people think the dependent family version is better, because it makes it easier to define functions by induction on vectors</p>",
        "id": 196084894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588482033
    },
    {
        "content": "<p>however, the example in TPIL is mostly there as an example of a dependent type family</p>",
        "id": 196084905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588482077
    },
    {
        "content": "<p>It's weird that in order to create a vector using the subtype version, you have to provide a list along with a proof that it is the right length; which makes me like the TPIL one better now.<br>\n<code>def myvec : vector ℕ 2 := ⟨[1,2], dec_trivial⟩</code></p>",
        "id": 196085027,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588482339
    },
    {
        "content": "<p>You can still create a vector using a <code>cons</code> function with the same type as the TPIL one so that you don't need a side proof</p>",
        "id": 196085144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588482513
    },
    {
        "content": "<p>it's just a definition now instead of a constructor</p>",
        "id": 196085149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588482530
    },
    {
        "content": "<p>How do you do that?</p>",
        "id": 196085328,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588482937
    },
    {
        "content": "<p>Look up the definition of <code>vector.cons</code> in the core library</p>",
        "id": 196085331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1588482951
    },
    {
        "content": "<p>Ah I see, nice. <code>def myvec2 (n : vector ℕ 0): vector ℕ 2 := vector.cons 1 (vector.cons 2 n)</code></p>",
        "id": 196085459,
        "sender_full_name": "Brandon Brown",
        "timestamp": 1588483193
    },
    {
        "content": "<p>I'm a bit confused about how subtypes work. This <code>simp [h]</code> doesn't close the subgoal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mv_power_series.has_zero.zero</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But if I change <code>cases em (f = 0)</code> to <code>cases em (f.val = 0)</code> it does close the goal. I don't get why this makes such a big difference; wouldn't it be more natural to write <code>f  = 0</code>?</p>",
        "id": 226251679,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232028
    },
    {
        "content": "<p>what imports do I need to make this a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 226252295,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232371
    },
    {
        "content": "<p>Edited, added them.</p>",
        "id": 226252336,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232472
    },
    {
        "content": "<p>I think there are some simp lemmas missing.</p>",
        "id": 226252418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232579
    },
    {
        "content": "<p>Some simp lemmas that need to be written for <code>mv_restricted_power_series</code>? Or things missing from one of the imports?</p>",
        "id": 226252505,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232659
    },
    {
        "content": "<p>If <code>h : f = 0</code> then  <code>simp [h]</code> takes you to <code>0.val x</code> and then to <code>↑0 x</code> and then it gets stuck</p>",
        "id": 226252544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613232719
    },
    {
        "content": "<p>If <code>h : f.val = 0</code> then the simp does a <code>pi.zero_apply</code>, which I guess it doesn't want to do if <code>h : f = 0</code></p>",
        "id": 226252643,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613232832
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_zero</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- works now</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226252836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233060
    },
    {
        "content": "<p>ahh amazing, thanks!</p>",
        "id": 226252896,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613233104
    },
    {
        "content": "<p><code>simp</code> changes <code>f.val</code> into <code>↑f</code> it seems, so you need a simp lemma saying that the coerced 0 is still 0.</p>",
        "id": 226252917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233138
    },
    {
        "content": "<p>Right ok that makes sense</p>",
        "id": 226252927,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613233149
    },
    {
        "content": "<p>The trick with these things is to look at the goal left by <code>simp</code> (in this case one involving <code>↑0</code>) and to ask \"why did it not get any further than this?\" and the answer is that the lemma you want to apply next (namely <code>↑0 = 0</code>) is not there.</p>",
        "id": 226252941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233192
    },
    {
        "content": "<p>Making definitions is much harder than proving theorems, but after a while you just pick up the tricks of what needs to be done.</p>",
        "id": 226252992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233221
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- don't want them to be explicit for this next function</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">mv_power_series</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coeff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">g</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ext_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">f</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">g</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">▸</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exists_max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≥</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">f.val</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">em</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">-- works now</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"235423\">@Ashwin Iyengar</span>  that's how I'd start. Any new type needs an extensionality lemma.</p>",
        "id": 226253635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613233936
    },
    {
        "content": "<p>Nice, thanks</p>",
        "id": 226253811,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613234134
    },
    {
        "content": "<p>In fact looking at <code>mv_power_series</code> the <code>coeff</code> function should be an R-module hom really.</p>",
        "id": 226253883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234176
    },
    {
        "content": "<p>so another thing you might want to do is to make <code>mv_restricted_power_series σ R</code> into an <code>R</code>-module and then beef up the definition of <code>coeff</code></p>",
        "id": 226253911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234220
    },
    {
        "content": "<p>Of course it's entirely up to you how you do this. If you're thinking about a PR (and you perhaps should be) then you might want to look at the beginning of the <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/ring_theory/power_series/basic.lean\">power series file</a> in mathlib, where they do exactly what I decided was the best idea -- give it an R-module structure and then define coeff and ext. They also defined monomial. These things will ultimately make your life easier in the end.</p>",
        "id": 226254174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234503
    },
    {
        "content": "<p>Cool yeah that's basically what I was planning to do after getting to grips with the library a bit more</p>",
        "id": 226254276,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613234612
    },
    {
        "content": "<p>I know several cases of beginners who have started exactly this way -- made a PR to mathlib generalising something which was already there.</p>",
        "id": 226254326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234647
    },
    {
        "content": "<p>Ashvni (who you know), Amelia and Jason (both IC UGs) all started like this.</p>",
        "id": 226254338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234683
    },
    {
        "content": "<p>If you do nothing more than to make it a ring under the assumption of the ultrametric inequality then this is already really useful. Then you come back to look at it 3 months later and other random people have built on top of it. It's the way the library grows.</p>",
        "id": 226254390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613234759
    },
    {
        "content": "<p>I would expect that in my instantiation of an <code>add_comm_group</code>, I should just be able to do <code>rfl</code> for <code>add_assoc</code> because I added a <code>coe_add</code> but it doesn't work. Is there a simple way to prove <code>add_assoc</code> which essentially just says \"it's true because it's true for the supertype\"? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mv_power_series.has_zero.zero</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_zero</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">f.val</span> <span class=\"bp\">+</span> <span class=\"n\">g.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.add</span> <span class=\"n\">f.2</span> <span class=\"n\">g.2</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp, norm_cast]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">a.add</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">f_conv</span> <span class=\"o\">:=</span> <span class=\"n\">metric.tendsto_nhds.1</span> <span class=\"n\">f.2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">f_conv</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">metric.tendsto_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f_conv</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"n\">add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"n\">neg</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226378684,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613392688
    },
    {
        "content": "<p>One thing that seems to work is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>  <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 226381254,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1613394326
    },
    {
        "content": "<p><code>ext</code> ought to help here too, after those rintros</p>",
        "id": 226383645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613395718
    },
    {
        "content": "<p><code>  add_assoc := λ _ _ _, by {ext, simp only [add_assoc, coe_add]},</code> would be the way I would prove it. <code>by {ext, simp [add_assoc]} works too, but is slower. Note that </code>add_assoc<code> is not a </code>simp` lemma so needs to be added explicitly.</p>",
        "id": 226383982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613395931
    },
    {
        "content": "<p><code>rfl</code> means \"this is true by definition, if you unfold all the definitions\", so it won't work here, because if you unfold all the definitions you are reduced to associativity of addition for multivariable power series, which is true, but not true by definition -- it's true because of a theorem (in fact an axiom, namely associativity of addition on R).</p>",
        "id": 226384060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613395989
    },
    {
        "content": "<p>Thanks all! <code>ext</code> was the key that I wasn't aware existed.</p>",
        "id": 226384502,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613396267
    },
    {
        "content": "<p>The <code>ext</code> lemma we proved earlier was tagged with <code>@[ext]</code>, which means that the <code>ext</code> tactic will use it. But actually I guess the reason it's working without that ext lemma is that the <code>ext</code> tactic is using <code>subtype.ext</code> and then the <code>ext</code> lemma for <code>mv_power_series</code>.</p>\n<p>Here's a proof of <code>neg</code> which just says \"f.2 says some filter tends to 0, so the corresponding filter for -f tends to -0\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">tendsto.comp</span> <span class=\"n\">continuous_at_neg</span> <span class=\"n\">f.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">neg_zero.symm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226385836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613396936
    },
    {
        "content": "<p>The implementation for something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.to_monoid/src\">src#submonoid.to_monoid</a> ought to show how <code>ext</code> is normally used here</p>",
        "id": 226385944,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397003
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">show_term</span><span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">},</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">coe_add</span><span class=\"o\">]},</span>\n</code></pre></div>\n<p>shows that it's using subtype.ext and then the ext lemma for mv power series</p>",
        "id": 226386050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397044
    },
    {
        "content": "<p>Actually it seems like <code>ext</code> isn't used at all, and the proofs are just transferred across the injectivity of <code>coe</code>, using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.add_comm_monoid\">docs#function.injective.add_comm_monoid</a></p>",
        "id": 226386132,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397082
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">coe_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype.coe_injective</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">add</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_neg</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">neg</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe_injective.add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226386931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397460
    },
    {
        "content": "<p>There's the <code>rfl</code>s you were hoping to see</p>",
        "id": 226387009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397487
    },
    {
        "content": "<p>How can this work? One has to check that the subtype condition is preserved by addition and negation.</p>",
        "id": 226387113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397539
    },
    {
        "content": "<p>That's why you have to define<code> add</code> and <code>neg</code> yourself</p>",
        "id": 226387208,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397589
    },
    {
        "content": "<p>Oh I see, you use the contructions of add and neg</p>",
        "id": 226387216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397594
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 226387308,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613397628
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"n\">continuous_at_neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226387623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397766
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">neg</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 226387751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397827
    },
    {
        "content": "<p>No need to ever translate into epsilons.</p>",
        "id": 226387879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613397869
    },
    {
        "content": "<p>Thanks. This code works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n</code></pre></div>\n<p>but now I want to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective.semimodule\">docs#function.injective.semimodule</a> to show that restricted power series are an R-module. The problem is that it's not clear that <code>coe</code> is an additive monoid homomorphism. My understanding is that homomorphisms should be bundled. So what's the best way of stating that <code>coe</code> is a homomorphism? Then I can do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coe_injective.semimodule</span> <span class=\"n\">_</span> <span class=\"bp\">???</span>\n</code></pre></div>",
        "id": 226415479,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613412594
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">coe_hom</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">coe_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">coe_add</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226415902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613412885
    },
    {
        "content": "<p>Ah ok so treat it as a separate thing. Thanks!</p>",
        "id": 226415918,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613412903
    },
    {
        "content": "<p>yeah it's kind of annoying. In Lean 4 we might be able to go back to the <code>instance : is_add_monoid_hom coe</code> approach but in Lean 3 the separate thing approach turned out to be nicer.</p>",
        "id": 226415984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613412957
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.injective.semimodule</span> <span class=\"n\">R</span> <span class=\"n\">coe_hom</span> <span class=\"n\">coe_hom_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>works but I can't get <code>coe_hom_injective.semimodule ...</code> to work.</p>",
        "id": 226416421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413297
    },
    {
        "content": "<p>Yeah I guess <code>coe_injective</code> doesn't know that <code>coe</code> is a hom</p>",
        "id": 226416591,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413405
    },
    {
        "content": "<p>Can you post an updated <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 226416697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613413469
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">tendsto</span> <span class=\"n\">f</span> <span class=\"n\">cofinite</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">)}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_restricted_power_series</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">subtype.val</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subtype.coe_injective</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f.val</span> <span class=\"bp\">+</span> <span class=\"n\">g.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.add</span> <span class=\"n\">f.2</span> <span class=\"n\">g.2</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">tendsto_const_nhds</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_neg</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.neg</span> <span class=\"n\">f.2</span><span class=\"o\">⟩⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">coe_injective.add_comm_group</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">coe_hom</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→+</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n    <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">function.injective.semimodule</span> <span class=\"n\">R</span> <span class=\"n\">coe_hom</span> <span class=\"n\">coe_injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 226416718,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413498
    },
    {
        "content": "<p>Hey, nice <code>has_scalar.smul</code> proof :-) You can use <code>f.2</code> for <code>f.property</code> if you want (and <code>f.1</code> for <code>f.val</code>) -- but I'm not sure that there is any particular preference for one over the other, I'm just noting this general trick of X.1 and X.2 which works in large generality. Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>",
        "id": 226416991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613413713
    },
    {
        "content": "<p>Ok, yeah either way I should probably pick a convention and stick to it</p>",
        "id": 226417335,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413931
    },
    {
        "content": "<p>I sort of like <code>f.val</code> and <code>f.property</code> because they're less ambiguous, but maybe that hasn't been the design principle?</p>",
        "id": 226417369,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613413973
    },
    {
        "content": "<p>No, I agree about the lack of ambiguity, stick with them, I was just pointing out a trick.</p>",
        "id": 226417406,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613414000
    },
    {
        "content": "<p>Honestly, the only reason I said it was that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f.val</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.property</span><span class=\"o\">⟩}</span>\n</code></pre></div>\n<p>is over 100 characters long, and there's a 100 character limit per line in mathlib, and this trick got it back down to under 100 characters :-)</p>",
        "id": 226417485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613414048
    },
    {
        "content": "<p>Ah good to know</p>",
        "id": 226417556,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613414110
    },
    {
        "content": "<p>Usually coercion is used as the simp-normal form in place of <code>.val</code> or <code>.1</code></p>",
        "id": 226418204,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613414575
    },
    {
        "content": "<p>That is,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">tendsto.comp</span> <span class=\"o\">((</span><span class=\"n\">mul_left_continuous</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">f.prop</span><span class=\"o\">⟩}</span>\n</code></pre></div>",
        "id": 226418252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613414612
    },
    {
        "content": "<blockquote>\n<p>Note that X.3 doesn't work :-( (in situations where it's meaningful, e.g. if X is a proof of P and Q and R) -- it's X.2.2.</p>\n</blockquote>\n<p>By the way, while I would be all for such an abbreviation, it makes X.2 ambiguous</p>",
        "id": 226418512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613414792
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I would think that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f.val</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">g.val</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>is more natural than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span> <span class=\"kd\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_restricted_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">coeff</span> <span class=\"n\">R</span> <span class=\"n\">n</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>but maybe  I'm missing something? Is the idea that using <code>coeff</code> is more elegant because it doesn't rely on the precise definition of <code>mv_power_series</code> or <code>mv_restricted_power_series</code>?</p>",
        "id": 226423757,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613418290
    },
    {
        "content": "<p>I am always a bit edgy about abuse of definitional equality. What you say is exactly what worries me -- but I know that some computer scientists would find your suggestion more elegant. Your code breaks if someone refactors mv_power_series to be e.g. a completion of k[sigma]/I^n with I the ideal generated by the sigma, whereas mine uses the interface so doesn't break. I've seen definitions change in the past in mathlib. On the other hand the current definition of power series seems to be one which makes everyone happy right now so maybe it's unlikely to change in future. Abuse of definitional equality is really handy when you're writing slick term mode proofs at the beginning of your API. After a while it basically becomes irrelevant though, because e.g. if you're trying to prove that Tate algebras in finitely many variables over a complete nonarchimedean normed field are Noetherian then these issues are not really the important ones -- you're going to write a long tactic proof there so who cares what the definition is under the hood.</p>",
        "id": 226424431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613418741
    },
    {
        "content": "<p>I see. Yeah it's the little things like this I get perplexed by, like e.g. right now I'm stuck trying to convert <code>hd: ¬⇑(coeff R d) f = 0</code> to <code>hd: ¬∥f.val d∥ = 0</code></p>",
        "id": 226424679,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613418959
    },
    {
        "content": "<p>You can probably <code>change ¬(f.val d = 0) at hd</code> because these will be definitional.</p>",
        "id": 226424783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613419027
    },
    {
        "content": "<p>But one thing you should definitely do is to decide once and for all whether you're going to refer to to the d'th coefficient of f via f.val d or coeff R d f or whatever, and then stick to your convention, and write simp lemmas changing every other convention to your convention.</p>",
        "id": 226424823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613419082
    },
    {
        "content": "<p>A tactic a day...</p>",
        "id": 226425081,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1613419292
    }
]