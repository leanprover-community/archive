[
    {
        "content": "<p>(apologies if this explained in MIL, just send me a pointer to read more). I am finishing Theorem proving with Lean and it has the following example for Semigroup</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Semigroup</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">  </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">carrier</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">carrier</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It is neat that dependent type theory allows for the carrier type to be just one more field in the structure, but why not use a direct polymorphism to define it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Semigroup2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Î±</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">Î±</span>\n<span class=\"w\">  </span><span class=\"n\">mul_assoc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Î±</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 500078368,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739766160
    },
    {
        "content": "<p>I think that excerpt from TPIL is just a motivating example for <code>CoeSort</code>. Your Semigroup2  is indeed the \"preferred\" way of doing it in Lean, that's how it's defined <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Group/Defs.html#Semigroup\">in mathlib</a>. </p>\n<p>(your definition of) Semigroup is what's called \"bundled\" and Semigroup2 is \"parameterized\" or \"unbundled\".  The first thing I read that explained why someone might prefer the bundled version was <a href=\"https://jiggerwit.wordpress.com/2018/09/18/a-review-of-the-lean-theorem-prover/\">this blog post</a> by Thom Hales about proof assistants (ane Lean); ctrl+f for the first use of the word \"bundled\" to skip to the relevant part.</p>",
        "id": 500094137,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1739773971
    },
    {
        "content": "<p>Fascinating, thanks for sharing that blog post. I see that there are good arguements pro and con either approach.</p>\n<p>It seems the mathlib's definition is also a type class, instead of structure, which is somewhat surprising to me since a single type like Nat can have multiple semigroups defined. Type classes feels like better solutions for having a single instance attached to a single type.</p>",
        "id": 500102644,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1739777700
    },
    {
        "content": "<p>By multiple semi-groups I assume you mean for + and *, but then rather than thinking about it as 2 separate semi-groups, they are actually related by distributivity, so you would think about it as a ring, and then pull in that more-general type class.</p>",
        "id": 500121700,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1739783040
    },
    {
        "content": "<p>Follow up question: why doesnâ€™t mathlib parametrise by both the Type and the operations? Does it mess up typeclass resolution?</p>",
        "id": 500155235,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1739791005
    },
    {
        "content": "<p>i'd guess it makes variations in spelling of the operation annoying to work with</p>",
        "id": 500221274,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1739806649
    },
    {
        "content": "<p>It means that things like <code>add_zero</code> end up:</p>\n<ul>\n<li>having unhelpful names like <code>op_identity</code></li>\n<li>not being eligible for <code>simp</code> as their key is just <code>_</code></li>\n</ul>",
        "id": 500221991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739806819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/why.20use.20carrier.20types.20instead.20of.20direct.20polymorphism.3F/near/500102644\">said</a>:</p>\n<blockquote>\n<p>It seems the mathlib's definition is also a type class, instead of structure, which is somewhat surprising to me since a single type like Nat can have multiple semigroups defined. Type classes feels like better solutions for having a single instance attached to a single type.</p>\n</blockquote>\n<p>Lean allows users to declare more than once instance of a typeclass for a given type. Also this is from a couple of years ago but I think most of this still holds: Anne Baanen (a user here) wrote a paper about the typeclass/hierarchy building choices made in mathlib: <a href=\"https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2022.4\">https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2022.4</a></p>\n<p>There are a lot of practical considerations that go into choice of representation when the primary goal is actually creating and interacting a large code base.</p>",
        "id": 500253182,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1739816286
    },
    {
        "content": "<p>Also a tl;dr summary of the paper by the author: <a href=\"#narrow/channel/287929-mathlib4/topic/TC.20.60extends.60.20vs.20instance-implicit.20binders/near/338842155\">#mathlib4 &gt; TC &#96;extends&#96; vs instance-implicit binders @ ðŸ’¬</a></p>",
        "id": 500253311,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1739816347
    },
    {
        "content": "<p>Typeclasses are a way to implement synecdoche (the figure of speech where you refer to something by one of its parts).</p>\n<p>In formal math texts, this is the common \"a <em>semigroup</em> is a pair <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>Î¼</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(G,\\mu)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">Î¼</span><span class=\"mclose\">)</span></span></span></span> such that [...], and by abuse of notation we will use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> itself to refer to the semigroup when it does not cause confusion.\" The \"not causing confusion\" is when there is a single canonized semigroup structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>. Classes (with the type as a parameter) let us register what we consider to be the canonical structure via instances.</p>\n<p>Lean doesn't do anything to prevent you from accidentally registering multiple instances. It's a design error when you give multiple instances.</p>\n<p>There are techniques to attach different structures to the same type. For example, given a multiplicative semigroup on <code>X</code>, you can write <code>Additive X</code> for the type with an additive structure that is defined in terms of the multiplicative one. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Additive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"c1\">-- 12</span>\n</code></pre></div>\n<p>This works because typeclasses work on the syntactic form of the type. While <code>Additive Nat = Nat</code>, typeclass synthesis doesn't see that.</p>",
        "id": 500278383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739828550
    },
    {
        "content": "<p>(of course, you're supposed to write <code>(Additive.ofMul 3 + Additive.ofMul 4).toMul</code> instead of that, but that's beside Kyle's point)</p>",
        "id": 500279303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739828999
    },
    {
        "content": "<p>Thanks for keeping it honest <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 500280014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739829311
    }
]