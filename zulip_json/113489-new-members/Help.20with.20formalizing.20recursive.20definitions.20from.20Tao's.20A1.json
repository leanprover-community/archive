[
    {
        "content": "<p>I'm working on formalizing Proposition 2.1.16 (Recursive definitions) from Tao's Analysis I in Lean. The proposition states:</p>\n<p><strong>Proposition 2.1.16 (Recursive definitions).</strong><br>\n<em>Suppose for each natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, we have some function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>:</mo><mi mathvariant=\"bold\">N</mi><mo>→</mo><mi mathvariant=\"bold\">N</mi></mrow><annotation encoding=\"application/x-tex\">f_n: \\mathbf{N} \\rightarrow \\mathbf{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6861em;\"></span><span class=\"mord mathbf\">N</span></span></span></span> from the natural numbers to the natural numbers. Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> be a natural number. Then we can assign a unique natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">a_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to each natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">a_0=c</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">c</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mo>+</mo></mrow></msub><mo>=</mo><msub><mi>f</mi><mi>n</mi></msub><mrow><mo fence=\"true\">(</mo><msub><mi>a</mi><mi>n</mi></msub><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">a_{n++}=f_n\\left(a_n\\right)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6389em;vertical-align:-0.2083em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2583em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mtight\">++</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span></span></span></span> for each natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</em></p>\n<p>I've created a TaoNat class to capture Tao's axioms and proved the existence of recursive sequences:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Logic</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Axiom 2.1: Zero exists</span>\n<span class=\"w\">  </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Axiom 2.2: Successor function</span>\n<span class=\"w\">  </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">N</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Axiom 2.3: Zero is not a successor</span>\n<span class=\"w\">  </span><span class=\"n\">zero_not_succ'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Axiom 2.4: Successor is injective</span>\n<span class=\"w\">  </span><span class=\"n\">succ_injective'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- Axiom 2.5: Induction principle</span>\n<span class=\"w\">  </span><span class=\"n\">induction_principle'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">postfix</span><span class=\"o\">:</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"s2\">\"⁺⁺\"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">succ</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"bp\">⁺⁺</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">induction_principle</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁺⁺</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">‹</span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"bp\">›.</span><span class=\"n\">induction_principle'</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"kn\">alias</span><span class=\"w\"> </span><span class=\"n\">Axiom₅</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">induction_principle</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁺⁺</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">induction_principle</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">zero</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">Succ</span><span class=\"w\"> </span><span class=\"bp\">_⟩</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TaoNat</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Exist_Rec_fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">An</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">An</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">An</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁺⁺</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">An</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">rec_fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exist_Rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The initial value of the value sequence -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">rec_fn_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exist_Rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"sd\">/-- The recursive step for the value sequence -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">rec_fn_succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁺⁺</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exist_Rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n\n<span class=\"sd\">/-- The value sequence is unique -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">rec_fn_unique</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ₀</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⁺⁺</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span><span class=\"bp\">.</span><span class=\"n\">rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Exist_Rec_fn</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">TaoNat</span>\n</code></pre></div>\n<p>Questions:</p>\n<ol>\n<li>\n<p>Does my ´TaoNat class´ faithfully represent Tao's axioms? Are there better ways to capture these axioms in Lean?</p>\n</li>\n<li>\n<p>How can I make this result more practical to use? Currently, I'm using Classical.choose which makes the function noncomputable. Is there a better way to define recursive sequences from an axiomatic approach?</p>\n</li>\n</ol>\n<p>Any input and suggestions would be appreciated.</p>",
        "id": 485177917,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1732927853
    },
    {
        "content": "<p>I was waiting for someone else who knows more to give you a tip, but since no one has yet -- the small amount I know is that some of what you have in <code>TaoNat</code> will butt up against Lean's type theory.</p>\n<p>(PS why did you make <code>TaoNat</code> a typeclass?)</p>",
        "id": 485248375,
        "sender_full_name": "Julian Berman",
        "timestamp": 1732988740
    },
    {
        "content": "<p>By which I mean, I think the two axioms at the end there are \"not needed\" and you can somehow even prove them already -- because when Lean gives you a new inductive type it generates some stuff \"automatically\", one of which is this thing called a recursor which you find in ... <code>.recOn</code> I think.</p>",
        "id": 485248440,
        "sender_full_name": "Julian Berman",
        "timestamp": 1732988778
    },
    {
        "content": "<p>In particular if you look at Lean's own definition of <code>Nat</code> you'll see it doesn't have some of the Peano axioms -- there's a post by Kevin on the Xena project blog which I think explains some of this, I'll try to find it -- but basically when you have an inductive type with separate constructors you already get \"no succ is equal to zero\", that' a property of any inductive type that unique constructors give you new terms.</p>",
        "id": 485248511,
        "sender_full_name": "Julian Berman",
        "timestamp": 1732988839
    },
    {
        "content": "<p>Not sure if you know any of the above, but I think it seems relevant to your question.</p>",
        "id": 485248522,
        "sender_full_name": "Julian Berman",
        "timestamp": 1732988851
    },
    {
        "content": "<p>Maybe the post I am recalling is <a href=\"https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/\">https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/</a></p>",
        "id": 485248806,
        "sender_full_name": "Julian Berman",
        "timestamp": 1732989093
    },
    {
        "content": "<p>Isn't the point here that we're <em>not</em> using the <code>inductive</code> keyword and so we have to put some axioms in? This is how Peano did it originally (although he started at 1). I like Lean's approach (ie the CIC approach) much better. Make recursion an axiom and you can prove all three of the axioms in the definition above.</p>",
        "id": 485253024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732992797
    },
    {
        "content": "<p>The answer to \"can I make it computable\" is almost certainly \"no\" because at some point you have to move from the Prop world into the Type world and this is exactly what choice does for you.</p>",
        "id": 485253112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732992885
    },
    {
        "content": "<p>But my answers to the original questions are: 1. yes I think it does, although of course it doesn't provide you with a model for the axioms (you could make an <code>instance : TaoNat ℕ := sorry</code> to prove that your axioms are consistent, for example). 2. you're never going to get a computable <code>Nat.rec</code> out of this set-up. The best way is to make recursion an axiom. </p>\n<p>Code style comment: we don't use <code>\\lam</code> usually, it's <code>fun</code> in Lean 4.</p>",
        "id": 485253795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732993465
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">induction_principle'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>would be more idiomatic in a functional language (avoid the \\and because you don't need it)</p>",
        "id": 485253913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732993582
    },
    {
        "content": "<p>I don't know how to fill in the <code>sorry</code> because when I realised that it was much much easier to go the other way around I just adopted that approach (although I'm aware there's a proof in Tao's book, I just never read it). In the Natural Number Game I prove <code>zero_not_succ'</code> and <code>succ_injective'</code> using recursion rather than the other way around.</p>",
        "id": 485254195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1732993840
    },
    {
        "content": "<p>Thanks for the detailed responses!</p>\n<p>I get that using <code>inductive</code> would be more practical (and give us computability), but I wanted to stick close to Tao's axiomatic approach. The book presents these as axioms and leaves deriving the recursion principle as an exercise - there's even a challenge version that doesn't use ordering.</p>\n<p>I went with a typeclass because I thought of these axioms as defining what it means to be \"natural numbers\" - kind of like an interface that different implementations (like ℕ) could satisfy. This way, proofs would work with any implementation that meets these requirements. I kept the <code>∧</code> structure in the induction principle to match Tao's presentation, even though it might not be the most Lean-like way to write it.</p>\n<p>I guess this axiomatic approach means giving up computability (because of classical choice), but for what I'm trying to do - following Tao's argument - I'm okay with that trade-off.</p>",
        "id": 485418670,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1732999156
    },
    {
        "content": "<p>I would say that <code>P -&gt; Q -&gt; R</code> reads \"If P, and if Q, then R\", so I would dispute your insistence on <code>∧</code> and you'll find it a mild pain to work with later, but only a mild pain. The point about the inductive def</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat0</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat0</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat0</span>\n</code></pre></div>\n<p>is that it is exactly the inductive definition of the naturals: it says \"zero is a natural, the successor of a natural is a natural, and that's it\" (i.e. definition ends there, i.e. the only way to make naturals is zero and succ, i.e. if you can do something for zero and for succ then you've done it for all naturals, i.e. the principles of induction and recursion). But you seem to understand well what you're doing and how it differs. I think it would be good to try and fill in that sorry, you can check that Tao is right. Within the context of type theory it seems strange to deduce recursion from induction but you seem to be well aware of what you're getting into.</p>",
        "id": 485429514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733009793
    },
    {
        "content": "<p>One thing going for the Lean approach is that you assume just one axiom (recursion) and now it's quite fun to deduce all the others (for example you use recursion to define a function <code>pred</code> with <code>pred 0 = 37</code> and <code>pred (n+1) = n</code>, and then prove <code>pred (succ n) = n</code> (by definition) and deduce that <code>succ</code> is injective from that). Proving recursion from induction will be a much harder challenge, I would imagine. Keep us posted!</p>",
        "id": 485429617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733009898
    },
    {
        "content": "<p>actually it's not exactly one axiom, because you also need the computation rules for the recursor in order to deduce things like <code>zero != succ n</code> from the recursor</p>",
        "id": 485440618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733021269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20formalizing.20recursive.20definitions.20from.20Tao's.20A1/near/485253112\">said</a>:</p>\n<blockquote>\n<p>The answer to \"can I make it noncomputable\" is almost certainly \"no\" because at some point you have to move from the Prop world into the Type world and this is exactly what choice does for you.</p>\n</blockquote>\n<p>If we can compute the natural <code>N -&gt; Nat</code> function then we can do whatever we want with it (<code>Nat -&gt; N</code> is easy). If <code>N</code> doesn't have decidable equality then this function isn't computable, but if it does then it can be computed with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a></p>",
        "id": 485443973,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1733024753
    },
    {
        "content": "<p>I should think that defining TaoNat -&gt; Nat is as hard as constructing the general recursor (it's the universal instance).</p>",
        "id": 485456796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1733038172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/Help.20with.20formalizing.20recursive.20definitions.20from.20Tao's.20A1/near/485429514\">said</a>:</p>\n<blockquote>\n<p>I would say that <code>P -&gt; Q -&gt; R</code> reads \"If P, and if Q, then R\", so I would dispute your insistence on <code>∧</code> and you'll find it a mild pain to work with later, but only a mild pain.</p>\n</blockquote>\n<p>Yeah, <code>P -&gt; Q -&gt; R</code> does seem nicer to apply than  <code>P ∧ Q -&gt; R</code>. That also why derived a version with the ´@[elab_as_elim]´ attribute. I was just afraid that it was somehow dishonest and somehow misrepresentative.</p>\n<p>And luckily, Tao was right. It took a couple of hundreds lines of code to prove the existence of the claimed sequence doing Tao's \"challenge\" version, where we do not rely on any ordering.</p>\n<p>But the more I think about, I am inclined to abandon my  <code>TaoNat</code> class going forward with the book and just define them inductively. I am not sure which approach I find most intuitive. As you explained, it is appealing to basically say - everything there is to say about the naturals can be said in terms of zero and succ. But guess I have not yet totally convinced  myself how the remaining axioms follow from the recursion principle alone. I guess I better finally get around to playing the Natural Numbers Game.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/113489-new-members/topic/Help.20with.20formalizing.20recursive.20definitions.20from.20Tao's.20A1/near/485443973\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Help.20with.20formalizing.20recursive.20definitions.20from.20Tao's.20A1/near/485253112\">said</a>:</p>\n<blockquote>\n<p>The answer to \"can I make it noncomputable\" is almost certainly \"no\" because at some point you have to move from the Prop world into the Type world and this is exactly what choice does for you.</p>\n</blockquote>\n<p>If we can compute the natural <code>N -&gt; Nat</code> function then we can do whatever we want with it (<code>Nat -&gt; N</code> is easy). If <code>N</code> doesn't have decidable equality then this function isn't computable, but if it does then it can be computed with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.find#doc\">docs#Nat.find</a></p>\n</blockquote>\n<p>So <code> TaoNat ℕ := </code>  could be made computable? Or am I misunderstanding something?</p>",
        "id": 485457557,
        "sender_full_name": "Peter Hansen",
        "timestamp": 1733038820
    },
    {
        "content": "<p>There is no interesting computational content in <code>TaoNat ℕ</code> so yes it could be made computable</p>",
        "id": 485498237,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1733073013
    }
]