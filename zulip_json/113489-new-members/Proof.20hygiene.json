[
    {
        "content": "<p>I have a relatively long proof where I find myself using the <code>have</code> tactic and <code>let</code> a lot. As I keep going, I find the environment is getting quite cluttered with definitions that I no longer need. This leads me to two questions:</p>\n<ol>\n<li>Is there a tactic that allows me to remove or hide things from the context in the Lean Infoview?</li>\n<li>Are there \"best practices\" to avoid this problem, or perhaps tactics I'm not aware of?</li>\n</ol>",
        "id": 499881457,
        "sender_full_name": "Jacob Weightman",
        "timestamp": 1739594960
    },
    {
        "content": "<p><a href=\"#narrow/channel/113489-new-members/topic/Proof.20hygiene/near/499881457\">A message</a> was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/RealWorld.20in.20the.20IO.20Monad\">#new members &gt; RealWorld in the IO Monad</a> by <span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span>.</p>",
        "id": 499888315,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739601749
    },
    {
        "content": "<p>If you no longer need them, is it possible that the definitions actually belonged in a previous have/let, and should not have been top-level definitions?</p>",
        "id": 499888353,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1739601804
    },
    {
        "content": "<p>The natural way to manage this is scoping:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bigResult1</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">small1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">small2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n<span class=\"c1\">-- `small1` and `small2` are not in the scope anymore</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bigResult2</span><span class=\"w\"> </span><span class=\"bp\">=</span>\n<span class=\"w\">  </span><span class=\"bp\">...</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 499890007,
        "sender_full_name": "suhr",
        "timestamp": 1739603361
    },
    {
        "content": "<p>You could also use <code>clear</code> to remove hypotheses, i.e. <code>clear small1 small2</code></p>",
        "id": 499890652,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1739603986
    },
    {
        "content": "<p>Sometimes having lots of <code>have</code>s and <code>let</code>s is inevitable, but this is “forward” thinking, where you manipulate and combine assumptions until they look like the goal. Instead, the more idiomatic style in Lean is “backward” thinking, manipulating and splitting the goal until it looks like the assumptions. Both are mathematically equivalent, but the latter results in less clutter. If you find that you must introduce a special term using <code>have</code> or <code>let</code>, you can often abstract it out into a separate lemma which can be invoked within the current proof.</p>\n<p>Perhaps we can help you golf your proof if you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>.</p>",
        "id": 499901181,
        "sender_full_name": "Winston Yin (尹維晨)",
        "timestamp": 1739614087
    },
    {
        "content": "<p>I would disagree that \"backwards\" reasoning is the only idiomatic style in lean.</p>",
        "id": 499913742,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739625669
    },
    {
        "content": "<p>Instead, many <code>have</code>s might indicate that your proof can be split into multiple lemmas</p>",
        "id": 499913769,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1739625699
    },
    {
        "content": "<p>Sometimes when you are performing forward reasoning, the <code>replace</code> and <code>specialize</code> tactics are handy</p>",
        "id": 499914648,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1739626501
    },
    {
        "content": "<p>Perhaps it's not possible, but one thing I'd like is a <code>have bar := some_lemma (clear% foo)</code> which has roughly the same effect as <code>have bar := some_lemma foo; clear foo</code></p>",
        "id": 499916966,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1739628558
    },
    {
        "content": "<p>Awesome. I didn't want to bog down the question with the full context of what I'm working on, but every single one of these answers was helpful in tidying up my proof. Thanks everyone!</p>",
        "id": 499953345,
        "sender_full_name": "Jacob Weightman",
        "timestamp": 1739656304
    }
]