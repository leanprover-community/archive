[
    {
        "content": "<p>Can someone please explain why I'm getting an error here? </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">mod_coprime</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"c1\">-- error : 'Exists.casesOn' can only eliminate into Prop</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 467580722,
        "sender_full_name": "Madison Crim",
        "timestamp": 1725464737
    },
    {
        "content": "<p>Actually, I'm just looking for a converse to #<a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/ModEq.html#Nat.coprime_of_mul_modEq_one\">Nat.coprime_of_mul_modEq_one</a>, namely that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> are coprime then there exists a natural number <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mo>=</mo><mn>1</mn><mspace></mspace><mspace width=\"0.6667em\"/><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a*b=1 \\mod n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:0.6667em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></p>",
        "id": 467584765,
        "sender_full_name": "Madison Crim",
        "timestamp": 1725465337
    },
    {
        "content": "<p>and I'm trying to obtain this <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span></p>",
        "id": 467584962,
        "sender_full_name": "Madison Crim",
        "timestamp": 1725465364
    },
    {
        "content": "<p>For some information about the initial error, search \"large elimination\" on Zulip.</p>",
        "id": 467585511,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725465446
    },
    {
        "content": "<p>Basically, if your goal is in Prop, then you can obtain a witness for your existentials.  This is fine, since you are building a proof.</p>\n<p>However, this is not allowed to construct a term of an actual Type, like <code>Nat</code> in your case above, since it <em>could</em> lead into issues.</p>",
        "id": 467586925,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725465637
    },
    {
        "content": "<p>Nevertheless, if you <em>really</em> want to do it, <code>choose</code> can do it for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Coprime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">mod_coprime</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"c1\">-- all good</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">natAbs</span>\n</code></pre></div>\n<p>and then you see that Lean wants you to make it as <code>noncomputable</code>, since your \"definition\" depends on an arbitrary choice.</p>",
        "id": 467587550,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725465729
    },
    {
        "content": "<p>Of course, this is a very computable thing, so there's no need for choice.</p>\n<p>If you look at the definition of <code>Int.mod_coprime</code> (<a href=\"https://github.com/leanprover-community/mathlib4/blob/ee3c8402eccc71786028ca6017afbabc062c7e33/Mathlib/Data/Int/ModEq.lean#L241-L248\">https://github.com/leanprover-community/mathlib4/blob/ee3c8402eccc71786028ca6017afbabc062c7e33/Mathlib/Data/Int/ModEq.lean#L241-L248</a>) you can see that the witness it is using <code>Nat.gcdA m n</code>.</p>",
        "id": 467588333,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1725465845
    },
    {
        "content": "<p>Oh, yes, I did not intend my answer as \"this is how to do it in this case\", just as \"in a situation where this is your only option, you could proceed as follows\"!</p>",
        "id": 467589371,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1725465991
    }
]