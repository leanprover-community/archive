[
    {
        "content": "<p>I'm trying to understand the connection between the template for simple induction and the recursive definition of natural numbers.</p>\n<p>Here's the template for simple induction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and here is Lean's definition of <code>Nat</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>I think I understand the connection intuitively but if I try to write it down or explain it to someone else - I can't, and that means I don't really understand it.</p>\n<p>I apologise if this question is a bit vague - it is because I can't grasp precisely what I don't understand, other than to say \"I can't explain the connection\".</p>\n<hr>\n<p>Here is my (failed) attempt at explaining the connection:</p>\n<ul>\n<li>\n<p>The definition of <code>Nat</code> defines <code>zero</code>. Proving a proposition <code>P</code> is true for <code>zero,</code>, <code>P(0)</code> is nothing special. </p>\n</li>\n<li>\n<p>The definition of <code>Nat</code> defines the successor of a natural number as an another natural number. It doesn't define it as unique as per Peano axioms, but I assume that is encoded elsewhere. Proving <code>P(n)</code>→ P(n+1)` is not on it's down sufficient to say the proposition holds for all natural numbers. </p>\n</li>\n<li>\n<p>Both together, <code>P(0) ∧ ( P(n)→P(n+1) )</code> is sufficient to say the proposition is true for all natural numbers <code>n</code> but only if we have some way of generating all the natural numbers, that is showing <code>n+1</code> exists if <code>n</code> exists, and that is done by the second part of the definition of <code>Nat</code> -  `| succ (n : Nat) : Nat.</p>\n</li>\n</ul>",
        "id": 491346815,
        "sender_full_name": "rzeta0",
        "timestamp": 1735605058
    },
    {
        "content": "<hr>\n<p>Update - I asked on stackexchange and as expected, the outcome was not fruitful.</p>\n<p><a href=\"https://math.stackexchange.com/questions/5017564/connection-between-induction-proofs-and-recursive-definition-of-natural-numbers\">https://math.stackexchange.com/questions/5017564/connection-between-induction-proofs-and-recursive-definition-of-natural-numbers</a></p>",
        "id": 491347136,
        "sender_full_name": "rzeta0",
        "timestamp": 1735605324
    },
    {
        "content": "<p>When you write <code>inductive</code> like that, Lean effectively axiomatizes:</p>\n<ul>\n<li>The type <code>Nat</code></li>\n<li>The constructors <code>Nat.zero</code> and <code>Nat.succ</code></li>\n<li><em>The recursion principle <code>Nat.rec</code></em></li>\n<li>The reduction rules which characterize this recursion principle</li>\n</ul>\n<p>The <code>induction</code> keyword is just sugar for <code>Nat.rec</code> in your example</p>",
        "id": 491347353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1735605507
    },
    {
        "content": "<p>So is the following not actually the definition of <code>Nat</code> but simply defining extra properties of an already defined <code>Nat</code> ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>I found this by right-clicking and \"Go to definition\".</p>\n<p>(I realise we've moved away from the original question to explain why induction proofs look like the definition of <code>Nat</code>)</p>",
        "id": 491348022,
        "sender_full_name": "rzeta0",
        "timestamp": 1735606055
    },
    {
        "content": "<blockquote>\n<p>I asked on stackexchange and as expected, the outcome was not fruitful.</p>\n</blockquote>\n<p>I'm sorry this was the case. Some users on that site can be intolerant towards questions that they feel are insufficiently rigorous, forgetting that rigor requires understanding in the first place.</p>",
        "id": 491348126,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1735606144
    },
    {
        "content": "<p>That site used to be better 10 years ago, something has changed. Thanks for your comment, I appreciate it.</p>",
        "id": 491348394,
        "sender_full_name": "rzeta0",
        "timestamp": 1735606343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/connection.20b.2Fw.20induction.20proofs.20and.20recursive.20def.20of.20.E2.84.95/near/491348022\">said</a>:</p>\n<blockquote>\n<p>So is the following not actually the definition of <code>Nat</code> but simply defining extra properties of an already defined <code>Nat</code> ?</p>\n</blockquote>\n<p>no, that <em>is</em> where it is defined. What i think eric is talking about is that lean figures out what induction should look like by itself: whenever you define an <code>inductive</code>, lean automatically gives you a <code>.rec</code> function which allows you to do induction.</p>",
        "id": 491348420,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735606374
    },
    {
        "content": "<p>Thanks Edward, that is helpful. Reading about \"inductive types\" is on my to-do list.</p>\n<p>So back to the original question,  I'm trying to understand why an induction proof looks like the definition of <code>Nat</code>.</p>\n<p>I recently learned the word \"constructor\" in the context of the recursive definitions. So I guess my question becomes \"why do we match each constructor\" in an induction proof.</p>",
        "id": 491349068,
        "sender_full_name": "rzeta0",
        "timestamp": 1735606858
    },
    {
        "content": "<p>because constructors denote \"primitive\"/\"atomic\" ways to create a value of an inductive type: these constructors are considered to be injective \"by definition\", and only finite uses of constructors can ever occur. Matching each constructor happens because <em>these are exactly all ways to create a new value of the type</em></p>",
        "id": 491349396,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1735607158
    },
    {
        "content": "<p>This is more than mathematical induciton, it is <a href=\"https://en.wikipedia.org/wiki/Structural_induction\">structural induction</a>.</p>\n<p>Every object of some inductive type is constructed by just one of its constructor, hence you can prove proposition about it by checking all its constructor.</p>\n<p>Every natural number in Lean is generated by the rules <code>Nat.zero</code> and <code>Nat.succ</code> freely.</p>",
        "id": 491349477,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735607207
    },
    {
        "content": "<p>Just like there's an xkcd for many topics, so there is a Xena blog post: <a href=\"https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/\">https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/</a></p>",
        "id": 491349506,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1735607229
    },
    {
        "content": "<p>Thanks Edward, Yakov and Zhang- I will think about your reply, xenaproject blog (which looks like it might do the trick) and the wikipedia page over the next day or so.</p>\n<p>All this is outside my comfort zone so thanks for your patience.</p>",
        "id": 491349547,
        "sender_full_name": "rzeta0",
        "timestamp": 1735607273
    },
    {
        "content": "<p>So I read the blog and the wiki article and I think they are just beyond my level of expertise.</p>\n<p>However I did manage to understand what I think is the key point, also made by Edward above, that the constructors for <code>Nat</code> are all the ways to generate any and all natural numbers, and therefore an induction proof which proves a proposition is true for all these constructors must therefore be true for all natural numbers.</p>\n<p>Thanks again for trying to help.</p>",
        "id": 491441989,
        "sender_full_name": "rzeta0",
        "timestamp": 1735679079
    }
]