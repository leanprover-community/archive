[
    {
        "content": "<p>For example: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/Card.html#Fintype.truncEquivFinOfCardEq\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Fintype/Card.html#Fintype.truncEquivFinOfCardEq</a><br>\nI don't understand the discussion about \"computable\" at all.</p>",
        "id": 495384830,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737584761
    },
    {
        "content": "<p><code>Trunc X</code> is the quotient of <code>X</code> by the relation <code>fun x y =&gt; True</code>. That is, every pair of elements becomes equal in the quotient.</p>\n<p>It's a type-valued version of <code>Nonempty X</code>.</p>",
        "id": 495386334,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1737585487
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a> is defined as a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a> which does not miss any elements.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a> is defined as a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset#doc\">docs#Multiset</a> which has no duplicates.<br>\n<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Multiset#doc\">docs#Multiset</a> is defined as the quotient of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List#doc\">docs#List</a> by <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.Perm#doc\">docs#List.Perm</a>.<br>\nSo when you have a <code>Fintype α</code> argument in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.truncEquivFinOfCardEq#doc\">docs#Fintype.truncEquivFinOfCardEq</a>, to the compiler this is really just a list with some wrappers. Since you have a list of all the elements of your type, you can match up element-by-element the lists <code>[a0, a1, a2, ...]</code> with <code>[0, 1, 2, ...]</code>, so <code>a0</code> gets mapped to <code>0</code>, <code>a1</code> gets mapped to <code>1</code>, etc.<br>\nBut we have a problem! Since <code>Fintype</code> is a quotient, we need to make sure that equal <code>Fintype</code> instances get mapped to equal <code>Equiv</code>s. This is not the case right now, so the <code>α ≃ Fin n</code> gets wrapped in a <code>Trunc</code>, which the quotient by the always-true relation. That way, <code>Quot.sound</code> will say that any two elements of <code>Trunc (α ≃ Fin n)</code> are equal.</p>",
        "id": 495386707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737585699
    },
    {
        "content": "<p>Thanks for the explanation.  But a Fintype is a type.  What does it mean for two Fintype instances to be \"equal\"?  Also, everything is finite here, what does the\"computable\" vs \"noncomputable\" distinction buy us?</p>",
        "id": 495388570,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737586666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/What.20is.20Trunc.3F/near/495388570\">said</a>:</p>\n<blockquote>\n<p>But a Fintype is a type.  What does it mean for two Fintype instances to be \"equal\"?</p>\n</blockquote>\n<p>Exactly the same as it means for two <code>LE</code> instances to be equal, or two <code>DecidableEq</code> instances, or two <code>Add</code> instances. Equality works the same for all types.</p>",
        "id": 495388962,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737586857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/What.20is.20Trunc.3F/near/495388570\">said</a>:</p>\n<blockquote>\n<p>Also, everything is finite here, what does the \"computable\" vs \"noncomputable\" distinction buy us?</p>\n</blockquote>\n<p>What do you mean by this? \"computable\" means that I can <code>#eval</code> my code, which is better than not being able to <code>#eval</code> my code, all other things being equal.</p>",
        "id": 495389604,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737587167
    },
    {
        "content": "<p>How about leaving out the <code>Trunc</code>(namely, conflate Fintype.truncEquivFinOfCardEq and Fintype.equivFinOfCardEq) but having #eval do what it does now as if there is a <code>Trunc</code>?</p>",
        "id": 495413765,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1737600965
    },
    {
        "content": "<p>That would be <code>unsafe</code>, and allow you to prove <code>False</code>. Basically, this is the distinction between <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.out#doc\">docs#Quot.out</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Quot.unquot#doc\">docs#Quot.unquot</a>.</p>",
        "id": 495414142,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737601232
    },
    {
        "content": "<p>Yeah, since <code>Trunc</code> introduces the idea that any two values are equal, bypassing it will mean that other code assumes that <code>x = y</code> but your code has <code>x ≠ y</code>.</p>",
        "id": 495479872,
        "sender_full_name": "Chris Wong",
        "timestamp": 1737631441
    }
]