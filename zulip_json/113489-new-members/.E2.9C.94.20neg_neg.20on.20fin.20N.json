[
    {
        "content": "<p>Hello everyone,</p>\n<p>If I understand correctly in finite field arithmetic I can take the negative of a number twice and arrive at the same number back. Say we have fin 7. Then -3 is \"congruent / the same as\" as 4. Then minus 4 is the same as 3. However the neg_neg lemma in mathlib does not seem to like this. Although lean can evaluate -(-x) of a finite type,  the neg_neg fails with the error message below the code snippet.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">neg_neg_rev</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">):</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">neg_neg</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span><span class=\"n\">x</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">y</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">-</span><span class=\"n\">y</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize type class instance for\nN : ℕ,\nx : fin N\n⊢ has_involutive_neg (fin N)\nstate:\nN : ℕ,\nx : fin N\n⊢ - -x = x\n</code></pre></div>\n<p>Thanks for the help.</p>",
        "id": 356560621,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683502697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> Can you please include a full <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> for this kind of questin, including the imports you have tried it with?   My guess is that you have not imported the file in which this type class instance is declared.</p>",
        "id": 356561005,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683503054
    },
    {
        "content": "<p>Anyway, you can try importing data.fin.basic at the start of the file and see if that works.</p>",
        "id": 356561033,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683503098
    },
    {
        "content": "<p>The import was there sorry for not copying that. I also attached a file if that makes it easire<br>\n<a href=\"/user_uploads/3121/z2nNlkFD7Qxq3iavniEnsRil/mwe_finN.lean\">mwe_finN.lean</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_neg_rev</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">):</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">neg_neg</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"c1\">-- Error here</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span><span class=\"n\">x</span>\n<span class=\"k\">#eval</span> <span class=\"n\">y</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">-</span><span class=\"n\">y</span>\n<span class=\"k\">#eval</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 356561467,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683503531
    },
    {
        "content": "<p>Just a note, if I replace N with an actual number the error disappears.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fin.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_neg_rev</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">):</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">neg_neg</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"c1\">--Does Not work</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">neg_neg_7</span> <span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span><span class=\"o\">):</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">neg_neg</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"c1\">--This one works!!</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 356563383,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683505078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> Aha, I see: the issue is that the instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.add_comm_group\">docs#fin.add_comm_group</a> requires <code>ne_zero n</code>.  This actually doesn't seem necessary, but there were some refactors lately that may have introduced this typeclass unnecessarily on some <code>fin</code> instances.</p>",
        "id": 356568892,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683507900
    },
    {
        "content": "<p>If you're willing to assume your <code>N</code> is nonzero, you can just write <code>[ne_zero N]</code> and everything should work.</p>",
        "id": 356568975,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683507961
    },
    {
        "content": "<p>I am very willing to do that. Thanks a lot! </p>\n<p>Just a further question along the same topic.</p>\n<p>I was trying to work around the <code>neg_neg</code> issue by doing:<br>\n<code>apply_fun (* -1)</code>. This gives the error </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize type class instance for\nn : ℕ,\nx : fin n\n⊢ has_one (fin n)\nstate:\nn : ℕ,\nx : fin n\n⊢ - -x = x\n</code></pre></div>\n<p>Using the command  <code>#print instances has_one</code>. SHows that the two instances of has_one related to fin n are:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>fin.has_one_of_ne_zero : Π {n : ℕ} [_inst_1 : ne_zero n], has_one (fin n)\nfin.has_one : Π {n : ℕ}, has_one (fin n.succ)\n</code></pre></div>\n<p>The first is not \"working\" because it requires <code>ne_zero</code> for the same reason <code>add_comm_group</code> wants <code>ne_zero</code>? Did I understand correctly?</p>\n<p>But why is the second not working? It seems to take, say <code>n = 3</code> and <code>give has_one(fin 4)</code> which seems wierd to me?</p>",
        "id": 356569939,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683508459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> I think if you made your <code>x</code> to be of type <code>fin n.succ</code> rather than <code>fin n</code> then the second <code>has_one</code> instance would be available.</p>",
        "id": 356581186,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683515213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356568892\">said</a>:</p>\n<blockquote>\n<p>This actually doesn't seem necessary, but there were some refactors lately that may have introduced this typeclass unnecessarily on some <code>fin</code> instances.</p>\n</blockquote>\n<p>It is necessary, for <code>0 : fin N</code></p>",
        "id": 356590355,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683520724
    },
    {
        "content": "<p>However, we could add the missing <code>has_distrib_neg</code> instance without it</p>",
        "id": 356590439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683520775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"497480\">@MohanadAhmed</span> just to point out that whilst <code>fin n</code> has slowly but surely been picking up structures which sometimes but not always hold (eg fin 0 isn't a ring), there is also <code>zmod n</code> which is always a ring and is what the algebraists use to do finite field theory. So if it's all the same to you, you could switch to <code>zmod 7</code> and see if it makes things better or worse. In my opinion people shouldn't be doing arithmetic with <code>fin n</code> as this is not what it was designed to do</p>",
        "id": 356620875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683532295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356568892\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"497480\">MohanadAhmed</span> Aha, I see: the issue is that the instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.add_comm_group\">docs#fin.add_comm_group</a> requires <code>ne_zero n</code>.  This actually doesn't seem necessary, but there were some refactors lately that may have introduced this typeclass unnecessarily on some <code>fin</code> instances.</p>\n</blockquote>\n<p>we do need it to define the zero, but we could definitely have <code>add_comm_semigroup</code> + <code>has_distrib_neg</code> on all <code>fin</code>; not that it super matters but it could make some things a little easier</p>",
        "id": 356683164,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1683547751
    },
    {
        "content": "<p>Switching to the type which already has the ring structure would also make things a little easier, I would imagine :-) I've always been quite anti putting a whole bunch of extra structure on <code>fin</code> -- my gut instinct was that if you want a set with n elements, use fin, and if you want the ring, use <code>zmod</code>.</p>",
        "id": 356725360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683555671
    },
    {
        "content": "<p>I've added the missing instances in <a href=\"https://github.com/leanprover-community/mathlib/pull/18970\">#18970</a></p>",
        "id": 356785459,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683570366
    },
    {
        "content": "<p>Arguably the way to decide between <code>zmod</code> and <code>fin</code> is to decide whether you want <code>zmod 0</code> or <code>fin 0</code>.</p>",
        "id": 356785552,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683570395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356620875\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"497480\">MohanadAhmed</span> just to point out that whilst <code>fin n</code> has slowly but surely been picking up structures which sometimes but not always hold (eg fin 0 isn't a ring), there is also <code>zmod n</code> which is always a ring and is what the algebraists use to do finite field theory. So if it's all the same to you, you could switch to <code>zmod 7</code> and see if it makes things better or worse. In my opinion people shouldn't be doing arithmetic with <code>fin n</code> as this is not what it was designed to do</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356785552\">said</a>:</p>\n<blockquote>\n<p>Arguably the way to decide between <code>zmod</code> and <code>fin</code> is to decide whether you want <code>zmod 0</code> or <code>fin 0</code>.</p>\n</blockquote>\n<p>I am working on linear algebra lemmas with matrices and these seems to be usually done in <code>fin N</code> rather than <code>zmod N</code>. What do you think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> ? In that context I believe <code>zmod 0</code> or <code>fin 0</code> are both not relevant. Right?  I mean we are interested in matrices containing some elements? right?</p>",
        "id": 356851654,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683599891
    },
    {
        "content": "<p>Are you talking about the elements of the matrices? (As opposed to the row/column indexes)</p>",
        "id": 356870504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683610843
    },
    {
        "content": "<p>I assume so, since your first message mentions \"finite field\". If you want a finite field then you should definitely use <code>zmod</code>, not <code>fin</code>.</p>",
        "id": 356870866,
        "sender_full_name": "Reid Barton",
        "timestamp": 1683610972
    },
    {
        "content": "<p><code>zmod</code> was designed to do what you want to do, <code>fin</code> was not, but for some reason people occasionally try to make <code>fin</code> slightly more like <code>zmod</code></p>",
        "id": 356893127,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683617599
    },
    {
        "content": "<blockquote>\n<p>Right? I mean we are interested in matrices containing some elements? right?</p>\n</blockquote>\n<p>Sure, but usually results about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n \\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices generalize to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> matrices</p>",
        "id": 356899557,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683619337
    },
    {
        "content": "<p>Note that <code>matrix (zmod 0) (zmod 0) R</code> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi><mo>×</mo><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty \\times \\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">∞</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span> matrix</p>",
        "id": 356899680,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683619373
    },
    {
        "content": "<p>So <code>matrix (fin 3) (fin 3) (zmod 7)</code> is sensible, and pretty much any permutation of that is not (although depending on how much tinkering has been done by the fintinkerers, it might actually be nowadays just about possible to make them work)</p>",
        "id": 356901784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683619900
    },
    {
        "content": "<p>Yes; as in Kevin's example, generally <code>fin n</code> is a good choice for the index type, but <code>zmod n</code> is probably what you want for the entries</p>",
        "id": 356903124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683620284
    },
    {
        "content": "<p><code>zmod n</code> can also make sense as an indexing type if you're doing some Vandermonde stuff, but at this point it's easier to just use an arbitrary finite type along with a cycle on it.</p>",
        "id": 356903359,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683620332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356870504\">said</a>:</p>\n<blockquote>\n<p>Are you talking about the elements of the matrices? (As opposed to the row/column indexes)</p>\n</blockquote>\n<p>I was talking about the indices of the matrices. But I can see that was not clear from my initial message.<br>\nIf I understand correctly, the set <code>fin N</code> are natural numbers less than N, hence fin 0 is just the empty set. Thus a matrix indexed by fin 0 is just an empty matrix.</p>",
        "id": 356932906,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683627299
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356899557\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Right? I mean we are interested in matrices containing some elements? right?</p>\n</blockquote>\n<p>Sure, but usually results about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n \\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices generalize to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> matrices</p>\n</blockquote>\n<p>What useful statements can we say about matrices with dimensions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> ? <br>\nOr you mean if a useful statement about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n \\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrix carries over to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>×</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\times 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, then the zero case does not have to be carved out as special case? And cause problems like the one I stepped into?</p>",
        "id": 356934484,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683627700
    },
    {
        "content": "<p>I'm curious, why would you need to negate indices into a matrix, let alone twice?</p>",
        "id": 356935389,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1683627912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356903359\">said</a>:</p>\n<blockquote>\n<p><code>zmod n</code> can also make sense as an indexing type if you're doing some Vandermonde stuff, but at this point it's easier to just use an arbitrary finite type along with a cycle on it.</p>\n</blockquote>\n<p>How would one do that? i.e. put a cycle on arbitrary finite type? </p>\n<p>In mathlib I see the vandermonde stuff <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_algebra.vandermonde\">docs#linear_algebra.vandermonde</a> is done using <code>fin N</code> e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">vandermonde</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"n\">i</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Do you think it would be easier to do using zmod? <br>\nI am working with DFT matrices, which I guess are in the same boat as vandermonde matrices.</p>",
        "id": 356936656,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683628296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356935389\">said</a>:</p>\n<blockquote>\n<p>I'm curious, why would you need to negate indices into a matrix, let alone twice?</p>\n</blockquote>\n<p>The DFT matrix is define using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo>±</mo><mn>2</mn><mi>π</mi><mi>i</mi><mi>k</mi><mi>n</mi><mi mathvariant=\"normal\">/</mi><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> exp(\\pm 2 \\pi i kn/N) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mord\">±</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">πikn</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span> where k and n are the row and column indices of the matrix.</p>",
        "id": 356936939,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683628397
    },
    {
        "content": "<p>I recommend defining it via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fourier\">docs#fourier</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_circle.to_circle\">docs#add_circle.to_circle</a></p>",
        "id": 356937202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683628486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356937202\">said</a>:</p>\n<blockquote>\n<p>I recommend defining it via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fourier\">docs#fourier</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_circle.to_circle\">docs#add_circle.to_circle</a></p>\n</blockquote>\n<p>You mean use the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fourier\">docs#fourier</a> to define the DFT matrix entries. What about the indices are they still <code>fin N</code> or some other type?</p>",
        "id": 356968241,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683635667
    },
    {
        "content": "<p>I think that it would be very mathematically elegant to do this kind of thing using a matrix indexed by <code>zmod</code>.</p>",
        "id": 356997147,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1683641366
    },
    {
        "content": "<p>Do we have the equivalence between <code>zmod n</code> and <code>add_circle n</code>?</p>",
        "id": 357002173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1683642328
    },
    {
        "content": "<p>Isn't <code>add_circle n</code> uncountable? It's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}/n\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span> not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/n\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>",
        "id": 357003080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683642506
    },
    {
        "content": "<p>No, <code>add_circle n</code> <em>is</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z/n\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span>. It's <code>add_circle (n : real)</code> that's <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mi mathvariant=\"normal\">/</mi><mi>n</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\R/n\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathbb\">Z</span></span></span></span>.</p>",
        "id": 357004760,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683642842
    },
    {
        "content": "<p>Apparently if <code>n : nat</code> then <code>add_circle n</code> doesn't even typecheck :P</p>",
        "id": 357005545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683642984
    },
    {
        "content": "<p>Yeah but <code>add_circle (n : int)</code> will</p>",
        "id": 357009457,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683643790
    },
    {
        "content": "<p>As will <code>add_circle (n : real)</code></p>",
        "id": 357010545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1683644053
    },
    {
        "content": "<p>Yeah so <code>zmod n</code> is isomorphic to <code>add_circle (n : int)</code> (and Reid argued before that it's how it should be defined)</p>",
        "id": 357010765,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1683644110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/neg_neg.20on.20fin.20N/near/356935389\">said</a>:</p>\n<blockquote>\n<p>I'm curious, why would you need to negate indices into a matrix, let alone twice?</p>\n</blockquote>\n<p>A more complete answer to your question:</p>\n<p>I was working on proving the following: <br>\nA circulant matrix  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> C( \\mathbf{t} ) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathbf\">t</span><span class=\"mclose\">)</span></span></span></span> whose first row is given by vector <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">t</mi></mrow><annotation encoding=\"application/x-tex\"> \\mathbf{t} </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6349em;\"></span><span class=\"mord mathbf\">t</span></span></span></span>, can be represented as :</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">t</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mi>W</mi><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mtext>Diag</mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"bold\">t</mi><mo stretchy=\"false\">)</mo><msub><mi>W</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\"> C(\\mathbf{t}) = W_n ^{-1} \\text{Diag} (\\mathbf{t}) W_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mopen\">(</span><span class=\"mord mathbf\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.453em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mord text\"><span class=\"mord\">Diag</span></span><span class=\"mopen\">(</span><span class=\"mord mathbf\">t</span><span class=\"mclose\">)</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br>\nwhere the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\"> W_n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are the DFT matrices of dimenion <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\"> n \\times n </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>.</p>\n<p>In this proof <a href=\"https://github.com/MohanadAhmed/lean-matrix-cookbook/blob/bc31147694d91e4e61fbcb0df64999e71e5d2aea/src/matrix_cookbook/9_special_matrices.lean#LL654C49-L654C49\"><code> matrix.circulant t = (Wₙ⁻¹) ⬝ (diagonal(dft t)) ⬝ Wₙ </code></a><br>\nwe get to a step (Line 654) where we need to show that the following sums are the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">Wₙ</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">Wₙ</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I use the lemma <code>equiv.sum_comp</code> which requires an equivalence to shift the sum. This is <code>shiftk_equiv</code> in the code.<br>\nThe resulting sum now looks like (after some dsimp steps)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">Wₙ</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span><span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">Wₙ</span> <span class=\"n\">j</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>The double negatives can now be cleared with <code>simp only [neg_neg, add_sub_cancel]</code> after placing <code>{hN: ne_zero N}</code> instead of  <code>hN: N ≠ 0</code> that was not getting picked up.</p>\n<p>Thanks everyone!</p>",
        "id": 358036653,
        "sender_full_name": "MohanadAhmed",
        "timestamp": 1683954713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"497480\">MohanadAhmed</span> has marked this topic as resolved.</p>",
        "id": 358036778,
        "sender_full_name": "Notification Bot",
        "timestamp": 1683954796
    }
]