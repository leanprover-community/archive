[
    {
        "content": "<p>Good day,<br>\nI'm trying to prove equivalence between type arguments and constructor used for my type family <code>Path</code>. It has two numeric arguments <code>x</code>, <code>y</code>, and if <code>x &lt; y</code>, then you can only construct a <code>point</code>; likewise, if <code>x &lt; y</code>, then you can only construct a <code>cons</code>. I'm trying to express that constraint through HEq.<br>\nHere's my unfinished program:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DAG</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">adj</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">DAG</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DAG</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- DAG.adj plus x &lt; y</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DAG</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Adj</span><span class=\"bp\">.</span><span class=\"n\">to_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rel</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DAG</span><span class=\"bp\">.</span><span class=\"n\">Adj</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">rel</span>\n<span class=\"w\">  </span><span class=\"n\">assumption</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Path</span>\n<span class=\"w\">  </span><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"w\">  </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">point_is_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">point</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)):</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `h` is HEq (cons ? ? ?) (point)</span>\n</code></pre></div>\n<p>If I could name second argument to <code>cons</code> subexpression in <code>h</code>, then I would be able to use <code>Adj.to_lt</code> and arrive at a contradiction. But I don't know how to do that.</p>",
        "id": 478975584,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1729883884
    },
    {
        "content": "<p>I think this is not provable, unfortunately.</p>",
        "id": 478977132,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729884661
    },
    {
        "content": "<p>The proof for non-provability is that if <code>G</code> is the path DAG (where only <code>G.Adj n (n + 1)</code> for each <code>n &lt; N</code>), then <code>Path G x y</code> has cardinality 1 iff <code>x &lt;= y</code>. This means that each such <code>Path G x y</code> type could in principle be equal to each other (according to the cardinality model of Lean in Mario's thesis), so you can't conclude anything about <code>x</code> and <code>y</code>.</p>",
        "id": 478977446,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729884824
    },
    {
        "content": "<p>Incidentally, trying to work with paths in graphs is how I learned about this issue.</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Walk.copy#doc\">docs#SimpleGraph.Walk.copy</a> is a way to work around the issue. You have to keep track of index equalities somehow.</p>",
        "id": 478977615,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729884916
    },
    {
        "content": "<p>Interesting! A very categorical way of thinking about it, but alas. I suppose I should go back to strict path construction, then, if I want to be able to distinguish these cases.<br>\nRelatedly, why does <code>conv</code> only allow me to extract the <code>G.Path z y</code> part from the <code>cons</code> constructor?</p>",
        "id": 478977633,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1729884933
    },
    {
        "content": "<p>Your link is the reverse direction, that's pretty easy to prove :)</p>",
        "id": 478977760,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1729884990
    },
    {
        "content": "<p>That's not a theorem, it's a definition</p>",
        "id": 478977798,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729885009
    },
    {
        "content": "<p>The idea is to avoid HEq entirely for paths, and instead only consider equalities, making use of this copy function to \"cast\" the paths</p>",
        "id": 478977855,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729885045
    },
    {
        "content": "<p>re <code>conv</code>: I'm not sure exactly, but this means that somehow the congruence lemma it's generating is deficient. I don't see why it would be, since you can in principle rewrite the Adj and Path arguments independently just fine... Constraints arise when there's dependence — that's why <code>z</code> can't be rewritten for example.</p>",
        "id": 478978028,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729885129
    },
    {
        "content": "<p>HEq is rightly confusing me:</p>\n<blockquote>\n<p>You should avoid using this type if you can. Heterogeneous equality does not have all the same properties as <code>Eq</code>, because the assumption that the types of <code>a</code> and <code>b</code> are equal is often too weak to prove theorems of interest. One important non-theorem is the analogue of <code>congr</code>: If <code>HEq f g</code> and <code>HEq x y</code> and <code>f x</code> and <code>g y</code> are well typed it does not follow that <code>HEq (f x) (g y)</code>. (This does follow if you have <code>f = g</code> instead.) However if <code>a</code> and <code>b</code> have the same type then <code>a = b</code> and <code>HEq a b</code> are equivalent.</p>\n</blockquote>\n<p>but then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">congr_heq</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">γ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u_3</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">γ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>What gives?</p>",
        "id": 479011508,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1729908219
    },
    {
        "content": "<p>this is provable, the version that is not provable is when f and g have different codomains <code>γ</code>, <code>γ'</code> (and you don't otherwise have an equality of these types in scope)</p>",
        "id": 479012770,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729909514
    }
]