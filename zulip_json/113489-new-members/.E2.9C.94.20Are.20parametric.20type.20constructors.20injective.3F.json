[
    {
        "content": "<p>For example, for <code>p q : Nat -&gt; Prop</code>, is it true that <code>Subtype p = Subtype q</code> implies <code>p = q</code>?<br>\nIs there any special case where a similar statement can be proved?</p>",
        "id": 477726790,
        "sender_full_name": "Eduardo Venturini",
        "timestamp": 1729281799
    },
    {
        "content": "<p>I think you can only get an equivalence via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.subtypeEquivProp#doc\">docs#Equiv.subtypeEquivProp</a></p>",
        "id": 477727797,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1729282292
    },
    {
        "content": "<p>No, this kind of statement is unprovable in general.</p>",
        "id": 477727829,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1729282315
    },
    {
        "content": "<p>i think that's independent of lean's type system. from what i understand, there is a model of lean where bijections between types implies the types are equal (typically called the cardinality model), and in this model the statement you're looking for doesn't hold...</p>",
        "id": 477727832,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729282316
    },
    {
        "content": "<p>for example, <code>p:= (. = 0)</code> and <code>q:= (. = 1)</code> would provide equal subtypes.</p>",
        "id": 477727983,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729282385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/113489-new-members/topic/Are.20parametric.20type.20constructors.20injective.3F/near/477727797\">said</a>:</p>\n<blockquote>\n<p>I think you can only get an equivalence via <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.subtypeEquivProp#doc\">docs#Equiv.subtypeEquivProp</a></p>\n</blockquote>\n<p>I'm interested in the opposite implication</p>",
        "id": 477728195,
        "sender_full_name": "Eduardo Venturini",
        "timestamp": 1729282469
    },
    {
        "content": "<p>like i said, the opposite implication is not provable in lean.</p>",
        "id": 477728664,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729282673
    },
    {
        "content": "<p>Thanks. Do you know if there are any reasons why injectivity proofs should not be automatically generated, as is done for a structure constructor?</p>",
        "id": 477728736,
        "sender_full_name": "Eduardo Venturini",
        "timestamp": 1729282692
    },
    {
        "content": "<p>This is unprovable, so it can't generate such injectivity proofs.</p>",
        "id": 477728866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729282769
    },
    {
        "content": "<p>There are also some examples where type constructors are not injective, provably.</p>",
        "id": 477728911,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729282787
    },
    {
        "content": "<p>Here's an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsntInj</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">Injective</span><span class=\"w\"> </span><span class=\"n\">IsntInj</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Function</span><span class=\"bp\">.</span><span class=\"n\">cantor_injective</span><span class=\"w\"> </span><span class=\"n\">IsntInj</span>\n</code></pre></div>",
        "id": 477729049,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729282839
    },
    {
        "content": "<p>With <code>Subtype</code>, in that cardinality model, if <code>{x | p x}</code> and <code>{x | q x}</code> have the same cardinality, then it would be the case that <code>Subtype p = Subtype q</code>. Edward already gave an example of a pair where the cardinality of each is 1. This shows that <code>p = q</code> is not provable.</p>",
        "id": 477729310,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729282968
    },
    {
        "content": "<p>Thank you so much, this clears up all  my doubts!</p>",
        "id": 477729413,
        "sender_full_name": "Eduardo Venturini",
        "timestamp": 1729283022
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672428\">Eduardo Venturini</span> has marked this topic as resolved.</p>",
        "id": 477731286,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729283821
    }
]