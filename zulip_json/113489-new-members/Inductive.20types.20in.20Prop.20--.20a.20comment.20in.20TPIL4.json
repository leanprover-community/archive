[
    {
        "content": "<p>In Ch. 7 of TPIL4, the following example is given:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Hid</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Hid</span>\n</code></pre></div>\n<p>There is the following comment after this example:  \"Roughly speaking, what characterizes inductive types in <code>Prop</code> is that one can only eliminate to other types in <code>Prop</code>.\"</p>\n<p>However, when I checked types of  the recursors, only the one for <code>Or</code> has motive that maps to <code>Prop</code>; everything else maps to <code>sort u</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Hid</span><span class=\"bp\">.</span><span class=\"n\">False</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"c1\">-- Hid.False.rec.{u} (motive : False → Sort u) (t : False) : motive t</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Hid</span><span class=\"bp\">.</span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"c1\">-- Hid.True.rec.{u} {motive : True → Sort u} (intro : motive True.intro) (t : True) : motive t</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Hid</span><span class=\"bp\">.</span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"c1\">-- Hid.And.rec.{u} {a b : Prop} {motive : And a b → Sort u} (intro : (a_1 : a) → (a_2 : b) → motive ⋯) (t : And a b) : motive t</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Hid</span><span class=\"bp\">.</span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"c1\">-- Hid.Or.rec {a b : Prop} {motive : Or a b → Prop} (inl : ∀ (a_1 : a), motive ⋯) (inr : ∀ (a_1 : b), motive ⋯) (t : Or a b) : motive t</span>\n</code></pre></div>\n<p>How does one reconcile these observations with the comment?</p>\n<p>Also, what is <code>⋯</code> in <code>motive ⋯</code>?</p>\n<p>Help greatly appreciated.</p>",
        "id": 450473113,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720622678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397075\">Kevin Cheung</span> <a href=\"#narrow/stream/113489-new-members/topic/Inductive.20types.20in.20Prop.20--.20a.20comment.20in.20TPIL4/near/450473113\">said</a>:</p>\n<blockquote>\n<p>Also, what is <code>⋯</code> in <code>motive ⋯</code>?</p>\n</blockquote>\n<p>This is an elision of proof terms, use <code>set_option pp.proofs true</code> to see them.</p>",
        "id": 450474613,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720622957
    },
    {
        "content": "<p>There is an exception to the rule that Prop can only eliminate into Prop for Props with no computational value. The rule, according to “The Type Theory of Lean”  is</p>\n<blockquote>\n<ol start=\"2\">\n<li>The type family has at most one constructor, and all the non-recursive arguments to the constructor are either propositions or directly appear in the output type. This is called subsingleton (SS) elimination, and is relevant for the definition of equality as a large eliminating proposition.</li>\n</ol>\n</blockquote>",
        "id": 450475075,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1720623045
    },
    {
        "content": "<p>Thanks. I'm wondering if TPIL should add a footnote about this?</p>\n<p>BTW, is \"large eliminating proposition\" a technical term? I can't quite make sense of it.</p>",
        "id": 450476232,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720623300
    },
    {
        "content": "<p>Large elimination means exactly what you observed, eliminating into a higher universe than the type lives in</p>",
        "id": 450481767,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1720624529
    },
    {
        "content": "<p>I see. I guess I need to spend some time reading <em>The type theory of Lean</em>.</p>",
        "id": 450485253,
        "sender_full_name": "Kevin Cheung",
        "timestamp": 1720625083
    }
]