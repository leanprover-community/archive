[
    {
        "content": "<p>Why are variables used only in the proof automatically included in defs but not in theorems?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- this gives an error, unknown identifier 'n'</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"c1\">-- this works fine</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 532402609,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754099053
    },
    {
        "content": "<p>The rule is that <code>theorem</code> includes variables based on what's mentioned in the theorem statement itself, but <code>def</code> includes variables based on the entire definition.</p>",
        "id": 532402691,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099114
    },
    {
        "content": "<p>thanks!  i was a bit surprised that its handled differently but i assume thats by design then :)</p>",
        "id": 532402741,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754099158
    },
    {
        "content": "<p>You can use the <code>include n</code> command to force the variable to be included in theorems</p>",
        "id": 532402749,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099165
    },
    {
        "content": "<p>There are two practical reasons for this:</p>\n<ol>\n<li>Many tactics operate on the whole local context, and it can create artificial dependencies.</li>\n<li>This allows the proofs to be elaborated asynchronously.</li>\n</ol>",
        "id": 532402797,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099210
    },
    {
        "content": "<p>Even basic tactics like <code>induction</code>/<code>cases</code> can cause variables to become included unnecessarily.</p>",
        "id": 532402847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099246
    },
    {
        "content": "<p>Example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ex</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">ex</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">ex (n : Nat) (m : Fin n) : 0 ≤ n</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 532402918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099304
    },
    {
        "content": "<p>ah interesting, so the tactic can see <code>m</code> and could potentially use it, so its not auto discarded</p>",
        "id": 532403103,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754099458
    },
    {
        "content": "<p>and be sure to look at the local context to see why <code>m</code> is used here</p>\n<p>Try changing it to <code>(m : Fin 2)</code>. You should observe that it's <em>not</em> included.</p>",
        "id": 532403250,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099594
    },
    {
        "content": "<p>ugh this is cursed, i dont fully understand, seems like the second placeholder assumes something with m, but only if m is available</p>",
        "id": 532403585,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754099864
    },
    {
        "content": "<p>In the first example, take a look how <code>m</code> changes, right before each <code>simp</code>.</p>\n<p>Then, change it to <code>(m : Fin 2)</code>, and look at the local contexts again.</p>\n<p>What's the difference?</p>",
        "id": 532403690,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754099962
    },
    {
        "content": "<p>seems like induction works by simple induction P(n) =&gt; P(n + 1) if no fin n is available but if fin n is available it takes the more general form of (all x in fin n : P(n)) =&gt; P(n + 1)</p>",
        "id": 532404033,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754100182
    },
    {
        "content": "<p>In particular, since <code>Fin n</code> depends on the induction variable <code>n</code>, the tactic does <code>revert m</code> first, and then <code>intro m</code> in each case. It's the auto-generalizing feature. (The thing where you can use the <code>generalizing</code> clause to add in more variables to generalize.)</p>",
        "id": 532404399,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754100474
    },
    {
        "content": "<p>It needs to auto-generalize because <code>n</code> is reverted too, to apply the induction principle.</p>",
        "id": 532404443,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754100533
    },
    {
        "content": "<p>(Said another way, <code>induction n</code> basically starts off with <code>revert n</code>, and that's what causes the artificial dependency on <code>m</code>)</p>",
        "id": 532404729,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1754100739
    },
    {
        "content": "<p>aah ok, thanks!  what i wrote is bs, the more general induction principle is not what i wrote.  yea makes much more sense now!</p>",
        "id": 532404887,
        "sender_full_name": "Klaus Gy",
        "timestamp": 1754100891
    }
]