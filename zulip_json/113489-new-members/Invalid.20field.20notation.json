[
    {
        "content": "<p>I'm having trouble with accessing fields within extended records, the following code  ( <code>_inst_1</code> has type <code>inner_product_space ℂ H</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.inner_product_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">ℂ</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">ℂ</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">norm2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">_inst_1.to_normed_group.to_has_norm.norm</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>outputs</p>\n<p><code>invalid field notation, function 'has_norm.norm' does not have explicit argument with type (has_norm ...)</code></p>\n<p>while if I erase the <code>x</code> after <code>.norm</code> Lean only complains that an argument is missing </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">norm</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℝ</span>\n</code></pre></div>",
        "id": 289521614,
        "sender_full_name": "Magalame",
        "timestamp": 1657746716
    },
    {
        "content": "<p>Is there a reason you're not just writing <code>norm</code>?</p>",
        "id": 289525540,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657748852
    },
    {
        "content": "<p>oh thank you it works! I had no idea it'd be straightforward. Is there any reason why what I tried does not though?</p>",
        "id": 289592083,
        "sender_full_name": "Magalame",
        "timestamp": 1657805562
    },
    {
        "content": "<p>I think there are some weird rules about how dot notation works on typeclasses that don't quite follow the usual pattern.</p>",
        "id": 289607129,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1657812379
    },
    {
        "content": "<p>I think the main rule is that when resolving dot notation, first the elaborator tries to resolve it as a projection (navigating the whole <code>extends</code> hierarchy) and then it falls back to extended dot notation. For projections, Lean will <em>always</em> use the first argument after all the type parameters, but for dot notation it will use the first explicit argument with the right type. The <code>function 'has_norm.norm' does not have explicit argument with type (has_norm ...)</code> means it's trying for extended dot notation.</p>",
        "id": 289610531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657814005
    },
    {
        "content": "<p>There's also a bug in dot notation that seems to be affecting this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">norm2</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">_inst_1.to_normed_group.to_has_norm.norm</span>\n<span class=\"k\">in</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 289611036,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657814239
    },
    {
        "content": "<p>It has to do with a difference between how dot notation is elaborated in the presence of arguments vs no arguments. I have a patch for it I've been meaning to polish and PR... (though I don't know if it fixes this particular error.)</p>",
        "id": 289611167,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1657814283
    },
    {
        "content": "<p>Some code with explanation along the lines above: <a href=\"#narrow/stream/113489-new-members/topic/Pi.20type.2Finvalid.20field.20notation/near/179611847\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Pi.20type.2Finvalid.20field.20notation/near/179611847</a></p>",
        "id": 289643581,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657829668
    }
]