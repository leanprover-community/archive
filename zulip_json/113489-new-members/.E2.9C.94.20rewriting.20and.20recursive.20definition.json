[
    {
        "content": "<p>I'm working through the book <a href=\"https://hrmacbeth.github.io/math2001/06_Induction.html#recurrence-relations\">The Mechanics of Proof</a> and currently I am at ch. 6.2. The motivation for my question comes from a home brew version of the factorial, but to make it clear that it's not really about the factorial, I created an artificial MWE sequence \"fake\" (as in fake factorial).</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Ring</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>The first rw[fake] in the 3rd last line only attempts to rewrite the \"fake 0\" on the RHS, which will obviously not justify the equation at that line. My guess is, that rw with a recursive definition like fake will stop at the first pattern it matches from its list. In this case it matches the pattern \"0\" and not the pattern \"n+1\" as instanciated in \"0+1\". Is this correct or a wrong assumption on my side? The second \"rw [fake]\" works fine to justify the second step.<br>\nAfter consulting the internet and ChatGPT I tried to specify the context to rw as in this code (continue from the previous MWE). To go all in, I tried to specify the context of both rw-s.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">calc</span>\n<span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>The first \"rw [fake (0+1)]\" still did not match the LHS (it also did not match the \"fake 0\" on the RHS anymore, which is as expected). Even worse, the second \"rw[fake 0]\" failed to match the \"fake 0\" on the previous line and could no longer justify the second step. What's going on here?<br>\nNext, I tried to specify the location at which the rw should operate (I only focus on the  bad line now)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">nth_rw</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This stilled showed the original behavior of trying to substitute for \"fake 0\" on RHS, as did</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Playing around a bit</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">2</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>gave a different error, namely</p>\n<blockquote>\n<p>failed to rewrite using equation theorems for 'fake'. Try rewriting with 'fake.eq_def'.</p>\n</blockquote>\n<p>The error message gives a suggestions, how to resolve this problem in terms of \"'fake.eq_def'\". So I tried</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">occs</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]})</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>which made lean4 finally accepted this step. Going back, I tried to modify my original attempt in this vain</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and lean4 also accepted it.</p>\n<p>So I'd really like to understand why lean4 struggles so hard to match \"fake (0+1)\" in the presence of some \"fake 0\". In particular, why does it fail when \"rw [fake (0+1)]\" is used, and even more, why does the second step fail, when trying to make the context explicit by \"rw [fake 0]\".<br>\nFor people having the same experience, I also like to share a different approach around these issue, which goes through.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This also raises the question, why this works, but a similar rw step inside a calc doesn't. Also note that specifying the context (\"rw [fake (0+1)]\" resp. \"rw [fake 0]\") will not be accepted any more even in this version without calc.<br>\nThe different behaviors raise many questions. Maybe there is a comprehensive documentation for this out there which I have not found. Answers and/or references are both appreciated.</p>",
        "id": 477125177,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1729056665
    },
    {
        "content": "<p>Do you mean to define <code>fake 0 = 1</code> in your initial post? This makes fake 1 = 2. Feel free to edit the post if this was a typo. Edit: this comment is totally wrong, apologies :-)</p>\n<p>I think you're supposed to use <code>simp [fake]</code> to access the equation lemmas for  <code>fake</code> nowadays.</p>",
        "id": 477134278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729060853
    },
    {
        "content": "<p>Funnily enough, I've answered a very similar question from someone who was also working with factorial after following mechanics of proof <a href=\"#narrow/stream/116395-maths/topic/Mechanics.20of.20Proof.20--.20Trouble.20rewriting.20factorial.20sometimes.3F/near/459950961\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Mechanics.20of.20Proof.20--.20Trouble.20rewriting.20factorial.20sometimes.3F/near/459950961</a></p>",
        "id": 477134906,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1729061080
    },
    {
        "content": "<p>There is an open issue for this behavior of <code>rw</code> at <a href=\"https://github.com/leanprover/lean4/pull/5026\">lean4#5026</a></p>",
        "id": 477135043,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1729061130
    },
    {
        "content": "<p>The workaround here is to create standalone theorems for each of the equations your recursive definition should satisfy and use those instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fake_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">fake_add_one</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake_add_one</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- success</span>\n</code></pre></div>",
        "id": 477136690,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1729061719
    },
    {
        "content": "<p>The problem is that <code>rw</code> is prioritizing rewriting by the first of these equations (i.e. <code>fake_zero</code>) rather than rewriting the first occurrence of <code>fake</code> in the goal. In fact, under the hood, <code>rw</code> generates equation theorems just like <code>fake_zero</code> and <code>fake_add_one</code> above, and then the problem is that <code>rw [fake]</code> is implemented by trying <code>rw [fake_zero]</code> and <code>rw [fake_add_one]</code> in that order and using whichever one is the first to actually match a part of the goal.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake_zero</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't solve the goal because it's rewriting the wrong occurence of `fake`</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- doesn't solve the goal because it has the same effect as `rw [fake_zero]`</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"bp\">.</span><span class=\"n\">eq_1</span><span class=\"w\"> </span><span class=\"c1\">-- `fake 0 = 1`</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"bp\">.</span><span class=\"n\">eq_2</span><span class=\"w\"> </span><span class=\"c1\">-- `fake (n + 1) = n + fake n`</span>\n<span class=\"c1\">-- under the hood, `rw` generates equation theorems just like `fake_zero` and `fake_add_one`.</span>\n</code></pre></div>",
        "id": 477137806,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1729062064
    },
    {
        "content": "<p>Trying <code>rw [fake (0 + 1)]</code> made sense because providing additional parameters is a common way to specify which occurrence to rewrite. The problem is that as soon as you put something more complicated than just a definition name inside the square brackets, <code>rw</code> no longer thinks you're trying to unfold a definition and instead interprets what you wrote as a proof of some equation, but <code>fake (0 + 1) : ℕ</code> is a number, not a proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake_add_one</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- success; we can rewrite with `fake_add_one` with `n = 2`.</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fake</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- error. using `rw` to unfold definitions only works when you write just the name of the definition. now lean thinks we're trying to use the expression `fake 2` as a proof, but `fake 2 : ℕ` so we have an error.</span>\n</code></pre></div>",
        "id": 477139189,
        "sender_full_name": "Timo Carlin-Burns",
        "timestamp": 1729062446
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Yes, I mean to define <code>fake 0 = 1</code>.<br>\nThe recursive definition <code>n + 1 =&gt; n + fake n</code>will then actually lead to <code>fake 1 = 1</code>and not 2. This is essentially by the calculation I try to prove step by steps with the rws.<br>\nYour suggestions to use <code>simp [fake]</code>also works to prove the example. Thank you.</p>",
        "id": 477182387,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1729075258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"500038\">@Timo Carlin-Burns</span> <br>\nThank you. The prioritization was my initial guess for the plain <code>rw</code>.<br>\nSo this prioritization persists also persists in the modified versions of <code>nth_rw</code> and the <code>rw (config := { occs := .pos [1]})</code>?<br>\nI'll take it, that using <code>rw [fake.eq_2]</code> is an abbreviated version of your suggestion to create separate theorems like your <code>theorem fake_add_one</code>.<br>\nThank you also for the link to the other thread. I searched the Zulip chat for something like that, but I probably used the wrong search terms.</p>",
        "id": 477184548,
        "sender_full_name": "Thomas Preu",
        "timestamp": 1729075990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"680252\">Thomas Preu</span> has marked this topic as resolved.</p>",
        "id": 477510270,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729193100
    }
]