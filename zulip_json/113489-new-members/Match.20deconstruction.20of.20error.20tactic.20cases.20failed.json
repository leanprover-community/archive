[
    {
        "content": "<p>Hello,<br>\nWe are trying to understand inductive types and trying to explicity construct and deconstruct objects of And and Or types. Specifically, we have the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hhp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">def</span> <span class=\"n\">hhq</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testAnd</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">And</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">And.intro</span> <span class=\"n\">hhp</span> <span class=\"n\">hhq</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testfunction1</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">testAnd</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">And.intro</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testOr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Or</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hhp</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">testfunction2</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">testOr</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hb</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>For the And everything works, but we don't understand why deconstructing the Or yields the following error:</p>\n<p>I get the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">cases'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">nested</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">tactic</span> <span class=\"bp\">'</span><span class=\"n\">induction'</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Or.casesOn'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.11843</span>\n<span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n<span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">motive</span> <span class=\"n\">x</span><span class=\"bp\">✝</span> <span class=\"n\">after</span> <span class=\"n\">processing</span>\n</code></pre></div>\n<p>Thank you very much</p>",
        "id": 396968650,
        "sender_full_name": "Golol",
        "timestamp": 1697486097
    },
    {
        "content": "<p>Please read <a href=\"https://github.com/leanprover-community/mathlib/wiki/Code-in-backticks\">#backticks</a> and edit your message to use them</p>",
        "id": 396969140,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1697486314
    },
    {
        "content": "<p>The issue is this. Pattern matching is using <code>And.casesOn</code> and <code>Or.casesOn</code> under the hood. These aren't available in the online documentation because they are autogenerated by the <code>inductive</code> keyword, but you can see their types with <code>#check And.casesOn</code> and <code>#check Or.casesOn</code>. If you do that you will see that the motives are <code>p ∧ q → Sort u</code> and <code>p ∨ q → Prop</code> respectively. This means that when you are pattern matching on <code>And</code>, you can output whatever type you want, including data like <code>5 : ℕ</code>, but for <code>Or</code> the output can only be a proof of some proposition.</p>\n<p>This is basically because of proof irrelevance, which states that if <code>p : Prop</code> and <code>hp hp' : p</code>, then <code>hp = hp'</code> <em>by definition</em> in Lean. So, if <code>p q : Prop</code>,  and <code>hp : p</code> and <code>hq : q</code>, then Lean cannot distinguish between <code>Or.inl hp</code> and <code>Or.inr hq</code>, which have type <code>p ∨ q</code> (which is itself a proposition). As such, it doesn't really make sense to define a function which does one thing in the former situation and another thing in the latter, because Lean doesn't know which one to choose. However, if all we're doing is providing a proof of some proposition as output, there's no problem because there's only one such possible proof.</p>\n<p>While in some sense the same issue would arise for <code>And</code>, it doesn't because this only has one constructor, so there is only one way to create a term of type <code>p ∧ q</code>. Therefore, we can safely create data using something called subsingleton elimination.</p>",
        "id": 396980270,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1697492048
    },
    {
        "content": "<p>You might be interested in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Or.by_cases#doc\">docs#Or.by_cases</a>, which provides lean a decision procedure for choosing, depending on whether <code>p</code> is true</p>",
        "id": 396984169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1697494361
    },
    {
        "content": "<p>I guess, the code below might be what you want to try. The key is you can not return <code>Nat</code> which, as Jireh said, 'Doesn't really make sense'. The code here works.: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testfunction2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hp</span>  <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hq</span>\n</code></pre></div>\n<p>You can also try to understand what happens with there codes. I think the <code>disjunction elimination</code> is the reason why it designed like this.:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">testfunction2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">h</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hp</span>  <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- tactic 'cases' failed, nested error:</span>\n<span class=\"c1\">-- tactic 'induction' failed, recursor 'Or.casesOn' can only eliminate into Prop</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Or.elim</span> <span class=\"n\">h</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hp</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inr</span> <span class=\"n\">hp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Or.inl</span> <span class=\"n\">hq</span><span class=\"o\">)</span>\n<span class=\"c1\">-- O.K.</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Or.elim</span> <span class=\"n\">h</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hp</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">hq</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"c1\">-- invalid universe level, ?u.202 is not greater than 0</span>\n</code></pre></div>",
        "id": 396987670,
        "sender_full_name": "ZHAO Jiecheng",
        "timestamp": 1697496347
    }
]