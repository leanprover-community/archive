[
    {
        "content": "<p>I asked Aristotle for code to find some primes in various intervals.  It responded with some code that did some initial sieving, some Miller-Rabin tests, and some #eval statements.</p>\n<p>One of the statements was</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">3003000000000000037</span>\n</code></pre></div>\n<p>which in the Lean playground takes some time to evaluate.</p>\n<p>Another was part of a routine, namely</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">all_primes</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">solution_fast</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">all_primes</span><span class=\"o\">[</span><span class=\"mi\">77</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This gives the response at the line '#eval all_primes[77]'</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">maximum</span><span class=\"w\"> </span><span class=\"n\">recursion</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">reached</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"ss\">`set_option</span><span class=\"w\"> </span><span class=\"n\">maxRecDepth</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">num</span><span class=\"bp\">&gt;`</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">increase</span><span class=\"w\"> </span><span class=\"n\">limit</span>\n<span class=\"n\">use</span><span class=\"w\"> </span><span class=\"ss\">`set_option</span><span class=\"w\"> </span><span class=\"n\">diagnostics</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">diagnostic</span><span class=\"w\"> </span><span class=\"n\">information</span>\n</code></pre></div>\n<p>Changing 1000 to 100 gets me a response which is a pair with the second member a 20 digit number which is likely prime, which is part of my goal.</p>\n<p>Based on this, it suggests that the recursion depth has been reached by forming the list, not by accessing elements with large index.  Is there a better method to generate and store the pairs for access?  Would Array be useful here?  (For proof of concept, I don't even need to store them if the playground can print some of them to the console.)  Most importantly, do I need to increase recursion depth to generate the list?</p>\n<p>The actual goal is to see how fast Lean can generate large (probable) primes and then verify the outputs are prime using something that is not <a href=\"http://Nat.prime\">Nat.prime</a>.</p>",
        "id": 574370857,
        "sender_full_name": "J. J. Issai (project started by GRP)",
        "timestamp": 1771356841
    }
]