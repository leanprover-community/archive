[
    {
        "content": "<p>Hi all,</p>\n<p>I want to represent a sorting tree (i.e. a decision tree where every node compares two elements of an list (say of length <code>n</code>) and branching based on the result of that comparison); the leaves of this tree are permutations of <code>List.range n</code> that represent the correct order for the array when that sequence of orderings has been reached.<br>\nFor example, in the tree seen <a href=\"https://imgur.com/a/aDNpdRf\">here</a> (where the left branch represents the first item being smaller), if we compare the 0th and 1st element of the list, and the 0th is smaller, we then compare the 0th and 2nd; if the 0th is again the smaller of the two, we know the correct order must be 0 1 2; which is a permutation of <code>List.range 3</code>.</p>\n<p>I came up with the following structure, but I have some questions.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">order</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">order</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Branch</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fstSmaller</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sndSmaller</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there a practical way to make Lean help me in proving that e.g. <code>[0, 3, 1, 2]</code> is in fact a permutation of <code>List.range 4</code>? I found the theorem <code>List.perm_iff_count</code> which seems like it could be especially useful if I use Lists of type <code>Fin len</code> as the <code>order</code> parameter for <code>SortingTree.Leaf</code>, but as it stands I'm kind of stuck on how to provide a proof for e.g. <code>List.Perm (List.range 3) [0, 2, 1]</code>. Could anyone give me some pointers for a more sensible way to go about this? Thanks in advance from a Lean beginner.</p>",
        "id": 504306019,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1741460232
    },
    {
        "content": "<p><code>List.Perm</code> is decidable when the element type has decidable equality, so you can use the <code>decide</code> tactic in the case of <code>List Nat</code></p>",
        "id": 504339509,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1741486150
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">order</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Perm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">order</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Branch</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">elems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fstSmaller</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">sndSmaller</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myLeaf</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">SortingTree</span><span class=\"bp\">.</span><span class=\"n\">Leaf</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 504339615,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1741486214
    },
    {
        "content": "<p>or is this a case where the lists in question aren't given explicitly?</p>",
        "id": 504340205,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1741486616
    },
    {
        "content": "<p>Perfect! Extra nice that the default <code>:= by decide</code> parameter works like that, makes it really ergonomic.</p>\n<p>The end goal is to _construct_ these sorting trees that work in general, but even then I will be testing concrete lists, which I guess should retain the decidability.</p>\n<p>Thanks a ton!</p>",
        "id": 504358383,
        "sender_full_name": "Simeon Duwel",
        "timestamp": 1741500340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819173\">Simeon Duwel</span> has marked this topic as resolved.</p>",
        "id": 504383571,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741519899
    }
]