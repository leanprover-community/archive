[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"o\">:</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"o\">:</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">:</span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">:</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span>\n<span class=\"kn\">variable</span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\">not work-/</span>\n</code></pre></div>\n<p>In Lean everything has a type but everything can BE a type. </p>\n<p>Out of interest I was wondering would it really break things if everything was allowed to be a type? i.e. instead of having an infinite tower of types upwards you have an infinite tower downwards. In C++ for example, every class can be inherited from. There is no restriction there. While in Lean for types there is a restriction that some things can't be the type of something else.</p>\n<p>As an made up example supposed you defined the definition of an electron in Lean which is not a Type but which has type Particle. But then you invent supersymmetry. Well now there are two types of electrons. But since electron is not a type this means you have to redefine everything.</p>\n<p>So I was just wondering if there was a theoretical reason for this. Or it's just how it is?</p>",
        "id": 445484146,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718756976
    },
    {
        "content": "<p>The inheritance relation in C++ inheritance isn't the has-type relation though. For example, if <code>C</code> and <code>D</code> are classes and <code>D</code> inherits from <code>C</code>, you wouldn't say that <code>D</code> has type <code>C</code>, but just that <code>D</code> inherits from <code>C</code>. Then, if <code>x</code> is an object that has type <code>D</code>, it can be cast to have type <code>C</code> (so in some sense it also has type <code>C</code>), but that's something about objects, not classes.</p>\n<p>Just like in Lean, in C++ there's no such thing as something of type <code>x</code> when <code>x</code> is an object, right?</p>",
        "id": 445487918,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718759171
    },
    {
        "content": "<p>It's definitely confusing that we use \"is a\" for both relations.</p>",
        "id": 445488445,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1718759571
    },
    {
        "content": "<p>But you can do C++ without objects at all (more-or-less) just by using singleton classes and static member functions and templates. Then if you have no objects, everything is a class.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">include</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"n\">iostream</span><span class=\"bp\">&gt;</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Animal</span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">public</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">static</span><span class=\"w\"> </span><span class=\"n\">void</span><span class=\"w\"> </span><span class=\"n\">MakeSound</span><span class=\"o\">(){</span><span class=\"w\"> </span><span class=\"n\">printf</span><span class=\"o\">(</span><span class=\"s2\">\"General animal sound\"</span><span class=\"o\">)</span><span class=\"bp\">;</span><span class=\"o\">}</span>\n<span class=\"o\">}</span><span class=\"bp\">;</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Dog</span><span class=\"o\">:</span><span class=\"n\">Animal</span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">public</span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">static</span><span class=\"w\"> </span><span class=\"n\">void</span><span class=\"w\"> </span><span class=\"n\">MakeSound</span><span class=\"o\">(){</span><span class=\"w\"> </span><span class=\"n\">printf</span><span class=\"o\">(</span><span class=\"s2\">\"Woof! \"</span><span class=\"o\">)</span><span class=\"bp\">;</span><span class=\"o\">}</span>\n<span class=\"o\">}</span><span class=\"bp\">;</span>\n<span class=\"n\">template</span><span class=\"bp\">&lt;</span><span class=\"n\">typename</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"bp\">&gt;</span>\n<span class=\"n\">void</span><span class=\"w\"> </span><span class=\"n\">DoSomething</span><span class=\"o\">(){</span>\n<span class=\"w\">     </span><span class=\"n\">T</span><span class=\"bp\">::</span><span class=\"n\">MakeSound</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"o\">()</span><span class=\"w\"> </span><span class=\"o\">{</span>\n\n<span class=\"w\">    </span><span class=\"n\">Dog</span><span class=\"bp\">::</span><span class=\"n\">MakeSound</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n\n<span class=\"w\">    </span><span class=\"bp\">//</span><span class=\"n\">passing</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">like</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">pass</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">object</span>\n<span class=\"w\">    </span><span class=\"n\">DoSomething</span><span class=\"bp\">&lt;</span><span class=\"n\">Dog</span><span class=\"bp\">&gt;</span><span class=\"o\">()</span><span class=\"bp\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">;</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>Here I might use the language that Dog \"a type of \" Animal. (Maybe not with the exact words Dog hasType Animal.</p>",
        "id": 445489965,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718760688
    },
    {
        "content": "<p>What would it mean for something to have the type <code>Nat.zero</code>? That doesn't make sense to me.</p>",
        "id": 445490119,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718760783
    },
    {
        "content": "<p>I can make an artificial example if you like:</p>\n<p>Imagine Gaussian Integers. It is perfectly possible to define them in such a way that <code>x+iy</code> has a \"type\" of the the natural number x for all y. e.g. 3+4i would have type Nat.3 and so would 3+72i. Therefor every Gaussian integer of the form 0+xi would have type <a href=\"http://Nat.zero\">Nat.zero</a>.</p>\n<p>This is of course a very silly example. But goes to show you can make sense of it. (Well maybe??? )</p>",
        "id": 445490776,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718761190
    },
    {
        "content": "<p>If I wanted to say that the real part of <code>z</code> is <code>3</code>, I would write <code>z.re = 3</code>, not <code>z : 3</code>. It's not clear from the notation <code>z : 3</code> that the statement <code>z : 3</code> has anything to do with the real part of <code>z</code>. Also, the statement that the real part of <code>z</code> is <code>3</code> should be a proposition, not a type judgment.</p>",
        "id": 445491697,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718761634
    },
    {
        "content": "<p>Maybe the setup for \"everything term has a type whereas some term is not a type\" is for being consistent with the mathematical intuition. But using inductive families one can do things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TermAsType</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">TermAsType</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 445491815,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718761687
    },
    {
        "content": "<p>Then <code>TermAsType.term 3</code> has type <code>TermAsType 3</code></p>",
        "id": 445492085,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718761843
    },
    {
        "content": "<p>What's the point of doing that, though?</p>",
        "id": 445492538,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718762087
    },
    {
        "content": "<p>I don’t know if there’s any real case for this too hhhh… I asked this before too <a href=\"#narrow/stream/113489-new-members/topic/term.20of.20a.20type.20cannot.20be.20a.20type.3F\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/term.20of.20a.20type.20cannot.20be.20a.20type.3F</a></p>",
        "id": 445492962,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718762322
    },
    {
        "content": "<p>I thought of another example.</p>\n<p>You could define both +3 and -3 as of type Nat.3 since they are both \"types\" of 3's. (yeah, no-one would actually do this probably as it would be confusing!)</p>\n<p>There's not much point to that, it would only become useful when instead of 3's you have some much more complicated object that you realise actually there's more than one instance of.</p>",
        "id": 445493034,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718762357
    },
    {
        "content": "<p>The type of <code>-3</code> is <code>Int</code>. (This is written <code>-3 : Int</code>.) The type of <code>-3</code> is not <code>3</code>. It can't be both.</p>",
        "id": 445493350,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718762478
    },
    {
        "content": "<p>Yep. That's where it breaks down i suppose :)</p>",
        "id": 445494134,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718762887
    },
    {
        "content": "<p>If <code>n : 3</code> could mean <code>n = 3 ∨ n = -3</code> (which it can't, because the former is a type judgment and the latter is a proposition), then you would end up with theorems like this, where it is impossible to tell what the theorem statement actually means just by looking.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 445494144,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718762894
    },
    {
        "content": "<p>BTW mainly I was just wondering if making every term a type would break something fundamental. Not really if it was useful. Just as a mathematical curiosity. The <code>TermAsType</code> inductive type seems to suggest it wouldn't break anything but I can't be sure.</p>",
        "id": 445494734,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718763258
    },
    {
        "content": "<p>Making all terms a type maybe get back to set theory as all things are set there. As Kevin said in <a href=\"https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/\">xena</a>:</p>\n<blockquote>\n<p>Now <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> is a term but it’s not a type. In Lean, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>:</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">x : \\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> makes no sense. In set theory, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">x\\in\\pi</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span></span></span></span> does happen to make sense, but this is a weird coincidence because everything is a set.</p>\n</blockquote>",
        "id": 445495320,
        "sender_full_name": "Shanghe Chen",
        "timestamp": 1718763630
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> My intuition says that it would break if terms don't fit in a strict computable hierarchy. If you could show that by letting all terms be types you can create a circular loop of types, or a type that is a type of itself then it would prove it would fail.</p>",
        "id": 445496683,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718764529
    },
    {
        "content": "<p>If you wanted to, you could create your own extension of the type theory that Lean uses. In this extension, <code>1, 2, 3</code> are still natural numbers (<code>1 : Nat</code>, <code>2 : Nat</code>, <code>3 : Nat</code>). However, now, you can also write <code>n : 1</code> to mean that <code>n</code> is an element of the monster group, and you can write <code>n : 2</code> to mean that <code>n</code> is a binary tree, and you can write <code>n : 3</code> to mean that <code>n</code> is a complex number. This would, of course, not \"break anything\". All you have done is introduce some new (and bad) notation.</p>",
        "id": 445496881,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718764681
    },
    {
        "content": "<p>You could even decide, totally arbitrarily, that <code>n : 4</code> means that <code>n</code> is a natural number. Then you'd have <code>4 : 4</code>. There would be nothing wrong with this, except that no one would understand what you mean.</p>",
        "id": 445497150,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718764870
    },
    {
        "content": "<p>OK. But what about this. You are an object right? But if I clone you, then I will say there are two objects of type Mitchell Lee. So the object has become a type.</p>\n<p>But then we have introduced two new objects. So there are still objects there but what was once an object is now a type.</p>\n<p>But nothing that was done has made anything inconsistent, so would it have mattered if everything was a type to start with?</p>",
        "id": 445497354,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718765006
    },
    {
        "content": "<p>If you were to clone me, the result would be two people. The type of each of them would be <code>Person</code>, not <code>Mitchell Lee</code>.</p>",
        "id": 445497740,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718765253
    },
    {
        "content": "<p>You seem to be familiar with C++. It, similarly, does not have \"types all the way down\". Consider the following code snippet:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Of course, this doesn't make any sense. The first line compiles because <code>int</code> is a type. But the second line doesn't compile because <code>3</code> is not a type. You could theoretically make an extension to C++ where the notation <code>3 y;</code> means whatever you want it to mean. This would not affect any currently existing C++ programs. However, there would be little point in doing so.</p>",
        "id": 445499252,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718766291
    },
    {
        "content": "<p>As Kyle pointed out, the C++ version of the Lean notation <code>x : A</code> is not <code>class x : A {}</code>, but rather <code>A x;</code>.</p>",
        "id": 445499438,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718766418
    },
    {
        "content": "<p>Yeah, I think you're right. I keep thinking in terms of inheritance where things can have more than one type. It's hard to get forget all that and get into the Type Theory mindset! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.</p>",
        "id": 445499453,
        "sender_full_name": "Mr Proof",
        "timestamp": 1718766429
    },
    {
        "content": "<p>Things cannot have more than one type in C++, either. Like Lean, it has a coercion (casting) system whereby a term of one type can be reinterpreted as another type.</p>",
        "id": 445499600,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1718766551
    },
    {
        "content": "<p>3.0+. <strong> </strong></p>",
        "id": 445507212,
        "sender_full_name": "Dean Young",
        "timestamp": 1718772734
    },
    {
        "content": "<p>0 0.<br>\n*+</p>",
        "id": 445507339,
        "sender_full_name": "Dean Young",
        "timestamp": 1718772860
    },
    {
        "content": "<p>I think that in fact lean would be easier to understand if instead of making \"everything can be a type\" true (which has been pointed out to be kind of meaningless) we could in fact make \"everything has a type\" false. In my mental model of lean there are three levels: terms like 37 (which aren't supposed to have elements), types like Nat and Real (things which are supposed to have elements) and then universes like Type and Prop (which are just there to be collections of everything and that we don't use as variables, and \"term of type Type\" is just a silly way of saying \"type\"). I think that the fact that Prop has type Type is an artifact of type theory and is not used in our mental model (we don't think of sets as functions, we have API to make it look like this is not happening), and the fact that we use the same notation for <code>t : T</code> and <code>T : Type</code> is not actually necessary because in practice we know whether our objects are \"sets\" or \"elements\".</p>",
        "id": 445520441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1718780679
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Why.20types.20all.20the.20way.20up.20but.20not.20all.20the.20way.20down.3F\">#maths &gt; Why types all the way up but not all the way down?</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 445527000,
        "sender_full_name": "Notification Bot",
        "timestamp": 1718783154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what you are describing reminds me of simple type theory / HOL like in HOL-Light or Isabelle/HOL.</p>",
        "id": 445573555,
        "sender_full_name": "Jason Rute",
        "timestamp": 1718798701
    },
    {
        "content": "<p>This isn't the <strong>most</strong> related thing ever (It's not about Lean at all actually), but there's this old post by Mike Shulman about Martin-Löf dependent type theory that goes into some philosophy on the topic of foundational systems.</p>\n<p><a href=\"https://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html\">link</a></p>\n<blockquote>\n<p>Thus, we ought to seek a foundational system which:</p>\n<p>1. contains structural-sets and their elements as basic things, but also subsets of these which behave like material-sets;<br>\n   2. contains both the structural quantifier-bounding membership and the material membership proposition; and<br>\n   3. allows elements of structural-sets to have some internal structure, but doesn’t force them to always have a particular kind of internal structure. The elements of a structural-set should have different structure depending on what that structural-set is: they may be material-sets, or functions, or ordered pairs, or natural numbers.</p>\n<p>In fact, such a foundational system already exists: it is called Martin-Löf dependent type theory (MLTT)</p>\n</blockquote>\n<p>I think that third point sort of hints toward a reason that you may not want all terms to also be types. It's simply nice to think of 27 as a Natural number without also having to think about it as a Type/Set/Etc.</p>",
        "id": 445687833,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1718825935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"725689\">Mr Proof</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20types.20all.20the.20way.20up.20but.20not.20all.20the.20way.20down.3F/near/445493034\">said</a>:</p>\n<blockquote>\n<p>You could define both +3 and -3 as of type Nat.3 since they are both \"types\" of 3's. (yeah, no-one would actually do this probably as it would be confusing!)</p>\n</blockquote>\n<p>Note that you can make this work, but it's not \"types all the way down\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CoeSort</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">coe</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">OfNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- 3 : { z // z = ↑3 ∨ z = -↑3 }</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 445786676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718871721
    },
    {
        "content": "<p>Here you're not telling Lean that <code>3 : Nat</code> <em>is</em> a type, you're telling it how to convert it to a type</p>",
        "id": 445786782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1718871752
    },
    {
        "content": "<p>I guess another way to look at this is that Types all the way up is a solution to a problem. </p>\n<p>If you just enjoy reading/thinking about this topic, a good subject to get into may be to learn why Lean's Type Universes are the way they are. As far as I understand it, we'd prefer not to have Types all the way up but it's there as a solution to <strong>Girard's Paradox</strong>.</p>\n<p>Types all the way down may or may not break things (I'm not really sure), but it would certainly complicate things which means you'd need a good reason for its presence rather than a reason for its absence.</p>\n<p>As far as I understand it; you can't (given the current system) <strong>always</strong> have an Types all the way down forever. For example <code> 1 = 2 : Prop : Type : Type 1 : Type...</code> is a Proposition for which there must be no inhabitants (If there were, it would be interpreted to be a proof of <code>1 = 2</code>).  Which means at least sometimes the downward direction must just stop.</p>",
        "id": 445837878,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1718888487
    },
    {
        "content": "<p>I think this is not quite accurate, because it's mixing two things. <code>1 = 2</code> is a false proposition, so it has no inhabitants, but it is a type so <code>h : 1 = 2</code> is <em>well formed</em>. That means you could have this as a hypothesis or lambda/pi binder, even though it happens to be a false supposition. Compare this to <code>x : h</code> (for such an <code>h : 1 = 2</code>), which is not even well formed: if you write <code>example := fun (h : 1 = 2) (x : h) =&gt; trivial</code> you get an error, because <code>h</code> is not a type and so cannot be used in the type position of a lambda.</p>",
        "id": 445975330,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1718928500
    }
]