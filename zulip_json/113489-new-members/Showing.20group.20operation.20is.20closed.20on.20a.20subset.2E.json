[
    {
        "content": "<p>If I have a group <code>G</code>, and a subset <code>s : Set G</code>, and that subset is also a group under the same operator, then the operator is closed on the subset.  How do I show this in Lean?  Here's my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , what can I put in the <code>sorry</code>?  Or am I going about this all wrong?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Algebra.Group.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.SetLike.Basic</span>\n\n\n<span class=\"kd\">structure</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Boilerplate for SetLike: Start</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">SubsetOfGroup</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">SetLike</span> <span class=\"o\">(</span><span class=\"n\">SubsetOfGroup</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"n\">SubsetOfGroup.carrier</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">q</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">mem_carrier</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">p.carrier</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.rfl</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">ext</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n  <span class=\"n\">SetLike.ext</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SubsetOfGroup</span>\n<span class=\"c1\">-- Boilerplate for SetLike: End</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">gG</span> <span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">gp</span><span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">p</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">Mul</span> <span class=\"n\">p</span> <span class=\"n\">where</span>\n  <span class=\"n\">mul</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">u.1</span> <span class=\"bp\">*</span> <span class=\"n\">v.1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 400941684,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699449257
    },
    {
        "content": "<p>Construct a term of type <code>Subgroup G</code>, where <code>carrier := s</code></p>",
        "id": 400942514,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699449543
    },
    {
        "content": "<p>Also, you told the Zulip chat that \" that subset is also a group under the same operator\", but your code does not mention this to Lean.  You currently seem to have two different multiplications floating around, <code>gG</code> and <code>gp</code> and you are trying to define a third one.</p>",
        "id": 400943388,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699449844
    },
    {
        "content": "<p>The way we work with subgroups in Lean is slightly different than what is usually done in standard mathematics. In particular in Lean we don't start with a subset <code>S</code> and say \"<code>S</code> is a subgroup\". Of course there is nothing crazy going on, a term of type <code>Subgroup G</code> mathematically corresponds to what you think, but for Lean it is more or less a tuple \"(subset, 1, ...)\".<br>\nIn practice what you want is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSubgroup#doc\">docs#IsSubgroup</a>, that is deprecated in mathlib (because it is a pain to use) but very close to what a mathematician would say.</p>",
        "id": 400945149,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699450454
    },
    {
        "content": "<p>The idea is that \"subgroup\" is not a property that certains subset have and certains don't, there is no \"being a subgroup\" (well, it is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSubgroup#doc\">docs#IsSubgroup</a>). We work the other way, saying \"Let <code>H</code> be a subgroup of <code>G</code>\".</p>",
        "id": 400945362,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699450527
    },
    {
        "content": "<p>Mathematically there is no difference, and we know from our experience than this approach works better.</p>",
        "id": 400945555,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699450588
    },
    {
        "content": "<p>Thanks, I should have been more clear.  Mathematically, if G is a group and H is a subset of G, then H is a group iff H is non-empty and closed under the group operation and inverse.  I understand that, in practice, it's easier to use the reverse direction, i.e. show it's closed under inverse &amp; operation &amp; contains the identity.  But I'm interested in proving the other direction: Given that G is a group, H is a subset of G with the same operation (restricted to H of course) and H is a group, show that H is closed under the operation, inverse, and contains the identity.</p>",
        "id": 400957106,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699454157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400943388\">said</a>:</p>\n<blockquote>\n<p>Also, you told the Zulip chat that \" that subset is also a group under the same operator\", but your code does not mention this to Lean.  You currently seem to have two different multiplications floating around, <code>gG</code> and <code>gp</code> and you are trying to define a third one.</p>\n</blockquote>\n<p>Thanks.  I agree there are two different operators around, but I'm not trying to define a third.  Rather, I'm trying to put a constraint on the second, constraining it to be the same as the first, at least on the restricted domain.  If there's a better way to express what I want, I'm all ears.</p>",
        "id": 400957432,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699454248
    },
    {
        "content": "<p>Does mathlib4, for example, contain a proof that any subset of a group G, where the subset is also a group using the same operator, is a <code>Subgroup</code>?</p>",
        "id": 400957704,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699454330
    },
    {
        "content": "<p>Question for you is how would you state <code>H is a group</code> in lean?</p>",
        "id": 400958755,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699454634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400958755\">said</a>:</p>\n<blockquote>\n<p>Question for you is how would you state <code>H is a group</code> in lean?</p>\n</blockquote>\n<p>That's what my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> above does, although I called it <code>p</code> instead of <code>H</code>.  I use SetLike to define <code>SubsetOfGroup</code> as a class that is <code>SetLike</code>, then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">gH</span><span class=\"o\">:</span> <span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 400959313,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699454806
    },
    {
        "content": "<p>Well no, that says \"there is a group structure on H that may be completely unrelated to the group structure on G\"</p>",
        "id": 400959469,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1699454848
    },
    {
        "content": "<p>Right.  Then you add a separate statement, saying \"the group operation on H is the same one on G.\"  And by \"same\" I mean isomorphic of course, and on the restricted domain.</p>",
        "id": 400959802,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699454933
    },
    {
        "content": "<p>In any case, as soon as you say <code>Group H</code>, whether or not it is related to another <code>(*)</code> by some hypothesis, that statement asserts that it is closed over the <code>(*)_H</code></p>",
        "id": 400960024,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699454997
    },
    {
        "content": "<p>I suspect that you are slowly converging to defining subgroups as they are defined in mathlib.</p>",
        "id": 400960486,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699455145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400960024\">said</a>:</p>\n<blockquote>\n<p>In any case, as soon as you say <code>Group H</code>, whether or not it is related to another <code>(*)</code> by some hypothesis, that statement asserts that it is closed over the <code>(*)_H</code></p>\n</blockquote>\n<p>Yes.  And it should be possible to use that in whatever replaces the <code>sorry</code> in my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , where I say \"and the group operator is the same group operator as in G,\" but of course you also need to provide a proof that it's closed on H.  So you and I can both see that it follows from the fact that we have <code>[gH : Group H]</code>.  How do we render that in Lean?</p>",
        "id": 400961446,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699455479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400960486\">said</a>:</p>\n<blockquote>\n<p>I suspect that you are slowly converging to defining subgroups as they are defined in mathlib.</p>\n</blockquote>\n<p>I definitely have the same definition.  In my math education, when something can be defined two different ways, you pick one as the \"official\" definition, the prove the other is equivalent.  That's what I'm trying to do here.  I'm accepting that the definition of <code>Subgroup</code> is as defined in mathlib4, namely closed under inverse, closed under *, and contains identity.  So then you need to show that any subset that is also a group is a <code>Subgroup</code>.  That's what I'm trying to do here.</p>",
        "id": 400962015,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699455647
    },
    {
        "content": "<p>For example, Linear Algebra Done Right, theorem 1.3.4 is that \"A subset U of V is also a vector space of V iff U satisfies the following 3 conditions.\" (Contains 0, closed under addition and scalar multiplication).  The proof of the forward direction is just \"If U is a subset of V and U is a vector space using the same addition and scalar multiplication, then U satisfies the three conditions by the definition of vector space.\"</p>",
        "id": 400963014,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699455917
    },
    {
        "content": "<blockquote>\n<p>So then you need to show that any subset that is also a group is a Subgroup. That's what I'm trying to do here.</p>\n</blockquote>\n<p>This is false without the extra \"and the operations agree\" condition</p>",
        "id": 400963336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699456018
    },
    {
        "content": "<p>Here's a start</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">martinSubgroup</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Subgroup</span> <span class=\"n\">G</span> <span class=\"n\">where</span>\n  <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">H</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">self_eq_mul_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 400964360,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699456313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400963336\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>So then you need to show that any subset that is also a group is a Subgroup. That's what I'm trying to do here.</p>\n</blockquote>\n<p>This is false without the extra \"and the operations agree\" condition</p>\n</blockquote>\n<p>I agree.  So let me revise my statement: \"then you should show that any subset of G that is a group using an operator that agrees with H, is closed under multiplication and inverse and is non-empty.\"</p>",
        "id": 400964448,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699456326
    },
    {
        "content": "<p>For example, the Wikipedia article on Subgroup says \" a subset H of G is called a subgroup of G if H also forms a group under the operation ∗.  More precisely, H is a subgroup of G if the restriction of ∗ to H × H is a group operation on H. \"  Then, in a later section called \"Subgroup tests\", says \"H is a subgroup of G if and only if H is nonempty and closed under products and inverses.\"</p>",
        "id": 400964979,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699456497
    },
    {
        "content": "<p>I think <code>if</code> means two different things here. One can mean \"propositionally\". The other meaning is \"by definition\". I am trying to get across that <code>[Group H]</code> gives you the \"by definition\" aspect.</p>",
        "id": 400965503,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699456661
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400964360\">said</a>:</p>\n<blockquote>\n<p>Here's a start</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks.  But I think this doesn't work, because <code>[Group H]</code> doesn't say what we want?  <code>Set G</code> is just an alias for <code>G -&gt; Prop</code>, i.e. a predicate on <code>G</code>.  I'm not sure what <code>[Group H]</code> would mean.  Basically, in Lean, a <code>Set</code> is not a class that contains a subset of objects of G, or even something isomorphic to that.  That's why, e.g. when we define Sub-things in mathlib4, we need to defined a structure and use <code>SetLike</code>.</p>\n<p>For example, in <code>variable (h : H)</code>, h is not what we want.  We can use the notation <code>h ∈ H </code> for something analogous, but that doesn't let us say <code>[Group H]</code>.</p>",
        "id": 400966068,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699456850
    },
    {
        "content": "<p>The wikipedia wording is very bad: the sentence <code>H is a subgroup of G if the restriction of ∗ to H × H is a group operation on H</code> doesn't make sense, since the restriction of ∗ to H × H is a map from H × H to G, and a priori not to H, so you can not ask if it gives a group structure.</p>",
        "id": 400966379,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1699456937
    },
    {
        "content": "<p>I don't know how you would state <code>there is a group on the subset H</code>. In mathlib, <code>Group</code> operates on Types. And we have a coercion of terms of <code>Set</code> to terms of Sorts, that is, a <code>Type</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- then you should show that any subset of G that is a group using an operator that agrees with H,</span>\n<span class=\"c1\">-- is closed under multiplication and inverse and is non-empty.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">martin</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">x</span><span class=\"bp\">⁻¹</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"n\">H.Nonempty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine'</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span>\n  <span class=\"bp\">·</span> <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">self_eq_mul_right</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 400966629,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699457011
    },
    {
        "content": "<p>And you can't define an operation <code>(*)</code> that only works on a subset. You can define operations on types. So <code>H</code> has to be promoted from a Set (read: subset) to a Type (read: set).</p>",
        "id": 400966844,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699457073
    },
    {
        "content": "<blockquote>\n<p>Basically, in Lean, a Set is not a class that contains a subset of objects of G, or even something isomorphic to that.</p>\n</blockquote>\n<p>On the contrary, I think it is that. Or more exactly, one possible implementation of that. The fact that <code>Set X = X -&gt; Prop</code> is an implementation detail. Would you feel more comfortable if it was</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">NewSet</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">predicate</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>",
        "id": 400967385,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699457210
    },
    {
        "content": "<p>Yes.  My approach in my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> above, was to define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">SubsetOfGroup</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And then have the <code>SetLike</code> boilerplate.  So same as when we define a <code>Subgroup</code> in mathlib, but leave out all the other properties.  Then it's just a subset without structure.  But perhaps that's not the right approach.</p>",
        "id": 400967703,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699457301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400967385\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Basically, in Lean, a Set is not a class that contains a subset of objects of G, or even something isomorphic to that.</p>\n</blockquote>\n<p>On the contrary, I think it is that. Or more exactly, one possible implementation of that. The fact that <code>Set X = X -&gt; Prop</code> is an implementation detail. Would you feel more comfortable if it was</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">NewSet</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">predicate</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Sorry, I meant isomorphic in a specific way (the way that SetLike gives, where you can cast back and forth between elements of the types), but I didn't say that.</p>\n<p>Basically, given <code>[Group G]</code>, you can say <code>#check (1 : G)</code> that that typechecks just fine.  But if you then define <code>H : Set G</code> and try <code>#check (1 : H)</code>, you get a type error.  You need to say <code>#check (1 ∈ H)</code> instead.  However, this means you can't just say plain old <code>[Group H]</code>, since <code>H</code> is the wrong kind of object.  Anyway, I think we agree on this point?</p>\n<p>Part of the problem here is that Lean's type system is very different from the naive set theory used in undergrad math texts.  So mapping undergrad math texts to Lean can run into issues.  For example, undergrad math texts define Group as a set with an operator; but in Lean, Set means something very different, you really need a Type with an operator, and there's really no such thing as sub-Types, e.g. in Lean, ℕ  is not a sub-Type of ℝ , but a completely disjoint Type composed of different objects, so that (1 : ℕ) is a different object than  (1 : ℝ).</p>",
        "id": 400969993,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699457942
    },
    {
        "content": "<p>The <code>SetLike</code> boilerplate is a distraction for you here: you could use <code>Set G</code> directly</p>",
        "id": 400970456,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699458093
    },
    {
        "content": "<p>The only reason we need <code>SetLike</code> in mathlib is because we need to store additional things after the <code>carrier</code></p>",
        "id": 400970519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699458116
    },
    {
        "content": "<p>Anyway, thank you very much for your time and effort in explaining this to me.  Perhaps the answer is, the standard undergrad way of thinking of this is kind of sloppy, and Lean doesn't even allow us to express it because of that.  As you say, <code>if</code> meaning \"by definition\" vs \"propositionally.\"</p>",
        "id": 400970716,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699458171
    },
    {
        "content": "<blockquote>\n<p>But if you then define H : Set G and try #check (1 : H), you get a type error</p>\n</blockquote>\n<p>It works just find if you add <code>[Group H]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"c1\">-- just fine</span>\n</code></pre></div>",
        "id": 400970778,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699458190
    },
    {
        "content": "<p>Huh, maybe I'm confused then.</p>",
        "id": 400970852,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699458219
    },
    {
        "content": "<p>Also, to point out another sloppiness of informal mathematics: when you say that <code>1 ∈ ℕ</code> is the same as <code>1 ∈ ℤ</code>, you are probably wrong.  The \"usual\" definitions are that <code>1 ∈ ℕ</code> is the set containing the empty set, while <code>1 ∈ ℤ </code> is the equivalence class of <code>(1, 0)</code> under some relation.</p>\n<p>These are very far from being the same.  If you then go as far as going via ℚ, further pairs and then onto ℝ via Cauchy sequences, you quickly see that <em>every</em> time you say that these are subsets of each other, you never literally mean that anyway.</p>",
        "id": 400972084,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699458591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  very true.  Although I always thought that, e.g. once you define ℤ, you the redefine the natural numbers as being those.  So 1 is redefined as being the equivalence class of <code>({{}}, {})</code> under that relation.  But if you do that I suppose there's the question of where you stop, e.g. the <code>1</code> in Real analysis is a real number, so a Cauchy sequence (or equiv class of Cauchy sequences?), where as in Complex analysis, it's now an ordered pair of those equiv classes.  So within a given textbook it has a defined meaning, but different texts define it differently.<br>\nUnless your Real Analysis textbook has a chapter at the end, \"introduction to Complex Analysis,\" in which case things are kind of hopeless.  :)  So I think I'm agreeing with you.</p>",
        "id": 400973087,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699458908
    },
    {
        "content": "<p>You <em>could</em> replace your older definitions by their images in the new sets, but the gain is just in obfuscation.  Informal mathematics is perfectly able to handle the imprecision.  It is only when you decide to formalise mathematical results that you need to get to grips with actual implementations.  And even then, you do that very briefly, until you form an API layer to allow you to get your imprecise intuition back!</p>",
        "id": 400973962,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699459172
    },
    {
        "content": "<p>I think we can say the same here for subgroup definitions. They're really laying out an API, a set of very basic axioms about some object, and we're free to implement it however. The pudding will be the ease of use of your implemented object in proving downstream theorems.</p>",
        "id": 400974512,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699459316
    },
    {
        "content": "<p>Anyway, Martin, I did not mean to seem dismissive: I think that a great way to really learn something is to break it apart and rebuild it, just like you were doing.</p>\n<p>In this case, the <code>sorry</code> that Yakov left further upstream is a very cute exercise, where you actually use a not-entirely-trivial fact about inverses in a group.</p>",
        "id": 400975818,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1699459579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400970778\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But if you then define H : Set G and try #check (1 : H), you get a type error</p>\n</blockquote>\n<p>It works just find if you add <code>[Group H]</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.GroupTheory.Subgroup.Basic</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"c1\">-- just fine</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I take back that <code>(1 : H)</code> doesn't type check, it does as you say.  However, it means something very different.  <code>(H : G → Prop)</code>.  For example, imagine <code>G</code> is <code>Fin 6</code>, so we're defining a finite group of size 6.  Imagine <code>H</code> is the proposition where <code>H (0 : Fin 6)</code>, <code>H (2 : Fin 6)</code> and <code>H (4 : Fin 6)</code> are true (or derivable or whatever), and the others false (not derivable).  What does \"h : H\" mean?</p>",
        "id": 400977021,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699459939
    },
    {
        "content": "<p>Then if you're giving a term <code>h</code> of type <code>H</code>, you're giving me a packet of information: <code>(h : G, proof that h \\in H)</code>.</p>",
        "id": 400977699,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699460160
    },
    {
        "content": "<p>Is <code>h : H</code> a proof that <code>H 0</code>, <code>H 2</code> and <code>H 4</code> are true or something?  By proof irrelevance, are <code>h i : H</code> considered equal?</p>",
        "id": 400977772,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699460173
    },
    {
        "content": "<p>Consider my angle brackets in my proofs above. I was deconstructing that packet of information of <code>x : H</code> into <code>x : G, hx : x \\in H</code>.</p>",
        "id": 400977908,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699460217
    },
    {
        "content": "<p>Note, we do not have in mathlib a coercion of terms of type <code>G -&gt; Prop</code> to types.</p>",
        "id": 400978381,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699460375
    },
    {
        "content": "<p>We _do_ for terms of type <code>Set G</code>. Even if their underlying implementation is the same, we can associate different semantics/operations on each.</p>",
        "id": 400978534,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699460412
    },
    {
        "content": "<p>I admit I didn't  read the whole conversation, but what's wrong with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsSubgroup#doc\">docs#IsSubgroup</a> ?</p>",
        "id": 400979194,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699460619
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 400979428,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699460681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> do you have a working link?  My Google-fu is failing me, and I can't find a definition of it or information about it.</p>",
        "id": 400979740,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699460777
    },
    {
        "content": "<p>Now it works</p>",
        "id": 400979965,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699460855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> perhaps that's the way to go.  It seems like a parallel definition.  We have <code>Subgroup</code>, and separately, we have <code>IsSubgroup</code>, which express the same mathematical truth.  But maybe that's not a bad thing?</p>",
        "id": 400981452,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699461296
    },
    {
        "content": "<p>Yes, the difference is purely practical. In theory one can do everything with <code>IsSubgroup</code>, and at the beginning this looks closer to standard math. For example I do that with my undergraduate students (well, I define <code>IsSubsbace</code>) since a lot of their linear algebra exercises are of of the kind \"show that  blah blah is a subspace of blah blah\". But the point is that one we start doing serious mathematics (and I don't mean anything complicated, for example when we want to consider the \"set\" of all subgroups) then it becomes a pain to use <code>IsSubgroup</code>, while our approach with <code>Subgroup</code> works better.</p>",
        "id": 400982230,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699461520
    },
    {
        "content": "<p>So it really depends on what you want to do. If your goal is to advanced mathematics, so you need to use mathlib, you are essentially forced to use <code>Subgroup</code>, since virtually all the library is written in that way.</p>",
        "id": 400982379,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699461573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> getting back to what <code>h : H</code> means, <code>Set X</code> is an alias for <code>X → Prop</code>, i.e. a predicate.  So e.g. <code>is_even</code> on <code>ℕ </code> can be viewed as a <code>Set ℕ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_even</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">is_even</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">is_even</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_even</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In this case, I get an error, \"type expected, got  (is_even : ℕ → Prop)\".</p>\n<p>So it seems analogous here.  Given an arbitrary type <code>G</code> (which could be <code>ℕ </code>), and <code>H : Set G</code> (where in some application <code>H</code> could be <code>is_even</code>), I don't think <code>h : H</code> has much meaning in Lean in general.  Or I'm confused, which is quite possible.</p>",
        "id": 400983120,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699461797
    },
    {
        "content": "<p>What I'm saying is that <code>Set X</code> should not be thought of as an alias of <code>X -&gt; Prop</code>.</p>",
        "id": 400983286,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699461845
    },
    {
        "content": "<p>Sure, we defined it that way, but now let's pinky promise to never peek behind the curtain.</p>",
        "id": 400983353,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699461867
    },
    {
        "content": "<p>And a way of respecting that is like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_even</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">evens</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Nat</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">is_even</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 400983514,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699461925
    },
    {
        "content": "<p>The crucial thing you're missing in your mwe is the following globally available coercion in mathlib: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.instCoeSortSetType#doc\">docs#Set.instCoeSortSetType</a></p>",
        "id": 400983745,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699461994
    },
    {
        "content": "<blockquote>\n<p>Note that a set is a term, not a type. There is a coercion from Set α to Type* sending s to the corresponding subtype ↥s.</p>\n</blockquote>",
        "id": 400983785,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699462013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348963\">@Martin C. Martin</span> <code>is_even</code> is not a well formed type, it hasn't terms.</p>",
        "id": 400984044,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462096
    },
    {
        "content": "<p>Not everything is a type. Everything (almost...) is a term.</p>",
        "id": 400984144,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400982379\">said</a>:</p>\n<blockquote>\n<p>So it really depends on what you want to do. If your goal is to advanced mathematics, so you need to use mathlib, you are essentially forced to use <code>Subgroup</code>, since virtually all the library is written in that way.</p>\n</blockquote>\n<p>My current goal is to understand how regular math maps to Lean, and my secondary goal is pedagogy.  I'm translating Linear Algebra Done Right into Lean, both so that I can learn it, and also hopefully that others can use it as a kind of Rosetta Stone, if they know linear algebra but not Lean, they can see how concepts from Linear Algebra are rendered in Lean.</p>\n<p>So defining <code>Subgroup</code> as a structure the way mathlib does, then wanting to prove that it's equivalent to \"any subset of a group that is also a group\" by ignoring our new definition, and instead introducing an <code>IsSubset</code>, seem a little unsatisfying.  Perhaps better to just say \"since we need to create a separate type that's isomorphic to the subset, we can't even represent a non-closed function\" and leave it at that.</p>",
        "id": 400984296,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699462197
    },
    {
        "content": "<p>Lean is able to decide whether \"something\" is a well formed type, and in particular it complains when you write <code>(t : is_even)</code></p>",
        "id": 400984370,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462208
    },
    {
        "content": "<p>I really think the mathlib approach is the best one. Just forget about all these questions that ask to prove that \"something is a subblah\"</p>",
        "id": 400984538,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462277
    },
    {
        "content": "<p>But this is a problem only for explicit examples.</p>",
        "id": 400984598,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462302
    },
    {
        "content": "<p>When you arrive at \"the intersection of two subspaces is a subspace\" this is perfectly translated in mathlib. The difference is that it is <em>not</em> a statement about the set theoretic intersection.</p>",
        "id": 400984758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462345
    },
    {
        "content": "<p>I very much like LADR as a book, but I don't think it maps well to mathlib much. Because LADR is highly specialized to vector spaces over R and C, while mathlib discusses modules (read: semimodules) and tries to avoid restricting to fields wherever possible.</p>",
        "id": 400984865,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699462381
    },
    {
        "content": "<p>It is a definition that takes two subspaces <code>A</code> and <code>B</code> and gives another one <code>A inter B</code>. Then one can prove that <code>(A inter B).carrier = A.carrier ∩ B.carrier</code></p>",
        "id": 400984926,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400984865\">said</a>:</p>\n<blockquote>\n<p>I very much like LADR as a book, but I don't think it maps well to mathlib much. Because LADR is highly specialized to vector spaces over R and C, while mathlib discusses modules (read: semimodules) and tries to avoid restricting to fields wherever possible.</p>\n</blockquote>\n<p>Sure, but you can suppose that you are working with modules over a field (aka vector spaces). Of course if one theorem is true over any ring we state it in such generality (but it will apply to your case). If a theorem really need the base ring to be a field we don't have any problem with it, we state with a field.</p>",
        "id": 400985203,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462486
    },
    {
        "content": "<p>Then it is true that not a lot of theorems <em>really</em> need the base ring to be a field, they probably need the module to be free or something, this is way you don't see a lot of linear algebra over fields in mathlib.</p>",
        "id": 400985364,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699462532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400983785\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Note that a set is a term, not a type. There is a coercion from Set α to Type* sending s to the corresponding subtype ↥s.</p>\n</blockquote>\n</blockquote>\n<p>Ah, interesting, thanks!</p>",
        "id": 400985495,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699462565
    },
    {
        "content": "<p>Agreed. My point was in bridging mathlib API to LADR \"API\" -- the gadgets LADR discusses and builds are done with less generality, so one has to carry around more assumptions on the mathlib gadgets, and thus some basic-LADR-gadget-theorems are annoying to express in mathlib.</p>",
        "id": 400985722,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1699462643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400984144\">said</a>:</p>\n<blockquote>\n<p>Not everything is a type. Everything (almost...) is a term.</p>\n</blockquote>\n<p>Interesting, I hadn't appreciated the difference, or that there could be an coercion when a non-type term is used in a type context.  Thanks!</p>",
        "id": 400985727,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699462644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400983745\">said</a>:</p>\n<blockquote>\n<p>The crucial thing you're missing in your mwe is the following globally available coercion in mathlib: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set.instCoeSortSetType#doc\">docs#Set.instCoeSortSetType</a></p>\n</blockquote>\n<p>The comment just before the definition says:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- It is currently an abbreviation so that instance coming from `Subtype` are available.</span>\n<span class=\"c1\">-- If you're interested in making it a `def`, as it probably should be,</span>\n<span class=\"c1\">-- you'll then need to create additional instances (and possibly prove lemmas about them).</span>\n<span class=\"c1\">-- The first error should appear below at `monotoneOn_iff_monotone`.</span>\n</code></pre></div>\n<p>however, it looks like a <code>def</code> to me.  Is that comment old?  Should it be removed?</p>",
        "id": 400987503,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699463120
    },
    {
        "content": "<p>I guess the comment refers to the <code>reducible</code> attribute.</p>",
        "id": 400988619,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699463521
    },
    {
        "content": "<p>(but I agree it is misleading)</p>",
        "id": 400988779,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699463565
    },
    {
        "content": "<p>Thank you all, this has been very helpful.  I somehow had thought that <code>Set X</code> was an actual alias for <code>X -&gt; Prop</code>, using an <code>alias</code> keyword, like a C <code>typedef</code>.  I don't know where I got that idea, as there's clearly a <code>def</code> in the definition.  Also, I hadn't appreciated the coercion.  Now that I have a deeper understanding of these fundamentals, I'll go read up on the details again.</p>",
        "id": 400990404,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699464168
    },
    {
        "content": "<p>I think you're getting more confused unfortunately, the <code>alias</code> keyword is just <code>def</code>  + \"autogenerate a docstring\". And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> is just a <code>def</code>.Maybe you mean <code>abbrev</code>, which is \"just\" <code>@[reducible] def</code></p>",
        "id": 400990507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699464209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400975818\">said</a>:</p>\n<blockquote>\n<p>Anyway, Martin, I did not mean to seem dismissive: I think that a great way to really learn something is to break it apart and rebuild it, just like you were doing.</p>\n<p>In this case, the <code>sorry</code> that Yakov left further upstream is a very cute exercise, where you actually use a not-entirely-trivial fact about inverses in a group.</p>\n</blockquote>\n<p>Thank you very much for your encouraging words.  \"The devil is in the details,\" and it often takes an experience like this for me to appreciate these things which seem like subtleties to me on a first reading.</p>",
        "id": 400990735,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699464279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400990507\">said</a>:</p>\n<blockquote>\n<p>I think you're getting more confused unfortunately, the <code>alias</code> keyword is just <code>def</code>  + \"autogenerate a docstring\". And <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> is just a <code>def</code>.</p>\n</blockquote>\n<p>Thanks.  I do think things are clearing up.  I had thought that <code>Set X</code> and <code>X -&gt; Prop</code> were indistinguishable to the Lean compiler, but now I understand they are clearly different, and there's coercion, so now I can go back to some of the example code earlier in this thread that made no sense to me.</p>",
        "id": 400991115,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699464431
    },
    {
        "content": "<p>There is no coercion between those types</p>",
        "id": 400991173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1699464456
    },
    {
        "content": "<p>Yep, I understand.  But there is coercion involved in <code>h : H</code> when <code>H : Set X</code>, but not when <code>H : X -&gt; Prop</code>, and that's where I was stuck before.</p>",
        "id": 400991586,
        "sender_full_name": "Martin C. Martin",
        "timestamp": 1699464582
    },
    {
        "content": "<p>Yes, the point is that <code>h : H</code> doesn't make sense neither when <code>H : Set X</code> nor when <code>H : X -&gt; Prop</code>. The only difference is that in the former case Lean knows how to modify what you wrote and in the latter it doesn't.</p>",
        "id": 400991964,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699464721
    },
    {
        "content": "<p>It seems like this was already sufficiently resolved, but I just wanted to point out that Sebastien put his finger on the key issue:<br>\n<span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/113489-new-members/topic/Showing.20group.20operation.20is.20closed.20on.20a.20subset.2E/near/400966379\">said</a>:</p>\n<blockquote>\n<p>The wikipedia wording is very bad: the sentence <code>H is a subgroup of G if the restriction of ∗ to H × H is a group operation on H</code> doesn't make sense, since the restriction of ∗ to H × H is a map from H × H to G, and a priori not to H, so you can not ask if it gives a group structure.</p>\n</blockquote>\n<p>When mathematicians (IMO, <em>sloppily</em>) define \"Given a group <code>G</code>, a nonempty subset <code>H</code> is a <em>subgroup</em> of <code>G</code> if it is a group with the same operations as on <code>G</code>\", this <strong>already presupposes</strong> that for <code>x y ∈ H</code>, that <code>x * y ∈ H</code> (because the multiplication has to agree with that of <code>G</code>, but it has to be a function <code>H × H → H</code> for <code>H</code> to be a group) and for <code>x ∈ H</code>, that <code>x⁻¹ ∈ H</code> (for similar reasons). Then the only part of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup#doc\">docs#Subgroup</a> which is not already presupposed by the mathematician's sloppy definition of subgroup is that <code>1 ∈ H</code>. This actually requires proof: since <code>H</code> is nonempty, there is some <code>x ∈ H</code>, and then <code>1 = x * x⁻¹ ∈ H</code>.</p>",
        "id": 400996854,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1699466528
    },
    {
        "content": "<p>Yeah, <code>H</code> being closed under the operations is mathematically trivial, and <code>1 ∈ H</code> is the only nontrivial part. You can actually leave out the inverse operation from the definition of a group and still get <code>1 ∈ H</code>, because multiplication in a group is cancellative: <code>1H * 1H = 1H = 1G * 1H</code> implies that <code>1H = 1G</code>. For the same reason, a subset in a vector space that is a vector space with the inherited operations must have the same zero as the ambient vector space. This is not true for the identity <code>1</code> in a ring, since multiplication is not necessarily cancellative in a ring; for example, given two rings <code>A</code> and <code>B</code>, <code>A × {0}</code> forms a ring under the operations inherited from <code>A × B</code>, but has identity (1,0), which is different from the identity (1,1) in <code>A × B</code>. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subring#doc\">docs#Subring</a> requires <code>1</code> to be in the subring and rules out such cases, but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NonUnitalSubring#doc\">docs#NonUnitalSubring</a> includes such cases (and it's introduced with applications in operator algebras in mind, I think).</p>",
        "id": 401904330,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1699936384
    }
]