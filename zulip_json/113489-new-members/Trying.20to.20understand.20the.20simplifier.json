[
    {
        "content": "<p>I am trying to get a feel for the simplifier with limited success.  In the following experiment, the odd-numbered examples don't work, while the even-numbered ones do.  I am unsure why that is the case, since I more or less expected all of them to work; I would benefit from some informed explanation on where the simplifier gets stuck in each case.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Nat.pos_iff_not_zero</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n    <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"n\">Nat.not_eq_zero_of_lt</span><span class=\"o\">,</span> <span class=\"n\">Nat.zero_lt_of_ne_zero</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">example1</span> <span class=\"o\">(</span><span class=\"n\">n_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">n_pos</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">example2</span> <span class=\"o\">(</span><span class=\"n\">n_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">n_pos</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">example3</span> <span class=\"o\">(</span><span class=\"n\">n_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">example4</span> <span class=\"o\">(</span><span class=\"n\">n_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.not_eq_zero_of_lt</span> <span class=\"n\">n_pos</span><span class=\"o\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">example5</span> <span class=\"o\">(</span><span class=\"n\">n_pos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Nat.not_eq_zero_of_lt</span><span class=\"o\">,</span> <span class=\"n\">n_pos</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>As an aside, if I want to have a modified <code>simp</code>, say <code>simp_context</code> that does <code>simp (config := {contextual := true})</code> by default, how can I declare that?</p>\n<p>Context: I have been learning Lean through TPIL and FPIL.</p>",
        "id": 385640231,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1692266342
    },
    {
        "content": "<p>Here is a second situation that is perplexing me:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">example_works</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this.symm</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_cancel</span><span class=\"o\">]</span>\n  <span class=\"n\">this</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">example_fails</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">Nat.add_sub_cancel</span><span class=\"o\">]</span>\n  <span class=\"n\">this</span>\n</code></pre></div>\n<p>I am confused as to why the second <code>simp</code> fails only because the first equation is not flipped around with <code>symm</code>.</p>",
        "id": 385647811,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1692269252
    },
    {
        "content": "<p>You have <code>{h : h ≤ n}</code>. Typo for <code>{h : k ≤ n}</code>?</p>",
        "id": 385648993,
        "sender_full_name": "Richard Copley",
        "timestamp": 1692269697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400544\">Buster</span> <a href=\"#narrow/stream/113489-new-members/topic/Trying.20to.20understand.20the.20simplifier/near/385648993\">said</a>:</p>\n<blockquote>\n<p>You have <code>{h : h ≤ n}</code>. Typo for <code>{h : k ≤ n}</code>?</p>\n</blockquote>\n<p>Thanks, fixed.</p>",
        "id": 385649092,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1692269717
    },
    {
        "content": "<blockquote>\n<p>I am confused as to why the second simp fails only because the first equation is not flipped around with symm.</p>\n</blockquote>\n<p>It's just that <code>simp</code> does its replacements in the direction specified by the lemma. That's why the <code>simp [← this]</code> syntax exists.</p>",
        "id": 385650899,
        "sender_full_name": "Richard Copley",
        "timestamp": 1692270372
    },
    {
        "content": "<p><code>simp</code> uses all lemmas tagged <code>@[simp]</code> - say of type <code>a = b</code> - and rewrites <code>a</code> in your goal with <code>b</code> (repeatedly). <code>simp [h]</code> will additionally include <code>h</code> in the rewrite. <code>simp</code> will automatically close the goal if the goal has been rewritten to <code>True</code>, or a hypothesis to <code>False</code> (it also does a bit more, I do not know exactly). However, it will not call <code>assumption</code> or anything.<br>\nSo the failures:<br>\n<code>example1</code>: no simp lemma is able to rewrite the goal.<br>\n<code>example3</code>: hypothesis has been rewritten, but missing a <code>assumption</code><br>\n<code>example4</code>: <code>Nat.not_eq_zero_of_lt n_pos</code> has type <code>n ≠ 0</code> (which <code>simp</code> will use as a rewrite rule <code>n ≠ 0 ↔ True</code>), so this works as a proof<br>\n<code>example5</code>: <code>Nat.not_eq_zero_of_lt</code> itself is an implication, and <code>simp</code> (apparently) doesn't use the other hypothesis for implications. If you had a lemma that has type <code>0 &lt; a → (a ≠ 0 ↔ True)</code>, then this would actually work, which you can see by running <br>\n<code>by simp only [fun a (h : 0 &lt; a) =&gt; iff_true_intro (Nat.not_eq_zero_of_lt h), n_pos]</code><br>\nNote that you can also use <code>simp at n_pos; simp [n_pos]</code> or <code>simpa using n_pos</code> (for the latter you need <code>import Mathlib.Tactic.Core</code>).<br>\n<code>example_fails</code> fails because <code>k + (n - k) - (n - k)</code> never occurs in your goal.</p>",
        "id": 385678073,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1692280335
    },
    {
        "content": "<p>I guess what confuses me is that, as you say, simp will close goals/hypotheses rewritten to <code>True/False</code>, but it does not use modus ponens on hypotheses.  But then your example explaining 5 seems like using modus ponens on the implication you devised and <code>n_pos</code> to get <code>True</code>.</p>",
        "id": 385718092,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1692292011
    },
    {
        "content": "<p>Furthermore, from what you are saying, lemmas of the form <code>p → q</code> are not followed, but those of the form <code>(p → (q ↔ True))</code> are; but those are equivalent: <code>(p → q) ↔ (p → (q ↔ True))</code>, so why is there a discrepancy here?  Should I rewrite all implications I want to use for <code>simp</code> in the form <code>(p → (q ↔ True))</code>?</p>",
        "id": 385719963,
        "sender_full_name": "Ioannis Konstantoulas",
        "timestamp": 1692292759
    },
    {
        "content": "<p>I think that is a bug/oversight in <code>simp</code>. We don't use <code>simp</code> all that much for lemmas with side conditions, and it is pretty likely that this case was not considered. Of course, there are many other tactics that can help you here.</p>",
        "id": 386667487,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1692727306
    }
]