[
    {
        "content": "<p>I often find myself writing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">baz</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- This is usually a small term mode term</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n</code></pre></div>\n<p>Is there an easier way to just use <code>baz</code> and convince Lean that it has the right type in one line?</p>",
        "id": 536417477,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756300375
    },
    {
        "content": "<p><code>foo ▸ baz</code> maybe?</p>",
        "id": 536420179,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756301171
    },
    {
        "content": "<p>Thanks, trying to do this with <code>(by simp) ▸ baz</code> this does not work. Is there a way to make it work? The simp proof actually uses a decent number of lemmas.</p>",
        "id": 536421385,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756301516
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"n\">baz</span>\n</code></pre></div>",
        "id": 536422178,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1756301749
    },
    {
        "content": "<p>Sadly both <code>x</code> and <code>y</code> are horrible, but I understand that this is a pretty idiomatic solution, thanks.</p>",
        "id": 536431682,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756304387
    },
    {
        "content": "<p>Wondering if Mathlib would like an <code>exact_by x p</code> that takes any <code>x : A</code> and a <code>p : A = Goal</code>, importantly <code>p</code> can be <code>by simp</code>.</p>",
        "id": 536432685,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756304673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"587858\">Fernando Chu</span> <a href=\"#narrow/channel/113489-new-members/topic/Simplifying.20the.20type.20of.20a.20term.20easily.3F/near/536432685\">said</a>:</p>\n<blockquote>\n<p>Wondering if Mathlib would like an <code>exact_by x p</code> that takes any <code>x : A</code> and a <code>p : A = Goal</code>, importantly <code>p</code> can be <code>by simp</code>.</p>\n</blockquote>\n<p>Try <code>convert x</code></p>",
        "id": 536445489,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756308270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Simplifying.20the.20type.20of.20a.20term.20easily.3F/near/536445489\">said</a>:<br>\nTry <code>convert x</code></p>\n<p>This is what I was looking for, great, thank you!</p>",
        "id": 536445911,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756308387
    },
    {
        "content": "<p>You shouldn't be using tactics to construct data, though</p>",
        "id": 536447255,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756308752
    },
    {
        "content": "<p>why not?</p>",
        "id": 536447707,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756308891
    },
    {
        "content": "<p>because presumably you care about which data gets constructed and many tactics don't give you control of that</p>",
        "id": 536448287,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1756309073
    },
    {
        "content": "<p>When in doubt \"don't use tactics to construct data\" is a very good rule of thumb.</p>\n<p>There are some exceptions when you know exactly what you need the data for and/or if you know exactly what the tactics are doing. The main reason for the rule is that tactics such as simp/convert/rw and the triangle operator insert casts (Eq recursors) to change types, and these are not friendly for definitional equality. (What Aaron said.)</p>\n<p>Even <code>cases</code> inserts casts as part of its normal operation.</p>\n<p>What you see are definitions in the library like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=decidable_of_iff#doc\">docs#decidable_of_iff</a> to be able to modify types of data in a controlled way. If your <code>P</code> is a specific type outside of this <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, then I'd suggest creating similar cast functions. You can find examples in the library as <code>MyType.cast</code> or <code>MyType.copy</code>, for reference.</p>",
        "id": 536452943,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1756310496
    },
    {
        "content": "<p>Thanks for the indepth explanation!</p>",
        "id": 536542489,
        "sender_full_name": "Fernando Chu",
        "timestamp": 1756364484
    }
]