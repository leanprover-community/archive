[
    {
        "content": "<p>First post. Hi Everyone!</p>\n<p>I'm David Gross, a theoretical physicist working on quantum information and mathematical physics. (There's a Nobel laureate by the same name. For better or worse, that's not me).</p>\n<p>I got interested in formal methods last year. As a medium-term project, I decided to have a go at formalization a general \"de Finetti theorem\".</p>\n<p>Background:</p>\n<p>The de Finetti Theorem of classical probability states that if a distribution of an infinite sequence of random variables is permutation-invariant, then it is a mixture of iid distributions.</p>\n<p>Importantly for my day job, there are quantum analogues of this result. They find applications in many-body theory (mean field limit), quantum communication (security proofs for key distribution), and computational methods (convergence of semi-definite programming hierarchies).</p>\n<p>What makes de Finetti's theorem an attractive formalization target is that it can be stated in the very general language of \"ordered vector spaces with order unit\". <a href=\"https://www.sciencedirect.com/science/article/pii/0022123668900165\">Here's an early example</a> of this genre. It doesn't use much structure beyond plain vector spaces and convex cones, but still specializes to both the quantum and the classical case.</p>\n<p>About a year ago, I've teamed up with Davood Tehrani to work out the details.</p>\n<p>(BTW: Davood has been active around here as @Paradoxy. He, and by extension me, have benefitted a lot from the very welcoming atmosphere of this space! Thanks everybody!)</p>\n<p>One piece of structure that <em>is</em> required is the notion of \"tensors with infinite index set, which are equal to a distinguished element on all but finitely many indices\". It's a well-known construction, e.g. in the theory of \"infinite tensor products\" of unital algebras, or of the \"local observable algebra\" of quantum statistical mechanics. A common realization is as an inductive limit of tensors indexed by finite subsets of some infinite set.</p>\n<p>When trying to express this in Lean, we ran into a TODO item of PiTensorProduct.lean: \"an API for the ways in which the index type can be split into subsets\".</p>\n<p>So to get off the ground, Davood and me had to put this piece of plumbing into place.</p>\n<p>We feel that our efforts are now ready for community review. PRs are about to be<br>\nposted. (Big moment! :-))</p>\n<p>On the one hand, the majority of the PRs is what I would think of as basic interface code. On the other hand, designing a useful API is hard, so we're looking forward to everybody's comments!</p>",
        "id": 562535034,
        "sender_full_name": "David Gross",
        "timestamp": 1765218597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"758749\">David Gross</span> <a href=\"#narrow/channel/113489-new-members/topic/David.20Gross/near/562535034\">said</a>:</p>\n<blockquote>\n<p>One piece of structure that <em>is</em> required is the notion of \"tensors with infinite index set, which are equal to a distinguished element on all but finitely many indices\"</p>\n</blockquote>\n<p>Hey! This looks a lot like the restricted product construction that <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> has been pushing for for FLT for a while now</p>",
        "id": 562535695,
        "sender_full_name": "YaÃ«l Dillies",
        "timestamp": 1765218856
    },
    {
        "content": "<p>It's a bit different and it's something we've not got in mathlib, it's restricted tensor product and like restricted product it's a colimit.</p>",
        "id": 562536160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765219021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/David.20Gross/near/562536160\">said</a>:</p>\n<blockquote>\n<p>It's a bit different and it's something we've not got in mathlib, it's restricted tensor product and like restricted product it's a colimit.</p>\n</blockquote>\n<p>\"Restricted tensor product\" -- excellent, now we've got a good name for it! We didn't know what to choose before, because the C^* people call it (or its norm closure) the \"infinite tensor product\" (emphasizing that there's no bound on the size of the sets), while the physicists call it the \"local algebra\" (emphasizing the exact opposite aspect, namely that each set is finite). <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 562559494,
        "sender_full_name": "David Gross",
        "timestamp": 1765228558
    },
    {
        "content": "<p>the Langlands people call it restricted tensor product (I didn't just make the term up!); it's how you make automorphic representations (representations of restricted products of groups) from local components.</p>",
        "id": 562560924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765229085
    },
    {
        "content": "<p>Our PRs have now been posted. We've broken the contribution into four pieces, with <a href=\"https://github.com/leanprover-community/mathlib4/pull/32609\">32609</a> referencing the earlier ones.</p>\n<p>Actually, a first question if I may: We've created each subsequent PR by branching off  of the previous one. This led to each PR including the commits of the PR it depends on. Is that how things should be handled? I imagine it makes code review difficult.</p>\n<p>We've checked existing PRs in the queue, and some show the same effect (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32594\">32594</a>), some don't (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32534\">32534</a>).</p>",
        "id": 562561428,
        "sender_full_name": "David Gross",
        "timestamp": 1765229339
    },
    {
        "content": "<p>Just looking at the place where I learnt about this stuff (Flath's \"decomposition of representations into tensor products\") and he claims that the concept is introduced in Jacquet-Langlands \"Automorphic forms on GL(2)\" (a book which is really quite hard to read IMO). Here's some Flath:</p>\n<p><a href=\"/user_uploads/3121/5R7-HUP-qz5hMc0TP9vLgs-0/Screenshot-from-2025-12-08-21-30-30.png\">Screenshot from 2025-12-08 21-30-30.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/5R7-HUP-qz5hMc0TP9vLgs-0/Screenshot-from-2025-12-08-21-30-30.png\" title=\"Screenshot from 2025-12-08 21-30-30.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"689x829\" src=\"/user_uploads/thumbnail/3121/5R7-HUP-qz5hMc0TP9vLgs-0/Screenshot-from-2025-12-08-21-30-30.png/840x560.webp\"></a></div>",
        "id": 562561692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765229444
    },
    {
        "content": "<p>PRs look good to me; nobody will review a PR with a depenency on an earlier one, they'll review the earlier ones first, so as things get merged you can merge master into the newer PRs. First one seems to be <a href=\"https://github.com/leanprover-community/mathlib4/pull/32598\">#32598</a> .</p>",
        "id": 562561814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1765229501
    },
    {
        "content": "<p>Thanks! </p>\n<p>In physics, people sometimes use the term \"incomplete tensor product\", after <a href=\"https://www.numdam.org/item/?id=CM_1939__6__1_0\">this early and lengthy paper</a> by von Neumann on the Hilbert space version.</p>",
        "id": 562562227,
        "sender_full_name": "David Gross",
        "timestamp": 1765229664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/David.20Gross/near/562561814\">said</a>:</p>\n<blockquote>\n<p>First one seems to be <a href=\"https://github.com/leanprover-community/mathlib4/pull/32598\">#32598</a> .</p>\n</blockquote>\n<p>That's right!</p>",
        "id": 562562331,
        "sender_full_name": "David Gross",
        "timestamp": 1765229702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"758749\">David Gross</span> <a href=\"#narrow/channel/113489-new-members/topic/David.20Gross/near/562561428\">said</a>:</p>\n<blockquote>\n<p>Our PRs have now been posted. We've broken the contribution into four pieces, with <a href=\"https://github.com/leanprover-community/mathlib4/pull/32609\">32609</a> referencing the earlier ones.</p>\n<p>Actually, a first question if I may: We've created each subsequent PR by branching off  of the previous one. This led to each PR including the commits of the PR it depends on. Is that how things should be handled? I imagine it makes code review difficult.</p>\n<p>We've checked existing PRs in the queue, and some show the same effect (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32594\">32594</a>), some don't (<a href=\"https://github.com/leanprover-community/mathlib4/pull/32534\">32534</a>).</p>\n</blockquote>\n<p>In GitHub you can specify the \"base\" branch of your PR. If you set the \"base\" to the one that you branched off of, it should display only the commits in that PR. However, I'm not sure if this is possible when it's a PR from a forked repo, and it might not be worth the trouble here (especially since fixing Git mishaps can be tricky).</p>",
        "id": 562578071,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1765238315
    },
    {
        "content": "<p>You should not do that, and instead keep the target branch as master. We will not review pull requests before their dependencies have been landed anyway</p>",
        "id": 562679924,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765285813
    },
    {
        "content": "<p>If the prs are independent rather than building up each on top of the other, you could (depending on your git proficiency) drop the previous work from the subsequent prs, though</p>",
        "id": 562680304,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1765285911
    },
    {
        "content": "<p>Thanks, Matt &amp; Ruben! I think I understand your workflow better now.</p>\n<p>As a result of the discussion, we have simplified the dependencies of our PRs. Things now look like this:</p>\n<p>Two short independent PRs:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32598\">Dependent <code>subsingletonEquiv</code></a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/32600\">Composition of multilinear maps</a></p>\n<p>Two longer ones depending on these:</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib4/pull/32608\">\"Set API\" for tensor indices</a><br>\n<a href=\"https://github.com/leanprover-community/mathlib4/pull/32609\">Nested PiTensorProducts</a></p>\n<p>(There's also <a href=\"https://github.com/leanprover-community/mathlib4/pull/32527\">two</a> <a href=\"https://github.com/leanprover-community/mathlib4/pull/32526\">chores</a> we addressed along the way.)</p>",
        "id": 562792975,
        "sender_full_name": "David Gross",
        "timestamp": 1765312473
    }
]