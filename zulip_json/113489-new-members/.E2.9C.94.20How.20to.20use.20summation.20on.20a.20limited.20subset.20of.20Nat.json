[
    {
        "content": "<p>Hi everyone!</p>\n<p>I'm new to lean and intrigued by the possibility to write provably correct programs. To get started I wanted to try to solve Project Euler problem 10 (Sum of all primes below n).<br>\nI easily implemented an efficient and correct solution using a Sieve of Erastothenes and am now trying to prove that the implemented function is equivalent to the problem statement.<br>\nBut without even getting to attempt a proof I'm already stuck at formalizing the problem. This is what I tried:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PrimesBelow</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Primes</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">PrimesBelow</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>It doesn't work because PrimesUpTo n does not have type Finset. So I'm trying to create a Finset from this set to use summation. But I'm completely stuck. Any hints how to formalize this?<br>\nOr is there some other sum notation that I should use that does not require a Finset?</p>",
        "id": 495977171,
        "sender_full_name": "ssar",
        "timestamp": 1737906314
    },
    {
        "content": "<p>A possible solution is to define <code>PrimesBelow</code> using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Ioo#doc\">docs#Finset.Ioo</a></p>",
        "id": 495978393,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1737907230
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.primesBelow#doc\">docs#Nat.primesBelow</a> in Mathlib (which returns a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset#doc\">docs#Finset</a>).</p>",
        "id": 495980015,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1737908521
    },
    {
        "content": "<p>If you want to build it yourself, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.filter#doc\">docs#Finset.filter</a> on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.range#doc\">docs#Finset.range</a> or <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Ico#doc\">docs#Finset.Ico</a></p>",
        "id": 495982850,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1737910557
    },
    {
        "content": "<p>Wow, thanks! NumberTheory.SmoothNumbers Is gold! Even has nice theorems to use for induction. Will go with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">primesBelow</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>Out of curiosity: while it's obviously equivalent, I was trying to put the wording of the problem exactly into a definition. \"primes below n\" to me reads like filtering the set of primes for the property p&lt; n, while all the suggestions here do the opposite (filtering integers below n using the predicate isPrime). Is it too pedantic to make a difference between these 2 ways of defining the set?</p>",
        "id": 495993431,
        "sender_full_name": "ssar",
        "timestamp": 1737918951
    },
    {
        "content": "<p>If you filter the primes (a <code>Set</code>) to only keep the numbers below n (a \"predicate\"), you get a <code>Set</code>, while if you filter the numbers below n (a <code>Finset</code>) to only keep the primes (a \"predicate\"), you get a <code>Finset</code>.</p>",
        "id": 496005140,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737928287
    },
    {
        "content": "<p>In other words, the set of numbers below n exists in the library both as a set (in theory could be infinite) and a finset (by construction finite), and filtering a finite set is clearly finite by construction. On the other hand, the set of all primes is infinite, and if you then take a subset of those, it needs a little thought to show that your set is indeed finite.</p>\n<p>(There's some more technical background, but this is why one direction is mathematically more sensible if you want a finite set)</p>",
        "id": 496008537,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1737931127
    },
    {
        "content": "<p>Got it, thanks!<br>\nIf I would really care about the difference of the 2 definitions I could still prove later that the 2 ways of defining the set are equivalent (though there's little value in doing this).</p>\n<p>Also, I realize now I should have used the search function in the mathlib documentation to find primesBelow. I was only looking through <a href=\"http://data.nat.prime\">data.nat.prime</a> expecting such definitions to be there if available.</p>",
        "id": 496083097,
        "sender_full_name": "ssar",
        "timestamp": 1737972205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870275\">ssar</span> has marked this topic as resolved.</p>",
        "id": 496089346,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737974153
    },
    {
        "content": "<p>For the purposes of finding lemmas, you can also use <a href=\"https://loogle.lean-lang.org/\">#loogle</a>, <a href=\"http://moogle.ai\">moogle.ai</a>, and <a href=\"http://leansearch.net\">leansearch.net</a></p>",
        "id": 496140911,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1737989541
    }
]