[
    {
        "content": "<p>I think you want ‚Äúgrind +simp‚Äù option?</p>",
        "id": 547326299,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761583386
    },
    {
        "content": "<p>I want such a option too.<br>\nI think ‚Äú@[simp]‚Äù tag and ‚Äú@[grind =]‚Äù tag tend to appear simultaneously‚Ä¶</p>",
        "id": 547326737,
        "sender_full_name": "Asei Inoue",
        "timestamp": 1761583509
    },
    {
        "content": "<p><code>grind</code> is not a better <code>simp</code>. Please refer to the reference manual sections for <a href=\"https://lean-lang.org/doc/reference/latest/The-Simplifier/#the-simplifier\">simp</a> and <a href=\"https://lean-lang.org/doc/reference/latest/The--grind--tactic/#grind-tactic\">grind</a>. They operate on fundamentally different ideas with <code>simp</code> aiming to be a confluent-as-possible rewriting system while <code>grind</code> works by combining equivalence classes of terms. While a lot of <code>simp</code> theorems are sensible grind theorems not all of them are.</p>",
        "id": 547329991,
        "sender_full_name": "Henrik B√∂ving",
        "timestamp": 1761584381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik B√∂ving</span>  I completely agree that they're different. But why do you think that not all <code>simp</code> lemmas are a sensible grind theorems? As far as I understand how <code>grind</code> works adding more lemmas to it won't stop it from being able to prove something it could before, the only downside being performance. I can agree that not all <code>simp</code> lemmas are needed for <code>grind</code>, or rather we can have better version of them. Current adoption of <code>grind</code> in mathlib is not anywhere near complete. Adding something like <code>grind +simp</code> sounds like a quick option to be able to start exploring using <code>grind</code> with mathlib. Once <code>grind</code> adoption is complete we can discourage using <code>grind +simp</code>.</p>",
        "id": 548074175,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1761885304
    },
    {
        "content": "<blockquote>\n<p>While a lot of <code>simp</code> theorems are sensible grind theorems not all of them are.</p>\n</blockquote>\n<p>I've heard this a few times and I think I would really benefit from some examples. (Also, having those examples in the documentation.) Cause I haven't been able to think of a case myself, probably because I don't fully grok grind myself.</p>",
        "id": 548158331,
        "sender_full_name": "Alex Meiburg",
        "timestamp": 1761917685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"448405\">@Alex Meiburg</span> here's a (not so good) example. Though I'm not even sure if <code>grind</code> is expected to fail.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieRing</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">lie_smul</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">lie_smul</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- invalid `grind` theorem, failed to find an usable pattern using different modifiers</span>\n</code></pre></div>",
        "id": 553315696,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1762155191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"372804\">Marcus Rossel</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20.60grind.60.20isn't.20using.20.60simp.60.20lemmas.3F/near/553315696\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"448405\">Alex Meiburg</span> here's a (not so good) example. Though I'm not even sure if <code>grind</code> is expected to fail.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CommRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieRing</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">lie_smul</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">‚Ä¢</span><span class=\"w\"> </span><span class=\"bp\">‚ÅÖ</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">‚ÅÜ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LieAlgebra</span><span class=\"bp\">.</span><span class=\"n\">lie_smul</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- invalid `grind` theorem, failed to find an usable pattern using different modifiers</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>But that's only an example of a theorem that cannot be used with grind. It's not an example of a theorem that's good for simp and bad for grind.<br>\nThat only means that <code>grind +simp</code> would probably not use all simp theorems. And that's assuming this would work by just adding simp theorems as grind theorems (which isn't very helpful, this could be automated with some script).</p>",
        "id": 553322439,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762157997
    },
    {
        "content": "<p>7 messages were moved here from <a href=\"#narrow/channel/113489-new-members/topic/Why.20.60grind.60.20isn.27t.20using.20.60simp.60.20lemmas.3F\">#new members &gt; Why &#96;grind&#96; isn't using &#96;simp&#96; lemmas?</a> by <span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span>.</p>",
        "id": 553323450,
        "sender_full_name": "Notification Bot",
        "timestamp": 1762158380
    },
    {
        "content": "<p><code>LieAlgebra.lie_smul</code> is just a bad lemma because of <a href=\"https://github.com/leanprover/lean4/pull/9727\">lean#9727</a>, which needs to be fixed.</p>",
        "id": 553333841,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762161870
    },
    {
        "content": "<p>It's a good question, with a few angles on the answer.</p>\n<ol start=\"0\">\n<li>Yes, <code>@[simp]</code> implies <code>@[grind =]</code> is a good zero-th approximation for adding annotations.</li>\n<li>It might lead to grind annotations that are not as good as they might be (with or without the use of <code>+simp</code>), and going slightly slower (i.e. encouraging, by requiring, users to think about the annotations for their libraries) may reach a better endpoint.</li>\n<li>It's not entirely trivial to implement: stuff is happening (i.e. patterns are being identified and indexed) at the time we write <code>@[grind]</code> or <code>grind_pattern</code>, and this would have to be hooked into <code>@[simp]</code> to also run then: you can't just, at tactic run time, decide to throw in all <code>simp</code> lemmas.</li>\n<li>It's pretty common to write <code>@[grind =]</code> on lemmas with an <code>if</code> on the right hand side (taking advantage of <code>grind</code>s case bashing power), but we tend not to want to do this for <code>@[simp]</code>. Conflating, even partially, <code>@[grind =]</code> and <code>@[simp]</code> might lead to deterioration in <code>@[simp]</code> sets (by people adding <code>@[simp]</code> in order to enable it in <code>grind</code>, and not realising that it causes a problem in <code>simp</code>.</li>\n</ol>\n<p>That all said, it's not crazy to try it out. We do need to make <code>grind</code> easier to use in situations where the library hasn't been annotated at all. As of a recent nightly we now have <code>grind +suggestions</code> which uses a (configurable) premise selection engine to add many theorems into the grind set at tactic invocation time. This will hopefully get a lot more powerful in coming releases, as we tune the premise selection engines, and enable using external neural engines.</p>",
        "id": 553333867,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1762161879
    },
    {
        "content": "<p>Is there some programmatic way of detecting some goals that <em>definitely</em> should have the <code>grind</code> attribute and link that to a linter?</p>",
        "id": 553334425,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1762162037
    },
    {
        "content": "<p>Not particularly that I can think of.</p>",
        "id": 553362968,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1762170746
    },
    {
        "content": "<p>I was thinking that we could use <code>simp</code> lemmas in <code>grind</code> differently than other <code>grind</code> lemmas. When the algorithm picks an expression A, applies some <code>grind</code> lemmas to it, which results in some expression B, we could then apply <code>simp</code> algorithm to the expression B. And then we could either add both to the e-graph, or completely forget about B. But always applying <code>simp</code> algorithm and forgetting about B can lead to failure in proofs <code>grind</code> would have been successful otherwise.</p>",
        "id": 553546186,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1762243130
    },
    {
        "content": "<blockquote>\n<p>Yes,¬†<code>@[simp]</code>¬†implies¬†<code>@[grind =]</code>¬†is a good zero-th approximation for adding annotations.</p>\n</blockquote>\n<p>Focusing on this point (since I don't have a strong opinion on the other things discussed here), are there concrete examples where <code>@[simp]</code> is good where <code>@[grind =]</code>isn't? And while reading the manual is of course the correct thing to do, what's the first-order correction needed for this approximation?</p>",
        "id": 553989625,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762391425
    },
    {
        "content": "<p>Wasn't it recommended to not tag lemma with grind if they are about algebra, such as <code>add_zero</code>, because matching on such patterns is messy (and redundant) due to the sattelite solvers of <code>grind</code>?</p>",
        "id": 553990455,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762392026
    },
    {
        "content": "<p>Oh yeah, good point!</p>",
        "id": 553991822,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392935
    },
    {
        "content": "<p>So the first-order approximation might be \"if it's simp, make it grind =, unless it's ringy\"</p>",
        "id": 553991869,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1762392962
    },
    {
        "content": "<p>Sounds about right for the time being, but doesn't appear to scale... we are one step away from 'unless one of the satellite solvers doesn't like that', and then you need this bag of trivia to not step on an arbitrary landmine that evolves over time.</p>",
        "id": 554046417,
        "sender_full_name": "Franti≈°ek Silv√°≈°i ü¶â",
        "timestamp": 1762423167
    },
    {
        "content": "<p>I haven't looked closely at the way <code>grind</code> indexes patterns, but it uses something else than the <code>DiscrTree</code> used by <code>simp</code>. So that may also play a role in determining what is or isn't a good <code>grind</code> annotation.</p>",
        "id": 554062991,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1762427771
    }
]