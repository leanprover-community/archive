[
    {
        "content": "<p>I just started working with Lean and as an exercise I was able to proof that a strictly upper triangular matrix is nilpotent (which seems not yet be available in mathlib). What I am actually interested in are proofs concerning  the Jordan Canonical Form and the more general Kronecker canonical form for matrix pencils. So my questions are: Is a proof for the existence of the Jordan Canonical Form already available in Mathlib? I suppose the Kronecker Canonical Form is not yet available? And would it make sense to commit the above mentioned proof about strictly upper triangular matrices into Mathlib?</p>",
        "id": 565782398,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767097384
    },
    {
        "content": "<p>No one here interested in linear algebra?</p>",
        "id": 566181157,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767479089
    },
    {
        "content": "<p>The closest I was able to find to the decomposition to Jordan Canonical Form is the Jordan–Chevalley–Dunford decomposition over perfect fields: <code>Module.End.exists_isNilpotent_isSemisimple</code>. Lean often likes to do things abstractly (if possible with Modules rather than vector spaces, etc.). I think the Jordan Canonical form could be possibly obtained from the decomposition to a nilpotent &amp; semisimple endomorphisms but probably requires some more work.</p>",
        "id": 566183251,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1767482037
    },
    {
        "content": "<p>Thanks for pointing me to the Jordan-Chevalley-Dunford decomposition, I didn't know about this form. I fully appreciate to proof certain properties in an as much as possible abstract setting, however, the danger is then that LEAN's mathlib becomes harder to use for average mathematicians, who e.g. just want to prove some properties of finite matrices. OK, but it is good to know, that there are quite a few gaps in the area of (finite-dimensional) linear algebra (i.e. matrix results), which I can try to fill by myself.</p>",
        "id": 566210618,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767519510
    },
    {
        "content": "<p>There is nothing wrong about having in mathlib the concrete form of a result, but the point is that it should be deduced by the general one, not proved separately. This ensures that various parts of the library use the same definitions and also shows that the general version is actually usable.</p>\n<p>Concerning Jordan's canonical form, I think that it's not completely clear how to write down a concrete statement. Working with matrices is unfortunately a little annoying, especially with submatrices. The reason is that informally one moves freely between indexes of the submatrix and of the big one, in the \"obvious\" way. In particular I guess the first step here is to write down a formal statement, before even starting to think about the proof.</p>",
        "id": 566212622,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767521673
    },
    {
        "content": "<p>Anyway we also have the classification of finitely generated module over a PID, so the math to prove the theorem is there.</p>",
        "id": 566212652,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767521699
    },
    {
        "content": "<p>So maybe a first step would be to make the working with matrices more straightforward (introducing e.g. submatrices, ...) because there are many results in linear algebra which are in fact about certain matrix structure. For example many text-books define the rank of a matrix by first tranforming it via Gauss-Elimination into Reduced Row Echelon Form and then count the number of non-zero rows. This is based on the theorem, that every matrix can be transformed into Reduced Row Echelon Form via elementary row operations. This theorem is really about the matrix representation and cannot (I think) be formulated on an abstract level of linear maps.</p>",
        "id": 566215036,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767524330
    },
    {
        "content": "<p>Submatrices are already there, see for example <code>Mathlib.Data.Matrix.Block</code>. The point is that what we do informally is just difficult to translate formally.</p>",
        "id": 566216043,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767525549
    },
    {
        "content": "<p>I wonder what the underlying reason is for \"what we do informally is just difficult to translate formally\" specificially for Matrix calculus? After all Matrix calculus is taught in the first year at university, so there seems to be not too much abstract formalism involved to understand it?</p>",
        "id": 566219626,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767529708
    },
    {
        "content": "<p>It is related with indexes. Here is a simple example: a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">4 \\times 4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">4</span></span></span></span> matrices with real coefficients is informally just a table of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">16</span></span></span></span> real numbers, written <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>m</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M = (m_{i,j})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>. Now, in Lean it is a function <code>M : Fin 4 → Fin 4 → ℝ</code> (here <code>Fin n</code> is the set <code>0, 1, ..., n-1</code>, the \"standard\" set with <code>n</code> elements), so you write <code>M i j</code> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>m</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">m_{i,j}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span>. So far so good. Now, if you want to speak about the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2 \\times 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span> submatrix in the upper left corner, informally you can use this sentence, and call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy=\"false\">(</mo><msub><mi>n</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi></mrow></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">N = (n_{i,j})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, and the relation between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is obvious. If you want to define <code>N</code> in Lean you may try <code>N : Fin 2 → Fin 2 := fun i j ↦ M i j</code>, but this <em>doesn't make sense</em>, since if <code>i : Fin 2</code> you cannot write <code>M i</code>, as <code>M</code> want a term of type <code>Fin 4</code>! So you have to insert manually the canonical map <code>Fin 2 → Fin 4</code>. This is totally doable, but the map will be there, and you  will see it in every statement. Things are even more convoluted if you want to take another submatrix.</p>\n<p>There is nothing really difficult here, it's totally doable, but this kind of annoyances tend to appear <em>a lot</em> and in practice they make things quite annoying.</p>\n<p>In my opinion the reason behind this is that we just don't say what a matrix is when we work informally, we have a (very good!) intuitive idea and that's enough.</p>",
        "id": 566220633,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767530816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"1009773\">Stephan Trenn</span> <a href=\"#narrow/channel/113489-new-members/topic/Jordan.20Canonical.20Form.20and.20similar.20matrix.20forms/near/566219626\">said</a>:</p>\n<blockquote>\n<p>..., so there seems to be not too much abstract formalism involved to understand it?</p>\n</blockquote>\n<p>This is exactly the problem! It's not abstract, it is very concrete, and experience has shown it's much harder to formalize concrete statements.</p>",
        "id": 566221037,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767531221
    },
    {
        "content": "<p>Interesting! So the issue seems to be to have an easy to work with notation of block matrices. For example if I have two large matrices A and B which are decomposed as A = [A11, A12; A21, A22] and B = [B11, B12; B21, B22] then A * B can be obtained by just treating A and B as 2x2 (block-)matrices and apply the multiplication rule for the 2x2 case.</p>",
        "id": 566221102,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767531300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Jordan.20Canonical.20Form.20and.20similar.20matrix.20forms/near/566220633\">said</a>:</p>\n<blockquote>\n<p>So you have to insert manually the canonical map <code>Fin 2 → Fin 4</code></p>\n</blockquote>\n<p>Isn't that what \"coercion\" is about in lean, do automate these kind of imbeddings?</p>",
        "id": 566221322,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767531492
    },
    {
        "content": "<p>There is no coercion from <code>Fin n</code> to <code>Fin m</code>, since this is meaningful only when <code>n ≤ m</code> (there is the map of course, it's <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Fin/Basic.html#Fin.castLE\">Fin.castLE</a>, but maybe you prefer <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Data/Fin/Basic.html#Fin.castAdd\">Fin.castAdd</a>, those are mathematically the same but for Lean are different). And anyway if you want to consider another block things are more complicated.</p>\n<p>For example, here is the statement that matrices multiplication can be done block by block (with 4 blocks): <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Matrix/Block.html#Matrix.fromBlocks_multiply\">Matrix.fromBlocks_multiply</a>. It's not that bad, but you need this <code>fromBlocks</code>, and if you have several blocks (like in Jordan form) things can be really painful.</p>",
        "id": 566221780,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767531892
    },
    {
        "content": "<p>But again, I am not saying that it isn't doable, but that first of all one should think about a reasonable statement, the proof will come later. There are surely various discussion about Jordan's canonical form.</p>",
        "id": 566221828,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767531934
    },
    {
        "content": "<p>So looking at Mathlib.Data.Matrix.Block, a 2x2 block matrix is defined just as a \"flat\" data structure consisting of four submatrices. I think the first step would be to introduce a general Block-Matrix Type which is a Matrix with different types in each entry, so something like \"BlockMatrix (n1, n2, ..., nk) (m1, m2, ..., ml) \\alpha\" where each ni and mi are Fin-types. Is there actually a Fin-Fin type consisting of finite sequence of finite sequences? I guess this has already been discussed before?</p>",
        "id": 566222517,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767532790
    },
    {
        "content": "<p>If <code>T</code> is any type the best way of saying \" an ordered <code>n</code>-tuple of terms of type <code>T</code> is a function <code>Fin n → T</code>\".</p>",
        "id": 566222619,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767532948
    },
    {
        "content": "<p>Hmm, but n : Fin k -&gt; Fin n does't work because each \"n k\" is not of type Fin n, but each entry has its own length, actually we are interested in tuples of finite length where the entries add up to n. So we need a Type parametrized by n (the total number of columns / row) which consists of all finite tuples of natural numbers whose entries add up to n.</p>",
        "id": 566223267,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767533762
    },
    {
        "content": "<p>You are starting to hit the \"annoyances\" I mentioned above. Usually the best way is to not use <code>Fin n</code> to parametrize matrices, but use any <code>Fintype</code> (as it is done in the theorem about block multiplication). The target will be a matrix indexed by some <code>Σ</code> type.</p>",
        "id": 566223697,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767534285
    },
    {
        "content": "<p>I started very briefly down this path long ago when I defined <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Matrix.blockDiagonal%27#doc\">docs#Matrix.blockDiagonal'</a></p>",
        "id": 566254915,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767566289
    },
    {
        "content": "<p>A piece of the puzzle you might want is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A block matrix produced from multiple blocks.</span>\n\n<span class=\"sd\">Compare to `Matrix.fromBlocks` which is for just two blocks. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"bp\">.</span><span class=\"n\">sigmaBlocks</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">κ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"w\"> </span><span class=\"n\">j'</span>\n</code></pre></div>",
        "id": 566255137,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767566560
    },
    {
        "content": "<p>Or maybe (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=DMatrix#doc\">docs#DMatrix</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- A block matrix produced from multiple blocks.</span>\n\n<span class=\"sd\">Compare to `Matrix.fromBlocks` which is for just two blocks,</span>\n<span class=\"sd\">or `Matrix.comp` which is for equally-sized blocks. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DMatrix</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DMatrix</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">toFun</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"w\"> </span><span class=\"n\">j'</span>\n<span class=\"w\">  </span><span class=\"n\">invFun</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"w\"> </span><span class=\"n\">j'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">j'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">left_inv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">right_inv</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"sd\">/-- `DMatrix.comp` as an additive equivalence. -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">simps!</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">DMatrix</span><span class=\"bp\">.</span><span class=\"n\">compAddEquiv</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Add</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">DMatrix</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≃+</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">Σ</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">DMatrix</span><span class=\"bp\">.</span><span class=\"n\">comp</span>\n<span class=\"w\">  </span><span class=\"n\">map_add'</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 566255513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767567030
    },
    {
        "content": "<p>Thanks for sharing the code. I was thinking that maybe a recursive approach to handle block matrices would work better, where a block matrix is either a matrix (leaf-case) or a 2x2 matrix consisting of block matrices. A similar structure could also be applied to the underlying vector space, which is defined as a direct sum of either a vector space (leaf-case) or another direct sum. Such a recursive direct sum of the vector space immediately defines a corresponding recursive block matrix representation of any linear map. Does this make sense?</p>",
        "id": 566285364,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767596464
    },
    {
        "content": "<p>I suspect that is not going to be convenient in practice, and using sigma types is the better bet</p>",
        "id": 566291263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1767599449
    },
    {
        "content": "<p>I haven't worked with sigma types yet and it may be indeed easier to work with them. However, for the use cases I have in mind, it seems more natural to have a recursive structure. For example, one approach to obtain the Jordan Canonical form is to first split the underlying vector space into the generalized (invariant) eigenspaces. This splitting already provides a high-level block matrix (and already on that level, you have a recursive structure: You pick one eigenvalue, define the generalized eigenspace and decompose the vector space into the direct sum of this eigenspace and the rest). As a next refinement step, you further decompose the individual generalized eigenspaces according to a filtering procedure into the smaller invariant subspaces corresponding to individual Jordan-blocks. Having a recursive block matrix structure makes this process very easy to implement I think.</p>",
        "id": 566294426,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767600692
    },
    {
        "content": "<p>I also think that sigma types are the way to go, but I may be wrong. The only way to know is to try and see what happens.</p>",
        "id": 566295419,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1767601089
    },
    {
        "content": "<p>Hello! I found this thread and I am glad to see if it has recently been active. Does anyone know if there is anyone working on RREF or row operations in lean? Or if there is any available code for these kinds of constructions? I am working on another library for formally verifying software, and I need some way to solve a linear system in lean (or determine that system is inconsistent). It seems like it should be doable, though maybe cumbersome, to prove that RREF exists constructively and then use this to solve the linear system.</p>",
        "id": 566661674,
        "sender_full_name": "Desmond Coles (UT Austin)",
        "timestamp": 1767761197
    },
    {
        "content": "<p>It seems there is no result concerning RREF in Mathlib directly and the reason may be similar to why there is not yet a result about the Jordan Canonical form: It is not yet clear, what the \"best\" way is to actually formalize the structure defining the corresponding normal forms. As mentioned above, it seems to me that a recursive block-structure would be easiest to implement (also for the proof). Specifically for the RREF, one could try to come up with a recursive definition, at least for the non-canonical RREF (where there is not yet the requirement that there should be zeros above the pivots) this should be straight-forward and the proof of existence is also straight-forward based on this recursion.</p>",
        "id": 566685906,
        "sender_full_name": "Stephan Trenn",
        "timestamp": 1767775954
    }
]