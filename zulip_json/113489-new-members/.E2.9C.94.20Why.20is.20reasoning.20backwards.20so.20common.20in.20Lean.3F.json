[
    {
        "content": "<p>As I learn Lean I'm noticing an emphasis on working \"backwards\" via <code>apply</code>. It took me a bit to get used to and although I feel more comfortable with it now, this style still feels a bit surprising â€” in the mathematical books I've read, the proofs tend to be described in the \"forward\" direction.</p>\n<p>Is there any particular reason that thinking \"backwards\" is so common (or perhaps even favored) in Lean? My guess would be that it lets the type inference shine (because when you work backwards, the goal is unambiguous, whereas a computer can't guess which of the available facts to use when moving forwards). I'm curious whether my guess is correct and whether there are any deeper reasons why <code>apply</code> shows up so much in the learning materials.</p>",
        "id": 498403531,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1738953107
    },
    {
        "content": "<p>I don't know if you've tried writing proof terms by hand (that is, without using <code>by</code> and tactic mode) yet, but indeed, working with <code>apply</code> is very similar to letting the type errors guide you towards a solution when constructing explicit proof terms. I think the name <code>apply</code> comes from function application, which is basically all that proof terms are made out of.</p>",
        "id": 498405565,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1738953897
    },
    {
        "content": "<p>Well I'd say that when making a proof, it tends to be easier to work backwards from the goal because then you have a limited set of theorems that you can use and your goal constantly becomes simpler and simpler. When proving forwards, you'll need to know more of how you want to approach your goal and you need to make sure that the path you're using actually gets you to where you want. However, it can be easier to <em>read</em> a proof forwards because then the steps are easier to understand. Metamath (another, very minimalistic theorem prover) actually has a very interesting approach that somewhat reflects this: When you prove a statement in Metamath, you're working backwards from the goal, assigning theorems to proof steps. But the proofs themselves are actually stored forwards and shown forwards.</p>",
        "id": 498406420,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1738954265
    },
    {
        "content": "<p>I suspect there's something to it that when going backwards, the new subgoals \"fall out\" of the application automatically, while going forward, you'd need to write a lot of them out explicitly before combining all the steps at the end. That also means that you get the subgoals in the exact shape that you need them, rather than any of the numerous equivalent but subtly different shapes that you might come up with yourself</p>",
        "id": 498406875,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738954461
    },
    {
        "content": "<p>Though I wouldn't say that proofs are often written only in a backwards or forwards style; mostly people combine them in whatever way makes sense to them</p>",
        "id": 498407153,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1738954570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 498413074,
        "sender_full_name": "Notification Bot",
        "timestamp": 1738956775
    },
    {
        "content": "<p>I actually think that forward reasoning is more common in Lean than it seems. While individual proofs seem to use backwards reasoning, Lean proofs tend to rely a lot more on lemmas than informal proofs, which can be seen as a type of forward reasoning. If an informal proof is 5 \"steps\" long, where each step is like \"We know ... because ...\" or \"It is clear that ...\", then in Lean, each of those steps might become its own lemma.</p>\n<p>I think the reason why forward reasoning is seemingly not used much in tactic mode is that a lot of the time, when you might be tempted to write <code>have h : ... := ...</code>, it often makes sense to move <code>h</code> out of the theorem into its own lemma. What is left is the backwards reasoning, which often can't easily be moved out of the theorem. Of course, it doesn't always make sense to extract proof to their own lemmas, especially with highly complicated proofs, but I think this explains why you see <code>apply</code> more often than <code>have</code>.</p>",
        "id": 498430701,
        "sender_full_name": "Niels Voss",
        "timestamp": 1738964344
    }
]