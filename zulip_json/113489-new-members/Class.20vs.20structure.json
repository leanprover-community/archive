[
    {
        "content": "<p>What is the convention in mathlib for choosing between using <code>structure</code> and <code>class</code> when defining, say, a group? If i understand correctly <code>class</code> is just syntax for <code>structure</code></p>",
        "id": 242515575,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1623596923
    },
    {
        "content": "<p>As far as I understand, a <code>class</code> is a <code>structure</code> that you can assume in square brackets, e.g <code>[my_class X]</code>, signaling Lean that it should find that assumption when you call that lemma, instead of having to provide it yourself.</p>",
        "id": 242515852,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1623597276
    },
    {
        "content": "<p>oh so <code>@[class]</code> tells lean to internalise any <code>instance</code> of the <code>class</code> so we don't have to write out what the lemma proving the <code>instance</code> was called</p>",
        "id": 242516091,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1623597558
    },
    {
        "content": "<p>There's a longer discussion in chapter 10 of <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a>: <a href=\"https://leanprover.github.io/theorem_proving_in_lean/type_classes.html\">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>",
        "id": 242516149,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623597621
    },
    {
        "content": "<p>One big difference between class and structure is that classes are used in situations where most of the time you expect only one instance per class, and structures are used when there might normally be several instances. For example <code>group G</code>(the type of group structures on G)  is a class because given a set/type G which is going to be a group, one would in general expect there to be only one group structure on G. On the other hand <code>subgroup G</code> (the type of subgroups of G) is a structure not a class, because in general it's completely reasonable to expect there to be more than one subgroup of G showing up in an argument, so you don't want to pick a \"special\" one.</p>",
        "id": 242520972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1623604705
    },
    {
        "content": "<p>Along the lines of what Kevin is saying, something that classes implement is the way we use synecdoche in mathematics.  Synecdoche is a figure of speech where a part stands for the whole (like \"nice wheels\" to compliment someone's car) or vice versa.  When we say \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> be a group\" we treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> as if it were its underlying set, even though a group is actually a structure that includes the set.  This is convenient because we can, for example, seamlessly treat <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> as if it were a monoid, too, even though that's a different structure, because we can infer the intended structure.  So, to implement this, we can translate \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> be a group\" to \"let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> be a type that 'is' a group,\" where 'is' means \"has an associated instance\" (in code: <code>(G : Type*) [group G]</code>).  This way, we refer to a group by its underlying type, and Lean fills in the rest.</p>\n<p>By the way, you can make other things classes, not just structures.  For example, here is an ill-advised thing that's possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">class</span><span class=\"o\">]</span> <span class=\"n\">nat</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">bar</span>\n<span class=\"c1\">-- results in 37</span>\n</code></pre></div>",
        "id": 242550180,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1623644703
    },
    {
        "content": "<p>Why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure#doc\">docs#MeasureTheory.Measure</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.OuterMeasure#doc\">docs#MeasureTheory.OuterMeasure</a> are structures, whereas <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure#doc\">docs#MeasureTheory.ProbabilityMeasure</a> is a subtype? If type classes are ways to group types together, shouldn't it also be a structure?</p>",
        "id": 463398908,
        "sender_full_name": "jsodd",
        "timestamp": 1724072504
    },
    {
        "content": "<p>We used to use subtypes more in the past, and some types didn't migrate to structures yet.</p>",
        "id": 463419352,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724077398
    },
    {
        "content": "<p>The main benefit of using a subtype is that you can reuse lemmas about <code>Subtype</code>, but we try  to establish API anyway, so it makes sense to migrate probability measures to structures.</p>",
        "id": 463419938,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724077510
    },
    {
        "content": "<p>Note that most of the probability theory in Mathlib is done for <code>(Œº : Measure _) [IsProbabilityMeausre Œº]</code>, not a bundled <code>ProbabilityMeasure</code>.</p>",
        "id": 463420055,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724077550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Thanks for the explanation! If I wanted to introduce some standard classes of probability measures, such as Gaussian measures on finite and infinite dimensional spaces, Levy measures and so on, what would be the best approach? Using classes, structures or subtypes?</p>",
        "id": 463421536,
        "sender_full_name": "jsodd",
        "timestamp": 1724077966
    },
    {
        "content": "<p>For continuous distributions, see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.gaussianPDFReal#doc\">docs#ProbabilityTheory.gaussianPDFReal</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.gaussianReal#doc\">docs#ProbabilityTheory.gaussianReal</a> for an example.</p>",
        "id": 463450585,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724084746
    },
    {
        "content": "<p>This is just one parametric family of univariate distributions. In this case it is clear that just defining it as one function is enough. General Gaussian measures are much richer and it would be fair to call them a \"class\", which is why I ask what is the right way to set up things like this.</p>",
        "id": 463452571,
        "sender_full_name": "jsodd",
        "timestamp": 1724085344
    },
    {
        "content": "<p>It's just that from my point of view, the difference between defining something as a class or a structure is more or less clear to me from these discussions (class = structure with implicit type argument, which is supposed to be inferred from the context, right?), but the benefits of preferring classes/structures over subtypes is not.</p>",
        "id": 463453905,
        "sender_full_name": "jsodd",
        "timestamp": 1724085834
    },
    {
        "content": "<p>By the way, it seems technically possible to use classes as structures through <code>@</code>. I guess the guideline for choosing between the two should be \"if you find yourself in need of using <code>@</code> with a class, then it should be a structure`.</p>",
        "id": 463460716,
        "sender_full_name": "jsodd",
        "timestamp": 1724087357
    },
    {
        "content": "<p>This is <em>not</em> the distinction between <code>class</code> and <code>structure</code>. The correct distinction is that <code>instance</code>s of <code>class</code>es (you can't have one for a <code>structure</code>) can be inferred automatically via type class synthesis. This is what allows, for example, the lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_one#doc\">docs#mul_one</a> to be applied to solve <code>x * 1 = x</code> when <code>x : ùïú</code> and where there is a <code>[Field ùïú]</code> instance in context, despite the fact that there is no mention of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Field#doc\">docs#Field</a> in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=mul_one#doc\">docs#mul_one</a>. (but there is a chain of instances from <code>Field</code> to <code>MulOneClass</code>.)</p>",
        "id": 463463513,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1724088111
    },
    {
        "content": "<p>Also, any <code>instance</code> of a <code>class</code> should be (essentially) unique modulo the explicit parameters to the type on which the instance is placed. In contrast, you can have as many <code>def</code>s of a <code>structure</code> as you want on the same type.</p>",
        "id": 463464022,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1724088256
    },
    {
        "content": "<p>For instance, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int#doc\">docs#Int</a> should only have one <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LinearOrderedCommRing#doc\">docs#LinearOrderedCommRing</a> instance (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.instLinearOrderedCommRing#doc\">docs#Int.instLinearOrderedCommRing</a>), but it could potentially have many <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Subgroup#doc\">docs#Subgroup</a>.</p>",
        "id": 463464468,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1724088386
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Class.20vs.20structure/near/463464022\">said</a>:</p>\n<blockquote>\n<p>should be (essentially) unique</p>\n</blockquote>\n<p>What's the modality of this \"should be\"? Does it mean that it's bad practice and misuse of classes? Because it seems that it's possible to define many, is it not?</p>",
        "id": 463464890,
        "sender_full_name": "jsodd",
        "timestamp": 1724088515
    },
    {
        "content": "<p>Bad practice, yeah</p>",
        "id": 463465040,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1724088569
    },
    {
        "content": "<p>Sometimes the bad practice is acceptable, because it's too inconvenient to do it right. For example, there can be multiple topological space structures on the same type, and the type <code>TopologicalSpace X</code> is an interesting type on its own, with interesting and useful theory. Ideally when you work with the type as a mathematical object it would be a structure, but outside this part of the theory you want it to be a class ‚Äî you want to work with X and have the TopologicalSpace structure be automatically associated to it. But, inside the theory you're breaking the rule that there should only be one instance per <code>X</code>.</p>",
        "id": 463466466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724088922
    },
    {
        "content": "<p>Okay, I see. But what about subtypes? Using the example from above, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.ProbabilityMeasure#doc\">docs#MeasureTheory.ProbabilityMeasure</a> is a subtype, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.Measure#doc\">docs#MeasureTheory.Measure</a> is a structure. Why prefer structures to subtypes?</p>",
        "id": 463475794,
        "sender_full_name": "jsodd",
        "timestamp": 1724091395
    },
    {
        "content": "<p>Subtypes are themselves just structures</p>",
        "id": 463509851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1724100212
    },
    {
        "content": "<p>The more I compare what is a structure and what is a class in the library, the more I feel lost despite all the great explanations I've received above. If the notion of a class is for making instances, why <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.IsMarkovKernel#doc\">docs#ProbabilityTheory.IsMarkovKernel</a> is a class but <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.ProbabilityMeasure#doc\">docs#ProbabilityTheory.ProbabilityMeasure</a> isn't? On one side it's perfectly common to have many Markov kernels in a given context, but on the other the notion of \"markov-kernelness\" is one and only and there's no way to change it. Shouldn't <code>ProbabilityMeasure</code> be a class for the same reason?</p>",
        "id": 463597270,
        "sender_full_name": "jsodd",
        "timestamp": 1724132468
    },
    {
        "content": "<p><code>IsMarkovKernel</code> is a typeclass saying that a given <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ProbabilityTheory.Kernel#doc\">docs#ProbabilityTheory.Kernel</a> is a Markov kernel. Lean will automatically find an instance of this class in the environment and use it as needed. There can be more than one <code>ProbabilityMeasure</code> on a type, so this is not a class. OTOH, <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MeasureTheory.IsProbabilityMeasure#doc\">docs#MeasureTheory.IsProbabilityMeasure</a> is a class.</p>",
        "id": 463603109,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724134220
    },
    {
        "content": "<p>And most of the probability theory code in Mathlib deals with <code>(Œº : Measure _) [IsProbabilityMeausre Œº]</code></p>",
        "id": 463603199,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1724134266
    }
]