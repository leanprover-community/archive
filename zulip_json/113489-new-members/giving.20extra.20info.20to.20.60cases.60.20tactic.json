[
    {
        "content": "<p>(<em>not a new member, but potentially silly question anyway</em>)<br>\nI have this <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>-ed MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.SetTheory.Ordinal.Basic</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Sigmo</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">basic</span> <span class=\"o\">:</span> <span class=\"n\">Sigmo</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">unio</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Sigmo</span> <span class=\"n\">y</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigmo</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sigmo</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigmo</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">aesop</span>\n</code></pre></div>\n<p><code>cases</code> realizes at once that  <code>(1 : ℕ)</code> is indeed different from <code>(0 : ℕ)</code> and only handles the <code>unio</code> case to <code>aesop</code>. But the same def with <code>Ordinal</code> that does not seem to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">Sigme</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ordinal</span> <span class=\"bp\">→</span> <span class=\"n\">Set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n  <span class=\"bp\">|</span> <span class=\"n\">basic</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">x</span>\n  <span class=\"bp\">|</span> <span class=\"n\">unio</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"n\">i</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"c\">/-</span>\n<span class=\"cm\">  dependent elimination failed, failed to solve equation</span>\n<span class=\"cm\">    Quot.mk Setoid.r { α := PUnit, r := EmptyRelation, wo := (_ : IsWellOrder PUnit EmptyRelation) } =</span>\n<span class=\"cm\">      Quot.mk Setoid.r { α := PEmpty, r := EmptyRelation, wo := (_ : IsWellOrder PEmpty EmptyRelation) }</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>At least, it seems that the error is about <code>cases</code> trying to equate 0 with 1. How do I tell it that <code>basic</code> does not apply here?</p>",
        "id": 387569470,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1693180583
    },
    {
        "content": "<p>I have got to admit that I have absolutely no clue what is going on here, I assume <code>cases</code> wants to try and eliminate the case that <code>h</code> comes from <code>basic</code>, but I will say that this is solvable using \"just\" <code>casesOn</code> so maybe that's at least a workaround for your real situation?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"n\">h.casesOn</span> <span class=\"bp\">?</span><span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Sigme.basic</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Sigme.basic</span>\n</code></pre></div>",
        "id": 387641627,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1693219318
    },
    {
        "content": "<p>\"dependent elimination\" is the thing that deals with type indices, and it's able to automatically handle equations between indices involving constructors of inductive types. The main problem is that <code>Ordinal</code> is not an inductive type (it's a quotient), and a secondary problem is that you can't directly communicate with <code>cases</code> about how to solve (or disprove) additional equations.</p>\n<p>An indirect way to communicate with <code>cases</code> is to use <code>generalize</code> to turn certain expressions into variables first, and then that leaves you with the obligations to handle index equalities.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">1</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Sigme</span> <span class=\"n\">y</span> <span class=\"mi\">0</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">generalize</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">Ordinal</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">one</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span>\n  <span class=\"bp\">·</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h1</span>\n  <span class=\"bp\">·</span> <span class=\"n\">cases</span> <span class=\"n\">h1</span>\n    <span class=\"c\">/-</span>\n<span class=\"cm\">    α✝: Type ?u.1317</span>\n<span class=\"cm\">    yz: Set α✝</span>\n<span class=\"cm\">    j✝: Ordinal.{?u.1510}</span>\n<span class=\"cm\">    x✝¹: Sigme y j✝ z</span>\n<span class=\"cm\">    x✝: j✝ &lt; 1</span>\n<span class=\"cm\">    ⊢ Sigme y 0 z</span>\n<span class=\"cm\">    -/</span>\n</code></pre></div>",
        "id": 387664967,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693227960
    },
    {
        "content": "<p>(I think \"dependent elimination\" in particular refers to doing cases on inductive types with indices, since these have more complicated dependent types, but I'm not actually sure.)</p>",
        "id": 387665636,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1693228162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/113489-new-members/topic/giving.20extra.20info.20to.20.60cases.60.20tactic/near/387641627\">said</a>:</p>\n<blockquote>\n<p>I will say that this is solvable using \"just\" <code>casesOn</code> so maybe that's at least a workaround for your real situation?</p>\n</blockquote>\n<p>Thanks, I had forgotten the naming convention of the low-level theorems on inductive predicates. I tried to apply it to my use case but I couldn't manage to get it through. <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s hack did the trick.</p>\n<p>Immediately after the generalization, <code>cases</code> knew that all other cases were unnecessary and right after that I did a <code>rw [←h1]</code> to get back to the original state. (This was actually part of a Lean3 ported proof using <code>induction'</code>, and it seems that this tactic knew something about this trick!)</p>",
        "id": 387731239,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1693246603
    }
]