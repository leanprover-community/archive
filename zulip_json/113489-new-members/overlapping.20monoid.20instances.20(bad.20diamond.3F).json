[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>\n\n<p>A simplified version of my problem : I want to prove theorems about presented monoids which are cancellative.</p>\n<p>I have defined a presented monoid over some relations (by quotienting a free monoid by the relations). I have proved that this <code>PresentedMonoid rels</code> is an instance of a <code>Monoid</code>. </p>\n<p>But my theorem about cancellative presented monoids cannot take in, say, <code>[CancelMonoid (PresentedMonoid rels)]</code>, for then Lean won’t know why <code>PresentedMonoid rels</code> is a monoid —  PresentedMonoid is a monoid, and a CancelMonoid is a monoid.</p>\n<p>For the moment, I have been using hypotheses like <code>(cancel_left : \\forall a b c, a * b = a * c \\to b = c)</code></p>\n<p>The full problem requires 5 such hypotheses, which feels unwieldy. I can bundle them into a tuple, but it really <em>feels</em> like it should be an instance/class kind of construction.</p>\n<p>My other idea was to define a class <code>PresentedMonoid</code>, with data of the underlying set, the relations, and then a theorem stating the universal property. Then I could use the <code>extends</code> keyword to add in, say, <code>CancelMonoid</code> to get <code>CancelPresentedMonoid</code>. (I am skeptical because PresentedGroup is not a class, so probably my PresentedMonoid shouldn’t be either).</p>\n<p>Is either of the two ways preferable? Is there another way? Thank you!</p>",
        "id": 475409362,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1728338954
    },
    {
        "content": "<p>I'm not sure I've understood your problem correctly -- is the issue that you have a monoid and want to beef it up to a CancelMonoid in the middle of a proof? If so then you can do somthing like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">letI</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LeftCancelMonoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">toMonoid</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">    </span><span class=\"n\">mul_left_cancel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Apologies if I've misunderstood.</p>",
        "id": 475493589,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728371932
    },
    {
        "content": "<p>thanks! that was one hurdle I've gotten through </p>\n<p>perhaps this will explain it better:</p>\n<p>Say I've proved that for some specific set of relations (call them <code>rels1</code>), that <code>PresentedMonoid rels1</code> is in fact cancellative; that I have<br>\n<code>instance [CancelMonoid (PresentedMonoid rels1)]</code>, via something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CancelMonoid</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PresentedMonoid</span><span class=\"w\"> </span><span class=\"n\">rels1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">mul_left_cancel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cancel_left_rels1</span>\n<span class=\"w\">  </span><span class=\"n\">mul_right_cancel</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">cancel_right_rels1</span>\n</code></pre></div>\n<p>That's all well and good. Now when I go to state a theorem about cancellative presented monoids, what should I do in my assumptions? I cannot use <code>[CancelMonoid (PresentedMonoid rels1)]</code> as I get some kind of \"bad diamond\" because there are two ways to infer the monoid instance. At the moment, I have been passing in <code>cancel_left_rels1</code> and <code>cancel_right_rels1</code> as arguments every time. It just seems like there should be a better way to write theorems about cancellative presented monoids</p>\n<p>I guess my question is, what's the best way to set up the assumptions for a theorem?</p>",
        "id": 475594011,
        "sender_full_name": "Hannah Fechtner",
        "timestamp": 1728400945
    },
    {
        "content": "<p>You can use <code>[IsCancelMul (PresentedMonoid rels1)]</code></p>",
        "id": 475604484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728403336
    }
]