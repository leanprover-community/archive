[
    {
        "content": "<p>Hi all. I've been reading about Lean4 with great interest, as the syntax largely looks like an improvement on Haskell. I'm interested in playing around with it as a general purpose programming language, rather than doing any math-specific applications. I know Lean is supposed to support general programming, but I see very little information about this (aside from the Functional Programming in Lean book, which is what piqued my curiosity). Is this something that people look at seriously? I recognize that the available libraries would be quite limited. I don't want to do anything crazy for now, probably just some command-line tools.</p>\n<p>While I'm here, I'll ask a more specific question. Does Lean support existential types? In particular I'm interested in having a heterogeneous list, where I can look through the list and find all items of type _a_ for any given type. One way this is handled in other languages is with existential types (tied to, say, a type class), with support for upcasting to the existential type so you can put everything in a list, and then downcasting back to the original types when you extract items from the list. I'm also curious if this can be handled in Lean with an inductive type, but my initial attempt failed.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Item</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">float</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Item</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Item</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valueType</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">values</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">values</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">valueType</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">valueType</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">valueType</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n</code></pre></div>\n<p>I was trying for something where I could call <code>getValue Item.int mylist</code>, but it doesn't work because <code>valueType</code> can't be used in a pattern match I guess.</p>\n<p>Thanks for any help on these two admittedly quite separate questions, and I hope to become more involved with this community.</p>",
        "id": 468974750,
        "sender_full_name": "misterdrgn",
        "timestamp": 1725940545
    },
    {
        "content": "<p>Re q1: Lean is mostly written in lean. So that is one example that serious programming can be done in Lean. Besides that, people have written several other tools, like a bibtex query tool, a ray tracer, etc...<br>\nBut the ecosystem is indeed still in its early stages</p>",
        "id": 468981793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725943130
    },
    {
        "content": "<p>The easiest way is to write three separate functions for every type, like this(untested as I'm on mobile):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getInts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Into</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">getInts</span><span class=\"w\"> </span><span class=\"n\">l</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">getInts</span><span class=\"w\"> </span><span class=\"n\">l</span>\n</code></pre></div>\n<p>To the first question on Lean as a programming language, it is definitely viable and there are a bunch of people using it that way however it is overshadowed by all the math related projects.</p>",
        "id": 468981881,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725943180
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Thanks. Honestly I’m less worried about the library support than I am about the lack of information online. If people here don’t mind being peppered with questions, then maybe it’s fine.</p>",
        "id": 468984984,
        "sender_full_name": "misterdrgn",
        "timestamp": 1725944382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346070\">@Tomas Skrivan</span> Thank you, but I’m particularly interested in a general-purpose solution that won’t require additional code when new types are added. I’m mostly just curious about how Lean handles that kind of a problem.</p>",
        "id": 468985840,
        "sender_full_name": "misterdrgn",
        "timestamp": 1725944610
    },
    {
        "content": "<p>Yeah, I am not a dependent type guru so there might be a way of having a general solution but I'm afraid that the naive function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getOfType</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Is impossible to implement. The only viable solution I can think of is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TypeTag</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">float</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">string</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">TypeTag</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TypeTag</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">float</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">String</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getItems</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TypeTag</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TypeTag</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toType</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It is probably quite easy to write a macro that automatically generates these given a list of types. The crucial point is that you have to fix the set of types you want to work with.</p>",
        "id": 468988332,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1725945800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"754034\">@misterdrgn</span> Please pepper this zulip with questions. If the end result is that people write more online docs/tutorials/etc... then that's a win (-;<br>\nI should note that there is very active work <em>right now</em> on writing a reference manual for Lean 4. So I'm confident that there will be high quality material for Lean core in the near future.</p>",
        "id": 468994342,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1725948982
    },
    {
        "content": "<p>there is the following pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">autoImplicit</span><span class=\"w\"> </span><span class=\"n\">false</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"n\">getString</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"String\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"w\">  </span><span class=\"c1\">-- whatever functions you need access to</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">toSpec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"bp\">.</span><span class=\"n\">toSpec</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MyInterface</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"bp\">.</span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"n\">getString</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"bp\">.</span><span class=\"n\">getString</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"String\"</span>\n<span class=\"w\">  </span><span class=\"n\">getString</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"Int\"</span>\n<span class=\"w\">  </span><span class=\"n\">getString</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">String</span><span class=\"bp\">.</span><span class=\"n\">reduceEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"c1\">-- since `h` says `\"Int\" = \"String\"`, we have a contradiction, and don't need to return.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"s2\">\"test1\"</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 468995462,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725949541
    },
    {
        "content": "<p>do note that using a single class for this can get quite out of hand. you'll likely want to define a hierarchy of classes and associated structures, along with (possibly) coersions between the structures</p>",
        "id": 468995671,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725949637
    },
    {
        "content": "<p>it can get out of hand, because when something is of type \"MyInterface\", you generally only will be able to tell if you have the right type by using functions only depending on the values of <code>MyInterfaceSpec</code></p>",
        "id": 468996173,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1725949788
    },
    {
        "content": "<p>Out of curiosity, what do you plan on using existential types for? The problem is that in general, deciding whether two types are equal is undecidable (and even worse, if two types have the same cardinality but are derived from different inductive types, then deciding whether two types are equal is actually independent of Lean). So in particular, trying to extract all elements of a type <code>A</code> from a list is uncomputable. (You can actually use the axiom of choice to produce the desired list. This is probably not what you want though, because such a list would be <code>noncomputable</code> and only useful in proofs.)</p>\n<p>I think Lean is capable of implementing most of the examples here: <a href=\"https://wiki.haskell.org/Existential_type\">https://wiki.haskell.org/Existential_type</a>. Lean can upcast to a typeclass just fine, it just isn't capable of downcasting (or basically doing anything that you would need an <code>instanceof</code> in an object oriented language) without explicitly tagging the types (at least I think, it's possible there's some extra metadata attached to terms that I'm not aware of).</p>",
        "id": 469461267,
        "sender_full_name": "Niels Voss",
        "timestamp": 1726073026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> It's largely a thought experiment. When I look at a new language, I tend to think about how easily I could implement a system from my work (research lab), which was programmed in Clojure. Since Clojure has dynamic typing, getting the system to work in a statically typed language makes for an interesting challenge. One of the trickier bits is supporting a heterogeneous list with upcasting and downcasting. You have a set of components that operate in parallel and produce elements as output. All the elements conform to certain constraints, but their details differ, so you can think of these as being different instances of the same type class. The elements are gathered into a single collection (a heterogeneous list or set), at which point the various components can search through this collection for for elements that meet particular criteria. So that's the point at which you need to downcast; in some cases you might downcast all the way to the concrete type, but in other cases you might downcast to a more specific type class. The final bit is that the system needs to be flexible, as new concrete types (new types of elements) can be added all the time. So that's where shoving everything into an inductive type seems less appealing, although I'm open to it if there's a flexible way to do it that doesn't require adding a bunch of boilerplate for each constructor in the inductive type (see my post at the top of this thread).</p>\n<p>I hope that makes sense. Likely, the system could be reimplemented in a new way that removed the need for heterogeneous lists. I'm just curious about what it would take to make that approach work in Lean, or in any statically typed language. (The language where I've had the most success is actually Swift. I think Scala would work well also. These languages are way less finicky about existential types with downcasting than, say, Haskell).</p>\n<p>EDIT: Admittedly, my Swift solution uses macros to eliminate boilerplate code. Perhaps that would also be the way to go for Lean. But I appreciate that Swift has easy downcasting.</p>",
        "id": 469529246,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726102349
    },
    {
        "content": "<p>I totally understand thought experiments trying to figure out what is theoretically possible in a language. To dispel some concerns that downcasting might be completely impossible, there is a function <code>unsafeCast</code> which will reinterpret a value of one type as a value of another type. This is usually a really terrible solution. If you do an invalid cast, it triggers undefined behavior. Also, you can only call this function in an <code>unsafe</code> block, so you can't prove anything about the semantics of programs that use such a function. However, it does exist if you <em>really</em> need it.</p>\n<p>As for more practical solutions, the problem is that Lean doesn't really have the concept of a run-time type error. Furthermore (and I might be wrong about this), when a Lean term is compiled down to native code, it is just a stream of bits representing the data, and there is no metadata attached that might allow you to determine the type. This is the same problem that C has, where if you have an array of <code>void *</code> you can't just extract the subarray of elements of a given type.</p>\n<p>Language that support things like <code>instanceof</code> usually attach some extra data at run time to make them possible. I think Lean does not do this automatically, so you need to do it manually. You could potentially make a <code>TypeId</code> typeclass which just contains a string, and then use metaprogramming so that you can just write <code>deriving TypeId for Int</code> or something (can't remember the exact syntax) to automatically add an instance of <code>TypeId</code> for a given type. (See <code>SizeOf</code> for a typeclass which is derived on every inductive type).</p>\n<p>This approach is imperfect because there's no way to get from the fact that a term has a given string id to a term of the required type. This itself might require <code>unsafeCast</code>, which is bad. The solutions posted above by others will probably work better.</p>\n<p>I can elaborate on details or maybe a compromise which works for your specific example later when I have more time.</p>",
        "id": 469531043,
        "sender_full_name": "Niels Voss",
        "timestamp": 1726103833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"521331\">@Niels Voss</span> I appreciate your response, and I take your point about explicit downcasting not really being a thing in Lean. I do want to explore <span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> 's proposed solution, but to be honest there are a lot of bits I don't understand. I may need to spend some more time with the Functional Programming in Lean book, at a minimum (this is where I miss having a full reference manual, so it's nice to hear that's being looked at). The <code>universe u</code> / <code>Type u</code> bit is a complete mystery to me, and I'm also curious what setting <code>autoImplicit</code> to false does.</p>\n<p>EDIT: Found the part of the book that discusses universes. Guess I jumped the gun on that one. But I'm lost on the middle part with <code>MyInterface</code>.</p>",
        "id": 469531618,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726104324
    },
    {
        "content": "<p>Is there a specific topic or topics you want covered in documentation? While Lean's documentation is currently not the best, there's still a fair bit of it, scattered between Theorem Proving in Lean 4, the Lean 4 Manual, and the Mathlib 4 API documentation.</p>\n<p>See <a href=\"https://lean-lang.org/lean4/doc/autobound.html\">https://lean-lang.org/lean4/doc/autobound.html</a> for what <code>autoImplicit</code> does. Basically, if <code>autoImplicit</code> is set to true, it will automatically add parameters to your function if it encounters a variable name you haven't defined yet. If <code>autoImplicit</code> is set to false, you may need to use <code>variable</code> or define the parameters explicitly.</p>\n<p><code>autoImplicit</code> has been controversial, because while it makes code less verbose, it also means if you make a typo, your code might compile for now, but not define the function you think you are defining. If I remember correctly, <code>autoImplicit</code> is <code>true</code> by default in Lean, but <code>false</code> if you are working on Mathlib. My recommendation is to always set <code>autoImplicit</code> to <code>false</code> at the top of every file until you get to the point where you can make an informed decision for yourself.</p>",
        "id": 469538683,
        "sender_full_name": "Niels Voss",
        "timestamp": 1726108729
    },
    {
        "content": "<blockquote>\n<p>But I'm lost on the middle part with <code>MyInterface</code>.</p>\n</blockquote>\n<p>Basically, an element of <code>MyInterface</code> consists of 1. a type <code>T</code>, 2. an implementation of the typeclass <code>MyInterfaceSpec</code> for <code>T</code>, and 3. an element of type <code>T</code>. Basically, it is just an existential type.</p>\n<p>The <code>{}</code> around <code>T : Type u</code> and the <code>[]</code> around <code>toSpec : MyInterfaceSpec T</code> mean that Lean will figure out what to set <code>T</code> and <code>toSpec</code> to for you. Right now, you can create an element of <code>MyInterface</code> like <code>MyInterface.mk \"hi\"</code> or just <code>⟨\"hi\"⟩</code> . But if the <code>{}</code> and <code>[]</code> were removed from the definition of <code>MyInterface</code>, you would instead have to type out <code>MyInterface.mk String someInstanceOfMyInterfaceSpecForString \"hi\"</code>.</p>",
        "id": 469539465,
        "sender_full_name": "Niels Voss",
        "timestamp": 1726109274
    },
    {
        "content": "<p>That makes sense on <code>autoImplicit</code>, thanks.</p>\n<p>I think useful things in a reference manual would include glossaries/searchable indices for keywords, options that can be set with <code>set_option</code>, and attributes. It would also be cool to have an operator cheat sheet--I found one of those for Haskell, and it was really helpful. I know that many Haskell operators like <code>&lt;$&gt;</code> are also found in Lean, but I tried at least one that wasn't. </p>\n<p>Of course, different operators can be defined in different libraries. I'm not entirely clear on the library structure for Lean. I was looking for the standard library, but I think maybe it's the library that's loaded by default, which is also called \"init\" here: <a href=\"https://leanprover-community.github.io/mathlib4_docs/\">https://leanprover-community.github.io/mathlib4_docs/</a></p>\n<p>Or maybe that's separate from the standard library? And then there's the batteries library, which I guess is part of mathlib, meaning it's community developed?</p>\n<p>Those are the kinds of questions I'm running into. A lot of it can be found in those three online books, and I just discovered that those books are searchable, which is nice, but finding the right answer can be difficult.</p>\n<p>Just some thoughts, since you asked. I appreciate that the community seems responsive and friendly on here. Really what it comes down to is that for a mature language, you can search online to find answers, since someone else has likely asked your question before. But with a newer language, it helps to have all the answers in one place. My specific question right now is what's happening here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">toSpec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyInterfaceSpec</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">MyInterface</span><span class=\"bp\">.</span><span class=\"n\">toSpec</span>\n</code></pre></div>\n<p>Thanks for talking about all this.</p>\n<p>EDIT: Just saw your update. So structures can contain type class instances? Crazy.</p>",
        "id": 469540824,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726110148
    },
    {
        "content": "<p>Regarding the libraries, if I'm not mistaken:</p>\n<ul>\n<li>There is <a href=\"https://github.com/leanprover/lean4/tree/master/src\">core</a>, which contains <code>Lean</code>, <code>Init</code>, <code>Std</code> and <code>Lake</code> (lake is Lean's build system, I don't believe it's often used programmatically)</li>\n<li>There is <a href=\"https://github.com/leanprover-community/batteries\">batteries</a>, which is a community-maintained programming library.</li>\n<li>There is Mathlib, which is a community-maintained mathematics library.</li>\n<li>\n<p>There are some other libraries Mathlib depends on:<br>\n-- Aesop, an automation tactic<br>\n-- ImportGraph, a tool for analyzing imports<br>\n-- ProofWidgets, I believe this is a library for interactive tactics, but I'm not certain<br>\n-- Qq, a library for type-safe metaprogramming </p>\n</li>\n<li>\n<p>There are a bunch of other libraries at: <a href=\"https://reservoir.lean-lang.org/\">https://reservoir.lean-lang.org/</a></p>\n</li>\n</ul>",
        "id": 469558687,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1726119003
    },
    {
        "content": "<p>If you want runtime type checking, you may also want to consider <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Dynamic#doc\">docs#Dynamic</a>, which is basically a type with a type tag, for which you can implement the <code>getOfType</code> function that Tomas shows</p>",
        "id": 469629126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726136860
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Dynamic</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">values</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">values</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">String</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Float</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"hi\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"there\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mf\">4.5</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"c1\">-- [\"hi\", \"there\"]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"hi\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"there\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mf\">4.5</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- [2]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"hi\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"s2\">\"there\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mf\">4.5</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- [4.500000]</span>\n</code></pre></div>",
        "id": 469630238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726137217
    },
    {
        "content": "<p>What would be the idiomatic way of bundling <code>Dynamic</code> with a typeclass instance? I.e. achieving runtime polymorphism?</p>",
        "id": 469654939,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1726143243
    },
    {
        "content": "<p><code>Dynamic</code> already uses a typeclass instance</p>",
        "id": 469662249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726144956
    },
    {
        "content": "<p>note the <code>deriving instance TypeName</code> lines above</p>",
        "id": 469662300,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726144971
    },
    {
        "content": "<p>You should probably not wrap the <code>TypeName</code> instance in another class because <code>TypeName</code> has a deriving handler which does some <code>unsafe</code> things which are hard to replicate without writing manual unsafe code</p>",
        "id": 469662727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726145052
    },
    {
        "content": "<p>I probably wasn't clear, what if I want a list where every item is an element of some group. I.e. I want to bundle every list item with an appropriate instance of <code>Group</code>.</p>",
        "id": 469663103,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1726145121
    },
    {
        "content": "<p>I'd say that example is likely to run into defeq issues, because even if you <em>do</em> find two elements of the same type, the instances needn't be defeq let alone propeq, so you'll need to choose which multiplication you use when you do.</p>",
        "id": 469664125,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726145363
    },
    {
        "content": "<p>Maybe <code>Group</code> is not a good example but what about <code>ToString</code>, that would be quite helpful.</p>",
        "id": 469664841,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1726145550
    },
    {
        "content": "<p>In that case, the <code>MyInterface</code> approach I suggested some time ago should suffice. (You can make <code>MyInterfaceSpec</code> extend it or some variant of that)</p>",
        "id": 469666364,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1726145876
    },
    {
        "content": "<p>Here's a generalization of <code>Dynamic</code> to allow you to store more information than just a value of the target type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">PDynamicPointed</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonemptyType</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span><span class=\"bp\">⟩</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Type-tagged union that can store any type with a `TypeName` instance.</span>\n\n<span class=\"sd\">This is roughly equivalent to `(α : Type) × TypeName α × P α` but without the</span>\n<span class=\"sd\">universe bump.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PDynamicPointed</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">type</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PDynamicPointed</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">typeNameImpl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">The name of the type of the value stored in the `Dynamic`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">typeNameImpl</span><span class=\"kd\">]</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">get?Impl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">typeName</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">any</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"bp\">.</span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"n\">none</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">Retrieves the value stored in the `Dynamic`.</span>\n<span class=\"sd\">Returns `some a` if the value has the right type, and `none` otherwise.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">get?Impl</span><span class=\"kd\">]</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">private</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">mkImpl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TypeName</span><span class=\"bp\">.</span><span class=\"n\">typeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unsafeCast</span><span class=\"w\"> </span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NonScalar</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">mkImpl</span><span class=\"kd\">]</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Groupish</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PDynamic</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">values</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Groupish</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">values</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getZero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">values</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Groupish</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">values</span><span class=\"bp\">.</span><span class=\"n\">filterMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">get?</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Groupish</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">AddGroup</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Groupish</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">TypeName</span><span class=\"w\"> </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">34</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)]</span><span class=\"w\">  </span><span class=\"c1\">-- [23]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getValue</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">34</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)]</span><span class=\"w\">  </span><span class=\"c1\">-- [Real.ofCauchy (sorry /- 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, ... -/)]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getZero</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">34</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)]</span><span class=\"w\">  </span><span class=\"c1\">-- [0]</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">getZero</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">23</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">34</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)]</span><span class=\"w\">  </span><span class=\"c1\">-- [Real.ofCauchy (sorry /- 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... -/)]</span>\n</code></pre></div>",
        "id": 469675696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726147638
    },
    {
        "content": "<p>It doesn't seem all that useful to have a heterogeneous list of groupish objects though, you can't multiply them together or do much generically with them</p>",
        "id": 469676231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726147704
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Your first code example is exactly what I was looking for. <code>Dynamic.get?</code> looks a lot like downcasting functions I see in other languages. And I like that the boilerplate for applying it to more types is so minimal. I don't know if there are any drawbacks--in some languages people hold their nose at using dynamic types, and you mention there are <code>unsafe</code> operations. But thanks for bringing this up.</p>\n<p>I guess the next question would be whether one can build on this. Dynamic provides a single level of abstraction, but suppose you want more. You might have a <code>Circle</code>, which is a <code>Shape</code>, which is an <code>Item</code>. So you start with your <code>List Item</code>, and you might want to find all the instances of <code>Circle</code>, or you might want to find all the instances of <code>Shape</code>, where you expect <code>Shape</code> to support certain methods, such as <code>Shape.boundingBox</code>. This is where tying existential types to type classes, as some languages do, is valuable, as <code>Circle</code> might be an instance of the <code>Shape</code> type class. Perhaps I'll think more on this.</p>",
        "id": 469838548,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726198906
    },
    {
        "content": "<p>This is not very easy, lean basically has no OO-style subtyping system and relies completely on haskell-style typeclasses to do the equivalent. If you wanted to use something like <code>Dynamic</code> for this you would have to encode a computable version of the hierarchy in the tag (<code>Dynamic</code> uses the name of the type as the tag, which is not sufficient for all purposes, especially if there are type operators involved). I think in general this approach is not recommended and you should instead use algebraic types (i.e. <code>inductive</code>) or typeclasses depending on whether you need an open or closed class of types</p>",
        "id": 469867168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1726209601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  Yes, understood. This is why I was originally asking about existential types--in some languages, type classes or the equivalent can be use as types in a list or other collection. Haskell supports this with a language extension, but afaik you can't downcast from the existential type in Haskell.</p>\n<p>Based on other suggestions in this thread, it sounds like there might be a reasonable type class-based solution in Lean, but it requires a fair amount of boilerplate, far more than the Dynamic version. Perhaps that could be addressed with macros. I haven't looked into Lean macros yet.</p>\n<p>In any case, it's largely a thought experiment. I recognize that this is not the way most strongly typed languages are meant to be used.</p>\n<p>I appreciate the advice.</p>",
        "id": 470011738,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726245646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"754034\">misterdrgn</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20lean.20as.20a.20general.20language/near/468974750\">said</a>:</p>\n<blockquote>\n<p>Hi all. I've been reading about Lean4 with great interest, as the syntax largely looks like an improvement on Haskell. I'm interested in playing around with it as a general purpose programming language, rather than doing any math-specific applications. I know Lean is supposed to support general programming, but I see very little information about this (aside from the Functional Programming in Lean book, which is what piqued my curiosity). Is this something that people look at seriously? I recognize that the available libraries would be quite limited. I don't want to do anything crazy for now, probably just some command-line tools.</p>\n</blockquote>\n<p>Since it seems to be a relatively rare interest in the Lean community, I wanted to mention that I'm also interested in Lean as a general-purpose language (and also came from Clojure, via some other dependently typed languages--Idris and Agda.).  I like dependent types because they give one more flexibility and control than a language like Haskell--though there are additional complexities as well--and I love how responsive the editing experience is in Lean.   It also can be valuable to be able to have the option prove the correctness of parts of a program.  (I am interested in the role of dependently typed languages in theorem proving, even if that's not my focus.)</p>",
        "id": 470015427,
        "sender_full_name": "mars0i",
        "timestamp": 1726247053
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"617444\">@mars0i</span> I agree that the editing experience is fantastic. It's miles ahead of Haskell, so that's another point in its favor.</p>",
        "id": 470045522,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726259840
    },
    {
        "content": "<p>A nice paper on OO vs abstract data type of functional programming. This might help you to replace these objects. <br>\n<a href=\"https://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf\">On Understanding Data Abstraction, Revisited</a></p>",
        "id": 470188370,
        "sender_full_name": "Nicolas Rolland",
        "timestamp": 1726328419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> I tried to do the following, partially inspired by your code snippet above.  The <code>getType</code> implementations failed, apparently because you can't do equality checks on types. Do you know if there's some other way to make <code>getType</code> work with the function signature shown here? I realize I could change the first argument from a Type to a String, but this is less reliable because a developer could get wrong results due to a typo (EDIT: Nm, then it wouldn't know the return type). Or I could try and emulate what <code>Dynamic</code> is doing, but that might get messy. Thanks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Shape</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">T</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Shape</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"n\">pt</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">pt</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Shape</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">width</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">width</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">height</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">height</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">getType</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"n\">rect</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">tp</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Rect</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">rect</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>",
        "id": 470407628,
        "sender_full_name": "misterdrgn",
        "timestamp": 1726447978
    }
]