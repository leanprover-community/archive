[
    {
        "content": "<p>Hello, </p>\n<p>I'm a new user of lean and I am trying out lean-auto on a simple model:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Auto</span>\n<span class=\"kn\">import</span> <span class=\"n\">Std.Data.BitVec</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">auto.smt</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">auto.smt.trust</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.auto.smt.printCommands</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.auto.smt.result</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Zone</span> <span class=\"n\">where</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Z1</span> <span class=\"bp\">|</span> <span class=\"n\">Z2</span> <span class=\"bp\">|</span> <span class=\"n\">Z3</span> <span class=\"bp\">|</span> <span class=\"n\">Z4</span>\n  <span class=\"c1\">-- Ask Lean to automatically show that type is not empty, has a representation function, and</span>\n  <span class=\"c1\">-- equality is decidable</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span><span class=\"o\">,</span> <span class=\"n\">Repr</span><span class=\"o\">,</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">Area</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">Int</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Zone.MinArea1</span> <span class=\"o\">:</span> <span class=\"n\">Zone</span> <span class=\"bp\">→</span> <span class=\"n\">Area</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z1</span>    <span class=\"bp\">=&gt;</span> <span class=\"mi\">10000</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z2</span>    <span class=\"bp\">=&gt;</span> <span class=\"mi\">5000</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z3</span>     <span class=\"bp\">=&gt;</span> <span class=\"mi\">3500</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z4</span>     <span class=\"bp\">=&gt;</span> <span class=\"mi\">2500</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Zone.MinArea2</span> <span class=\"o\">:</span> <span class=\"n\">Zone</span> <span class=\"bp\">→</span> <span class=\"n\">Area</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z1</span>    <span class=\"bp\">=&gt;</span> <span class=\"mi\">12000</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z2</span>    <span class=\"bp\">=&gt;</span> <span class=\"mi\">7000</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z3</span>     <span class=\"bp\">=&gt;</span> <span class=\"mi\">4000</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">Z4</span>     <span class=\"bp\">=&gt;</span> <span class=\"mi\">3000</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Zone</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.MinArea1</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">x.MinArea2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Zone</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x.MinArea1</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">x.MinArea2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">auto</span>\n</code></pre></div>\n<p>Simp succeeds but auto fails here.  Looking at the generated SMT it looks like MinArea1 and MinArea2 are treated as uninterpreted functions.  How do I tell lean-auto to use these definitions?</p>",
        "id": 403394838,
        "sender_full_name": "Mike Whalen",
        "timestamp": 1700577637
    },
    {
        "content": "<p>cc: <span class=\"user-mention\" data-user-id=\"524339\">@Yicheng Qian</span></p>",
        "id": 403424997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700585849
    },
    {
        "content": "<p>Currently lean-auto does not have good support for <code>match</code> expressions, but that might change in the near future.</p>",
        "id": 403428099,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700586880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Is there already code in Lean to generate/obtain equational theorems for aux constants like <code>?.match_1</code>?</p>",
        "id": 403428292,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700586957
    },
    {
        "content": "<p>I thought it did, but <code>getEqnsFor?</code> only seems to return <code>some</code> if the definition is recursive, and it returns it only for the main recursive definition, not the internal match splitters</p>",
        "id": 403433773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700588897
    },
    {
        "content": "<p>oh, there is a special function for matchers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Meta.Match.getEquationsFor</span> <span class=\"bp\">``</span><span class=\"n\">foo.match_1</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.eq_1</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.eq_2</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.splitter</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo.match_1.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">Nat.casesOn</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">())</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">foo.match_1.eq_1.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_1</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h_1</span> <span class=\"o\">()</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">())))</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">foo.match_1.eq_2.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_1</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h_2</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">foo.match_1.splitter.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">Nat.casesOn</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 403435033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700589414
    },
    {
        "content": "<p>(Hopefully I am replying correctly - still my first post) - I also tried using <code>auto u[Zone.MinArea1, Zone.MinArea2]</code> but got some errors, e.g. <code>lamTerm2STerm :: Unexpected head term Auto.Embedding.Lam.LamTerm.lam (.atom 1) (.app (.base (.nat)) (.base (.icst (.iofNat))) (.base (.ncst (.natVal 10000))))</code></p>",
        "id": 403448102,
        "sender_full_name": "Mike Whalen",
        "timestamp": 1700594771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Correct.20use.20of.20lean-auto/near/403435033\">said</a>:</p>\n<blockquote>\n<p>oh, there is a special function for matchers:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n  <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n  <span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">Lean.Meta.Match.getEquationsFor</span> <span class=\"bp\">``</span><span class=\"n\">foo.match_1</span>\n\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.eq_1</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.eq_2</span>\n<span class=\"k\">#print</span> <span class=\"n\">foo.match_1.splitter</span>\n</code></pre></div>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">foo.match_1.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">Nat.casesOn</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">())</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">foo.match_1.eq_1.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"mi\">0</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_1</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h_1</span> <span class=\"o\">()</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">())))</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">theorem</span> <span class=\"n\">foo.match_1.eq_2.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_1</span> <span class=\"o\">:</span> <span class=\"n\">Unit</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)),</span>\n  <span class=\"o\">(</span><span class=\"k\">match</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_1</span> <span class=\"o\">()</span>\n    <span class=\"bp\">|</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h_2</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">n</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.refl</span> <span class=\"o\">(</span><span class=\"n\">h_2</span> <span class=\"n\">n</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">private</span> <span class=\"kd\">def</span> <span class=\"n\">foo.match_1.splitter.</span><span class=\"o\">{</span><span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">fun</span> <span class=\"n\">motive</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"n\">h_2</span> <span class=\"bp\">↦</span> <span class=\"n\">Nat.casesOn</span> <span class=\"n\">x</span> <span class=\"n\">h_1</span> <span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"bp\">↦</span> <span class=\"n\">h_2</span> <span class=\"n\">n</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah, this seems to be what I've been missing! I was only calling <code>getEqnsFor?</code> before.</p>",
        "id": 403494335,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700616270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"668376\">Mike Whalen</span> <a href=\"#narrow/stream/113489-new-members/topic/Correct.20use.20of.20lean-auto/near/403448102\">said</a>:</p>\n<blockquote>\n<p>(Hopefully I am replying correctly - still my first post) - I also tried using <code>auto u[Zone.MinArea1, Zone.MinArea2]</code> but got some errors, e.g. <code>lamTerm2STerm :: Unexpected head term Auto.Embedding.Lam.LamTerm.lam (.atom 1) (.app (.base (.nat)) (.base (.icst (.iofNat))) (.base (.ncst (.natVal 10000))))</code></p>\n</blockquote>\n<p>Yes, that's another issue in <code>auto</code>. If we unfold these match-expressions, there will be dependently typed terms that <code>auto</code> can't handle. The expected usage is <code>auto d[Zone.MinArea1, Zone.MinArea2]</code>, but that doesn't work right now. The first issue is recorded in <code>TODO.md</code>, and the second issue is recorded in <code>Test/SmtTranslation/Inductive.lean</code> (I'll add it to <code>TODO.md</code>).</p>",
        "id": 403494674,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700616433
    },
    {
        "content": "<p>So that's it. Lean-auto is only 4 months old and I'm the only developer of it, so it's pretty rudimentary. It do work on some mathlib examples when used together with duper.</p>",
        "id": 403495320,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700616729
    },
    {
        "content": "<p>Sure, no problem.  Thank you for your quick response!</p>",
        "id": 403513005,
        "sender_full_name": "Mike Whalen",
        "timestamp": 1700625276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"668376\">@Mike Whalen</span> p.s: Recently I've been busy with other stuff and have no time for lean-auto, but it will get better after January 7th next year. Sorry about this.<br>\nIssues on github are still welcome.</p>",
        "id": 404043368,
        "sender_full_name": "Yicheng Qian",
        "timestamp": 1700876884
    }
]