[
    {
        "content": "<p>I'm stuck trying to prove a statement about preimages, involving casting of subsets. Mathematically, roughly my problem is: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>⊂</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">s\\subset t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> are subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and I'm given an element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">x\\in t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span>, how can I, in Lean, obtain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> as an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span>? Find a MWE below. (I guess solving one direction might already help for the other one.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">minimized</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span><span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"c\">/-</span><span class=\"cm\"> dummy statement -/</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- idea: shrink u to g(t); more precisely: restrict g to the preimage of u under g':=g∣t.</span>\n  <span class=\"k\">let</span> <span class=\"n\">g'</span> <span class=\"o\">:=</span> <span class=\"n\">t.restrict</span> <span class=\"n\">g</span>\n  <span class=\"k\">let</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"c1\">-- The following is mathematically easy; I'm wrestling with filling the sorries.</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">t'</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">∩</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">Set.Subset.antisymm_iff</span><span class=\"o\">)</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">Set.coe_subset</span> <span class=\"n\">hx</span>\n      <span class=\"bp\">·</span> <span class=\"c1\">-- goal: x ∈ g ⁻¹' u</span>\n        <span class=\"c1\">-- informal argument: as x ∈ t', we can apply g' (and land in u by definition), so g'(x)=g(x) ∈ u</span>\n        <span class=\"c1\">-- my first step: present x is an element of t</span>\n        <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- apply Set.mem_coe_of_mem hx, somehow?</span>\n        <span class=\"c1\">-- now I'm stuck</span>\n        <span class=\"gr\">sorry</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hgu</span><span class=\"o\">⟩</span>\n      <span class=\"c1\">-- goal: x ∈ t'</span>\n      <span class=\"c1\">-- informal argument: as x ∈ t, we can write g(x)=g'(x); the rhs lies in u, so x ∈ g⁻¹(u) also</span>\n      <span class=\"gr\">sorry</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 392500131,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1695382874
    },
    {
        "content": "<p>Instead of thinking about your problem I just hit it with a hammer and it worked <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">minimized</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span><span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"c\">/-</span><span class=\"cm\"> dummy statement -/</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- idea: shrink u to g(t); more precisely: restrict g to the preimage of u under g':=g∣t.</span>\n  <span class=\"k\">let</span> <span class=\"n\">g'</span> <span class=\"o\">:=</span> <span class=\"n\">t.restrict</span> <span class=\"n\">g</span>\n  <span class=\"n\">set</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">ht'</span>\n  <span class=\"c1\">-- The following is mathematically easy; I'm wrestling with filling the sorries.</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">t'</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">∩</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ht'</span><span class=\"o\">]</span>\n    <span class=\"n\">ext1</span> <span class=\"n\">y</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Lean.Internal.coeM</span><span class=\"o\">]</span>\n    <span class=\"n\">aesop</span>\n\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 392502601,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695383858
    },
    {
        "content": "<p>I've seen this <code>Lean.Internal.coeM</code> thing showing up before and it probably shouldn't show up in mathematical proofs, but it seems to be unavoidable now <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 392502754,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695383917
    },
    {
        "content": "<p>Yeah, I was worried about that <code>coeM</code> too, so I avoided it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">minimized</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Y</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">Z</span><span class=\"o\">]</span>\n    <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">Y</span><span class=\"o\">}</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ht</span><span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span><span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">True</span> <span class=\"c\">/-</span><span class=\"cm\"> dummy statement -/</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"c1\">-- idea: shrink u to g(t); more precisely: restrict g to the preimage of u under g':=g∣t.</span>\n  <span class=\"k\">let</span> <span class=\"n\">g'</span> <span class=\"o\">:=</span> <span class=\"n\">t.restrict</span> <span class=\"n\">g</span>\n  <span class=\"k\">let</span> <span class=\"n\">t''</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n  <span class=\"k\">let</span> <span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t''</span> <span class=\"o\">}</span>\n  <span class=\"c1\">-- The following is mathematically easy; I'm wrestling with filling the sorries.</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">t'</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">∩</span> <span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">Set.Subset.antisymm_iff</span><span class=\"o\">)</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hx</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ha1</span><span class=\"o\">,</span> <span class=\"n\">ha2</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hx</span>\n      <span class=\"n\">constructor</span>\n      <span class=\"bp\">·</span> <span class=\"n\">assumption</span>\n      <span class=\"bp\">·</span> <span class=\"c1\">-- goal: x ∈ g ⁻¹' u</span>\n        <span class=\"c1\">-- informal argument: as x ∈ t', we can apply g' (and land in u by definition), so g'(x)=g(x) ∈ u</span>\n        <span class=\"c1\">-- my first step: present x is an element of t</span>\n        <span class=\"c1\">-- now I'm stuck</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha1</span><span class=\"o\">]</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rintro</span> <span class=\"n\">x</span> <span class=\"o\">⟨</span><span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"n\">hgu</span><span class=\"o\">⟩</span>\n      <span class=\"c1\">-- goal: x ∈ t'</span>\n      <span class=\"c1\">-- informal argument: as x ∈ t, we can write g(x)=g'(x); the rhs lies in u, so x ∈ g⁻¹(u) also</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hgu</span>\n      <span class=\"n\">simp</span>\n      <span class=\"n\">use</span> <span class=\"n\">x</span>\n  <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 392502845,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1695383958
    },
    {
        "content": "<p>Wow, thanks a lot for the quick responses, both of you!</p>",
        "id": 392505251,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1695384834
    },
    {
        "content": "<p>I didn't know about set (or ext1) before.<br>\nAnd I'm glad to have an aesop-free argument in case I need one (the aesop output is <em>not</em> nice).</p>",
        "id": 392505480,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1695384931
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Internal.coeM#doc\">docs#Lean.Internal.coeM</a> is just the coercion between monadic types induced by a coercion between their underlying types. It's not a problem that we see it, just a bit annoying. We need to find a good place to add the <code>@[coe]</code> attribute to this declaration. This is in core, but the attribute isn't declared until <code>Std</code>.</p>",
        "id": 392575205,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695405574
    },
    {
        "content": "<p>In your case, <code>Set</code> is the monad.</p>",
        "id": 392575243,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695405596
    },
    {
        "content": "<p>For example, if <code>t : Set X</code>, then there is a coercion <code>(↑) : ↥t → X</code> (this is <code>Subtype.val</code>), and then <code>Lean.Interal.coeM</code> is the coercion <code>(↑) : Set ↥t → Set X</code>, but it doesn't get the <code>↑</code> because it doesn't have the <code>@[coe]</code> attribute.</p>",
        "id": 392575576,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695405738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Inverse.20image.20and.20cast.20to.20subsets/near/392575205\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Internal.coeM#doc\">docs#Lean.Internal.coeM</a> is just the coercion between monadic types induced by a coercion between their underlying types. It's not a problem that we see it, just a bit annoying. We need to find a good place to add the <code>@[coe]</code> attribute to this declaration. This is in core, but the attribute isn't declared until <code>Std</code>.</p>\n</blockquote>\n<p>I'm not sure Jireh, the docstring of Lean.Internal.coeM quite clearly says \"Helper definition used by the elaborator. It is not meant to be used directly by users.\" which makes me worry that something is not quite working as intended here</p>",
        "id": 392621933,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695429316
    },
    {
        "content": "<p>I think that docstring still agrees with what I said. The user should never write down this function, it should only exist as the result of other coercions.</p>",
        "id": 392624217,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1695430576
    },
    {
        "content": "<p>I'm still unconvinced, it's tagged as <code>@[coe_decl]</code> which says, \"auxiliary definition used to implement coercion (unfolded during elaboration\" but I've not yet finished debugging why the unfolding is not working in this case</p>",
        "id": 392627512,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695432352
    },
    {
        "content": "<p>With <a href=\"https://github.com/alexjbest/lean4/tree/patch-4\">https://github.com/alexjbest/lean4/tree/patch-4</a> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Functor</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>gives a goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"bp\">←</span> <span class=\"n\">C</span>\n    <span class=\"n\">pure</span> <span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">B</span>\n</code></pre></div>\n<p>instead of  <code>Internal.coeM C = B</code>, one advantage of this is that <code>dsimp</code> now results in something sensible  <code>⋃ (i : ↑B) (_ : i ∈ C), {↑i} = B</code></p>",
        "id": 392856864,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1695579933
    },
    {
        "content": "<p>I agree that this is cleaner. I really think we shouldn't train users to see names such as <code>Internal.something</code> as things that should be used in everyday proofs. Am I right that there was no coercion form <code>Set A</code> to <code>Set B</code> given a coercion from <code>A</code> to <code>B</code> in Lean3? Is there any risk of such a coercion causing diamonds somewhere?</p>",
        "id": 392864203,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1695586159
    },
    {
        "content": "<p>There was no such coercion, no. I don't think such a coercion will cause a diamond, unless we also introduce the <code>Coe A B → Coe (Set B) (Set A)</code> instance given by the preimage, in which case they'll conflict when <code>A = B</code>.</p>",
        "id": 392865270,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1695587063
    }
]