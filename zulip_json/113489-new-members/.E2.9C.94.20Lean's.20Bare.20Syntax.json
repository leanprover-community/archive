[
    {
        "content": "<p>Thanks to Lean's metaprogramming framework, most syntactic features are merely calls to metaprograms, allowing for fine control over language features. An examination of datatypes representing the surface language (e.g., <code>Lean.Syntax</code>) reveals that there are barely any built-in constructs in the syntax tree. Naturally, one might ask: what constitutes Lean's surface language?</p>\n<p>Besides highlighting aspects of metaprogramming in Lean, this question is crucial for scenarios where controlled exposure to language features is desired. Lectures introducing students to Lean code can gradually do so by starting from a minimal setup, and domain-specific languages can be embedded in Lean in a more controlled manner</p>\n<p>As the answer heavily depends on initial parameters and meta-definitions available in the environment, it is important to establish a reasonable definition of a minimal Lean coding environment, such as a Lean file starting with <code>prelude</code> in a minimal execution environment. What language would be accepted by Lean's parser in such a setup?</p>\n<p>Thank you</p>",
        "id": 478721872,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729777758
    },
    {
        "content": "<p>There are a number of syntaxes that are added to the system at load time from the prelude, and a number of \"builtin\" ones that are added by a later stage so that they exist while the prelude is being built. You can search for <code>syntax</code>/<code>notation</code>/<code>infix</code>/<code>prefix</code>/<code>postfix</code> declarations in Init as well as <code>builtin_term_parser</code> attributes in the Lean module.</p>\n<p>There are also various <code>builtin_***_parser</code>s for commands and tactics.</p>",
        "id": 478760964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729789071
    },
    {
        "content": "<p>I was actually wondering about something similar myself recently.  The syntax of Lean seems a little \"informal\" (I don't mean this in a condescending sense). </p>\n<p>For example, is there a reason why the syntax is based around parser combinators (AFAICT) rather than something a bit more structured like e.g. an Earley parser?  It would seem that would admit grammar extensibility but also the ability to actually examine the grammar etc.</p>\n<p>In addition (and I've not given this more than a passing thought), it would seem that the recovery semantics of a more \"powerful\" parsing framework would perhaps make it easier to e.g. process more of Lean in parallel?  I don't have a strong idea of the profile traces yet but it seems that making changes in larger files leads to a fairly slow update in the VSCode plugin.</p>",
        "id": 478766952,
        "sender_full_name": "Tom",
        "timestamp": 1729790959
    },
    {
        "content": "<p>Thank you for the replies.</p>\n<p>I have also found <a href=\"https://lean-lang.org/doc/reference/latest/\">Lean's language reference</a>.<br>\nIt seems such bare syntax, and minimal environment, is difficult to define at the moment.</p>\n<p>Thread is marked resolved (by call_by_need):  <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s reply, along with the reference,  describes a procedure to extract such a language when needed.</p>",
        "id": 478860175,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729842601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"762283\">middle adjunction</span> has marked this topic as resolved.</p>",
        "id": 478860237,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729842615
    }
]