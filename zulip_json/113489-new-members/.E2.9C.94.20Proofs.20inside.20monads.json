[
    {
        "content": "<p>Hey all -- suppose that I have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>We know that because x is [1, 2, 3], x.get 0 will be valid -- so how do I fill in that sorry?</p>\n<p>I think I need some way of carrying the fact that x is [1, 2, 3] across the assignment arrow to fill in the sorry that lets me conclude the list is nonempty. I know this isn't immediate because when we desugar into bind, we have some function <code>fun x =&gt; pure (x.get ⟨0, sorry⟩)</code> for which we cannot conclude in general that x is nonempty.</p>\n<p>In general, I want a way to carry the structure of bind for a particular monad across an assignment. For Option, I know that insofar as x is assigned, it must be a value inside a some. For another example, for List, I know that whenever x is assigned, it must be a value in the previous list -- i.e. when we have <code>do let x &lt;- l; ...</code>, we know that <code>x ∈ l</code>.</p>\n<hr>\n<p>For some added context, this came up when I was trying to do a small re-implementation of the parser combinator library to learn how it worked -- it seemed that for termination proofs, I needed to have the information that if I assigned some parser's result to a value-substring pair with bind or do-notation, then a) that pair would be the result of a successful parse and b) the substring would be shorter than the original substring if the parser was guaranteed to consume an element on success; in short, I thought I needed some way to carry the structure of the parser monad's bind across the assignment arrow.</p>\n<p>One solution I came up with was writing a typeclass like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">DMonad</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">dpure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">dbind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>In such a situation, I would have instances like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">dmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">::</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Membership</span><span class=\"bp\">.</span><span class=\"n\">mem</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">instMembership</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Mem</span><span class=\"bp\">.</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">dmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Mem</span><span class=\"bp\">.</span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DMonad</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">dpure</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">dbind</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">join</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">dmap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but it seems like there are all sorts of problems that get created when trying to create some conveniences for said typeclass (something about synthesization order), like a way of forgetting the proposition and turning it into a regular monad, some infix notation for bind (seemingly because of metavariable inference), etc. etc.</p>\n<hr>\n<p>At any rate, is there a solution to this kind of problem? More generally speaking, how can we do proofs inside of monads?</p>",
        "id": 451978626,
        "sender_full_name": "Mark Pock",
        "timestamp": 1721203177
    },
    {
        "content": "<p>I'm not sure whether it applies to your real example, but a low-tech solution to your initial example could be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">],</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"bp\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n<p>Something similar should work for lists, using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.attach#doc\">docs#List.attach</a>.</p>",
        "id": 451980947,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1721203815
    },
    {
        "content": "<p>You might also be interested in <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SatisfiesM#doc\">docs#SatisfiesM</a>, which is based on a similar idea, but for after-the-fact proving instead of inline proofs.</p>",
        "id": 451981331,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1721203895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"736905\">Mark Pock</span> has marked this topic as resolved.</p>",
        "id": 452277580,
        "sender_full_name": "Notification Bot",
        "timestamp": 1721290014
    },
    {
        "content": "<p>Thank you, SatisfiesM is in the spirit of what I'm looking for!</p>",
        "id": 452277751,
        "sender_full_name": "Mark Pock",
        "timestamp": 1721290057
    },
    {
        "content": "<p>I am running into a problem trying to go back from a <code>SatisfiesM</code> to the \"during the proof\" style</p>\n<p>In particular trying to wrap <code>Array</code> in <code>Vector N</code>, and trying to define <code>modifyM</code>. So I need to proove that modifying an array element will not change the length <em>within the monad</em>.</p>",
        "id": 466762282,
        "sender_full_name": "John Ericson",
        "timestamp": 1725224763
    },
    {
        "content": "<p>I see the definition of <code>SatisfiesM</code> has the existential quantification for the refinement type I need. But that is \"erased\" quantification at the level of Prop (as I understand it). I am not sure how to combine that erased fragment with the concrete monadic value to get the thing I need</p>",
        "id": 466762762,
        "sender_full_name": "John Ericson",
        "timestamp": 1725225034
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">internalizePostCondition</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u_2</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">action</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">action</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">action</span><span class=\"o\">})</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">//</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>OK this is the ingredient I am missing</p>",
        "id": 466767103,
        "sender_full_name": "John Ericson",
        "timestamp": 1725228221
    },
    {
        "content": "<p>OK no one responded so I opened an issue <a href=\"https://github.com/leanprover-community/batteries/issues/1032\">https://github.com/leanprover-community/batteries/issues/1032</a></p>",
        "id": 481575965,
        "sender_full_name": "John Ericson",
        "timestamp": 1731255878
    }
]