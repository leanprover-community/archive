[
    {
        "content": "<p>I'm looking at this proof of Cantor's theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Set</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">surj</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">surj</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fa_eq_S</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_nin_fa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_in_fa</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fa_eq_S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_in_fa</span>\n<span class=\"w\">    </span><span class=\"n\">contradiction</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_in_S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a_nin_fa</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fa_eq_S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_nin_fa</span>\n<span class=\"w\">    </span><span class=\"n\">contradiction</span>\n\n<span class=\"w\">  </span><span class=\"n\">contradiction</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>\n<p>(This is the same proof as <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C04_Sets_and_Functions.html#functions\">in MIL</a> but with some renames to help me retrace what's going on.)</p>\n<p>I found it particularly difficult to understand because in the tactic state, I don't <em>see</em> the contradiction itself. For example, place the cursor in this part:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_nin_fa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">a_in_fa</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fa_eq_S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_in_fa</span>\n<span class=\"w\">    </span><span class=\"c\">/-</span>\n<span class=\"cm\">    surj : Surjective f</span>\n<span class=\"cm\">    S : Set α := {i | i ∉ f i}</span>\n<span class=\"cm\">    a : α</span>\n<span class=\"cm\">    fa_eq_S : f a = S</span>\n<span class=\"cm\">    h : a ∈ f a</span>\n<span class=\"cm\">    a_in_fa : a ∈ S</span>\n<span class=\"cm\">    ⊢ False</span>\n<span class=\"cm\">    -/</span>\n<span class=\"w\">    </span><span class=\"n\">contradiction</span>\n</code></pre></div>\n<p>What is the contradiction here?</p>\n<p>If you're eagle-eyed, you'd notice that it's between</p>\n<ul>\n<li><code>a ∈ f a</code></li>\n<li><code>a ∈ S</code></li>\n</ul>\n<p>Wait, but how are those contradictory?</p>\n<p><em>\"Well, you see,\"</em> a mathematician might say, <em>\"<code>S</code> is defined to be <code>{i | i ∉ f i}</code> and thus <code>a ∈ S</code> means <code>a ∈ {i | i ∉ f i}</code>, which means <code>a ∉ f a</code>, which contradicts <code>a ∈ f a</code></em>.</p>\n<p>Very cool, I say to the mathematician. But how was I supposed to <em>see</em> that in this environment? What if I had an indirection of multiple named variables?</p>\n<p>What I <em>wish</em> I could do here is dereference <code>S</code>'s definition. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">a_in_fa</span>\n</code></pre></div>\n<p>So that I could clearly see <code>a ∈ f a</code> and <code>a ∉ f a</code> first and <em>then</em> confidently write <code>contradiction</code>.</p>\n<p>How do I do that?</p>",
        "id": 499960419,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739663169
    },
    {
        "content": "<p><code>unfold S at a_in_fa</code> should work.</p>",
        "id": 499960532,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663285
    },
    {
        "content": "<p><code>dsimp only [S] at a_in_fa</code> (or <code>simp</code> if you prefer) should work too</p>",
        "id": 499960546,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663303
    },
    {
        "content": "<p>Ahh I see. I tried <code>simp? at a_in_fa</code> but for some reason it didn't guess to include <code>S</code>.</p>",
        "id": 499960577,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739663349
    },
    {
        "content": "<p>Actually I guess this is the first time in my experience that <code>simp</code> on its own does \"worse\" than <code>simp only</code>. Why doesn't it try to expand <code>S</code> the way it usually tries with known lemmas?</p>",
        "id": 499960594,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739663388
    },
    {
        "content": "<p>Hm I guess expanding variables is actually not something you <em>usually</em> want so the default behavior makes sense.</p>",
        "id": 499960667,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739663432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 499960670,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739663437
    },
    {
        "content": "<p>Yeah, this behavior is intentional for that reason.</p>",
        "id": 499960679,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663449
    },
    {
        "content": "<p>There's also <code>dsimp +zetaDelta only at a_in_fa</code> I believe (or, again, <code>simp</code>)</p>",
        "id": 499960695,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663469
    },
    {
        "content": "<p>You can hover over <code>+zetaDelta</code> to read the option's docstring.</p>",
        "id": 499960712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663504
    },
    {
        "content": "<p>MIL feedback (cc <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span>, pls let me know if I shouldn't tag you in these!) — this proof felt unfairly complex because <code>unfold</code> technique is not explained by then and using <code>simp only</code> with variables was never demonstrated. When you're used to \"matching\" hypotheses almost symbolically, it's a non-obvious jump to \"remember\" what <code>S</code> is defined to and to \"notice\" the contradiction. The nested <code>j ∉ f j</code> proof in the suggested solution (which I think is only needed to avoid overwriting the hypothesis we'll need later) is also not an obvious thing to do. IMO this task fails more people than necessary and could be more fun if not for these technicalities.</p>",
        "id": 499960894,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1739663698
    },
    {
        "content": "<p>(Btw, I used <code>only</code> to prevent using any global simp lemmas. Explaining this just in case.)</p>",
        "id": 499960933,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739663753
    },
    {
        "content": "<p>Also, I hope you keep complaining about things as you come across them :-)</p>\n<p>The <code>unfold</code> tactic works with local definitions only because someone complained about it sometime a few months ago. Maybe <code>rw [S]</code> should work too, though there are some considerations why not, at least based on the current design of <code>rw</code>.</p>",
        "id": 499962125,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739664797
    },
    {
        "content": "<p>Here's another style of proof, which I think is somewhat clearer. The <code>congr(...)</code> syntax lets you create iffs or equalities by doing the same thing to both sides. In this case, applying <code>a ∈ .</code> to both sides.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Cantor</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">Surjective</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">surj</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">surj</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fa_eq_S</span><span class=\"bp\">⟩</span>\n\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congr</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">fa_eq_S</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- The following three lines can be replaced by `simp [S] at this`</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_setOf_eq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">iff_not_self</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 499962752,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1739665324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"418569\">@Dan Abramov</span> Feel free to tag me. Patrick and I seem to find time every few weeks to catch up and make changes to MIL, so you can also leave issues on the repository. It's often hard to remember the context of an example or exercise, so it's not always easy to evaluate suggested changes quickly. As Lean and Mathlib change, we often triage MIL with quick fixes when the better strategy would be to figure out where to introduce a new concept or method properly.</p>",
        "id": 500032454,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1739730167
    }
]