[
    {
        "content": "<p>Naively, I would have assumed <code>by exact T</code> would be interchangeable with <code>T</code> for any term <code>T</code>. </p>\n<p>However, searching around in Lean Std, I find things like <a href=\"https://github.com/leanprover/lean4/blob/master/src/Std/Do/PostCond.lean#L191-L193\">\"NB: Postponement through by exact is the entire point of this macro\"</a> and I notice in the definition of <code>TreeMap.ofArray</code>, the <code>cmp</code> argument is default <code>(cmp : α → α → Ordering := by exact compare)</code>, which appears to be a deliberate choice. I also found <a href=\"https://leanprover-community.github.io/archive/stream/113488-general/topic/subject.20reduction.html#312224138\">this archived zulip thread</a> discussing \"by-exact postponement\" somewhat. </p>\n<p>More concretely, I see in examples like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Klass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Klass</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Klass</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span>\n\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">good1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\">         </span><span class=\"n\">meth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">          </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">good2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\">          </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad_2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\">         </span><span class=\"n\">meth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the goods typecheck and the bads have \"typeclass instance is stuck\" errors, and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ord</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\">  </span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">compare</span><span class=\"o\">))</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\">  </span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>leads to actual type mismatch errors. This is coming from an example <span class=\"user-mention\" data-user-id=\"419650\">@Rob Simmons</span> showed me that led to this after I tried minimizing it.</p>\n<p>I dimly perceive that <code>by exact</code> is somehow reordering some steps of elaboration; is this summarized or documented in more detail somewhere that I should be looking?</p>",
        "id": 528357439,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752245974
    },
    {
        "content": "<p><code>by</code> delays elaboration of the tactic as much as possible, so that when you see the tactic state there won't be random metavariables there. As a side effect, if you want to delay elaboration of a particular term then <code>by exact</code> works pretty well.</p>",
        "id": 528357947,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752246111
    },
    {
        "content": "<p>Can you drill into why</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Klass</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Klass</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Klass</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>doesn't work, then? Is the type ascription simply too \"late\" in elaboration to propagate the <code>String</code> into the required type of <code>exact meth</code>? I see the expected type if I replace <code>by exact meth</code> with <code>by sorry</code> as a free metavariable.</p>",
        "id": 528358764,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246373
    },
    {
        "content": "<p>Can you pinpoint what you need explained?</p>",
        "id": 528358863,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752246403
    },
    {
        "content": "<p>Sorry, I hit 'enter' instead of 'shift-enter' there</p>",
        "id": 528358959,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246429
    },
    {
        "content": "<p>If the answer is it tries to delay it \"as much as possible\" but, given the design of elaboration, what I'm asking for is <em>more</em> than what is possible, then I'd be totally satisfied.</p>",
        "id": 528359269,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246535
    },
    {
        "content": "<p>I'm guessing the expected type isn't taken into account when elaborating an application with the <code>(arg := val)</code> syntax</p>",
        "id": 528359351,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752246559
    },
    {
        "content": "<p>Ok, I think I find that satisfying enough as an explanation as well.</p>",
        "id": 528359465,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246591
    },
    {
        "content": "<p>I worry a bit there is still a repeatable footgun lurking here, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Ord</span>\n\n<span class=\"c1\">-- This is a type mismatch, because the invisible 'by exact compare'</span>\n<span class=\"c1\">-- can't instantiate Compare where the type variable is a metavariable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\">  </span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">])</span>\n\n<span class=\"c1\">-- But making the default argument explicit fixes it</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">Label</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span>\n<span class=\"w\">  </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s2\">\"name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"w\">  </span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>for end users who never actually said <code>by exact</code>, because the default <code>cmp</code> argument of <code>Std.TreeMap</code> for example (and there are some other examples in <code>Std</code> and <code>Mathlib</code> that I found just grepping around) causes it to appear</p>",
        "id": 528360645,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246944
    },
    {
        "content": "<p>(This in fact just came up because <span class=\"user-mention\" data-user-id=\"419650\">@Rob Simmons</span> encountered this problem in the wild and we were both puzzled by it for a bit)</p>",
        "id": 528360775,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752246985
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528359351\">said</a>:</p>\n<blockquote>\n<p>I'm guessing the expected type isn't taken into account when elaborating an application with the <code>(arg := val)</code> syntax</p>\n</blockquote>\n<p>It's still taken into account.</p>\n<p>Expected type propagation only happens at the first explicit argument, and <code>Foo.mk</code> has no explicit arguments.</p>",
        "id": 528401682,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752265408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">Jason Reed</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528357439\">said</a>:</p>\n<blockquote>\n<p>I notice in the definition of <code>TreeMap.ofArray</code>, the <code>cmp</code> argument is default <code>(cmp : α → α → Ordering := by exact compare)</code>, which appears to be a deliberate choice.</p>\n</blockquote>\n<p>The reason here is that <code>:= compare</code> doesn't work, since there's no <code>Ord</code> instance passed to <code>Std.TreeMap.ofArray</code>, which <code>compare</code> needs.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"662452\">Jason Reed</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528358764\">said</a>:</p>\n<blockquote>\n<p>Can you drill into why</p>\n</blockquote>\n<p>I'm not sure exactly why the first works and the second doesn't:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm guessing it's something to do with <code>by exact meth</code> immediately creating a synthetic opaque metavariable <code>?m.2</code>, which can't unify with <code>meth</code>, so <code>Foo String meth</code> can't unify with <code>Foo ?m.1 ?m.2</code>, so <code>α</code> is still unknown by the time <code>by exact meth</code> is forced to evaluate.</p>",
        "id": 528403450,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752266383
    },
    {
        "content": "<p>Oh, yeah, that's why. If we add a unification hint to allow partial unification of <code>Foo</code>, then it goes through.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">unif_hint</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">α'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">α'</span>\n<span class=\"w\">  </span><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"bp\">=?=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">α'</span><span class=\"w\"> </span><span class=\"n\">wit'</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">now_good</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">meth</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 528403627,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752266473
    },
    {
        "content": "<p>Interesting! Thanks for the explanation. I'll have to read up on <code>unif_hint</code> then.</p>",
        "id": 528405176,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752267406
    },
    {
        "content": "<p>Maybe you don't need to read too much about it, but it's good to know about!</p>\n<p>Here's what you need to know: this tells unification to try doing the unifications above the <code>⊢</code> if the one after <code>⊢</code> is currently failing.</p>",
        "id": 528405733,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752267652
    },
    {
        "content": "<p>I am someone who has done proof assistant implementation in the past, in addition to being a normal Lean user who wants to do math in Lean, so gnarly details about unification mechanisms are interesting :)</p>",
        "id": 528405892,
        "sender_full_name": "Jason Reed",
        "timestamp": 1752267735
    },
    {
        "content": "<p>I'm pretty sure my unification hint is a bad one (what's above the turnstile should cause what's below to be a defeq), but at least it helps prove the hypothesis.</p>\n<p><a href=\"https://github.com/leanprover/lean4/blob/e2e36087e1ff1c29043ded4949862d5da7a8cf4a/src/Lean/Meta/ExprDefEq.lean#L1862\">https://github.com/leanprover/lean4/blob/e2e36087e1ff1c29043ded4949862d5da7a8cf4a/src/Lean/Meta/ExprDefEq.lean#L1862</a> is when they're applied, for reference.</p>",
        "id": 528410338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752270359
    },
    {
        "content": "<p>To make concrete what <span class=\"user-mention\" data-user-id=\"662452\">@Jason Reed</span> called a \"repeatable footgun\" and which I keep running into, this is basically the situation I'm finding myself in:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Str</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Age\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">]</span>\n</code></pre></div>\n<p>It's super unmotivated that this doesn't work! But it seems like (and I think the <a href=\"https://lean-lang.org/functional_programming_in_lean/Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions\">FP in Lean book</a> is backing me up here) the right solution wasn't discussed here, and it's that the cosmetic <code>Schema</code> definition should be an abbrev instead:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Str</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Age\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">]</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"662452\">@Jason Reed</span> , how much do you remember the problems that led Twelf to have an <a href=\"https://twelf.org/wiki/abbrev-declaration/\">#abbrev decl</a>? Because I wonder if it's similar. How possible might it be to detect this footgun and error/warn the user about it, pointing them towards abbrev instead of def?</p>",
        "id": 528548494,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752431773
    },
    {
        "content": "<p>I might want to upgrade this from \"footgun\" to \"elaboration bug\" (or \"library bug\" due to missing language features).</p>\n<p>It's either from functions like <code>Std.TreeMap.ofArray</code> using this <code>:= by exact compare</code> auto-param scheme, which isn't friendly for unification due to the kinds of metavariables tactic goals use (synthetic opaque) or its from the way the expected type is propagated, or both.</p>",
        "id": 528548882,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752432125
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span> Maybe you want to take a look at this? I can see why the library uses auto-params, since it means you can pass a <code>cmp</code> argument, which is more convenient than using <code>Ord</code> instances, but on the flip side since it's a tactic it seems like it's not really possible to solve for by unification.)</p>",
        "id": 528549136,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752432380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"419650\">@Rob Simmons</span> A workaround, rather than using an <code>abbrev Schema</code> (correct me if I'm wrong, but I believe that's where you intended to add <code>abbrev</code>), you can use a <code>(cmp := _)</code> named argument to disable the auto-param and let it be solved for by unification.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cmp</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Str</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Age\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 528549242,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752432471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> yes whoops put the <code>abbrev</code> in the wrong place in the \"this works\" example (I've now edited it)</p>",
        "id": 528549271,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752432508
    },
    {
        "content": "<p>For the purpose of my example <code>abbrev</code> clearly seems like the \"introduces fewer unusual concepts\" solution, but it's useful to know about the <code>cmp := _</code> method of, in effect, re-ordering arguments.</p>",
        "id": 528549456,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752432722
    },
    {
        "content": "<p>I guess <code>Ord</code>... or, something else... is the approach I'd expect to see here — <del>seems like you could cause some pretty severe shenagians by forming a tree with one compare function and then looking up in it with another compare function</del> oh, I think I'm understanding what the dependent types are doing here a bit better now — seems like that won't work</p>",
        "id": 528549668,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752432944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419650\">Rob Simmons</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528549456\">said</a>:</p>\n<blockquote>\n<p>in effect, re-ordering arguments.</p>\n</blockquote>\n<p>This isn't what's going on here to be clear. I can equally have written</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Str</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Age\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n</code></pre></div>\n<p>The point is that since I'm specifying the argument myself as <code>_</code>, it's the kind of metavariable that <em>can</em> be solved for by unification. The <code>by exact compare</code> creates a metavariable that's \"synthetic opaque\" and can't be solved for by unification. You can check that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Name\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Str</span><span class=\"o\">),</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"s2\">\"Age\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"bp\">.</span><span class=\"n\">Int</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">compare</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>fails in the same way.</p>",
        "id": 528549843,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752433148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"419650\">Rob Simmons</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528549456\">said</a>:</p>\n<blockquote>\n<p>For the purpose of my example <code>abbrev</code> clearly seems like the \"introduces fewer unusual concepts\" solution</p>\n</blockquote>\n<p>I'm finding the fact that <code>abbrev</code> works here to be somewhat mysterious. I'm guessing it's letting expected type propagation to solve for the <code>cmp</code> argument and then the auto-param doesn't get triggered... but I'm not sure, I'd have to check the elaboration code more carefully.</p>\n<p>Named arguments are not an unusual concept, and you can switch between using positional and named arguments without changing anything about elaboration.</p>",
        "id": 528549989,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752433268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> The rule that I'm gleaning from the linked \"FP in lean\" lesson is \"you can't assume that <code>def</code> obeys the property of substitution/inlining, but <code>abbrev</code> has this property\" — are there cases where <code>abbrev</code> definitions _don't_ obey substitution? I'd find that more surprising.</p>",
        "id": 528550364,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752433620
    },
    {
        "content": "<p>When typechecking/unifying, <code>def</code>s can be unfolded, and I think I'd expect it to be unfolded here when propagating the expected type.</p>",
        "id": 528550520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752433771
    },
    {
        "content": "<p>That said, I don't see expected type propagation happening at all either for <code>def</code> or <code>abbrev</code>, according to the output of <code>set_option trace.Elab.app.propagateExpectedType true</code>.</p>",
        "id": 528550675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752433931
    },
    {
        "content": "<p>interesting... still learning here, will keep the question \"what does abbrev mean if it's not syntactic substitution/inlining\" in my head as I learn</p>",
        "id": 528551017,
        "sender_full_name": "Rob Simmons",
        "timestamp": 1752434214
    },
    {
        "content": "<p>Sorry, I implicitly answered your question by not saying anything about <code>abbrev</code>. It creates a \"reducible\" definition, one that unfolds even at the most conservative transparency setting.</p>",
        "id": 528551150,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752434278
    },
    {
        "content": "<p><code>def</code> creates a \"semireducible\" definition, which tends not to get unfolded by processes that match expressions, for example when finding instances that might apply for a given typeclass.</p>",
        "id": 528551232,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752434327
    },
    {
        "content": "<p>I still don't see any reason why <code>abbrev</code> should make this elaboration succeed...</p>\n<p>It's very delicate whether it succeeds or not. For example, even this makes it succeed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Str</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Typ</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Typ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">TreeMap</span><span class=\"bp\">.</span><span class=\"n\">ofArray</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:)</span>\n</code></pre></div>\n<p>This causes the <code>by exact compare</code> to evaluate <em>before</em> unifying types.</p>",
        "id": 528551641,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752434682
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover/lean4/pull/9346\">lean4#9346</a> is an experiment in having auto-params elaborate in a way that lets these unifications go through)</p>",
        "id": 528562203,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1752445805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/T.20vs.2E.20by.20exact.20T/near/528549136\">said</a>:</p>\n<blockquote>\n<p>(<span class=\"user-mention silent\" data-user-id=\"221653\">Paul Reichert</span> Maybe you want to take a look at this? I can see why the library uses auto-params, since it means you can pass a <code>cmp</code> argument, which is more convenient than using <code>Ord</code> instances, but on the flip side since it's a tactic it seems like it's not really possible to solve for by unification.)</p>\n</blockquote>\n<p>I fully agree that the situation at hand is confusing, but it's not clear to me how to improve it from the library's angle. Always requiring an <code>Ord</code> instance would be an option, although it would complicate other use cases that involve an ad-hoc comparison function. Let me hope for now that the experimental PR turns out to be promising ;)</p>",
        "id": 528603682,
        "sender_full_name": "Paul Reichert",
        "timestamp": 1752479601
    }
]