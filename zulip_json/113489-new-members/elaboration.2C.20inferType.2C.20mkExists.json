[
    {
        "content": "<p>I am learning my around elaboration and type inference.  As an exercise, I'm trying to write a macro and elaborator to convert <code>foo 5</code> into <code>∃ x : Nat, x = 5</code>.  I'm having difficulty getting the monads to line up so that the elaborator typechecks. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Term</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Command</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Meta</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"c1\">-- this returns the argument to `foo`</span>\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabFoo1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- throwError s!\"entry point: 0={stx[0]} 1={stx[1]} 1.0={stx[1][0]} {typ?}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mt</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"n\">mt</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"c1\">-- returns 5</span>\n\n<span class=\"c1\">-- this doesn't typecheck, because the result is Expr when it should be TermElabM Expr</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabFoo2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Syntax</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"c1\">-- throwError s!\"entry point: 0={stx[0]} 1={stx[1]} 1.0={stx[1][0]} {typ?}\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- get the argument to foo</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mt</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- elaborate the argument to get a TermElabM Expr</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\">  </span><span class=\"n\">mt</span><span class=\"w\"> </span><span class=\"c1\">-- extract the Expr from the monad</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\">  </span><span class=\"bp\">←</span><span class=\"w\">  </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\"> </span><span class=\"c1\">-- infer the type</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkForall</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">BinderInfo</span><span class=\"bp\">.</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\">  </span><span class=\"c1\">-- build the result Expr</span>\n<span class=\"w\">  </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"c1\">-- type = Expr, expected type = TermElabM Expr</span>\n</code></pre></div>\n<p>The second problem is that I haven't found a mkExists that works like mkForall or mkForallEx.</p>\n<p>-mark</p>",
        "id": 482911764,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1731891972
    },
    {
        "content": "<p>At the risk of giving you bad advice: have you considered doing <code>pure res</code> instead of just <code>res</code>?</p>\n<p>I have no understanding of your code or metaprogramming in Lean in general, but when it comes to monads, whenever you have a term of type <code>a</code> and you need a term of type <code>m a</code>, often using <code>pure</code> (or <code>return</code>) will do the trick.</p>",
        "id": 482913982,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1731893830
    },
    {
        "content": "<p>Matt,<br>\nThanks.  Adding in <code>pure</code> led to some progress.  The code below type checks, but throws an error.  </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabFoo1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">tryPostponeIfNoneOrMVar</span><span class=\"w\"> </span><span class=\"n\">typ?</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"c1\">-- setting expected type to none, bad idea?</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\">  </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkForall</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">BinderInfo</span><span class=\"bp\">.</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">res</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"c1\">-- failed to synthesize instance</span>\n<span class=\"c1\">--  OfNat (Sort ?u.747) 5</span>\n</code></pre></div>\n<p>-mark</p>",
        "id": 482916689,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1731895830
    },
    {
        "content": "<p>The issue here is that you're constructing the expression <code>forall x : ty, 5</code>, and there's no instance that makes <code>5 : Sort _</code> make sense.</p>",
        "id": 482919352,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731897921
    },
    {
        "content": "<p>Maybe this helps?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabFoo1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">    </span><span class=\"n\">withLocalDeclD</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkForallFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">      </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"c1\">-- ∀ (x : Nat), x = 5 : Prop</span>\n</code></pre></div>",
        "id": 482919473,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731898010
    },
    {
        "content": "<p>(Tip: use <code>#check</code> here instead of <code>#eval</code>, since you aren't wanting to evaluate the expression, just see what it elaborates to.)</p>",
        "id": 482919494,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731898032
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> would the code be similar to construct <code>∃ (x : Nat), x = 5</code>? I think that was <span class=\"user-mention\" data-user-id=\"741196\">@Mark Aagaard</span>'s next question and tbh I'm kind of curious too</p>",
        "id": 482920580,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1731898911
    },
    {
        "content": "<p>Yes, the first difference would be to use mkLambdaFVars instead of mkForallFVars, and then you pass that to the last argument of <code>Exists</code></p>",
        "id": 482920803,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731899056
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s2\">\"foo\"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">term_elab</span><span class=\"w\"> </span><span class=\"n\">foox</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">elabFoo1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElab</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"n\">typ?</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">stx</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">bod</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">inferType</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">    </span><span class=\"n\">withLocalDeclD</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkEq</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">bod</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkLambdaFVars</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">eq</span>\n<span class=\"w\">      </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``Exists</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">res</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">throwUnsupportedSyntax</span>\n\n<span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"bp\">.</span><span class=\"n\">funBinderTypes</span><span class=\"w\"> </span><span class=\"n\">true</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n<span class=\"c1\">-- ∃ (x : Nat), x = 5 : Prop</span>\n</code></pre></div>",
        "id": 482920836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1731899112
    },
    {
        "content": "<p>Kyle-<br>\nThanks!  Your solution is very informative.<br>\n-mark</p>",
        "id": 482921589,
        "sender_full_name": "Mark Aagaard",
        "timestamp": 1731899713
    },
    {
        "content": "<p>So the core Elab is <code>Generalize</code> + <code>Change</code> + <code>Rfl</code> + <code>Symm</code> + <code>Rewrite</code>? Then it's the simplification layer - <code>Simp</code> / <code>NormCast</code> / <code>SimpTrace</code> ? Then some automation (like <code>SolveByElim</code>), some logical \"features\" like <code>FalseOrByContra</code>, induction and some transformation mechanisms (I see 4? <code>Conv</code>, <code>Unfold</code>, <code>Split</code>, <code>Delta</code>)</p>\n<p>And then building an elab is essentially accessing the syntax tree, applying  transformations,  and updating the proof state? (one can also declare the custom syntax)</p>",
        "id": 483058789,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1731945225
    }
]