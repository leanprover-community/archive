[
    {
        "content": "<p>Hi there, apologies if this is not the right place to ask such a question.</p>\n<p>I'm just wondering why there isn't a <code>List.Vector.MapM</code>? I wondered if it is perhaps because there is a more general implementation of this somewhere that I should be using?</p>\n<p>My particular use-case, if it helps, is that I have a <code>List.Vector (List.Vector α n) n</code>, and a function <code>α → Option β</code>, and I want to create an <code>Option (List.Vector (List.Vector β n) n)</code>. This was simple with (non <code>List</code>) <code>Vector.mapM</code>, but I am switching over to <code>List.Vector</code> to make a lot of other proofs much simpler.</p>\n<p>Thanks in advance!</p>",
        "id": 564678470,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766145083
    },
    {
        "content": "<p>I think it's missing and we should have it. In fact, it looks like <code>List.Vector</code> API is missing quite a lot e.g. <code>mapM</code>, <code>forM</code>, <code>zip</code>, <code>zipWithM</code>, <code>fold{l,r}{,M}</code>.</p>",
        "id": 564684556,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766147026
    },
    {
        "content": "<p>Ok, good to know! I have already implemented <code>List.Vector.MapM</code> for my own satisfaction, I'd very much like to be involved in adding these to the library, if that is possible! I'm studying existing implementations for other types to try to match the approach.</p>",
        "id": 564690171,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766148977
    },
    {
        "content": "<p>Sure! Check out <a href=\"https://leanprover-community.github.io/contribute/index.html\">#contrib</a>.</p>",
        "id": 564699558,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766152047
    },
    {
        "content": "<p>List.Vector has limited API for good reason. It got superseded by Vector for almost all uses.</p>",
        "id": 564770405,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766175567
    },
    {
        "content": "<p>It was kept around because someone felt that they were still useful in some cases like PL contexts. I am not sure this is true anymore, since Finvec might work better and Vector can be used like Lists if absolutely needed.</p>",
        "id": 564770519,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766175628
    },
    {
        "content": "<p>Why not supersede List with Array?</p>",
        "id": 564770594,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766175667
    },
    {
        "content": "<p>Operations that are efficient for arrays are not natural for lists and vice versa</p>",
        "id": 564771178,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766175988
    },
    {
        "content": "<p>Exactly, that's why there's List.Vector and Vector. It's just List and Array with length as index parameter.</p>",
        "id": 564771312,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766176050
    },
    {
        "content": "<p>Yes except when you find a definition missing in list.vector, it is worthwhile trying the Vector version.</p>",
        "id": 564773303,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766177094
    },
    {
        "content": "<p>I think list.vector was saved by one member of the community. And they had very specific uses in mind</p>",
        "id": 564773346,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766177118
    },
    {
        "content": "<p>In my opinion it's better to deprecate something then have a half-baked API. But if <span class=\"user-mention\" data-user-id=\"115259\">@Scott Buckley</span> wishes to contribute to List.Vector then I see no reason to not have it.</p>",
        "id": 564773751,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766177351
    },
    {
        "content": "<p>Are there many uses for Vector though? I never used it, and I would prefer to just use <code>arr.size = n : Prop</code> if there's a need for it.</p>",
        "id": 564774176,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766177562
    },
    {
        "content": "<p>There’s prior discussion on this in the mathlib4 channel</p>",
        "id": 564777645,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766179579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564777645\">said</a>:</p>\n<blockquote>\n<p>There’s prior discussion on this in the mathlib4 channel</p>\n</blockquote>\n<p>Could you point me to this discussion please? I did a search before posting but wasn't able to find it.</p>",
        "id": 564779443,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766180708
    },
    {
        "content": "<p><a href=\"#narrow/channel/287929-mathlib4/topic/Mathlib.20Vector.20namespace/near/440588550\">https://leanprover.zulipchat.com/#narrow/channel/287929-mathlib4/topic/Mathlib.20Vector.20namespace/near/440588550</a></p>",
        "id": 564784042,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766183625
    },
    {
        "content": "<p>Basically nobody except Mario was defending its continued existence</p>",
        "id": 564784835,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766184171
    },
    {
        "content": "<p>And Mario’s objection to deleting it rested on List.Vector being useful for something because it doesn’t  have array underneath.</p>",
        "id": 564784912,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766184222
    },
    {
        "content": "<p>It seems to me that it is a fair bit more useful for writing proofs (which is what I am usually doing). However, if there was a nice way to do case destruction and induction in a list-like manner on the array-based <code>Vector</code>, that would also suit my needs I guess!</p>",
        "id": 564785061,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766184311
    },
    {
        "content": "<p>Regardless, it does exist as of now. Purely as an exercise I would be happy to implement some of the features mentioned above for it, and it would be fine if they ended up being thrown away if <code>List.Vector</code> is thrown away - it is good practice for me nonetheless.</p>",
        "id": 564785144,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766184398
    },
    {
        "content": "<p>Convert the vector to a list of course</p>",
        "id": 564785977,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1766185092
    },
    {
        "content": "<p>I've looked through usages of Array in mathlib4, and it's not being used in any definition. It's only being used internally in a few functions for List (as an optimization). <code>Vector</code> is not being used in mathlib4 at all.<br>\nThere are some usages of <code>List.Vector</code> though.</p>",
        "id": 564786242,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766185284
    },
    {
        "content": "<p>There is no lemma of the form <code>arr = .empty ∨ arr = arr'.push a</code>, nor there is eliminator for these two cases for neither <code>Array</code> nor <code>Vector</code>. This is because, for this kind of induction style use, <code>List</code> and <code>List.Vector</code> are better suited.</p>",
        "id": 564786488,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766185480
    },
    {
        "content": "<p>There is no performance gain of using Array over List in kernel. It only matters for compiled programs.</p>",
        "id": 564787196,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564786488\">said</a>:</p>\n<blockquote>\n<p>There is no lemma of the form <code>arr = .empty ∨ arr = arr'.push a</code></p>\n</blockquote>\n<p>Note that these lemmas are generally worthless anyway; they should be expressed as induction principles not as  compound expressions with <code>Exists</code> and <code>Or</code></p>",
        "id": 564787794,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766186666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564787794\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"870257\">Jakub Nowak</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564786488\">said</a>:</p>\n<blockquote>\n<p>There is no lemma of the form <code>arr = .empty ∨ arr = arr'.push a</code></p>\n</blockquote>\n<p>Note that these lemmas are generally worthless anyway; they should be expressed as induction principles not as  compound expressions with <code>Exists</code> and <code>Or</code></p>\n</blockquote>\n<p>Hm, why exactly do you think they would be worthless?</p>",
        "id": 564787857,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186736
    },
    {
        "content": "<p>Is there an induction principle for <code>Vector</code> similar to <code>List.Vector.inductionOn</code>?</p>",
        "id": 564787869,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766186745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"115259\">Scott Buckley</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564787869\">said</a>:</p>\n<blockquote>\n<p>Is there an induction principle for <code>Vector</code> similar to <code>List.Vector.inductionOn</code>?</p>\n</blockquote>\n<p><del>There isn't, I think you could write one, but Eric seems to disagree?</del></p>",
        "id": 564787908,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186799
    },
    {
        "content": "<p>Ah, wait, no. Sorry, I've misread your message Eric.</p>",
        "id": 564787981,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186860
    },
    {
        "content": "<p>You could use <code>obtain \\&lt;h, h\\&gt; := </code> on a lemma expressed with <code>Or</code>. So I don't think it's worthless.</p>",
        "id": 564788030,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186899
    },
    {
        "content": "<p>Why is that better than using <code>induction</code> though?</p>",
        "id": 564788042,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766186911
    },
    {
        "content": "<p>It isn't.</p>",
        "id": 564788053,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766186920
    },
    {
        "content": "<p>In the end your <code>⟨ ⟩</code> has far more things in the braces than that, and you end up using the induction principle for <code>Eq</code>, <code>Or</code>, and <code>Exists</code> instead of more directly using the one for your specific type</p>",
        "id": 564788104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766186964
    },
    {
        "content": "<p>We should definitely have an <code>Array.recPush</code> definition with the analgous statement</p>",
        "id": 564788173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766187024
    },
    {
        "content": "<p>I'm not so sure we should. If you need to prove something about your implementation that uses Array, wouldn't it be easier to just convert your Array to List at the very start of the proof?</p>",
        "id": 564788320,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766187169
    },
    {
        "content": "<p>That is</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">elab_as_elim</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">recPush</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[])</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cast</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">pop</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">back</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">recPush</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">pop</span><span class=\"o\">)</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n</code></pre></div>",
        "id": 564788785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766187506
    },
    {
        "content": "<p>I played a bit with a definition for <code>List.Vector.mapM</code> today. It can be a little tricky with the length proof obligation hanging around. I got the following working using tactic mode:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I tried to implement the above using <code>List.Vector.casesOn</code> outside of tactic mode, which is doable, but will require some fiddling with specifying the right motive I guess - I'm new to this \"motive\" structure.</p>",
        "id": 564810548,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766216561
    },
    {
        "content": "<p>The following feels like a more \"natural\" definition to me, but does not compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The issue here is that <code>List.Vector.cons</code> creates a <code>List.Vector</code> of length <code>Nat.succ n'</code>, which needs to match against <code>n</code> - intuitively we know that the length <code>n</code> in the <code>cons</code> case is non-zero and therefore unifies with some <code>Nat.succ n'</code>, but cramming that knowledge/logic into this definition might get a bit unwieldy.</p>\n<p>Any tips?</p>",
        "id": 564810753,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766216723
    },
    {
        "content": "<p>The tactic one looks fine to me</p>",
        "id": 564814949,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766222178
    },
    {
        "content": "<p>You could otherwise invoke <code>casesOn</code> directly without using <code>cases</code>, if you want to stay in term mode</p>",
        "id": 564814964,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766222196
    },
    {
        "content": "<p>I woner if something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.size_mapM#doc\">docs#Array.size_mapM</a> (but for List) is useful here</p>",
        "id": 564815142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766222392
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> can comment on whether mvcgen's machinery replaces SatisfiesM</p>",
        "id": 564815166,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1766222412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"115259\">@Scott Buckley</span> Matching on index parameters often helps.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"bp\">⟩</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 564818024,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766225571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"870257\">@Jakub Nowak</span> very nice! And Lean is clever enough here to not require the two invalid cases? very clever :)</p>",
        "id": 564818091,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766225654
    },
    {
        "content": "<p>This is because the type of <code>⟨[], h⟩</code> is <code>Vector α 0</code> and the type of <code>⟨a :: v, h⟩</code> is <code>Vector α (Nat.succ n)</code>.<br>\n<a href=\"https://github.com/leanprover-community/mathlib4/blob/7478ffb26bdb1d28e594d5de3c49a170e30404cf/Mathlib/Data/Vector/Defs.lean#L44-L53\">https://github.com/leanprover-community/mathlib4/blob/7478ffb26bdb1d28e594d5de3c49a170e30404cf/Mathlib/Data/Vector/Defs.lean#L44-L53</a></p>",
        "id": 564818851,
        "sender_full_name": "Jakub Nowak",
        "timestamp": 1766226566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/MapM.20for.20List.2EVector/near/564815166\">said</a>:</p>\n<blockquote>\n<p>Maybe <span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> can comment on whether mvcgen's machinery replaces SatisfiesM</p>\n</blockquote>\n<p>I think the new <a href=\"https://github.com/leanprover/lean4/blob/13c88f960f40b7c163b99e742010bbbbdbe8bba7/src/Init/Control/MonadAttach.lean#L30\"><code>MonadAttach</code></a> type class (cc <span class=\"user-mention\" data-user-id=\"221653\">@Paul Reichert</span>) could be used instead of <code>SatisfiesM</code> (and we are planning to prove such goals with <code>mvcgen</code>). <code>SatisfiesM</code> is more general than the <code>MonadAttach</code>/<code>WPMonad</code> framework in a way that is restrictive for higher-order specifications, but in <em>this particular case</em> <code>SatisfiesM</code> seems like the optimal solution because it requires fewer instances (i.e. no <code>MonadAttach</code>). That restriction shouldn't make a difference for computable, non-CPS monads.</p>\n<p>Although even the <code>SatisfiesM</code> lemma would require an unnecessary <code>LawfulMonad</code> on <code>mapM</code>. I suggest to write the (somewhat painful) definition of <code>List.Vector.mapM</code> directly and then prove the \"extensionality lemma\" that <code>toList &lt;$&gt; List.Vector.mapM xs f = List.mapM xs.toList f</code>.</p>",
        "id": 564961117,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1766394396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> I didn't find <code>List.Vector.mapM</code> too painful to define, but I did need <code>LawfulMonad</code> for the extensionality proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">[],</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_+</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_right_cancel</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM_cons</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">l_v</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">l_h</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM_nil</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM_extensionality</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Vector</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">mapM</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">expose_names</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 565263476,
        "sender_full_name": "Scott Buckley",
        "timestamp": 1766569162
    },
    {
        "content": "<p>Probably the original definition should be <code>mapA</code> to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.mapA#doc\">docs#List.mapA</a></p>",
        "id": 567396191,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1768144684
    }
]