[
    {
        "content": "<p>I have been working on showing that profinite groups possess a neighbourhood basis of the identity consisting of normal and open subgroups (cf. <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/profinite.20sets\">#Is there code for X? &gt; profinite sets</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/7991\">https://github.com/leanprover-community/mathlib4/pull/7991</a>). While showing this, the main step is to show that any clopen set containing the identity element in a compact topological group contains an open subgroup. I do this by constructing a cover and then extract a finite subcover by compactness. This is an adapted mwe excerpt of it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Group.Basic</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">TopologicalGroup</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">U</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">v_open</span> <span class=\"o\">(</span><span class=\"n\">U_open</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U_compact</span> <span class=\"o\">:</span> <span class=\"n\">IsCompact</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isOpen_iff_forall_mem_open.mpr</span>\n  <span class=\"n\">intro</span> <span class=\"n\">v</span> <span class=\"n\">hv</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">g₁</span><span class=\"o\">,</span> <span class=\"n\">g₂</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">g₁</span> <span class=\"bp\">*</span> <span class=\"n\">g₂</span>\n  <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">Set</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">U_u</span><span class=\"o\">,</span> <span class=\"n\">V_u</span><span class=\"o\">⟩</span> <span class=\"bp\">↦</span>\n    <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U_u</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">V_u</span> <span class=\"bp\">∧</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U_u</span> <span class=\"bp\">∧</span> <span class=\"n\">IsOpen</span> <span class=\"n\">V_u</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">U_u</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">V_u</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">m</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span>\n  <span class=\"k\">have</span> <span class=\"n\">hU</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">u</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨(</span><span class=\"n\">U_u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">V_u</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">U_u_open</span><span class=\"o\">,</span> <span class=\"n\">V_u_closed</span><span class=\"o\">,</span> <span class=\"n\">u_in_U_u</span><span class=\"o\">,</span> <span class=\"n\">v_in_V_u</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:</span>\n        <span class=\"bp\">∃</span> <span class=\"n\">U_u</span> <span class=\"n\">V_u</span><span class=\"o\">,</span> <span class=\"n\">IsOpen</span> <span class=\"n\">U_u</span> <span class=\"bp\">∧</span> <span class=\"n\">IsOpen</span> <span class=\"n\">V_u</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">U_u</span>\n        <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">V_u</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">U_u</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">V_u</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">m</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">isOpen_prod_iff.mp</span>\n      <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">IsOpen.preimage</span> <span class=\"n\">continuous_mul</span> <span class=\"n\">U_open</span>\n      <span class=\"bp\">·</span> <span class=\"n\">apply</span> <span class=\"n\">hv</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n    <span class=\"n\">exists</span> <span class=\"o\">(</span><span class=\"n\">U_u</span><span class=\"o\">,</span> <span class=\"n\">V_u</span><span class=\"o\">)</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Classical.axiomOfChoice</span> <span class=\"n\">hU</span>\n  <span class=\"k\">let</span> <span class=\"n\">cov</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">IsCompact.elim_finite_subcover</span> <span class=\"n\">U_compact</span> <span class=\"n\">cov</span>\n    <span class=\"bp\">·</span> <span class=\"n\">aesop</span>\n    <span class=\"bp\">·</span> <span class=\"n\">intro</span> <span class=\"n\">u</span> <span class=\"n\">u_in_U</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iUnion</span><span class=\"o\">]</span>\n      <span class=\"n\">exists</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u_in_U</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Subtype.forall</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span> <span class=\"bp\">⋂</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">IsOpen</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">isOpen_biInter_finset</span>\n    <span class=\"n\">intro</span> <span class=\"n\">u</span> <span class=\"n\">_</span>\n    <span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">V_u_open</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">u</span>\n    <span class=\"n\">assumption</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">V'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp_all</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iInter</span><span class=\"o\">,</span> <span class=\"n\">implies_true</span><span class=\"o\">]</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">V'</span> <span class=\"bp\">⊆</span> <span class=\"n\">V</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">v'</span> <span class=\"n\">v'_in_V'</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u_in_U</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">⟩</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"bp\">⋃</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">cov</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">ht</span> <span class=\"n\">u_in_U</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.mem_iUnion</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_iInter</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hu</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">i_in_t</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">u_in_i</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)⟩</span> <span class=\"o\">:=</span> <span class=\"n\">bex_def.mp</span> <span class=\"n\">this</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hm</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">i</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hm</span> <span class=\"o\">(</span><span class=\"n\">Set.mk_mem_prod</span> <span class=\"n\">u_in_i</span> <span class=\"o\">(</span><span class=\"n\">v'_in_V'</span> <span class=\"n\">i</span> <span class=\"n\">i_in_t</span><span class=\"o\">))</span>\n  <span class=\"n\">exists</span> <span class=\"n\">V'</span>\n</code></pre></div>\n<p>My issue with this is the use of <code>Classical.axiomOfChoice</code> to construct an explicit cover. Can this be somehow circumvented, since I don't care about the explicit cover, any cover satisfying the properties suffices? Or does this actually depend on choice? I think the problem arises from the fact that the sets of the form <code>U_u ×ˢ V_u</code> only form a basis of the topology on <code>G × G</code>, so I can't just explicitly construct the sets <code>U_u</code> and <code>V_u</code>.</p>",
        "id": 399040004,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698491558
    },
    {
        "content": "<p>As a side question, is there a nice way to avoid the these</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">V_u_open</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span> <span class=\"n\">u</span>\n</code></pre></div>\n<p>lines?</p>",
        "id": 399040228,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698491705
    },
    {
        "content": "<p>You could use <code>choose U V huU huV hUopen hVopen hUV using hf</code>. Also note that <code>obtain ⟨f, hf⟩ := Classical.axiomOfChoice hU</code> is just <code>obtain ⟨f, hf⟩ := hU</code>.</p>",
        "id": 399041604,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698492727
    },
    {
        "content": "<p>You need the axiom of choice when <strong>constructing data</strong> (namely your goal, the thing after the <code>⊢</code>, has type <code>Type</code>). If you merely <strong>prove propositions</strong> (namely your goal has type <code>Prop</code>), you can just eliminate the existential intuitionistically.</p>",
        "id": 399041776,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698492859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/axiom.20of.20choice.20in.20constructing.20covers/near/399041604\">said</a>:</p>\n<blockquote>\n<p>You could use <code>choose U V huU huV hUopen hVopen hUV using hf</code>. Also note that <code>obtain ⟨f, hf⟩ := Classical.axiomOfChoice hU</code> is just <code>obtain ⟨f, hf⟩ := hU</code>.</p>\n</blockquote>\n<p><code>obtain ⟨f, hf⟩ := hU</code> does not seem to work. I suspect this is because <code>hU</code> is of type <code>hu : ∀ u, ∃ s, r u s</code>, i.e. it is not of the form <code>hu : ∃ ...</code>. What bugs me here is that my ultimate goal is of type <code>Prop</code> but to use <code>IsCompact.elim_finite_subcover</code> I actually need the data <code>cov (u : U) : Set G</code> and to obtain this with obtain, I need some statement of the form <code>∃ f : U → Set G, ...</code> which I only get via choice.</p>",
        "id": 399043074,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698493803
    },
    {
        "content": "<p>If you only know <code>hu : ∀ u, ∃ s, r u s</code>, how can you obtain <code>s</code> mathematically? I didn't check all the types here, but maybe <code>u</code> lives in the empty type, so your <code>hu</code> is useless.</p>",
        "id": 399043402,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698494069
    },
    {
        "content": "<p>I am not saying it is, just that it is normal you can not use directly.</p>",
        "id": 399043411,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698494080
    },
    {
        "content": "<p>I want to obtain a function <code>f (u : U) : Set G × Set G</code>, so given <code>u : U</code> I obtain <code>hU u : ∃ s, r u s</code> which I can eliminate via choice.</p>",
        "id": 399043626,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698494233
    },
    {
        "content": "<p>Have a look at the <a href=\"https://github.com/haruhisa-enomoto/mathlib4-all-tactics/blob/main/all-tactics.md#choose\">choose</a> tactic.</p>",
        "id": 399043765,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698494347
    },
    {
        "content": "<p>(<code>choose!</code> if often enough)</p>",
        "id": 399043897,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1698494418
    },
    {
        "content": "<p>Thanks to both of you. That made it way better.</p>",
        "id": 399044937,
        "sender_full_name": "Christian Merten",
        "timestamp": 1698495084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"648495\">Christian Merten</span> has marked this topic as resolved.</p>",
        "id": 399044945,
        "sender_full_name": "Notification Bot",
        "timestamp": 1698495094
    },
    {
        "content": "<p>Note that under the hood you're still using the axiom of choice, but in a less inconvenient way</p>",
        "id": 399045544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1698495565
    },
    {
        "content": "<p>Ah sorry I misread. But indeed the first part of my answer also solved the second part.</p>",
        "id": 399049692,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698498545
    }
]