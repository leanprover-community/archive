[
    {
        "content": "<p>In the first tutorial the following proof of Euclid's theorem that there is an infinite number of primes is given:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Euclid_Thm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">minFac</span> <span class=\"o\">(</span><span class=\"n\">Nat.factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.ne_of_gt</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">factorial_pos</span> <span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">minFac_prime</span> <span class=\"n\">f1</span>\n  <span class=\"k\">have</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n    <span class=\"n\">le_of_not_ge</span> <span class=\"k\">fun</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">dvd_factorial</span> <span class=\"o\">(</span><span class=\"n\">minFac_pos</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n      <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_add_iff_right</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">minFac_dvd</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">pp.not_dvd_one</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">np</span><span class=\"o\">,</span> <span class=\"n\">pp</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I don't understand the line <code>le_of_not_ge fun h =&gt;</code>. It seems to be decomposing <code>¬ n≥p</code> into <code>n≥p → False</code>. How does <code>fun h =&gt;</code> do that? I don't think I've seen this syntax in MiL.</p>",
        "id": 405105713,
        "sender_full_name": "Moti Ben-Ari",
        "timestamp": 1701346825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"667469\">Moti Ben-Ari</span> <a href=\"#narrow/stream/113489-new-members/topic/Euclid's.20proof.20from.20LftCM.202023.20tutorial/near/405105713\">said</a>:</p>\n<blockquote>\n<p>It seems to be decomposing <code>¬ n≥p</code> into <code>n≥p → False</code>.</p>\n</blockquote>\n<p>That's because this is the definition of <code>¬</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Not#doc\">docs#Not</a>)!</p>",
        "id": 405106815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701347294
    },
    {
        "content": "<p>Sorry for not being clear. I know the definition of negation, but the previous occurrences of <code>n≥p → False</code> that I have seen have used <code>intro</code> to make <code>n≥p</code> into a hypothesis and <code>False</code> into a goal. How does <code>fun h =&gt; do</code> work in this situation? Would it be possible to use <code>intro</code> instead?</p>",
        "id": 405116080,
        "sender_full_name": "Moti Ben-Ari",
        "timestamp": 1701350309
    },
    {
        "content": "<p>A rough analogy is that in term-mode, <code>fun x =&gt; by foo</code> is the same as <code>by intro x; foo</code></p>",
        "id": 405117092,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701350671
    },
    {
        "content": "<p>Or alternatively, in tactic-mode <code>exact fun x =&gt; y</code> is the same as <code>intro x; exact y</code></p>",
        "id": 405117153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701350703
    },
    {
        "content": "<p>In this case, this is essentially equivalent to what you see:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Euclid_Thm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">minFac</span> <span class=\"o\">(</span><span class=\"n\">Nat.factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.ne_of_gt</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">Nat.succ_lt_succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">factorial_pos</span> <span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">minFac_prime</span> <span class=\"n\">f1</span>\n  <span class=\"k\">have</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_of_not_ge</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">dvd_factorial</span> <span class=\"o\">(</span><span class=\"n\">minFac_pos</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_add_iff_right</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">minFac_dvd</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">pp.not_dvd_one</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">np</span><span class=\"o\">,</span> <span class=\"n\">pp</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 405117275,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701350758
    },
    {
        "content": "<p>What's relevant here is that everything after the <code>have np : n ≤ p :=</code> is in term-mode not tactic mode, but I think MiL tries very hard to pretend that term-mode proofs don't exist (as they're harder to learn to write, and often less readable)</p>",
        "id": 405117431,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701350810
    },
    {
        "content": "<p>Thanks! I am looking into Lean for teaching math and tactics really are easier than terms.</p>",
        "id": 405121596,
        "sender_full_name": "Moti Ben-Ari",
        "timestamp": 1701352245
    },
    {
        "content": "<p>All the <code>have ... := ...</code>s in the proof above can be converted to <code>have ... := by exact ...</code> (I think, I did not test it).</p>",
        "id": 405122707,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1701352603
    },
    {
        "content": "<p>For the benefit of other newbees, I am trying to modify this program to use a minimal number of Lean constructs: tactics only, no anonymous, explicit applications of tactics and rewrites. This is as far as I can get:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Prime</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">Euclid_Thm</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">minFac</span> <span class=\"o\">(</span><span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">f1</span> <span class=\"o\">:</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">≠</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">Nat.ne_of_gt</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">succ_lt_succ</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">factorial_pos</span> <span class=\"n\">_</span>\n  <span class=\"k\">have</span> <span class=\"n\">pp</span> <span class=\"o\">:</span> <span class=\"n\">Nat.Prime</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">minFac_prime</span> <span class=\"n\">f1</span>\n  <span class=\"k\">have</span> <span class=\"n\">np</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_of_not_ge</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">factorial</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"n\">dvd_factorial</span> <span class=\"o\">(</span><span class=\"n\">minFac_pos</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">Nat.dvd_add_iff_right</span> <span class=\"n\">h₁</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"o\">(</span><span class=\"n\">minFac_dvd</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">apply</span> <span class=\"n\">pp.not_dvd_one</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h₂</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">np</span><span class=\"o\">,</span> <span class=\"n\">pp</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<ol>\n<li>Is <code>pp.not_dvd_one</code> an anonymous projection? If so I should be able to do something like <code>apply not_dvd_one pp</code> but I get unknown identifier. How can I get rid of the projection or whatever it is?</li>\n<li>I also want to get rid of the anonymous constructor in the last line. <code> use p</code> works, but I want to do this step-by-step. I tried <code>constructor</code> to prove the two subformulas of the conjunction in the main goal separately using <code>np,pp</code> but couldn't get it to work. Help would be appreciated.</li>\n</ol>",
        "id": 406075007,
        "sender_full_name": "Moti Ben-Ari",
        "timestamp": 1701788370
    },
    {
        "content": "<ol>\n<li><code>pp</code> has type <code>Nat.Prime p</code> so <code>pp.not_dvd_one</code> means <code>Nat.Prime.not_dvd_one pp</code>. </li>\n<li>Replace <code>exact ⟨p, np, pp⟩</code> with <code>show_term exact ⟨p, np, pp⟩</code> to see what the actual constructor used was. It's <code>Exists.intro</code>.</li>\n</ol>",
        "id": 406091613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701792440
    },
    {
        "content": "<p>Thanks, Kevin. I searched the entire collection of Lean documentation and couldn't find any mention of the syntax<code>{ left = ... , right = ... }</code>. But I found another way of doing it that should be easier to understand for newbees:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"n\">Exists.intro</span> <span class=\"n\">p</span>\n    <span class=\"n\">constructor</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">np</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">pp</span>\n</code></pre></div>",
        "id": 406112886,
        "sender_full_name": "Moti Ben-Ari",
        "timestamp": 1701798163
    },
    {
        "content": "<p><code>{ left = ... , right = ... }</code> is just the default constructor for <code>And</code>(it's a structure and those are the names of the fields). You could use <code>And.intro</code>.</p>",
        "id": 406117718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1701799749
    }
]