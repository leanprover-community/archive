[
    {
        "content": "<p>Prime can be decided without LEM and <code>Classical.choice</code> (correct me if I'm wrong)</p>\n<p>My failed try</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Tauto</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hello</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">10</span>\n<span class=\"k\">then</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n<span class=\"k\">else</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">tauto</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">hello</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">decidablePrime</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">isTrue</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">isFalse</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">hello</span>\n\n<span class=\"c1\">-- depends on axioms: [propext, Classical.choice, Quot.sound]</span>\n</code></pre></div>\n<p>I want to decide prime without  <code>Classical.choice</code></p>",
        "id": 476940061,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728982946
    },
    {
        "content": "<p>related discussions<br>\n<a href=\"#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472756638\">https://leanprover.zulipchat.com/#narrow/stream/348111-batteries/topic/Batteries.20and.20LEM/near/472756638</a></p>",
        "id": 476940214,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728982986
    },
    {
        "content": "<p>Why?</p>",
        "id": 476944676,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1728984316
    },
    {
        "content": "<p>Primeness in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> is clearly decidable, so if the Lean version depends on additional axioms, I would suspect it is because it is written in a much more general context where things are not always decidable? (like, since operations in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>  are not computable, I suspect primeness in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> is not decidable either)</p>\n<p>(Is primeness a word? Not sure)</p>",
        "id": 476948149,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1728985331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476944676\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p>I come from coq and I prefer constructive logic</p>",
        "id": 476948811,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728985587
    },
    {
        "content": "<p>is there any tactic specific to <code>Decidable</code> and can avoid LEM ?</p>",
        "id": 476949200,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728985702
    },
    {
        "content": "<p>Mathlib is not designed to use constructive logic. By this I mean that if you start using tactics it's very difficult to avoid choice. This is because we essentially didn't pay too much attention to do so, even if in principle it is possible.</p>",
        "id": 476950212,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1728986032
    },
    {
        "content": "<p>You could certainly write your own decidability instance for the predicate because it's certainly decidable. The moment you do this though, you run into the issue that there are people who just want an abstract decidability algorithm and those who actually want to run something because they care about examples, ie \"theoretical decidability\" v \"decidability in practice\". The mathlib approach in general is just to ignore all of these questions because we're mostly focused on proving theorems in classical mathematics.</p>",
        "id": 476956434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728987992
    },
    {
        "content": "<p>To be clear, your objection is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">decidablePrime</span>\n</code></pre></div>\n<p>emits <code>Classical.choice</code>, right?</p>",
        "id": 476957041,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728988207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476956434\">said</a>:</p>\n<blockquote>\n<p>ie \"theoretical decidability\" v \"decidability in practice\". The mathlib approach in general is just to ignore all of these questions because we're mostly focused on proving theorems in classical mathematics.</p>\n</blockquote>\n<p>I don't think this is true. <code>Nat.decidablePrime</code> is an example of something that is \"decidable in practice\" (as it is computable), but might not be considered \"theoretically decidable\" to a strict constructivist.</p>",
        "id": 476957163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728988258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476957041\">said</a>:</p>\n<blockquote>\n<p>To be clear, your objection is that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">decidablePrime</span>\n</code></pre></div>\n<p>emits <code>Classical.choice</code>, right?</p>\n</blockquote>\n<p>yes</p>",
        "id": 476957335,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728988303
    },
    {
        "content": "<p>The presence of <code>Classical.choice</code> here does not mean \"the decision procedure uses the axiom of choice\", but rather \"the proof that the decision procedure is correct uses the axiom of choice\".</p>",
        "id": 476957565,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728988385
    },
    {
        "content": "<p>If it were the former, then Lean would additionally tell you it was <code>noncomputable</code></p>",
        "id": 476957919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728988512
    },
    {
        "content": "<p>As a further example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hello''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">hello''</span>\n<span class=\"c1\">-- depends on axioms: [propext]</span>\n</code></pre></div>",
        "id": 476960208,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1728989412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476960208\">said</a>:</p>\n<blockquote>\n<p>As a further example</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">hello''</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n\n<span class=\"bp\">#</span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"n\">axioms</span><span class=\"w\"> </span><span class=\"n\">hello''</span>\n<span class=\"c1\">-- depends on axioms: [propext]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>nice<br>\nBut I need to judge prime on variable  in practise</p>",
        "id": 476960412,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1728989494
    },
    {
        "content": "<p>Then you don't need an abstract decidability proof, you need a practical algorithm</p>",
        "id": 476960850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728989678
    },
    {
        "content": "<p>And mathlib has the abstract prerequisites you'll need to write such an algorithm, but nobody wrote a practical algorithm yet as far as I know. Most algorithms one uses in practice are probabilistic but of course there are good non-probabilistic ones nowadays after the breakthroughs from the beginning of this century. But proving such an algorithm correct might be a nontrivial project.</p>",
        "id": 476961615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728989944
    },
    {
        "content": "<p>Kevin, isn't <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.decidablePrime#doc\">docs#Nat.decidablePrime</a> precisely the algorithm in question?</p>",
        "id": 476961716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728989990
    },
    {
        "content": "<p>Without even looking at the code I would confidently guess that this is an exponential time algorithm. Polynomial time algorithms for primality testing have been known for around 20 years.</p>",
        "id": 476961933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728990048
    },
    {
        "content": "<p>However probabilistic poly time algorithms are much older, and when you're at the point where the chances that the algorithm is failing is smaller than the chance that a gamma ray flipped a bit then this is in practice good enough for most people in practice.</p>",
        "id": 476962567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728990269
    },
    {
        "content": "<p><code>#eval Nat.Prime 109139149179199</code> takes about 1.5s, so I guess \"practical\" really depends on how large the inputs <span class=\"user-mention\" data-user-id=\"449070\">@lengyijun</span> cares about are</p>",
        "id": 476962568,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728990269
    },
    {
        "content": "<p>If they only care about <code>n = 10</code>, a practical algorithm is <code>return false</code>!</p>",
        "id": 476962727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1728990344
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">isprime</span><span class=\"o\">(</span><span class=\"mi\">109139149179199</span><span class=\"o\">)</span>\n<span class=\"bp\">%</span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">##</span>\n<span class=\"w\">  </span><span class=\"bp\">***</span><span class=\"w\">   </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">cpu</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">real</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">ms</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>Pari-GP seems to be infinitely faster! (modulo rounding errors)</p>",
        "id": 476962930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1728990419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476961933\">said</a>:</p>\n<blockquote>\n<p>Without even looking at the code I would confidently guess that this is an exponential time algorithm. Polynomial time algorithms for primality testing have been known for around 20 years.</p>\n</blockquote>\n<p>Do you mean exponential time in the number of bits? Because <code>minFac</code> just does the very basic “keep dividing until you get to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mathnormal\" style=\"padding-left:0.833em;\">n</span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"400em\" height=\"1.08em\" viewBox=\"0 0 400000 1080\" preserveAspectRatio=\"xMinYMin slice\"><path d=\"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z\"/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span></span></span></span>” thing, so it is in fact poly-time in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></p>",
        "id": 476963976,
        "sender_full_name": "Luigi Massacci",
        "timestamp": 1728990795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466290\">Luigi Massacci</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476963976\">said</a>:</p>\n<blockquote>\n<p>Do you mean exponential time in the number of bits?</p>\n</blockquote>\n<p>Yes, because that's the size of the input</p>",
        "id": 476985694,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1728997577
    },
    {
        "content": "<p>Just to check <span class=\"user-mention\" data-user-id=\"449070\">@lengyijun</span>, are you aware that even if <code>#print axioms</code> shows <code>Classical.choice</code> that <code>Nat.Prime</code> can still be computable? If I write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">calcIsPrime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then since there are no warnings, Lean has succeeded in compiling it to executable code.</p>\n<p>This isn't even just a compiler trick. In this case, it also is reducible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">131</span><span class=\"o\">)</span>\n<span class=\"c1\">-- true</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"mi\">132</span><span class=\"o\">)</span>\n<span class=\"c1\">-- false</span>\n</code></pre></div>",
        "id": 477081513,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729031782
    },
    {
        "content": "<p>I'm working on <a href=\"https://github.com/lengyijun/goldbach_tm\">https://github.com/lengyijun/goldbach_tm</a></p>\n<p>I hope all theorems don't depend on Classical.choice</p>",
        "id": 477424987,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1729166258
    },
    {
        "content": "<p>Why?</p>",
        "id": 477425575,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1729166429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/477425575\">said</a>:</p>\n<blockquote>\n<p>Why?</p>\n</blockquote>\n<p>prime should be decidable without Classical.choice</p>",
        "id": 477426113,
        "sender_full_name": "Yijun Leng",
        "timestamp": 1729166567
    },
    {
        "content": "<p>Most people here don't care about that. You're unlikely to convince anyone by just blandly asserting that this should be a goal</p>",
        "id": 477429580,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1729167699
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20decide.20prime.20without.20.60Classical.2Echoice.60/near/476961933\">said</a>:</p>\n<blockquote>\n<p>Without even looking at the code I would confidently guess that this is an exponential time algorithm. Polynomial time algorithms for primality testing have been known for around 20 years.</p>\n</blockquote>\n<p>Note that this conflates \"polynomial time\" and \"practical algorithm\". The AKS algorithm is generally not regarded as practically useful, compared to probabilistic algorithms that run much faster.</p>",
        "id": 477742211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729289979
    },
    {
        "content": "<p>I think some elliptic curve algorithms (which are subexponential) are not probabilistic and still run faster in practice than AKS except on some really stupidly large primes</p>",
        "id": 477742329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729290057
    },
    {
        "content": "<p>If they're not polynomial then I can <em>guarantee</em> that they'll not run faster than AKS on some really stupidly large primes :-) And of course this set does represent 100% of primes :-)</p>",
        "id": 477785101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729325108
    },
    {
        "content": "<p>Apparently <a href=\"https://en.wikipedia.org/wiki/Elliptic_curve_primality\">ECPP</a> is conjectured to be asymptotically faster than AKS</p>",
        "id": 477785784,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729325699
    },
    {
        "content": "<p>Ah so indeed I'm wrong! The ECPP algorithm seems to be \"polynomial time most of the time\" but not (yet?) provably poly time. So perhaps that's the one we want. There might be some large random primes where AKS is better but I hadn't until now grokked that a non poly time algo can often be poly time anyway (so my 100% claim falls over). I guess this is also true for the simplex algorithm.</p>",
        "id": 477795389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1729334725
    },
    {
        "content": "<p>This is, in a sense, proved for the simplex algorithm. IIRC, every neighborhood of an instance contains mostly instances for which the simplex algorithm performs efficiently (though I am not sure of the exact statement).</p>",
        "id": 477824222,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1729358463
    }
]