[
    {
        "content": "<p>The first mention of \"introduction rule\" and \"elimination rule\" isn TPIL is chapter 3, to quote:</p>\n<blockquote>\n<p>In the last chapter we observed that lambda abstraction can be viewed as an \"introduction rule\" for <code>→</code>. In the current setting, it shows how to \"introduce\" or establish an implication. Application can be viewed as an \"elimination rule,\" showing how to \"eliminate\" or use an implication in a proof.</p>\n</blockquote>\n<p>I think I have deduced intuitively that an <strong>elimination rule</strong> \"simplifies by removing\" a logical element. For example by \"applying\" <code>h: A → B</code> to a goal <code>B</code> I am left with a new goal <code>A</code>.  I have \"eliminated\" the implication.</p>\n<p>I haven't yet grasped intuitively \"<strong>introduction rule</strong>\" aside from the <code>intro</code> tactic which I don't think is related.</p>\n<p>So back to that quote, I'm afraid it doesn't explain what \"lambda abstraction\" it is talking about from the last chapter (2?).  I've looked repeatedly but can't find anything.</p>\n<p>Does it mean that there is a lambda function (anonymous function?) that behaves equivalently to the logical truth table for implication? And simply existing is what \"introduction\" means?</p>\n<p><strong>I'd welcome help with this.</strong></p>",
        "id": 493399592,
        "sender_full_name": "rzeta0",
        "timestamp": 1736787309
    },
    {
        "content": "<p>An introduction rule is a way to create something. For example, the introduction rule for <code>Prod</code> says that if you have a <code>x : X</code> and a <code>y : Y</code>, you can create <code>(x, y) : X × Y</code>.<br>\nDually, an elimination rule is a way to use something. The elimination rule for <code>False</code> says that if you have a <code>a : False</code> then you use <code>a</code> to get <code>False.elim a : P</code>.</p>",
        "id": 493402270,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1736788020
    },
    {
        "content": "<p>Thanks Aaron.</p>\n<p>So for the <code>Implies</code> example, what is being created? </p>\n<p>I will try to answer my own question ... </p>\n<p>Like <code>Prod</code> that <code>Implies</code>  takes two \"inputs\". Unlike <code>Prod</code> these two inputs must be propositions <code>Prop</code>. What is the output? It is a <code>Bool</code>, evaluated on the truth-values of the two input propositions. </p>\n<p>So what is being created by <code>Implies</code>? A <code>Bool</code> ? Or a function that evaluates to a <code>Bool</code>with two <code>Prop</code>s as inputs?</p>",
        "id": 493421806,
        "sender_full_name": "rzeta0",
        "timestamp": 1736793539
    },
    {
        "content": "<p>(sorry I don't know what <code>False.elim a : P</code> means )</p>",
        "id": 493421882,
        "sender_full_name": "rzeta0",
        "timestamp": 1736793563
    },
    {
        "content": "<p>Given <code>a: False</code>, one can get anything.</p>\n<p>From <a href=\"https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#False.elim\">https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#False.elim</a></p>\n<blockquote>\n<p><code>False.elim : False → C</code> says that from <code>False</code>, any desired proposition  <code>C</code> holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.</p>\n<p>The target type is actually <code>C : Sort u</code> which means it works for both propositions and types.</p>\n</blockquote>",
        "id": 493422607,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1736793806
    },
    {
        "content": "<p>Thanks Ilmars. </p>\n<p>Are you able to explain what <code>Implies</code> creates? I'm struggling to get my mind around it.</p>",
        "id": 493423027,
        "sender_full_name": "rzeta0",
        "timestamp": 1736793954
    },
    {
        "content": "<p>TPIL says:  \"In the current setting, it shows how to \"introduce\" or establish an implication.\"<br>\nSo what they mean by \"introducing\" an implication is simply establishing an implication--i.e., proving an implication.  The idea is that you might have some hypotheses that say something about <code>P</code> and <code>Q</code>, but <code>P → Q</code> is not a hypothesis.  If you can use those hypotheses to prove <code>P → Q</code>, then you have \"introduced\" an implication symbol in a place that you didn't have it before.</p>\n<p>There are several theorems that can be used to prove statements with particular logical forms.  They often have names that end with \"intro\".  Check out <code>And.intro</code>, <code>Iff.intro</code>, and <code>Exists.intro</code>.</p>\n<p>The term \"lambda abstraction\" is explained in Chapter 2 of TPIL.  It just means creating a function using the <code>fun</code> notation.</p>",
        "id": 493424557,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1736794424
    },
    {
        "content": "<p>There are also two intro rules for or:  <code>Or.intro_left</code> and <code>Or.intro_right</code>, along with slightly different versions <code>Or.inl</code> and <code>Or.inr</code>.</p>",
        "id": 493425116,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1736794612
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/first.20mention.20of.20.22introduction.20rule.22.20in.20TPIL.20.28beginner.20q.29/near/493399592\">said</a>:</p>\n<blockquote>\n<p>For example by \"applying\" <code>h: A → B</code> to a goal <code>B</code> I am left with a new goal <code>A</code>.  I have \"eliminated\" the implication.</p>\n</blockquote>\n<p>I think a better way to say it is that applying <code>h : A → B</code> to a proof of <code>A</code> gives you a proof of <code>B</code>.  That is, if you have <code>h : A → B</code> and <code>hA : A</code>, then <code>h hA</code> is a (term-mode) proof of <code>B</code>.  This is, literally, function application.  If <code>h</code> has type <code>A → B</code>, then it is a function from <code>A</code> to <code>B</code>; that is, it is a function that maps proofs of <code>A</code> to proofs of <code>B</code>.  When you apply that function to <code>hA</code>, you get an expression of type <code>B</code>; that is, a proof of <code>B</code>.</p>\n<p>A peculiarity of the <code>apply</code> tactic is that it works backwards from the goal.  If you have <code>h : A → B</code> and your goal is <code>B</code>, then <code>apply h</code> asks Lean to figure out \"what would you have to apply <code>h</code> to in order to get a proof of <code>B</code>?\"  Lean figures out that the answer is \"a proof of <code>A</code>,\" so it sets the goal to be <code>A</code>.</p>",
        "id": 493426642,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1736795103
    },
    {
        "content": "<p>Thanks Dan - I am comfortable with the second part of your reply on application, and also the extra-stuff <code>apply</code> does.</p>\n<p>I'm still thinking about the first part. So here is an experiment I did based on your suggestion - see below.</p>\n<p>What I think I learn from this is:</p>\n<ul>\n<li><code>And</code> takes two parameters and outputs one, all of type <code>Prop</code>.</li>\n<li>Given two <code>Prop</code>, <code>a</code> and <code>b</code>, then <code>And</code> creates/introduces a thing which behaves as <code>a ∧ b</code>. This resonates with what you said \"you didn't have it before\". <em>(It seems circular, unless <code>∧</code> is hardcoded in Lean whereas <code>And</code> isn't)</em></li>\n<li>I'm struggling to read the elimination rule but I think it says: if I have <code>a : Prop</code> and <code>b : Prop</code> and also something else <code>ɑ</code> of any type (level 1, so not a term and not a universe), then if <code>a → b → ɑ</code> and also <code>a∧b</code> then we can conclude <code>ɑ</code>. In other words, we have applied <code>And</code>. Is that right?</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">And</span>\n<span class=\"c1\">-- And (a b : Prop) : Prop</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"c1\">-- And.intro {a b : Prop} (left : a) (right : b) : a ∧ b</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"c1\">-- And.elim.{u_1} {a b : Prop} {α : Sort u_1} (f : a → b → α) (h : a ∧ b) : α</span>\n\n<span class=\"c1\">---</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">And</span>\n<span class=\"c1\">-- And : Prop → Prop → Prop</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"c1\">-- @And.intro : ∀ {a b : Prop}, a → b → a ∧ b</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"c1\">-- @And.elim : {a b : Prop} → {α : Sort u_1} → (a → b → α) → a ∧ b → α</span>\n</code></pre></div>",
        "id": 493429472,
        "sender_full_name": "rzeta0",
        "timestamp": 1736796065
    },
    {
        "content": "<p>If you hover over the <code>a ∧ b</code> in the infoview, you'll see that <code>And</code> and <code>∧</code> are actually the same thing! <code>And</code> is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=And#doc\">docs#And</a>, and <code>∧</code> is defined at <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=%C2%ABterm_%E2%88%A7_%C2%BB#doc\">docs#«term_∧_»</a>.</p>",
        "id": 493445797,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1736801376
    },
    {
        "content": "<p>If you have <code>hP : P</code> and <code>hQ : Q</code>, then you can use <code>And.intro</code> to infer <code>P ∧ Q</code>--thus \"introducing\" the symbol <code>∧</code> between the hypotheses you already had, <code>P</code> and <code>Q</code>.  In fact, <code>And.intro hP hQ</code> is a (term-mode) proof of <code>P ∧ Q</code>.  And therefore if your goal is <code>P ∧ Q</code>, then <code>apply And.intro</code> will give you the new separate goals <code>P</code> and <code>Q</code>.</p>\n<p>The naming of the elimination rule for <code>And</code> is a little strange.  I think it would make more sense to consider <code>And.left</code> and <code>And.right</code> to be elimination rules for <code>And</code>.  By analogy with the naming of the intro rules for <code>Or</code>, it might have made sense to call them <code>And.elim_left</code> and <code>And.elim_right</code>.  But that's not what they're called; they're just called <code>And.left</code> and <code>And.right</code>.  When I want to use a hypothesis of the form <code>P ∧ Q</code>, I usually do it by using <code>And.left</code> and <code>And.right</code>.  But <code>And.elim</code> also gives you a way to use a hypothesis of the form <code>P ∧ Q</code>, so it makes sense to consider it an elimination rule for <code>And</code>.</p>\n<p>The elimination rule for <code>Or</code> might be easier to understand.  See if you can figure out why <code>Or.elim</code> justifies proof by cases, which is the usual way of using a hypothesis of the form <code>P ∨ Q</code>.</p>",
        "id": 493447222,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1736801854
    },
    {
        "content": "<blockquote>\n<p>something else <code>ɑ</code> of any type (level 1, so not a term and not a universe)</p>\n</blockquote>\n<p>You might be misreading <code>Sort u_1</code> as <code>Sort 1</code>, but <code>u_1</code> is just a generic universe variable and it could represent any universe level.</p>",
        "id": 493447446,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1736801911
    },
    {
        "content": "<p>Perhaps an example will illustrate why I think of <code>And.left</code> and <code>And.right</code> as elimination rules for <code>And</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">left</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h4</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"n\">h3</span><span class=\"w\"> </span><span class=\"n\">h4</span>\n</code></pre></div>\n<p>The <code>have h3</code> and <code>have h4</code> lines \"take apart\" <code>h2 : P ∧ Q</code> into the two statements <code>P</code> and <code>Q</code>, thus eliminating the <code>∧</code>.  This is how I usually use a statement of the form <code>P ∧ Q</code>.</p>\n<p>But the same example could be proven using <code>And.elim</code>, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n</code></pre></div>",
        "id": 493450669,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1736802895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453098\">@Dan Velleman</span>  this paragraph has helped clarify things hugely for me - thank you:</p>\n<blockquote>\n<p>If you have <code>hP : P</code> and <code>hQ : Q</code>, then you can use <code>And.intro</code> to infer <code>P ∧ Q</code>--thus \"introducing\" the symbol <code>∧</code>between the hypotheses you already had, <code>P</code> and <code>Q</code>. In fact, <code>And.intro hP hQ</code> is a (term-mode) proof of <code>P ∧ Q</code>. And therefore if your goal is <code>P ∧ Q</code>, then <code>apply And.intro</code> will give you the new separate goals <code>P</code> and <code>Q</code>.</p>\n</blockquote>",
        "id": 493454039,
        "sender_full_name": "rzeta0",
        "timestamp": 1736804022
    },
    {
        "content": "<hr>\n<blockquote>\n<p>The elimination rule for <code>Or</code> might be easier to understand.  See if you can figure out why <code>Or.elim</code> justifies proof by cases, which is the usual way of using a hypothesis of the form <code>P ∨ Q</code>.</p>\n</blockquote>\n<p>So I did a <code>#check @Or.elim</code> which gives me <code>@Or.elim : ∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c</code>. <br>\nI read this as, if  have as a hypotheses <code>a ∨ b</code> and I want to prove <code>c</code> then I need to prove (both cases) <code>a → c</code> and <code>b → c</code>. <br>\nThat seems to make sense and I'm happy with that if this is correct.</p>",
        "id": 493454738,
        "sender_full_name": "rzeta0",
        "timestamp": 1736804281
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> has marked this topic as resolved.</p>",
        "id": 493454976,
        "sender_full_name": "Notification Bot",
        "timestamp": 1736804377
    }
]