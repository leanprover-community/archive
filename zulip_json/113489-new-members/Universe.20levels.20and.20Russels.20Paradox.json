[
    {
        "content": "<p>Hi everyone! I'm new to type theory and struggling to understand when and how Lean steps up universe levels beyond the basic maximum rule.<br>\n<strong>What I understand so far:</strong></p>\n<ol>\n<li>\n<p>Generally, the universe of a type is the maximum of all universe levels in its construction</p>\n</li>\n<li>\n<p><code>Type : Type</code> is not allowed</p>\n</li>\n<li>\n<p><code>Type u : Type (u+1)</code></p>\n</li>\n<li>\n<p>Strict positivity prevents paradoxes in inductive types</p>\n</li>\n</ol>\n<p><strong>What I'm confused about:</strong></p>\n<ul>\n<li>\n<p>Is <code>Type u : Type (u+1)</code> the <strong>only</strong> universe stepping rule, or are there others?</p>\n</li>\n<li>\n<p>How exactly does Lean detect when the simple \"maximum rule\" isn't sufficient (like with Russell's paradox)?</p>\n</li>\n<li>\n<p>When I define an inductive type, how does Lean determine it needs universe stepping beyond just looking at constructor argument types? </p>\n</li>\n</ul>\n<p><code>def Russell : Type (u+1) := {S : Type u // S ∉ S}</code> still produces an error because of the 'membership relation' not being given...</p>",
        "id": 538298714,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1757359025
    },
    {
        "content": "<p>I can't speak to the rest of your questions, but the problem with your <code>Russell</code> definition is that types don't have \"members\"... sets do</p>",
        "id": 538302800,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757360471
    },
    {
        "content": "<p>Extra information:<br>\nIn Lean we have:<br>\n<code>Type u : Type (u+1)</code><br>\nand <code>Prop:Type</code></p>\n<p>but in other languages they use (I'm told) Agada/Idris?:<br>\n<code>Type u : Type (u+1)</code><br>\nand <code>Prop u : Prop (u+1)</code></p>\n<p>and there's lots of other ways.  So I think there is more than one way to have an infinite tower of types to avoid Russell Paradox.</p>",
        "id": 538305448,
        "sender_full_name": "Mr Proof",
        "timestamp": 1757361582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"588691\">@Jasper Ganten</span> btw, Lean has an implementation of ZFC that allows you to define the Russell \"set\", but it's a Class (and in fact it's the universal Class):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Russell</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Russell</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">not_mem_self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∉</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">mem_irrefl</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">mem_self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"bp\">.</span><span class=\"n\">coe_apply</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hS</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_mem_self</span><span class=\"w\"> </span><span class=\"n\">mem_self</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Russell</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Class</span><span class=\"bp\">.</span><span class=\"n\">eq_univ_of_forall</span><span class=\"w\"> </span><span class=\"n\">ZFSet</span><span class=\"bp\">.</span><span class=\"n\">mem_irrefl</span>\n</code></pre></div>",
        "id": 538325740,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1757371819
    },
    {
        "content": "<p>Thanks a lot - I think this already helps to build the intuition!</p>",
        "id": 538367838,
        "sender_full_name": "Jasper Ganten",
        "timestamp": 1757402874
    }
]