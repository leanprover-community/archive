[
    {
        "content": "<p>Hi, I'm struggling to prove some basic Fin arithmetic like <code>\nlemma fin_add_cancel {n : Nat} (u v : Fin n) : u + (v - u) = v := by sorry\n</code> what does a short proof for that look like? is there a way of transforming the goal into a goal about Nat's with <code>%</code> so that tactics like <code>ring_nf</code> can be used?</p>",
        "id": 496676027,
        "sender_full_name": "Bernardo Anibal Subercaseaux Roa",
        "timestamp": 1738200473
    },
    {
        "content": "<p>This is what I came up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">ZMod</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Ring</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fin_add_cancel</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">elim0</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n</code></pre></div>\n<p>If <code>n</code> is zero then <code>Fin 0</code> does not form a ring because there is no element <code>0</code>. But we are provided with <code>(u : Fin n)</code> so <code>n</code> cannot be <code>0</code>. If <code>n</code> is not zero then <code>Fin n</code> is a <code>CommRing</code> and <code>ring</code> can solve it.</p>",
        "id": 496677569,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738201225
    },
    {
        "content": "<p>Here's a version that converts everything to a <code>Nat</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Lemma</span><span class=\"w\"> </span><span class=\"c1\">-- apparently the `lemma` syntax is defined in Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fin_add_cancel</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_inj</span><span class=\"bp\">.</span><span class=\"n\">mp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_add</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> no `Fin.val_sub`? -/</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">sub_def</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> `rw [Fin.val_mk]` unifies with ↑u here -/</span>\n<span class=\"w\">  </span><span class=\"n\">dsimp</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_mod_mod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_sub_of_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_mod_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">mod_eq_of_lt</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 496678866,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738202132
    },
    {
        "content": "<p>Thanks!! I didn't realize that <code>n = 0</code> made it not be a field :) important corner case...</p>",
        "id": 496682197,
        "sender_full_name": "Bernardo Anibal Subercaseaux Roa",
        "timestamp": 1738204448
    },
    {
        "content": "<p>If you don't want this behaviour then you can use <code>ZMod n</code> which is always a ring</p>",
        "id": 496710638,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738222941
    },
    {
        "content": "<p>thanks, <code>ZMod n</code> ended up simplifying my life by a lot;  for context, I'm trying to formalize some theorems about vertex transitive graphs, and I was trying to prove an almost trivial statement: cycle graphs are vertex-transitive. The modular arithmetic over <code>Fin n</code> was being complicated, but everything went away when switching to <code>ZMod n</code></p>",
        "id": 496869237,
        "sender_full_name": "Bernardo Anibal Subercaseaux Roa",
        "timestamp": 1738271487
    },
    {
        "content": "<p>That sounds fun! Look forward to seeing the result!</p>",
        "id": 496963696,
        "sender_full_name": "Chris Wong",
        "timestamp": 1738315930
    },
    {
        "content": "<p>From what I've seen, <code>Fin</code> is used when you want <code>n</code> arbitrary labels, or to index into an array. For modular arithmetic indeed <code>ZMod</code> is superior.</p>",
        "id": 496963935,
        "sender_full_name": "Chris Wong",
        "timestamp": 1738316003
    }
]