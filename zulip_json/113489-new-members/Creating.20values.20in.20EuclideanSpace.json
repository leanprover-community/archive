[
    {
        "content": "<p>I naively thought that</p>\n<p><code>def x := (![1, 0]  : EuclideanSpace ℝ (Fin 2))</code></p>\n<p>would create a value of <code>EuclideanSpace ℝ (Fin 2)</code> but the type shown on <code>x</code> is <code>x : Fin (Nat.succ 1) → ℝ</code> so after a bit more searching I found</p>\n<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/InnerProductSpace/PiL2.html#EuclideanSpace\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/InnerProductSpace/PiL2.html#EuclideanSpace</a></p>\n<p>But if I try this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">!₂</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I see the type of <code>q</code> is <code>q : WithLp 2 (Fin 2 → ℝ)</code>.</p>\n<p>So how do I get a type of <code>EuclideanSpace ℝ (Fin 2)</code>?</p>",
        "id": 503805600,
        "sender_full_name": "Dominic Steinitz",
        "timestamp": 1741270702
    },
    {
        "content": "<p><code>EuclideanSpace</code> is an abbreviation for <code>WithLp</code>, so the <code>!₂</code> spelling is fine and it really is of the type you want</p>",
        "id": 503806313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741270870
    },
    {
        "content": "<p><code>def x := (![1, 0] : EuclideanSpace ℝ (Fin 2))</code> creates a term of a type that's definitionally equivalent to what you want (<code>EuclideanSpace ℝ (Fin 2)</code>), if you want to make it stricter you can do <code>show EuclideanSpace ℝ (Fin 2) from ![1, 0]</code> which should give you the right one but perhaps you'd rather want to use <code>!₂</code> to avoid defeq abuse.</p>",
        "id": 503821884,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1741274640
    },
    {
        "content": "<p>What you care about is whether it's <em>reducibly</em> definitionally equal, which the <code>![</code> spelling is not</p>",
        "id": 503855070,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741283505
    },
    {
        "content": "<p>You will find that none of the theorems work the way you want to if you use that incorrect spelling.</p>",
        "id": 503855098,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1741283520
    }
]