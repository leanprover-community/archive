[
    {
        "content": "<p>I'm trying to understand why structures of type Prop cannot contain any fields with values of Type, when you can just refactor the structure into a single constructor inductive that contains the value inside the constructor just fine?</p>\n<p>I understand that you're not allowed to extract the value unless you're eliminating into Prop, but if Lean has machinery for detecting this for an inductive why can it not do the same for values taken from a structure?</p>\n<p>Is this related to proof irrelevance? That matching on an inductive gets you in a mode where the contents of the inductive constructor can never be visible in Type but you can extract values from structures without matching on them and therefore that doesn't impose the same mode?</p>",
        "id": 547545285,
        "sender_full_name": "aron",
        "timestamp": 1761670176
    },
    {
        "content": "<blockquote>\n<p>when you can just refactor the structure into a single constructor inductive that contains the value inside the constructor just fine?</p>\n</blockquote>\n<p>Can you give an example of that?</p>",
        "id": 547546367,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1761670481
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- This is fine -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">TInductive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TInductive</span>\n\n<span class=\"sd\">/-- This is not -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>",
        "id": 547548326,
        "sender_full_name": "aron",
        "timestamp": 1761671026
    },
    {
        "content": "<p>Assuming I understand what you're saying, it is due to Props only being able to eliminate into Prop. It is only an issue for structures because they try to automatically generate functions out of your structure whereas an inductive does not.</p>\n<p>For example, the structure <code>Test</code> here automatically generates a function <code>Test.t</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"bp\">.</span><span class=\"n\">t</span>\n</code></pre></div>\n<p>This is a projection function. Given a term of <code>Test</code>, it gives you back a term of type <code>2 = 3</code>.<br>\nThe equivalent inductive does not generate this function.</p>\n<p>So now in the case where there is a string:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">String</span>\n</code></pre></div>\n<p>It tries to again generate a projection function <code>Test.t</code> whose type should be <code>Test → String</code>. But since you can only make functions from <code>Test</code> to <code>Prop</code>, this fails.<br>\nSince the corresponding inductive does not attempt to make these projection functions, there are no errors. </p>\n<p>Note that even though you can create this inductive without errors (since no projections are automatically generated), you cannot write the projection functions yourself for the same reason they can't be automatically generated.</p>",
        "id": 547548344,
        "sender_full_name": "Eric Paul",
        "timestamp": 1761671031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"512030\">@Eric Paul</span> thanks for that explanation! But presumably there is some special machinery in Lean to prevent you from being able to match on props when your goal is in Type. So is there a reason why the same machinery couldn't apply that check to the generated projection functions? I.e. that you can't use <code>Test.t</code> unless your goal is in Prop?</p>",
        "id": 547549529,
        "sender_full_name": "aron",
        "timestamp": 1761671370
    },
    {
        "content": "<p>I think what I'm getting is that the restriction that prevents you from matching on props when your goal is in Type feels very ad hoc to me. So I don't see a fundamental reason for why certain operations (extracting a value from a prop) are allowed in some contexts but not others. So if matching on a prop is an ad hoc restriction anyway, why not apply that same ad hoc restriction to the generated structure projection functions?</p>",
        "id": 547550051,
        "sender_full_name": "aron",
        "timestamp": 1761671523
    },
    {
        "content": "<p>Proof irrelevance + large elimination (eliminating a prop into type) is inconsistent.</p>",
        "id": 547550898,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1761671774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"814082\">@aron</span> more specifically, if we allow:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- This is not -/</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>and if we allow <code>(TStruct.mk 37).x = 37</code> and <code>(TStruct.mk 67).x = 67</code>, then we can in fact derive a contradiction, because any two proofs are equal</p>",
        "id": 547551265,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761671887
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TStruct</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">x_mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">x_mk</span><span class=\"w\"> </span><span class=\"mi\">37</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">67</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">67</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">TStruct</span><span class=\"bp\">.</span><span class=\"n\">x_mk</span><span class=\"w\"> </span><span class=\"mi\">67</span>\n<span class=\"w\">  </span><span class=\"c1\">-- note that Lean automatically equates TStruct.mk 37 and TStruct.mk 67</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">37</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">67</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">h₂</span>\n<span class=\"w\">  </span><span class=\"n\">absurd</span><span class=\"w\"> </span><span class=\"n\">h₃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 547551699,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761672026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> thanks for the illustration, it's helpful to have a concrete demo of the exact problem.</p>\n<p>But my question is more about what is special about matching on an inductive that puts Lean in a special mode where any values may only eliminate into Prop – and why can't that special mode also be applied to the generated projection functions on a structure?</p>",
        "id": 547552530,
        "sender_full_name": "aron",
        "timestamp": 1761672338
    },
    {
        "content": "<p>because <code>inductive</code> doesn't generate projections automatically</p>",
        "id": 547552966,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761672490
    },
    {
        "content": "<p>for example, <code>Nat</code> is an inductive type with two constructors <code>Nat.zero</code> and <code>Nat.succ</code>, and <code>Nat.succ</code> eats a natural number, and there is no automatically generated <code>Nat.pred</code></p>",
        "id": 547553048,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761672517
    },
    {
        "content": "<p>Whenever you use <code>match</code>, you are creating a function out of your type. If your goal is a <code>Prop</code>, then you are using match to create a function from your type to a <code>Prop</code> and so it succeeds. There is no difference between using <code>match</code> on an inductive versus a structure. So there is no special mode. Whether or not you can <code>match</code> successfully depends on whether your goal is a <code>Type</code> or a <code>Prop</code>.</p>\n<p>Since the attempted projection functions are trying to make a <code>Type</code>, they cannot <code>match</code> successfully.</p>",
        "id": 547557724,
        "sender_full_name": "Eric Paul",
        "timestamp": 1761674118
    },
    {
        "content": "<p>To ask a silly question: if the projection functions weren't generated for structures, would Aron's initial example work?</p>",
        "id": 547564953,
        "sender_full_name": "One Happy Fellow",
        "timestamp": 1761676596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"983119\">@One Happy Fellow</span> a <code>structure</code> is just a one-constructor inductive type; if there's no projection functions, then it's just the inductive type, which we've seen work</p>",
        "id": 547572325,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1761679268
    },
    {
        "content": "<p>Thank you, I didn't realise these are equivalent.</p>",
        "id": 547572751,
        "sender_full_name": "One Happy Fellow",
        "timestamp": 1761679437
    }
]