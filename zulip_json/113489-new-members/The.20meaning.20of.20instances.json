[
    {
        "content": "<p>Just what is an instance in Lean 4 and how does it differ from definitions/theorems?</p>",
        "id": 341129079,
        "sender_full_name": "Jeremy Tan",
        "timestamp": 1678543001
    },
    {
        "content": "<p>It is an instance of a type class. If you dont know what type classes are, similar systems are known under names like trait (in .e.g Rust) or also the weaker interface concept from e.g. Java.</p>\n<p>And technically speaking since type classes are (except for <code>class inductive</code> variations but those are very rare) structures an instance is actually only definition with a value of some structure with some tag that makes it special to the compiler. But that is more of a detail</p>",
        "id": 341133319,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1678544483
    },
    {
        "content": "<p>There's a good explanation in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a></p>",
        "id": 341150260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1678550507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> <a href=\"#narrow/stream/113489-new-members/topic/The.20meaning.20of.20instances/near/341133319\">said</a>:</p>\n<blockquote>\n<p>except for <code>class inductive</code> variations but those are very rare</p>\n</blockquote>\n<p>Following up on <a href=\"https://leanprover-community.github.io/archive/stream/270676-lean4/topic/class.20inductive.3F.html\">class inductive (archived topic)</a>, what then is the syntax for creating an \"instance\" of a <code>class inductive</code>? <br>\nI haven't seen this explained anywhere in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/\">#tpil</a></p>",
        "id": 345161395,
        "sender_full_name": "Somo S.",
        "timestamp": 1680015944
    },
    {
        "content": "<p>The syntax should be exactly the same as creating a <code>def</code> of the same type, except the name is optional for an <code>instance</code>.</p>",
        "id": 345164327,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1680016558
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://leanprover.github.io/functional_programming_in_lean/type-classes/conveniences.html#constructor-syntax-for-instances\">from #fpil</a></p>\n<p>Behind the scenes, type classes are structure types and instances are values of these types. The only differences are that Lean stores additional information about type classes, such as which parameters are output parameters, and that instances are registered for searching.</p>\n</blockquote>\n<p>I am not sure I understand <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>. If you use a <code>def</code> to declare your <code>class inductive</code> instance value, will Lean properly register that value for class searching (and store output parameters etc) as is described above (for regular structure based <code>class</code> types)</p>",
        "id": 345458848,
        "sender_full_name": "Somo S.",
        "timestamp": 1680107885
    },
    {
        "content": "<p>In the foundational logic there is no difference at all between <code>class inductive</code> and <code>inductive</code>, or <code>class</code> and <code>structure</code>, or <code>instance</code> and <code>def</code>, all of these pairs are translated to the same core concepts. In fact, a <code>structure</code> is just an <code>inductive</code> with only one constructor. This is what TPiL means by \"behind the scenes\".</p>\n<p>The difference comes in the translation from your code to these foundations, where a part of Lean called the elaborator fills in all the implicit arguments, the ones between <code>{curly braces}</code> (implicit parameters) and <code>[square braces]</code> (instance parameters). When trying to fill in an instance parameter, Lean essentially does a depth-first search until it finds something with the right type. And the set of declarations it searches through is exactly those that have been declared an <code>instance</code> instead of a plain <code>def</code>.</p>\n<p>Even more precisely, an instance is just a <code>def</code> together with an attribute <code>@[instance]</code>. The <code>instance</code> keyword assigns this attribute automatically, or you can do this manually by writing <code>attribute [instance] your_def</code>. Similarly, a class is just any declaration with an attribute <code>@[class]</code>. Lean 3 doesn't actually check that the attribute is on an inductive type. </p>\n<p>So what this means in practice for a <code>class inductive</code> like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/decidable\">docs#decidable</a> is that declaring an instance works exactly the same: you construct a term of the type, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/and.decidable\">docs#and.decidable</a>, and as long as it gets the <code>@[instance]</code> attribute (either through the <code>instance</code> keyword or <code>attribute [instance] and.decidable</code>), it will function like any other class instance.</p>\n<p>Does that help or is there still something unclear?</p>",
        "id": 345602016,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1680165752
    },
    {
        "content": "<p>actually this all makes sense now. the links you provided showed me example code. Thanks <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span></p>",
        "id": 345764250,
        "sender_full_name": "Somo S.",
        "timestamp": 1680202915
    }
]