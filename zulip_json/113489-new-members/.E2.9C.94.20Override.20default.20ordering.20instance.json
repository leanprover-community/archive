[
    {
        "content": "<p>Hi<br>\nI'm trying to define a new kind of order on finitely supported functions like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">term_order</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">linear_order</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">additive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">v₁</span> <span class=\"bp\">≤</span> <span class=\"n\">v₂</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">v₁</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">v₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The problem is, that mathlib already defines a preorder on <code>σ →₀ ℕ</code>, by pointwise comparison of ℕ. Thus <code>σ →₀ ℕ</code> now has two instances of <code>has_le</code>, which is bad.</p>\n<p>To fix it, I started defining my own order, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">term_order'</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">total</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">antisymm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">=</span><span class=\"n\">b</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">additive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">le</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">zero_lt</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">le</span> <span class=\"mi\">0</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">decidable_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but I now I lose access to all the functionality in mathlib using orderings. F.ex. I can no longer find the minimal element of a <code>list (σ →₀ ℕ)</code>, since <code>list.minimum</code> just uses the <code>preorder</code> instance. I can of course replicate this functionality, and prove the necessary lemmas again, but is there a better way to do it?</p>\n<p>Thanks in advance</p>",
        "id": 339878485,
        "sender_full_name": "Andreas Poulsen",
        "timestamp": 1678111894
    },
    {
        "content": "<p>What we tend to do when we have multiple instances of one class on the same type is using type synonyms. For example, you could define:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive [has_add, has_zero]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">term_ordered</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">term_order</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">linear_order</span> <span class=\"o\">(</span><span class=\"n\">term_ordered</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">additive</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">term_ordered</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">v₁</span> <span class=\"bp\">≤</span> <span class=\"n\">v₂</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">v₁</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span> <span class=\"bp\">+</span> <span class=\"n\">v₂</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">zero_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">term_ordered</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 339882298,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678112722
    },
    {
        "content": "<p>(By the way, if <code>σ</code> is finite, <code>σ →₀ ℕ</code> is isomorphic to <code>σ → ℕ</code>, so is there a reason to specifically require the functions are finitely supported?)</p>",
        "id": 339882929,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678112838
    },
    {
        "content": "<p>Thanks, that might work. The reason I'm using <code>σ →₀ ℕ</code> is, I'm working with <code>mv_polynomials</code> which uses them.<br>\nIs there something like <code>@</code> in Haskell, where I can choose the newtype I want to use? That way I don't have to wrap and unwrap newtypes all the time.</p>",
        "id": 339885570,
        "sender_full_name": "Andreas Poulsen",
        "timestamp": 1678113475
    },
    {
        "content": "<p>Can you give an example of what you mean? I'm not super familiar with the Haskell syntax</p>",
        "id": 339887934,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1678114000
    },
    {
        "content": "<p>Since <code>term_ordered</code> is just a <code>def</code>, converting between <code>term_ordered</code> and <code>finsupp</code> should be automatic, or at worst only require type ascription: <code>(x : term_ordered σ)</code> or <code>(x : σ →₀ ℕ)</code> to turn <code>x</code> from one into the other. A Haskell newtype maps somewhat closer to a <code>structure</code> with one field (or an <code>@[irreducible] def</code>, but that won't translate so well into Lean 4).</p>",
        "id": 339889114,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678114283
    },
    {
        "content": "<p>Oh, that's very clever! Thank you, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, that removes all the pain points. Dang, Lean is cool</p>",
        "id": 339890088,
        "sender_full_name": "Andreas Poulsen",
        "timestamp": 1678114527
    },
    {
        "content": "<p>See <a href=\"https://tqft.net/mathlib/data/finsupp/lex\">file#data/finsupp/lex</a> for ideas</p>",
        "id": 339890683,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1678114684
    },
    {
        "content": "<p>It does create a few new pain points, though: writing <code>∀ v : term_ordered σ, 0 ≤ v</code> will treat <code>0</code> and <code>v</code> as term ordered, but <code>∀ i (v : term_ordered σ), finsupp.single i 1 ≤ v</code> will treat <code>finsupp.single</code> and <code>v</code> as finsupps. So you have to be careful that things don't get unfolded accidentally.</p>",
        "id": 339890796,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1678114715
    },
    {
        "content": "<p>Thank you for the reference <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>, that's very helpful.</p>",
        "id": 339891867,
        "sender_full_name": "Andreas Poulsen",
        "timestamp": 1678114962
    },
    {
        "content": "<p>You're right, Anne, but that is manageable. Thanks for the warning :)</p>",
        "id": 339892092,
        "sender_full_name": "Andreas Poulsen",
        "timestamp": 1678115008
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"581034\">Andreas Poulsen</span> has marked this topic as resolved.</p>",
        "id": 339892223,
        "sender_full_name": "Notification Bot",
        "timestamp": 1678115043
    }
]