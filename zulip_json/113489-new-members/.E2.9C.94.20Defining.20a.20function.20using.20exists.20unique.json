[
    {
        "content": "<p>suppose I have the fact that for all x, there is a unique y satisfying a predicate P(x, y). How do I define a function f that maps that x to y? in particular this is what I want to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\">    </span><span class=\"c1\">-- the unique y from h above</span>\n</code></pre></div>\n<p>My knowledge about advanced mathematics is a bit weak. So I am not sure if there is some issue with defining such a function mathematically in general. But I am assuming we can define that in lean.</p>",
        "id": 504831515,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1741697457
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∃!</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">noncomputable</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\">    </span><span class=\"c1\">-- the unique y from h above</span>\n</code></pre></div>",
        "id": 504832958,
        "sender_full_name": "suhr",
        "timestamp": 1741697801
    },
    {
        "content": "<p>See also: <code>Classical.choose_spec</code>.</p>",
        "id": 504833398,
        "sender_full_name": "suhr",
        "timestamp": 1741697898
    },
    {
        "content": "<p>If you have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype#doc\">docs#Fintype</a>, you can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.choose#doc\">docs#Fintype.choose</a>.</p>",
        "id": 504834036,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1741698042
    },
    {
        "content": "<p>We also have a <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Choose.html#Mathlib.Tactic.Choose.choose\">tactic</a> for that.</p>",
        "id": 504837088,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741698766
    },
    {
        "content": "<p>Most of the time <code>choose!</code> is enough.</p>",
        "id": 504837300,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741698812
    },
    {
        "content": "<p>interesting, the Classical.choose_spec doesn't need uniqueness proof. I guess that's just how axiom of choice works.</p>",
        "id": 504837417,
        "sender_full_name": "Sabbir Rahman",
        "timestamp": 1741698840
    },
    {
        "content": "<p>Well, choice chooses an element with the property, so that's not surprisingly.</p>",
        "id": 504837771,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741698917
    },
    {
        "content": "<p>yes... the reason why <code>Fintype.choose</code> <em>does</em> need it is in order to make it computable and total. Internally, <code>Fintype</code> stores a list of all elements up to permutation, and in order to get an element from that computably, you need to make sure you always choose the same element from the list no matter the position. Uniqueness is what guarantees you find the same element each time</p>",
        "id": 504838020,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1741698978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484770\">Sabbir Rahman</span> has marked this topic as resolved.</p>",
        "id": 505047084,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741763655
    }
]