[
    {
        "content": "<p>Is there a way to simplify <code>x ∈ Set.univ</code> using <code>Set.mem_univ</code> without using <code>simp</code> in the following example?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>P.S. I am interested in <em>how</em> to do this more than in the statement itself. Clearly <code>simp only [Set.mem_univ]</code> does what I want, but there must be some way to use <code>Set.mem_univ</code> directly...</p>",
        "id": 460067795,
        "sender_full_name": "jsodd",
        "timestamp": 1723463985
    },
    {
        "content": "<p>P.P.S. <code>show_term simp only [Set.mem_univ]</code> gives something which doesn't work...</p>",
        "id": 460068620,
        "sender_full_name": "jsodd",
        "timestamp": 1723464251
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply?</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Try this: exact iff_true_intro hp</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">iff_true_intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"c1\">-- simp? says simp only [Set.mem_iUnion, true_implies]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">true_implies</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 460068746,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1723464306
    },
    {
        "content": "<p>Yes, this is clear, but is there some functional way to do this? Without introducing an additional hypothesis...</p>",
        "id": 460068976,
        "sender_full_name": "jsodd",
        "timestamp": 1723464366
    },
    {
        "content": "<p><code>rw [iff_true_intro (Set.mem_univ x)]</code>?</p>",
        "id": 460069370,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723464532
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/jSjNu6-YkJabC7oXmUhv_Z92/image.png\">image.png</a><br>\nThis is what <code>show_term simp</code> shows. This doesn't make sense since there's no <code>auxLemma</code> by that name and if I click on this suggestion, it gives an error</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/jSjNu6-YkJabC7oXmUhv_Z92/image.png\" title=\"image.png\"><img data-original-dimensions=\"671x86\" src=\"/user_uploads/thumbnail/3121/jSjNu6-YkJabC7oXmUhv_Z92/image.png/840x560.webp\"></a></div>",
        "id": 460069479,
        "sender_full_name": "jsodd",
        "timestamp": 1723464565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Is.20there.20a.20way.20to.20simplify.20left.20side.20of.20the.20implication.3F/near/460069370\">said</a>:</p>\n<blockquote>\n<p><code>rw [iff_true_intro (Set.mem_univ x)]</code>?</p>\n</blockquote>\n<p>This seems to be what I'm looking for, thank you very much!</p>",
        "id": 460070021,
        "sender_full_name": "jsodd",
        "timestamp": 1723464751
    },
    {
        "content": "<p>I am pretty sure that the <code>auxLemma</code> you see in the suggestion is precisely analogous to Ruben's <code>have : x ∈ Set.univ ↔ True := iff_true_intro (Set.mem_univ x)</code></p>",
        "id": 460070145,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723464795
    },
    {
        "content": "<p>How do we interpret the output of <code>show_term simp</code> then? Shouldn't it be exactly what <code>simp</code> has found?</p>",
        "id": 460070336,
        "sender_full_name": "jsodd",
        "timestamp": 1723464870
    },
    {
        "content": "<p>It is, but simp generates these auxiliary lemmas sometimes</p>",
        "id": 460070430,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723464910
    },
    {
        "content": "<p>So the output isn't supposed to be clickable?</p>",
        "id": 460070749,
        "sender_full_name": "jsodd",
        "timestamp": 1723465032
    },
    {
        "content": "<p>In the sense that it's not guaranteed to work after clicking on it.</p>",
        "id": 460070786,
        "sender_full_name": "jsodd",
        "timestamp": 1723465049
    },
    {
        "content": "<p>It is, but Lean 4 is still very much in development and not everything works as intended yet. Here, you are hitting the limits of \"pretty-printing\", namely the action of turning a Lean expression back into a human-readable string.</p>",
        "id": 460070955,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723465098
    },
    {
        "content": "<p>Thank you for the explanation!</p>",
        "id": 460071030,
        "sender_full_name": "jsodd",
        "timestamp": 1723465133
    },
    {
        "content": "<p>So, <code>iff_true_intro</code> converts a true statement <code>Set.mem_univ x</code> intro a form <code>True \\iff (Set.mem_univ x)</code>, which may then be used in <code>rw</code>? This explains why my original attempts at using <code>rw</code> here failed.</p>",
        "id": 460073237,
        "sender_full_name": "jsodd",
        "timestamp": 1723465930
    },
    {
        "content": "<p>Well, <code>x ∈ Set.univ ↔ True</code> rather than <code>True ↔ (Set.mem_univ x)</code>, but yes</p>",
        "id": 460073355,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1723465978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"743246\">jsodd</span> has marked this topic as resolved.</p>",
        "id": 463223889,
        "sender_full_name": "Notification Bot",
        "timestamp": 1724008010
    },
    {
        "content": "<p>Here's sort of how <code>simp</code> does its thing. It uses congruence theorems to swap out the expression.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">CompleteSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">⋃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">implies_congr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">eq_true_intro</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">true_implies</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  ⊢ x ∈ ⋃ n, f n</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 463228383,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724009333
    },
    {
        "content": "<p>(It's easier and clearer to use <code>simp</code>)</p>",
        "id": 463228442,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724009360
    },
    {
        "content": "<p>It was just a curiosity question, <code>simp</code> is a blackbox. It's interesting though whether using a lot of <code>simp</code>s adds up making lean slow. Not that I've encountered it yet...</p>",
        "id": 463228699,
        "sender_full_name": "jsodd",
        "timestamp": 1724009466
    },
    {
        "content": "<p>Im trying to use <code>rw</code> or <code>simp only</code> instead of <code>simp</code>. Not sure it's the best strategy.</p>",
        "id": 463228780,
        "sender_full_name": "jsodd",
        "timestamp": 1724009509
    },
    {
        "content": "<blockquote>\n<p>It was just a curiosity question</p>\n</blockquote>\n<p>Yeah, I understood, and so that's what the example is showing, a working expression that morally does what simp does.</p>\n<p>Are you aware of <code>simp?</code> for constructing a working <code>simp only</code>? That's what people do for either \"non-terminal simps\" or otherwise slow simps. You might hear this called \"squeezing simps\" since it used to be called <code>squeeze_simp</code> long ago.</p>",
        "id": 463229065,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1724009764
    },
    {
        "content": "<p>Yes, I use it all the time. <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Division.20by.20zero.20in.20gaussianPDFReal_zero_var\">Just learned</a> that division by zero = multiplication by zero using it <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 463229154,
        "sender_full_name": "jsodd",
        "timestamp": 1724009882
    }
]