[
    {
        "content": "<p>One of the arguments for dependent type theory says that the vector type is good because it is a type which also contains the size of the list.</p>\n<p>On the other hand I could just use a list type and then use a function to get the length of the list. So in both cases I can get the length of the list.</p>\n<p>So for example if I wanted to add two lists I could define a function <code>add:List-&gt;List-&gt;List</code> and just check the length of the lists with a function and if the lists aren't the same I just return a null list or some such object.</p>\n<p>So I'm just wondering if someone can convince me that having the length of the list in the type is any better than being able to get the length of a list using a function.</p>\n<p>The reason this has come up is that I'm thinking about types for, say, a bitmap object. And whether the type should just be Bitmap and we could get the width and height using functions (e.g. Bitmap.width(mybitmap) ), or the type should be Bitmap(width,height). There seem to be pros and cons of both approaches.</p>",
        "id": 454104399,
        "sender_full_name": "Mr Proof",
        "timestamp": 1721954224
    },
    {
        "content": "<p>The commonly held belief in these circles is actually that the indexed vector type is not a good representation, it's mainly used as a toy example but we recommend against using it in favor of <code>List</code> for exactly the reasons you indicate</p>",
        "id": 454113128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721954501
    },
    {
        "content": "<p>That said, for 2 or more dimensional objects bundling the size in the type can be more convenient than adding a bunch of quantified hypotheses saying that the length of the list is w and the length of every element of the list is h</p>",
        "id": 454115389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721954588
    },
    {
        "content": "<p>but you can use a subtype representation to make it easy to forget about the length constraint and drop to the raw list representation when it gets in the way</p>",
        "id": 454116027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1721954631
    },
    {
        "content": "<p>I'm implementing automatic differentiation in Lean and having vectors with fixed size is absolutely crucial because they form a vector space. Working with arrays of arbitrary size would be difficult as they form a manifold(a diffeological space to be more precise) and doing automatic differentiation in that setting gets way more complicated.</p>\n<p>But this is a very niche application/argument so take with a grain of salt.</p>",
        "id": 454144361,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1721959487
    },
    {
        "content": "<p>I'm using dependent type theory because the concept of a sheaf is a central idea in modern algebraic geometry (which is essential for the proof of FLT) and a sheaf is a dependent type.</p>",
        "id": 454231330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1721979717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20are.20vectors.20better.20than.20lists.3F/near/454144361\">said</a>:</p>\n<blockquote>\n<p>I'm implementing automatic differentiation in Lean and having vectors with fixed size is absolutely crucial because they form a vector space. Working with arrays of arbitrary size would be difficult as they form a manifold(a diffeological space to be more precise) and doing automatic differentiation in that setting gets way more complicated.</p>\n<p>But this is a very niche application/argument so take with a grain of salt.</p>\n</blockquote>\n<p>Is it difficult to do this with <code>Mathlib.Vector</code> for example? Does it need the inductive definition of <code>Vector a n</code>?</p>",
        "id": 454266116,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721989145
    },
    {
        "content": "<p>Maybe I misunderstood the question but I don't think it is about inductive vs subtype definition of Vector and yes I don't care which definition you use. The important part is that the length is in the type.</p>",
        "id": 454303500,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1722001933
    },
    {
        "content": "<p>As someone who spends a lot of time working with n dimensional arrays, having the dimension of the array is quite important and I notate every array in my code with its dimension.  Having it as part of the static type checker would be amazing!  (Again, I’m not advocating for a particular implementation, although integrating Jax with Lean would be really interesting!)</p>",
        "id": 454333717,
        "sender_full_name": "Jason Rute",
        "timestamp": 1722011447
    },
    {
        "content": "<p>There is a batteries PR to have statically sized arrays pending for two months now</p>",
        "id": 454333978,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722011509
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/batteries/pull/793\">batteries#793</a> (disclosure: I am the author)</p>",
        "id": 454334101,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1722011529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20are.20vectors.20better.20than.20lists.3F/near/454231330\">said</a>:</p>\n<blockquote>\n<p>I'm using dependent type theory because the concept of a sheaf is a central idea in modern algebraic geometry (which is essential for the proof of FLT) and a sheaf is a dependent type.</p>\n</blockquote>\n<p>Hi <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <br>\nI'm confused: was this message intended for <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/is.20dependent.20type.20theory.20a.20must.20to.20define.20a.20sheaf.3F\">#maths &gt; is dependent type theory a must to define a sheaf?</a> instead? Somehow, it ended up here. Apologies if I am missing something.</p>",
        "id": 454444666,
        "sender_full_name": "Florent Schaffhauser",
        "timestamp": 1722069036
    },
    {
        "content": "<p>Can't be since the conversation in <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/is.20dependent.20type.20theory.20a.20must.20to.20define.20a.20sheaf.3F\">#maths &gt; is dependent type theory a must to define a sheaf?</a>  started after Kevin sent his message</p>",
        "id": 454445046,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722069181
    },
    {
        "content": "<p>(I was just giving another argument for dependent type theory, responding to the first sentence here, but it sparked the conversation there)</p>",
        "id": 454447676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1722071253
    },
    {
        "content": "<blockquote>\n<p>So for example if I wanted to add two lists I could define a function <code>add: List-&gt;List-&gt;List</code> and just check the length of the lists with a function and if the lists aren't the same I just return a null list or some such object.</p>\n</blockquote>\n<p>This makes the question sound like you're wondering when and why you might prefer having the list's length verified in the type signature instead of as a runtime check.</p>\n<p>Let's think about a function like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"c1\">-- This line is weird</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>So, now both <code>add [] []</code> and <code>add [1] [1,2]</code> return the empty list. You need to know how <code>add</code> was called in order to know which whether you've been given the junk value.</p>\n<p>So  you can do it like this perhaps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span>\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>this might be a slightly bad API if the intended way to use this function is to never fall into the <code>none</code> branch in the first place. Like, if you know for sure your lists are the same length because of the way they were constructed, then you can make the caller prove that the run-time check isn't necessary.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">λ_</span><span class=\"w\"> </span><span class=\"bp\">↦</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Something like that perhaps.</p>",
        "id": 454651089,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1722193035
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PFun#doc\">docs#PFun</a> for the latter option.</p>",
        "id": 454660355,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722197355
    },
    {
        "content": "<p>But this operation doesn't turn <code>List Int</code> into an additive commutative group.</p>",
        "id": 454660480,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722197405
    }
]