[
    {
        "content": "<p>Why does the first example below work but the second doesn't?  Lean tells me that <code>simp</code> made no progress.  That doesn't make any sense.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 519950485,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1747965380
    },
    {
        "content": "<p>The short answer is that <code>simp [show k ≠ 0 by omega]</code> works.</p>",
        "id": 519951498,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747965875
    },
    {
        "content": "<p>The longer answer is that <code>have h' := (by omega : k ≠ 0)</code> only works because of the order that unification happens. Roughly, <code>by omega</code> is deferred and is a metavariable, it gets the type <code>k ≠ 0</code>, and this unifies with the type of <code>h'</code> (which starts as a metavariable) which \"locks in\" the type.</p>",
        "id": 519951677,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747965962
    },
    {
        "content": "<p>However, as a simp argument, <code>(by omega : k ≠ 0)</code> doesn't have any such place the intended type is stored. Tactics don't guarantee that the term they produce is structurally the expected type, any more than other terms do. Using <code>show</code> adds in a discretionary term that ensures the type of the term is what you want.</p>",
        "id": 519951895,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747966050
    },
    {
        "content": "<p>You can verify it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"c1\">-- fun a =&gt; _check._proof_1 k h a : k = 0 → False</span>\n</code></pre></div>\n<p>So <code>omega</code> creates a term of type <code>k = 0 → False</code>.</p>",
        "id": 519952003,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747966104
    },
    {
        "content": "<p>There are other ways to incidentally capture the type too. For example <code>simp [id (by omega : k ≠ 0)]</code>.</p>",
        "id": 519952112,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747966175
    },
    {
        "content": "<p>But putting <code>(by omega : ...)</code>inside the <code>simp</code> bracket seems to work most of the time.  I just occasionally encounter the above behavior.</p>",
        "id": 519952936,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1747966565
    },
    {
        "content": "<p>Yes, that is consistent with the fact that tactics don't guarantee that the term they produce has a type that is structurally the expected type. When it happens to work, it happens to work.</p>",
        "id": 519957594,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747969897
    },
    {
        "content": "<p>if the proof gets extracted, it seems like it should have saved the type at that point though</p>",
        "id": 519957899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970099
    },
    {
        "content": "<p>What do you mean by 'extracted' <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>?</p>\n<p>If <code>simp</code> fully elaborates each term in the simp list before taking a look, then even though the <code>by</code> metavariable has <code>k ≠ 0</code> as its type, once the tactic assigns a term to the metavariable, that's gone. Tactics don't generally insert type hint terms, right?</p>",
        "id": 519958438,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747970475
    },
    {
        "content": "<p>note that the proof above is <code>_check._proof_1</code> and not a proof term</p>",
        "id": 519958483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970499
    },
    {
        "content": "<p>at the point of extraction, you have to decide on the type of the term to extract</p>",
        "id": 519958550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970524
    },
    {
        "content": "<p>and the logical choice for this is the expected type you started with, which if done would ensure that you get <code>k ≠ 0</code> in this example</p>",
        "id": 519958605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970562
    },
    {
        "content": "<p>Omega proves by contradiction though, so I'm not surprised <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 519958625,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747970574
    },
    {
        "content": "<p>This is a common gotcha, the fact that type ascriptions don't ensure structural type hints, and the tip is to use <code>show</code> instead.</p>",
        "id": 519958646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747970587
    },
    {
        "content": "<p>the actual proof approach of omega doesn't really matter here</p>",
        "id": 519958655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970592
    },
    {
        "content": "<p>because whatever it does is wrapped in \"extract the result of this tactic\"</p>",
        "id": 519958686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970609
    },
    {
        "content": "<p>I'm saying that extraction is another kind of <code>show</code></p>",
        "id": 519958763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970644
    },
    {
        "content": "<p>I'm not sure what point you're making — \"since omega does extract proofs, it should try to use the expected type even though there's no guarantee that tactics in general create types that are structurally the expected type\"?</p>",
        "id": 519958798,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747970673
    },
    {
        "content": "<p>yes</p>",
        "id": 519958817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970686
    },
    {
        "content": "<p>although many tactics do ensure this property</p>",
        "id": 519958831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970697
    },
    {
        "content": "<p><code>norm_num</code> pays specific attention to this, not because of making <code>: T)</code> work but because defeq unfolding can cause surprising slowdowns when the kernel decides to unfold the wrong thing</p>",
        "id": 519958896,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970746
    },
    {
        "content": "<p><code>dsimp</code> also specifically puts in unfolding hints</p>",
        "id": 519958996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970792
    },
    {
        "content": "<p>in fact most cases where the hints were skipped later get refactored when it turns out it was a bad idea</p>",
        "id": 519959034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1747970816
    },
    {
        "content": "<p>Whether or not there are concerns about the terms <code>omega</code> is creating, it's still not something you can rely on, that a tactic produces a term whose type is structurally equal to the expected type. (E.g. <code>exact</code>, <code>refine</code>, <code>apply</code>, <code>intro</code>, <code>constructor</code>, and so on.)</p>\n<p>Using \"<code>show k ≠ 0 by omega</code>\" rather than a type ascription is a way to ensure the type is <code>k ≠ 0</code>.</p>",
        "id": 519961365,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1747972270
    }
]