[
    {
        "content": "<p>I've been picking up MIL again and I've been attempting the following problem in Section 9 on groups:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This took me hours because I was trying to figure out how to properly interact with the <code>≤</code> operator. At first I looked at just using theorems in lattices thinking that I could show that if <code>comap φ ·</code> behaves monotonically, then this should be trivial. But I wasn't able to get anything to work on that end and gave up here.</p>\n<p>Then I played around a while trying to get <code>S</code> and <code>T</code> to be sets and this also didn't work! Finally after a long time of looking I found the theorem <code>SetLike.le_def</code> and then used this to create the following (very simple) proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">le_def</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"bp\">.</span><span class=\"n\">le_def</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hST</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">phi_g_in_S</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"n\">phi_g_in_S</span>\n</code></pre></div>\n<p>After this I looked in the solutions page to see if there was something easy and I saw this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">comap</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_comap</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"c1\">-- Lean does not need this line</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hST</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n</code></pre></div>\n<p>But this solution is very confusing to me because how am I supposed to know upfront that under the hood the objects are defined like <code>x → hx → ...</code>?</p>",
        "id": 536284746,
        "sender_full_name": "Luna",
        "timestamp": 1756229836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"769874\">@Luna</span> if you're not in the context of MIL, then the correct thing to do would be to ask loogle, for example this statement is about <code>Subgroup.comap</code>, and is about \"mono\", so I put <a href=\"https://loogle.lean-lang.org/?q=Subgroup.comap%2C+%22mono%22\">Subgroup.comap, \"mono\"</a> to Loogle and the first result is what you need</p>\n<p>if you are in the context of proving this by yourself, then the first thing you would want to do would be do right click on <code>comap</code> and click \"see definition\", which will bring you to the definitions \"under the hood\".</p>\n<p>trying to see the definition of LE is less trivial, but there is still a way to do it using <code>#synth</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>note that the result is <code>CompleteLattice.toCompletePartialOrder.toLE</code> which tells you how the LE is defined, and most importantly the result is clickable, so you can click to trace the definitions</p>",
        "id": 536300195,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756236802
    },
    {
        "content": "<p>If you don't know the implementation then <code>rw [mem_comap]</code> at least gives you what your mental model of the definition is (I should think)</p>",
        "id": 536305182,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1756238962
    },
    {
        "content": "<p>So in theory the right answer is rewriting with <code>SetLike.le_def</code> as you did. In practice many people will assume that <code>le_def</code> is indeed the <em>definition</em> of <code>\\le</code>, and will use tactics like <code>intro</code> that see through the definition.</p>",
        "id": 536309930,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241188
    },
    {
        "content": "<p>And because the definition in this case is so simple and unlikely to change, there's not much appetite for pushing towards using the API</p>",
        "id": 536310062,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  I did something similar to that and came across <code>CompleteLattice.toCompletePartialOrder.toLE</code> but clicking \"go to definition\" just brings me to the definition of <code>PartialOrder</code>. I tried going through the stack a bit more but I couldn't find the origins of the definition of <code>≤</code> for subgroups. </p>\n<p>And <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I saw that at first but it never came to mind to use it since the theorem doesn't contain <code>≤</code> </p>\n<p>After the fact, I finally found the definition of the instance of <a href=\"https://github.com/leanprover-community/mathlib4/blob/1e4458c6e6244d1593ef0c8775452479ec35ee63/Mathlib/Algebra/Group/Subgroup/Lattice.lean#L241\"><code>CompleteLattice</code></a> for subgroups.</p>\n<p>So I guess my question is, is there a way to go from <code>A ≤ B</code> to \"definition of <code>≤</code> for the type of <code>A</code>?</p>",
        "id": 536310098,
        "sender_full_name": "Luna",
        "timestamp": 1756241264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"769874\">Luna</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20determine.20the.20intended.20API.20of.20an.20object/near/536310098\">said</a>:</p>\n<blockquote>\n<p>So I guess my question is, is there a way to go from <code>A ≤ B</code> to \"definition of <code>≤</code> for the type of <code>A</code>?</p>\n</blockquote>\n<p>If you find one, let me know :)</p>",
        "id": 536310236,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241327
    },
    {
        "content": "<p>You can probably get there by clicking the right instances in the infoview, but it's not the most obvious</p>",
        "id": 536310334,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241376
    },
    {
        "content": "<p>If you click on the <code>CompleteLattice.toCompletePartialOrder</code> part of <code>CompleteLattice.toCompletePartialOrder.toLE</code>, you get a popup that shows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">CompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">toCompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">instCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and in vs code, you can control-click the <code>instCompleteLattice</code> part of that and you might end up in a good place</p>",
        "id": 536310679,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241555
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/e68729735c6afe9a085958187facee5f6782e312/Mathlib/Algebra/Group/Subgroup/Lattice.lean#L239-L251\">https://github.com/leanprover-community/mathlib4/blob/e68729735c6afe9a085958187facee5f6782e312/Mathlib/Algebra/Group/Subgroup/Lattice.lean#L239-L251</a></p>",
        "id": 536310784,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241606
    },
    {
        "content": "<p>Yeah, that doesn't help either, sadly</p>",
        "id": 536310830,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756241631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20determine.20the.20intended.20API.20of.20an.20object/near/536310679\">said</a>:</p>\n<blockquote>\n<p>If you click on the <code>CompleteLattice.toCompletePartialOrder</code> part of <code>CompleteLattice.toCompletePartialOrder.toLE</code>, you get a popup that shows</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">CompleteLattice</span><span class=\"bp\">.</span><span class=\"n\">toCompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">instCompleteLattice</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CompletePartialOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and in vs code, you can control-click the <code>instCompleteLattice</code> part of that and you might end up in a good place</p>\n</blockquote>\n<p>it is actually the right path, but the next steps are more non-trivial:</p>\n<ol>\n<li>do <code>#print Subgroup.instCompleteLattice</code>, and run around in the infoview, until you understand the logic that it comes from <code>let __src := completeLatticeOfInf (Subgroup G) ⋯</code></li>\n<li>click on <code>completeLatticeOfInf </code> to see <code>@completeLatticeOfInf (Subgroup G) SetLike.instPartialOrder Subgroup.instInfSet ⋯ : CompleteLattice (Subgroup G)</code>, understand the logic and realise that it comes from <code>SetLike.instPartialOrder</code></li>\n<li>now do <code>#print SetLike.instPartialOrder</code>, and see <code>le := fun H K =&gt; ∀ ⦃x : B⦄, x ∈ H → x ∈ K</code> in the output, and this is the info requested</li>\n</ol>",
        "id": 536311415,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756241900
    },
    {
        "content": "<p>which, i admit is very convoluted and may not be that well suited to a beginner</p>",
        "id": 536311439,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756241914
    },
    {
        "content": "<p>it's a bit hard to make this better, because if we just request an algorithm to \"unfold all the definitions\", then you'll end up unfolding the mem as well... maybe we can request the macro to accept a natural number as input to tell it the number of steps to unfold</p>",
        "id": 536311869,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242147
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"769874\">@Luna</span> please don't be discouraged that you found this hard - it is :)</p>",
        "id": 536312297,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1756242328
    },
    {
        "content": "<p>I've brought this up in <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/feature.20request.3A.20unfold.20n.20steps.20of.20definition/with/536312276\">#lean4 &gt; feature request: unfold n steps of definition</a></p>",
        "id": 536312334,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242348
    },
    {
        "content": "<p>I suppose the algorithm would be at each step to get the head of the expression and then <code>unfold</code> it, and if it fails (e.g. structural projection) then get the next head, etc.</p>",
        "id": 536312470,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242411
    },
    {
        "content": "<p>I can try to write something later (not today) if nobody beats me to it</p>",
        "id": 536312496,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1756242425
    },
    {
        "content": "<p>Thank you all for looking into this! So my understanding is that the best current solution for MIL excersizes is to keep recursively looking into all the instances to try find the concrete definition, and for Mathlib to use a search engine.</p>\n<p>The unfold approach sounds interesting and like an automated version of the above. I'd imagine that in theory one should be able to recursively unfold the function <code>(· ≤ · : Subgroup _ → Subgroup _ → Prop)</code> until you reach Lean primitives and then rewind until you get to the desired level. </p>\n<p>A confusing aspect I guess is that because class instances can be chained together, its not easy to find the \"original\" definition. Is there an easy way to filter out instances that are generated \"on-the-fly\" and keep only the instances that are \"user-defined\"?</p>",
        "id": 536473447,
        "sender_full_name": "Luna",
        "timestamp": 1756318000
    },
    {
        "content": "<p>Also when in VS-code, is there an easier way to find how each instance is created other than hover over it in the info-view, and then hover over the term in the pop up window, and continuing that for arbitrarily long? It becomes very difficult to read and sometimes clicking \"Go-to definition\" doesn't work because moving my mouse makes the window disappear. E.g. below</p>\n<p><a href=\"/user_uploads/3121/fgJndtVaWeKWxmUYucclCkBp/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/fgJndtVaWeKWxmUYucclCkBp/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"838x577\" src=\"/user_uploads/thumbnail/3121/fgJndtVaWeKWxmUYucclCkBp/image.png/840x560.webp\"></a></div>",
        "id": 536475004,
        "sender_full_name": "Luna",
        "timestamp": 1756318654
    }
]