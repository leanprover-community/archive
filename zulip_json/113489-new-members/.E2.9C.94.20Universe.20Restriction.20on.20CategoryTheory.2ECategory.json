[
    {
        "content": "<p>Formalising category theory can be complex: subtle choices in core definitions can lead to noticeable deviations from the theory as it is studied on paper. Some of these choices are driven by technicalities in the host language, some to facilitate certain constructions later on, and some simply reflect the authors' preferences.</p>\n<p>Although there are publications on this topic (e.g., [1, 2, 3], among others), a beginner may still struggle to understand the rationale behind some of the caused restrictions.  One such restriction lies in the very definition of a category in <code>mathlib</code>: objects and hom-sets of a category defined in <code>CategoryTheory.Category</code> are limited to <code>Type u</code> and <code>Type v</code>  (rather than <code>Sort u</code> and <code>Sort v</code>). This definition prevents <code>⟨ Type , Eq , refl , trans ⟩</code> from being an instance of <code>CategoryTheory.Category</code>, since <code>Eq a b</code> resides in <code>Prop</code>. In practice, one can indeed lift <code>Eq</code> (e.g., by <code>PLift</code>) to types; the question is of theoretical interest.</p>\n<p>What is the reasoning behind this restriction?<br>\nAre there specific constructions within the library that prevent generalisation to arbitrary <code>Sort</code>?</p>\n<p>(Note that the use of <code>Prop</code> does not appear to introduce issues with equality, as the laws are fixed to be subsingletons in the library.)</p>\n<p>Thank you</p>\n<p>[1] Hu &amp; Carette, \"Formalizing Category Theory in Agda\"<br>\n[2] Timany &amp; Jacobs, \"Category Theory in Coq\"<br>\n[3] Ahrens et al., \"Univalent Categories and the Rezk Completion\"</p>",
        "id": 479078691,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1729976090
    },
    {
        "content": "<p>I think understanding this fully will require some digging into the early history of mathlib. <a href=\"https://github.com/leanprover-community/mathlib3/pull/1412\">mathlib3#1412</a> and <a href=\"#narrow/channel/116395-maths/topic/category.20universes.20again/near/175012654\">this thread</a> should be good starting points.</p>",
        "id": 479113338,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1730015401
    },
    {
        "content": "<p>Before closing this thread, I add what I could gather on this topic below.</p>\n<p>The two links provided by <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>  offer a good overview of the issue regarding \"sort-polymorphic\" categorical definitions and the historical reasons behind the current design. To find some clear examples , I also personally investigated the matter: I updated <code>Mathlib.CategoryTheory</code> to work with <code>Sort</code>s instead of <code>Type</code>s, and then distilled  and studied the problematic parts.</p>\n<p>Generally, there are two categories of problems: practical software-engineering challenges and the theoretical implications of largeness.</p>\n<p>In practice,  such a library-wide change is non-trivial and intrusive. It includes updating core definitions, from <code>ulift</code> to type-indexed sets, to work with <code>Sort</code>s instead of <code>Type</code>s.</p>\n<p>Theoretically, the central issue is that, in a sort-polymorphic setting, definitions like <code>Prefunctor</code> can end up in a <code>Sort</code> with an unrestricted universe,  such as <code>Sort (max u v)</code>. This unbounded sort-polymorphism poses problems in Lean (see [1]). To retain sort-polymorphism, it is necessary to restrict the universe to a <code>Type</code>. For instance,  by changing  <code>Sort (max u v)</code> to <code>Sort (max u v 1)</code> or <code>Sort ((max u v) + 1)</code>. However, these changes create further complications:<br>\nthe latter forces the category of categories Cat to be small (both objects and morphisms at the same universe level),<br>\nand the former leads to Cat being neither small nor large. The table below illustrates the relationship between different choices for sort-polymorphism and their impact on universe levels. </p>\n<p><a href=\"/user_uploads/3121/RC16XR7vqyk4ZSfAbswxZx8G/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/RC16XR7vqyk4ZSfAbswxZx8G/image.png\" title=\"image.png\"><img data-original-dimensions=\"1309x374\" src=\"/user_uploads/thumbnail/3121/RC16XR7vqyk4ZSfAbswxZx8G/image.png/840x560.webp\"></a></div><p>Only the following basic categorical definitions were considered within the library: categories, functors, natural transformations, (strict)bicategories, Cat via a direct definition (had to be introduced), Cat via (strict)bicategories, and functor category.</p>\n<p>The concept of largeness is relevant for certain core definitions and theorems, such as Yoneda and the existence of (co)limits. However, the resulting \"largeness\" seems to stem primarily from the arbitrary restriction of sort-polymorphism. In the absence of unrestricted sort-polymorphism, the library's current implementation appears both practical and theoretically justified.</p>\n<p>[1] <a href=\"https://lean-lang.org/doc/reference/latest//The-Lean-Language/The-Type-System/#prop-vs-type\">https://lean-lang.org/doc/reference/latest//The-Lean-Language/The-Type-System/#prop-vs-type</a></p>",
        "id": 479780105,
        "sender_full_name": "Middle Adjunction",
        "timestamp": 1730330758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"762283\">Middle Adjunction</span> has marked this topic as resolved.</p>",
        "id": 479780171,
        "sender_full_name": "Notification Bot",
        "timestamp": 1730330784
    }
]