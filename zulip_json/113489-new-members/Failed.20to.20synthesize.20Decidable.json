[
    {
        "content": "<p>I'm having some issue with sets that I can't quite untangle. See the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">dsaasd</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MeasurableSpace</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Countable</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">dirac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>For some reason, in the theorem statement, Lean complains that <code>failed to synthesize  Decidable (f i ∈ s)</code>, whereas <code>let t := { i | f i ∈ s }</code> is OK. What am I doing wrong here? Thanks!</p>",
        "id": 522172838,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748969351
    },
    {
        "content": "<p>The fix here is to add <code>[DecidablePred (· ∈ s)]</code></p>",
        "id": 522173235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748969479
    },
    {
        "content": "<p>You don't need it for <code>{i | f i ∈ s}</code> because that's just a set literal, not a decision procedure like <code>if</code>.</p>",
        "id": 522173479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748969549
    },
    {
        "content": "<p>Doesn't that just bump the issue one level up in that I would then have to supply the decidability when I use the theorem? (Is there some formal reason why I can't assume that I can ask the question \"is <code>f i</code> an element of the set <code>s</code>\"?)</p>",
        "id": 522173941,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748969673
    },
    {
        "content": "<p>Sure, but when you use the theorem you can just write <code>classical</code> in the proof and it's fine</p>",
        "id": 522174305,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748969777
    },
    {
        "content": "<p>You only should add these assumptions when the <em>statement</em> requires them, because if you don't then the thing you proved isn't as general as it might need to be</p>",
        "id": 522174481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1748969834
    },
    {
        "content": "<p>Aha, I had seen <code>classical</code> floating around in various places without knowing what it does. From what I can glean from the Mathlib code, all <code>classical</code> does is makes set belonging decidable. Is this correct? If so, I think it's <em>probably</em> OK for what I'm doing now.</p>",
        "id": 522175421,
        "sender_full_name": "Björn Wehlin",
        "timestamp": 1748970125
    },
    {
        "content": "<p>The problem is if you have a concrete set whose membership is decidable (like <code>Set.Ico 0 1</code>) and you decide to use <code>classical</code> in the theorem statement instead of <code>[DecidablePred (· ∈ s)]</code>, when unifying your theorem statement Lean will complain that the classical decidability is not the same as the concrete decidability instance (even though they're propositionally equal). This is always annoying when it happens, so it's best to just put the decidability in the theorem statement to prevent this kind of problem before it happens.</p>",
        "id": 522176592,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1748970515
    }
]