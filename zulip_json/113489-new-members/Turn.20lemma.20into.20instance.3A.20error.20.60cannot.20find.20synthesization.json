[
    {
        "content": "<p>I'm trying to turn a lemma into an instance, but am getting errors I don't understand. MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ChartedSpace</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">HasGroupoid</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">contDiffGroupoid</span> <span class=\"mi\">0</span> <span class=\"n\">I</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">aux</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners.Boundaryless</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">IsCompact</span> <span class=\"n\">s</span>  <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- proof omitted for brevity</span>\n\n<span class=\"c1\">-- This works. Question: how to turn this into an instance.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">Manifold.locallyCompact_of_finiteDimensional_of_boundaryless</span>\n    <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners.Boundaryless</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">LocallyCompactSpace</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">local_compact_nhds</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"bp\">↦</span> <span class=\"n\">aux</span> <span class=\"n\">I</span> <span class=\"n\">hI</span> <span class=\"n\">hn</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- This fails with an error mentioning `cannot find synthesization order for instance ...` and</span>\n<span class=\"c1\">-- `all remaining arguments have metavariables:` with E and 𝕜 being metavariables.</span>\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners.Boundaryless</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LocallyCompactSpace</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">local_compact_nhds</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"bp\">↦</span> <span class=\"n\">aux</span> <span class=\"n\">I</span> <span class=\"n\">hI</span> <span class=\"n\">hn</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Next attempt, mention E and 𝕜 explicitly: also fails -- with unchanged error?!</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">NontriviallyNormedField</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">NormedSpace</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">TopologicalSpace</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ChartedSpace</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">HasGroupoid</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">contDiffGroupoid</span> <span class=\"mi\">0</span> <span class=\"n\">I</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"n\">FiniteDimensional</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">LocallyCompactSpace</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">ModelWithCorners.Boundaryless</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">LocallyCompactSpace</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"o\">{</span> <span class=\"n\">local_compact_nhds</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"bp\">↦</span> <span class=\"n\">aux</span> <span class=\"n\">I</span> <span class=\"n\">hI</span> <span class=\"n\">hn</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I've heard about classes, but not understood them in depth yet (obviously...). I'm cargo-culting here - perhaps somebody can tell me a fix before I've found the time to digest chapter 7 in MIL, including all the exercises...</p>",
        "id": 397821927,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697869451
    },
    {
        "content": "<p><a href=\"https://live.lean-lang.org/#code=import%20Mathlib%0Avariable%20%7BE%20%3A%20Type%20u%7D%20%7B%F0%9D%95%9C%20%3A%20Type%20u%7D%20%5BNontriviallyNormedField%20%F0%9D%95%9C%5D%0A%20%20%5BNormedAddCommGroup%20E%5D%20%5BNormedSpace%20%F0%9D%95%9C%20E%5D%20%7BH%20%3A%20Type%20u%7D%20%5BTopologicalSpace%20H%5D%0A%20%20(I%20%3A%20ModelWithCorners%20%F0%9D%95%9C%20E%20H)%20%7BM%20%3A%20Type%20u%7D%20%5BTopologicalSpace%20M%5D%20%5BChartedSpace%20H%20M%5D%0A%20%20%5BHasGroupoid%20M%20(contDiffGroupoid%200%20I)%5D%0A%0Aopen%20Topology%0Alemma%20aux%20%5BFiniteDimensional%20%F0%9D%95%9C%20E%5D%20%5BLocallyCompactSpace%20%F0%9D%95%9C%5D%20(hI%20%3A%20ModelWithCorners.Boundaryless%20I)%0A%20%20%20%20%7Bx%20%3A%20M%7D%20%7Bn%20%3A%20Set%20M%7D%20(hn%20%3A%20n%20%E2%88%88%20%F0%9D%93%9D%20x)%20%3A%20%E2%88%83%20s%20%3A%20Set%20M%2C%20s%E2%88%88%20%F0%9D%93%9D%20x%20%E2%88%A7%20s%20%E2%8A%86%20n%20%E2%88%A7%20IsCompact%20s%20%20%3A%3D%20by%0A%20%20sorry%20--%20proof%20omitted%20for%20brevity%0A%0A--%20This%20works.%20Question%3A%20how%20to%20turn%20this%20into%20an%20instance.%0Alemma%20Manifold.locallyCompact_of_finiteDimensional_of_boundaryless%0A%20%20%20%20%5BFiniteDimensional%20%F0%9D%95%9C%20E%5D%20%5BLocallyCompactSpace%20%F0%9D%95%9C%5D%20(hI%20%3A%20ModelWithCorners.Boundaryless%20I)%20%3A%20LocallyCompactSpace%20M%20%3A%3D%20by%0A%20%20exact%20%7B%20local_compact_nhds%20%3A%3D%20fun%20x%20n%20hn%20%E2%86%A6%20aux%20I%20hI%20hn%20%7D%0A%0A--%20This%20fails%20with%20an%20error%20mentioning%20%60cannot%20find%20synthesization%20order%20for%20instance%20...%60%20and%0A--%20%60all%20remaining%20arguments%20have%20metavariables%3A%60%20with%20E%20and%20%F0%9D%95%9C%20being%20metavariables.%0Ainstance%20%5BFiniteDimensional%20%F0%9D%95%9C%20E%5D%20%5BLocallyCompactSpace%20%F0%9D%95%9C%5D%20%5BhI%20%3A%20ModelWithCorners.Boundaryless%20I%5D%20%3A%20LocallyCompactSpace%20M%20%3A%3D%20by%0A%20%20exact%20%7B%20local_compact_nhds%20%3A%3D%20fun%20x%20n%20hn%20%E2%86%A6%20aux%20I%20hI%20hn%20%7D%0A%0A--%20Next%20attempt%2C%20mention%20E%20and%20%F0%9D%95%9C%20explicitly%3A%20also%20fails%20--%20with%20unchanged%20error%3F!%0Ainstance%20%7BE%20%3A%20Type%20u%7D%20%7B%F0%9D%95%9C%20%3A%20Type%20u%7D%20%5BNontriviallyNormedField%20%F0%9D%95%9C%5D%0A%20%20%5BNormedAddCommGroup%20E%5D%20%5BNormedSpace%20%F0%9D%95%9C%20E%5D%20%7BH%20%3A%20Type%20u%7D%20%5BTopologicalSpace%20H%5D%0A%20%20(I%20%3A%20ModelWithCorners%20%F0%9D%95%9C%20E%20H)%20%7BM%20%3A%20Type%20u%7D%20%5BTopologicalSpace%20M%5D%20%5BChartedSpace%20H%20M%5D%0A%20%20%5BHasGroupoid%20M%20(contDiffGroupoid%200%20I)%5D%0A%20%20%5BFiniteDimensional%20%F0%9D%95%9C%20E%5D%20%5BLocallyCompactSpace%20%F0%9D%95%9C%5D%20%5BhI%20%3A%20ModelWithCorners.Boundaryless%20I%5D%20%3A%20LocallyCompactSpace%20M%20%3A%3D%20by%0A%20%20exact%20%7B%20local_compact_nhds%20%3A%3D%20fun%20x%20n%20hn%20%E2%86%A6%20aux%20I%20hI%20hn%20%7D%0A\">Code on the web editor</a></p>",
        "id": 397821943,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697869473
    },
    {
        "content": "<p>The typeclass inference system (the \"square bracket system\") is a big list of instances. An instance is either a term of a type which is a class (eg \"the integers are a commutative ring\") or a theorem or construction of the form \"if you can find these instances then you can make this instance too\" (eg \"every commutative ring is an additive abelian group\"). So if you try and apply a theorem about additive abelian groups to the integers, the system looks through this big list looking for either a proof that the integers are an additive abelian group, or a theorem which says that every field or whatever is an additive abelian group (and if it tried applying this, which it could well do, then it would start looking for a proof that the integers are a field). I think the computer scientists call this a prolog-like search. So basically the typeclass inference system is solving a big logic game, but one of the rules of the game is that it's only allowed to look at all the instances in the list it has.</p>\n<p>Whenever you write <code>variable [NormedSpace k E]</code> the system makes a term <code>inst_37 : NormedSpace k E</code> and adds it to the list. And whenever a theorem has an input in square brackets, the typeclass inference system attempts to make this input using the algorithm and the things currently on the list. Note that instances have to be terms of classes. A class is simply a structure with an internal box ticked saying \"I am a class and so the typeclass inference system should pay attention to me when performing its search\". For example CommRing and AddCommGroup are classes, not just structures, they're structures with the box ticked.</p>\n<p>That's the basics of how it works. I don't know my way around the manifold part of the library at all but now let me try to answer your question unless someone else gets there first</p>",
        "id": 397824580,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697872149
    },
    {
        "content": "<p>I think your error means \"I'm not putting this on my list because I can see that my algorithm will never be able to use this instance\" by the way</p>",
        "id": 397824696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697872270
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=ModelWithCorners.Boundaryless#doc\">docs#ModelWithCorners.Boundaryless</a></p>",
        "id": 397824739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697872323
    },
    {
        "content": "<p>Ok so that's a class so your lemma <code>aux</code> which works should definitely have this input in square brackets.</p>",
        "id": 397824810,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697872397
    },
    {
        "content": "<p>The error, I believe (on mobile and not in familiar territory) is that the typeclass inference system will never be able to find <code>I</code> (because it's not on the list) and hence will never be able to work out what k and E you're talking about. Edit: no that's not right because it can see the <code>HasGroupoid</code> instance. But it's complaining that the logic game it plays can't ever be won for some reason. If you hover over the working lemma, I'm assuming it must be using the HasGroupoid instance? I think I'll stop talking now and defer to a manifold expert.</p>",
        "id": 397825188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697872815
    },
    {
        "content": "<p>Thank you for the detailed response!</p>",
        "id": 397825704,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697873393
    },
    {
        "content": "<p>Making <code>aux </code> take <code>hI</code> in square brackets doesn't suffice yet.<br>\nHovering over the lemma, I can see the HasGroupoid instance is not shown either. Adding it in square brackets also doesn't suffice, though. Overall, the errors in the second example change slightly, but I still cannot figure them out...</p>",
        "id": 397826082,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697873836
    },
    {
        "content": "<p><a href=\"https://tinyurl.com/bddenw5a\">Updated code</a></p>",
        "id": 397826188,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697873922
    },
    {
        "content": "<p>I would <code>set_option autoImplicit false</code> during this phase to get more accurate error messages (otherwise lean just makes stuff up without you knowing)</p>",
        "id": 397828269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1697875903
    },
    {
        "content": "<p>Good catch. Updated again. Now the error is definitely the same as in the beginning.</p>",
        "id": 397831107,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1697878648
    }
]