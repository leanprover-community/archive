[
    {
        "content": "<p>Hi! I'm trying to understand why the following code does <em>not</em> check, failing at the <code>rfl</code> inside the definition of <code>foo</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>It's apparent that the <code>x</code> I'm getting from pattern matching on φ isn't definitionally equal to the one I get from projecting it from φ. </p>\n<p>1) Is this expected behavior? I'm guessing it is.<br>\n2) Is there an easy way to show they're propositionally equal?<br>\n3) Is there a better workaround than simply not using pattern matching in this way? I'm currently doing the equivalent of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span>\n<span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">y</span>\n</code></pre></div>\n<p>but obviously this is less pleasantly syntactic-sugary and it feels more unfortunate the more fields there are.</p>\n<p>(I tried searching docs, searching broader internet, etc. but pointers to canonical explanations of underlying mechanisms here would be super appreciated if any)</p>",
        "id": 510040160,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743715640
    },
    {
        "content": "<p>Yeah, the new variables don't remember their relationship to the original variable.</p>\n<p>Could you say a bit about why you need to refer to <code>φ</code> after the pattern match?</p>",
        "id": 510040730,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743715911
    },
    {
        "content": "<p>Sure; it comes up because in my current development <code>φ</code> is not just a couple of numbers, but rather a decently big bundle of related data that I pass to a lemma. The lemma's conclusion winds up stating things about projected fields of <code>φ</code>. </p>\n<p>So from the perspective of the containing theorem, the lemma's results are not useful (under the assumption that the containing theorem starts by unpacking <code>φ</code> via pattern matching) because it appears to be stating properties about different fields (different up to definitional equality anyway)</p>",
        "id": 510040891,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743715980
    },
    {
        "content": "<p>But is it really the case that we can't even prove projected fields propositionally equal to their pattern-matched cousins?</p>",
        "id": 510041159,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716123
    },
    {
        "content": "<p>No, that's definitely not the case, it just takes a couple minutes to write some examples :-)</p>",
        "id": 510041298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716178
    },
    {
        "content": "<p>Great, I have ample patience for examples, happy to know that things are more or less as I expect. :)</p>",
        "id": 510041356,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716212
    },
    {
        "content": "<p>Here's one option where you get a new phi with a theorem relating the fields:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">@</span><span class=\"n\">h</span><span class=\"o\">:</span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>The new phi should replace all instances of the old one. Possibly you need every instance of the phi to be in the expected type.</p>",
        "id": 510041424,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716239
    },
    {
        "content": "<p>(though I was expecting them to be definitionally equal, I guess... but the exact contours of how definitional equality works varies from logical framework to logical framework enough that I'm not too shocked)</p>",
        "id": 510041446,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716250
    },
    {
        "content": "<p>Ok, thanks, I think that pretty much addresses my question perfectly</p>",
        "id": 510041557,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716285
    },
    {
        "content": "<p>More powerful is <code>match</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">congrArg</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"w\">    </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>",
        "id": 510041568,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716288
    },
    {
        "content": "<p>The <code>let</code> syntax is sugar for a <code>match</code>.</p>",
        "id": 510041609,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716305
    },
    {
        "content": "<p>Right, <code>let</code> being sugar for <code>match</code> makes perfect sense to me</p>",
        "id": 510041635,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716328
    },
    {
        "content": "<p>Anyway thanks a bunch. I'm trying to formalize a still unpublished result from HoTT'25 that I got excited about and got some hints from the author about how the proof goes, and it's exercising a bunch of the lean knowledge that I don't yet have in a fun way</p>",
        "id": 510041842,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716424
    },
    {
        "content": "<p>The biggest hint that there's no definitional equality is that if you look at the expected type in the Infoview after the <code>let</code>, none of the variables have any assigned values. There's no way for a variable to be definitionally equal to some value if there's no value present.</p>",
        "id": 510041847,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716427
    },
    {
        "content": "<p>Ah, that's interesting</p>",
        "id": 510041871,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716441
    },
    {
        "content": "<p>With the <code>match</code> version for example you can see</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n</code></pre></div>\n<p>Nothing here has a <code>:= ...</code> value assignment, but at least <code>h</code> records information you can make use of propositionally.</p>",
        "id": 510041964,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716497
    },
    {
        "content": "<p>People have suggested that pattern matching of structures should create let bindings. It's not consistent with how pattern matching normally works though, but maybe the convenience for structures is worth it, I'm not sure.</p>\n<p>Perhaps a separate syntax, like <code>let_proj</code>, could be a way to introduce these projections.</p>",
        "id": 510042543,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">jcreed</span> has marked this topic as resolved.</p>",
        "id": 510042670,
        "sender_full_name": "Notification Bot",
        "timestamp": 1743716784
    },
    {
        "content": "<p>Yeah I could get behind a different syntax</p>",
        "id": 510042694,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716802
    },
    {
        "content": "<p>It's just a nice convenience to unpack a structure all at once</p>",
        "id": 510042708,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716812
    },
    {
        "content": "<p>Is there anything else this would enable other than being able to write <code>x</code> instead of <code>φ.x</code>?</p>",
        "id": 510042807,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716874
    },
    {
        "content": "<p>If <code>φ</code> is actually some larger expression, there's always <code>let s := φ</code> as a first step.</p>",
        "id": 510042924,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716931
    },
    {
        "content": "<p>I mean, what it's concretely enabling for me is writing </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">factorizes</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n</code></pre></div>\n<p>instead of</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">X</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">g</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">h</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">factorizes</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">factorizes</span>\n</code></pre></div>",
        "id": 510042926,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716932
    },
    {
        "content": "<p>I get that, I'm asking about what comes next.</p>",
        "id": 510042956,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743716950
    },
    {
        "content": "<p>ah, then perhaps the answer you're looking for is it enables me writing <code>lemma φ</code> instead of <code>lemma X g h factorizes</code>?</p>",
        "id": 510043017,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743716984
    },
    {
        "content": "<p>(where the return type of <code>lemma</code> is a <code>Prop</code> that mentions the fields of <code>φ</code>)</p>",
        "id": 510043103,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717015
    },
    {
        "content": "<p>That's closer. I'm wondering if there's something especially onerous about <code>φ.X</code> instead of <code>X</code>.</p>",
        "id": 510043152,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717046
    },
    {
        "content": "<p>If there's some other way of doing all of this that's more idiomatic I'm all ears</p>",
        "id": 510043161,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717052
    },
    {
        "content": "<p>No, I consider φ.x no worse than x, that's fine</p>",
        "id": 510043186,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717067
    },
    {
        "content": "<p>but, for the sake of the exercise, I consider having to supply all of the arguments to the lemma separately to be more onerous than supplying them as one package</p>",
        "id": 510043226,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717093
    },
    {
        "content": "<p>Maybe I can whip up a more explanatory minimal example if it would make things clearer...</p>",
        "id": 510043328,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717133
    },
    {
        "content": "<p>Yeah, this <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is a bit too minimal — it's not showing why you need the original phi.</p>\n<p>If it's just that you want to package up values to pass to multiple lemmas, then no need to illustrate that, I get it.</p>",
        "id": 510043466,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717206
    },
    {
        "content": "<p>But if there's some reason you want to be able to write <code>X</code> instead of <code>φ.X</code>, that might be worth an illustration.</p>",
        "id": 510043508,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717230
    },
    {
        "content": "<p>Unpacking the structure seems rather inconvenient overall, even if <code>X</code> is a bit more convenient than <code>φ.X</code>.</p>",
        "id": 510043652,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717290
    },
    {
        "content": "<p>If there are some other systems that preserve the definitional equality, I'd appreciate it if you'd point me toward them.</p>",
        "id": 510043920,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717428
    },
    {
        "content": "<p>agree, I constructed the above <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> just to check whether I was correctly understanding that the two were not definitionally equal, and to ask whether they were still propositionally equal.</p>",
        "id": 510043953,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717447
    },
    {
        "content": "<p>I think agda does (based merely on the fact that I've never run into this issue there before), but I'd have to check. I could be wrong.</p>",
        "id": 510043992,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717462
    },
    {
        "content": "<p>Oh, I think I understand you as asking me, more or less, \"Why not just write <code>φ.X</code> absolutely everywhere you would have written <code>X</code>, and avoid anything like <code>let ⟨ X, g, h, factorizes ⟩ := φ</code> in the first place\" --- I didn't understand that framing earlier, sorry</p>",
        "id": 510044193,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717553
    },
    {
        "content": "<p>I guess I do think of that as somewhat onerous? Or at least its onerousness is proportional to the product of the number of keystrokes in <code>φ</code> (which choice of variable name is entirely my fault) times the number of times I refer to its fields...</p>",
        "id": 510044222,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717568
    },
    {
        "content": "<p>We wouldn't have language features like <code>open</code> if writing fully qualified identifiers everywhere was palatable :)</p>",
        "id": 510044251,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717587
    },
    {
        "content": "<p>Perplexingly, the following code <em>does</em> check ok:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fooLemma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fooLemma</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>",
        "id": 510044873,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717912
    },
    {
        "content": "<p>I thought it wouldn't</p>",
        "id": 510044887,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743717920
    },
    {
        "content": "<p>I think <code>open</code> is different, since that saves writing the full namespace name, which can be long, and it also makes code more robust, since you can relocate things into different namespaces. (Lean reports ambiguities too.)</p>\n<p>With this structure case, it's always just <code>φ.X</code>, and if <code>φ</code> is too long, you can make a new <code>let</code> binding for it. It's also more reliable using the field notation in some ways, since without these variables, you don't stand the risk of shadowing a field variable and not realizing <code>X</code> isn't <code>φ.X</code>.</p>",
        "id": 510044933,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717948
    },
    {
        "content": "<p>That example is expected, since it unfolds <code>triv</code> to get <code>Unit</code></p>",
        "id": 510045039,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743717988
    },
    {
        "content": "<p>Oh I see, ok</p>",
        "id": 510045071,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718007
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fooLemma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">triv</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">fooLemma</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>\n<p>fails as expected</p>",
        "id": 510045178,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718077
    },
    {
        "content": "<p>because <code>triv x</code> and <code>triv φ.x</code> fail to unify</p>",
        "id": 510045255,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718108
    },
    {
        "content": "<p>Anyway I don't think I have any remaining deep questions. I'm satisfied enough that if I truly want an unqualified name abbreviation I can do<br>\n<code>let X := φ.X</code></p>\n<p>The only thing that I would add my enthusiastic signature to is a PR that would desugar something like <code>let_proj &lt; a, b, c, d, etc. &gt; := p</code> to a sequence of <code>let a := p.a</code> etc.</p>",
        "id": 510045571,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718274
    },
    {
        "content": "<p>But it's not a huge deal</p>",
        "id": 510045584,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718282
    },
    {
        "content": "<p>Thanks for mentioning Agda does it. I found the reference page: <a href=\"https://agda.readthedocs.io/en/stable/language/let-and-where.html#let-binding-record-patterns\">https://agda.readthedocs.io/en/stable/language/let-and-where.html#let-binding-record-patterns</a></p>",
        "id": 510045959,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718504
    },
    {
        "content": "<p>ah so agda's let and record pattern matching lines up with the hypothetical <code>let_proj</code> then, yeah?</p>",
        "id": 510046022,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718548
    },
    {
        "content": "<p>I hasten to add that my motive in all this is not any sort of \"why isn't lean more like agda\" :)</p>",
        "id": 510046113,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718585
    },
    {
        "content": "<p>Yeah. (By the way, you can use <code>{ x, y }</code> as a pattern. It lets you omit fields too, with <code>{x, ..}</code>)</p>",
        "id": 510046141,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718603
    },
    {
        "content": "<p>No that's fine, having a behavior that appears in Agda could make it easier to get something like this done.</p>",
        "id": 510046236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718666
    },
    {
        "content": "<p>yeah</p>",
        "id": 510046247,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718675
    },
    {
        "content": "<p>I definitely need to adapt to some different habits around <code>sorry</code> compared to typed holes in agda also, but I'm sure that'll happen fine with practice...</p>",
        "id": 510046320,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718702
    },
    {
        "content": "<p>One big question I have though is \"in nested patterns, should structure pattern matching also use let bindings?\" Or would <code>let { x, y, .. } := v</code> be a special case?</p>",
        "id": 510046333,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718713
    },
    {
        "content": "<p>Yeah, that's a good question, and why I make statements about how I would probably be supportive of such a PR, and not the person racing to make it at this time. There are probably some fiddly decision decisions to be made.</p>",
        "id": 510046389,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718751
    },
    {
        "content": "<p>Although agda clearly does something, so perhaps that could be imitated. At least if one were to introduce another syntax, it wouldn't do any harm to the familiar-to-the-lean-community behavior of the old.</p>",
        "id": 510046446,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718785
    },
    {
        "content": "<p>Come to think of it, do you reckon <code>let_proj</code> could simply be authored as a macro without delving very deep into the lean library or internals?</p>",
        "id": 510046538,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718827
    },
    {
        "content": "<p>A difference here is that it seems that Agda doesn't have arbitrary pattern matching for <code>let</code> bindings, there's just this special case.</p>",
        "id": 510046573,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718850
    },
    {
        "content": "<p>that strikes me as likely based on how much lean's extensibility has been advertised to me</p>",
        "id": 510046579,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718854
    },
    {
        "content": "<p>ohhh so my \"Agda does <em>something</em> here\" is false, actually, got it</p>",
        "id": 510046609,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718872
    },
    {
        "content": "<p>By the way, there are \"hole actions\" in Lean:</p>\n<p><a href=\"/user_uploads/3121/oiPjFEJWGs92qqJjpBbPs3N-/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/oiPjFEJWGs92qqJjpBbPs3N-/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"792x274\" src=\"/user_uploads/thumbnail/3121/oiPjFEJWGs92qqJjpBbPs3N-/image.png/840x560.webp\"></a></div><p>This also appears to be enabled with <code>sorry</code>. This is from the Batteries library I believe.</p>",
        "id": 510046629,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743718891
    },
    {
        "content": "<p><del>I don't know if that's accessible to me from emacs lsp. It might be? Or I might be feeling the seductive gravitational pull of vscode...</del></p>\n<p>Ah, yup, it's exposed even in my lsp client. <code>lsp-execute-code-action</code>. Nice.</p>",
        "id": 510046726,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743718926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"662452\">jcreed</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Understanding.20definitional.20equality.20for.20pattern.20matching/near/510046538\">said</a>:</p>\n<blockquote>\n<p>Come to think of it, do you reckon <code>let_proj</code> could simply be authored as a macro without delving very deep into the lean library or internals?</p>\n</blockquote>\n<p>Oh yeah, it's definitely something that a user could write. (It might not be possible to integrate with <code>do</code> notation though.) It takes some internals understanding, unless you do a simple macro that trusts what the user writes.</p>",
        "id": 510046836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743719010
    },
    {
        "content": "<p>I'm an emacs user for everything but Lean</p>",
        "id": 510046859,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743719030
    },
    {
        "content": "<p>I'm trying to decide whether to be an emacs user for everything but Lean, or an emacs user full stop :)</p>\n<p>My erstwhile colleague Sean McLaughlin in the AWS formal methods group I found out is just like you --- went with vscode just for Lean</p>",
        "id": 510046980,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719089
    },
    {
        "content": "<p>I can't deny the appeal of using the most robustly supported option</p>",
        "id": 510047049,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719130
    },
    {
        "content": "<p>(FWIW I'm the same, although my motivations for VS Code for Lean were that I was interested in teaching Lean and I didn't want to force emacs onto the undergrads so I figured I should learn what 99% of them were going to be using)</p>",
        "id": 510047588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743719423
    },
    {
        "content": "<p>Yeah, that motivation makes a ton of sense</p>",
        "id": 510047616,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719444
    },
    {
        "content": "<p>At one point in a former job I even wrote a vscode plugin (to replace an eclipse plugin that new customers weren't stoked about) because it was where the audience was</p>",
        "id": 510047667,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719478
    },
    {
        "content": "<p>I am happy to be pragmatic, especially when the win is meeting other people in a place where they'll be happier</p>",
        "id": 510047694,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719499
    },
    {
        "content": "<p>I should point out that there is a small but active emacs user community here, you'll find them in <a class=\"stream\" data-stream-id=\"468104\" href=\"/#narrow/channel/468104-Emacs\">#Emacs</a> if you have questions</p>",
        "id": 510047814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1743719566
    },
    {
        "content": "<p>Indeed, I already saw that and am excited that they have a fix for the unicode hiccups that I've been experiencing</p>",
        "id": 510047855,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719588
    },
    {
        "content": "<p>Here you go, a simple macro that does absolutely no consistency checking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">syntax</span><span class=\"w\"> </span><span class=\"s2\">\"let_proj \"</span><span class=\"w\"> </span><span class=\"s2\">\"⟨\"</span><span class=\"w\"> </span><span class=\"n\">ident</span><span class=\"o\">,</span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"s2\">\"⟩ \"</span><span class=\"w\"> </span><span class=\"s2\">\":= \"</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"n\">optSemicolon</span><span class=\"o\">(</span><span class=\"n\">term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">term</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">macro_rules</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">let_proj</span><span class=\"w\"> </span><span class=\"bp\">⟨$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">fields</span><span class=\"o\">],</span><span class=\"bp\">*⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">fields</span><span class=\"bp\">.</span><span class=\"n\">foldrM</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">body</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">body</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">field</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.$</span><span class=\"n\">field</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">v</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">body</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Pair</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\"> </span><span class=\"n\">let_proj</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">φ</span>\n<span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"bp\">.</span><span class=\"n\">unit</span>\n</code></pre></div>",
        "id": 510047866,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743719595
    },
    {
        "content": "<p>It lets you write <code>let_proj ⟨ x ⟩ := φ</code> to get just one field.</p>",
        "id": 510047896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1743719616
    },
    {
        "content": "<p>Cool, thanks! That may prove useful for me as a nice small example of <code>macro_rules</code> in case I want to play around with that later too</p>",
        "id": 510047913,
        "sender_full_name": "Jason Reed",
        "timestamp": 1743719627
    }
]