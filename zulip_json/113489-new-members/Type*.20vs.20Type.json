[
    {
        "content": "<p>For \"ordinary mathematics\", is there any reason to use <code>Type*</code> rather than just <code>Type</code>?</p>\n<p>The reason I ask this question is this:  In my automata theory project, I had made an automaton's alphabet type and state type to be <code>Type*</code>.  This works fine in almost all situations.  But sometimes I get obscure type universe errors which I don't really understand.  My intuition is that automata are very concrete mathematical objects and <code>Type</code> is surely \"big enough\" to accommodate any alphabet and state types one will ever use.  So the generality of <code>Type*</code> is unnecessary.  Is my understanding correct?</p>",
        "id": 534323228,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755131373
    },
    {
        "content": "<p>I assume you mean <code>Type</code> not <code>TYPE</code>?</p>",
        "id": 534323479,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755131609
    },
    {
        "content": "<p>This topic was moved here from <a href=\"#narrow/channel/113489-new-members/topic/TYPE*.20vs.20TYPE\">#new members &gt; TYPE&#42; vs TYPE</a> by <span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span>.</p>",
        "id": 534323761,
        "sender_full_name": "Notification Bot",
        "timestamp": 1755131867
    },
    {
        "content": "<p>Sorry for the typos!  I've fixed them.</p>",
        "id": 534323837,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755131935
    },
    {
        "content": "<p>you can't (provably) fit the ordinals into <code>Type</code></p>",
        "id": 534324084,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755132122
    },
    {
        "content": "<p>I don't need ordinals.  The only \"ordinals\" I need to deal with are natural numbers.</p>",
        "id": 534324306,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755132337
    },
    {
        "content": "<blockquote>\n<p>But sometimes I get obscure type universe errors which I don't really understand</p>\n</blockquote>\n<p>If your goal is to just make these go away, you might find that replacing <code>Type*</code> with <code>Type _</code> in the cases where this occurs helps.</p>",
        "id": 534324365,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755132394
    },
    {
        "content": "<p>But I think it would be clearer with an example</p>",
        "id": 534324378,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755132405
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/113489-new-members/topic/Type*.20vs.20Type/near/534323228\">said</a>:</p>\n<blockquote>\n<p><code>Type</code> is surely \"big enough\" to accommodate any [...] state types one will ever use.</p>\n</blockquote>\n<p>if you implement a virtual function table pattern (what C++ does with vtables) using typeclasses, you can easily end up in <code>Type 1</code></p>",
        "id": 534324480,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755132506
    },
    {
        "content": "<p>The following is an example.  The definition of <code>RegLang</code> triggers a universe error.  Currently I deal with this problem by making both <code>A</code> and <code>M.State</code> to be <code>Type</code>, as in the definition of <code>RegLang'</code>.  Definitions like <code>RegLang</code> are located toward the top of the dependency hierarchy of my theory., so there are many other definitions and theorems in which the alphabet and states are  still <code>Type*</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Function</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Filter</span>\n\n<span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span>\n<span class=\"w\">  </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n<span class=\"w\">  </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">State</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A finite run of an automaton.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"bp\">.</span><span class=\"n\">FinRun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- The acceptance condition for finite runs.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"bp\">.</span><span class=\"n\">FinAccept</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">FinRun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n\n<span class=\"sd\">/-- The language accepted by an automaton.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"bp\">.</span><span class=\"n\">AcceptedLang</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">al</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">FinAccept</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">al</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">ofFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- A language is regular iff it is accepted by a finite-state automaton.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RegLang</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">AcceptedLang</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">A'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RegLang'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Automaton</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">A'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">AcceptedLang</span><span class=\"w\"> </span><span class=\"n\">acc</span>\n</code></pre></div>",
        "id": 534325342,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755133228
    },
    {
        "content": "<p>why are you bundling the state</p>",
        "id": 534325627,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133477
    },
    {
        "content": "<p>ok so what category theory does to solve this issue is it makes the universes explicit</p>",
        "id": 534325661,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133501
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Category#doc\">docs#CategoryTheory.Category</a></p>\n<blockquote>\n<p>The typeclass <code>Category C</code> describes morphisms associated to objects of type <code>C</code>. The universe levels of the objects and morphisms are unconstrained, and will often need to be specified explicitly, as <code>Category.{v} C</code>. (See also <code>LargeCategory</code> and <code>SmallCategory</code>.)</p>\n</blockquote>",
        "id": 534325761,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133562
    },
    {
        "content": "<p>We discussed this before.  I want to define various constructions on automata  (such as products and sums) and it is convenient for the state to be bundled.</p>",
        "id": 534325775,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755133567
    },
    {
        "content": "<p>so what you're doing here is similar I think</p>",
        "id": 534325886,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133635
    },
    {
        "content": "<p>you have an alphabet instead of objects and you have a type of states instead of morphisms but it's the same thing with the universes</p>",
        "id": 534325945,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133682
    },
    {
        "content": "<p>The category theory solution seems a gross overkill for my purpose.  In many parts of automata theory we need to assume that the state space is finite.  (The definition of a regular language is one such example.). Surely <code>Type</code> is big enough for us to discuss any finite sets?</p>",
        "id": 534326047,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755133772
    },
    {
        "content": "<p><code>Type</code> is indeed good enough for finite things</p>",
        "id": 534326099,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133815
    },
    {
        "content": "<p>I was a bit surprised when I saw that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat#doc\">docs#FintypeCat</a> is universe polymorphic</p>",
        "id": 534326146,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133850
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=FintypeCat.Skeleton#doc\">docs#FintypeCat.Skeleton</a> is <em>also</em> universe polymorphic</p>",
        "id": 534326182,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133882
    },
    {
        "content": "<p>when you're stating stuff like <code>RegLang</code> you should probably specialize the universe inside the definition</p>",
        "id": 534326224,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133917
    },
    {
        "content": "<p>but the characterizing theorem should be universe polymorphic</p>",
        "id": 534326241,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133930
    },
    {
        "content": "<p>and you should still take in <code>{A : Type*}</code> in the definition</p>",
        "id": 534326258,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755133945
    },
    {
        "content": "<p>What universe the alphabet belongs to is immaterial.  If an automaton has only finitely many states, it can \"distinguish\" between only a finite number of subsets of the alphabet anyway.</p>",
        "id": 534326426,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755134086
    },
    {
        "content": "<p>that may be true, but it's so much work to prove</p>",
        "id": 534326772,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755134363
    },
    {
        "content": "<p>I had to prove something similar recently and it was like 200 lines</p>",
        "id": 534326800,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755134395
    },
    {
        "content": "<p>this was because <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QPF.Cofix.corec#doc\">docs#QPF.Cofix.corec</a> was not sufficiently universe polymorphic for my needs</p>",
        "id": 534326848,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755134436
    },
    {
        "content": "<p>in contrast, it is trivial to pass from a universe-polymorphic version to a monomorphic version</p>",
        "id": 534327149,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755134695
    },
    {
        "content": "<p>Why do I want to deal with universes when I know I don't need them?</p>",
        "id": 534327415,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1755134949
    },
    {
        "content": "<p>maybe you actually won't need them</p>",
        "id": 534327507,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755135025
    },
    {
        "content": "<p>but maybe you will need them, and maybe it will be convenient to have them, and maybe someone else using your work will need them</p>",
        "id": 534327591,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1755135056
    }
]