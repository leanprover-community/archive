[
    {
        "content": "<p>I noticed that many logic proofs from <em>The Mechanics Of Proof</em> (paragraph 5) can be written using some combinations of <code>intro-exact</code> or  <code>intro-obtain-exact</code> (some with certain <code>rw</code>s in them).<br>\nDoes there exist any tactic that targets such proofs (it'd essentially follow a certain process, and try certain lines)?</p>",
        "id": 483757696,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732212021
    },
    {
        "content": "<p>I'm not necessarily aware of any tactic that lets you <code>rw</code> with a claim without <code>intro</code>ing it. If you are interested in tactics that operate purely on logical applications, there are things like <code>tauto</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 483805942,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1732230708
    },
    {
        "content": "<p><code>Tauto</code> is exactly what I needed. Thank you!</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>With tauto</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\nimport Lean\n\nexample (P : α → β → Prop) : (∀ x y, P x y) ↔ ∀ y x, P x y := by\n  tauto\n\nexample (P : α → Prop) (Q : Prop) : ((∃ x, P x) ∧ Q) ↔ ∃ x, (P x ∧ Q) := by\n  tauto\n</code></pre></div>\n</div></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Without tauto</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>import Mathlib\nimport Lean\n\nexample (P : α → β → Prop) : (∀ x y, P x y) ↔ ∀ y x, P x y := by\n  constructor\n  · intro h\n    intro y x\n    exact h x y\n  · intro h\n    intro x y\n    exact h y x\n\nexample (P : α → Prop) (Q : Prop) : ((∃ x, P x) ∧ Q) ↔ ∃ x, (P x ∧ Q) := by\n  constructor\n  · intro h\n    obtain ⟨⟨x, hx⟩, hq⟩ := h\n    exact ⟨x, ⟨hx, hq⟩⟩\n  · intro h\n    obtain ⟨x, ⟨hx, hq⟩⟩ := h\n    exact ⟨⟨x, hx⟩, hq⟩\n</code></pre></div>\n</div></div>",
        "id": 483840569,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732253883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> has marked this topic as resolved.</p>",
        "id": 483840578,
        "sender_full_name": "Notification Bot",
        "timestamp": 1732253890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483805942\">said</a>:</p>\n<blockquote>\n<p>I'm not necessarily aware of any tactic that lets you <code>rw</code> with a claim without <code>intro</code>ing it.</p>\n</blockquote>\n<p><code>simp +contextual</code> is one such tactic <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 483885658,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732273145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483885658\">schrieb</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"282271\">Bolton Bailey</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483805942\">said</a>:</p>\n<blockquote>\n<p>I'm not necessarily aware of any tactic that lets you <code>rw</code> with a claim without <code>intro</code>ing it.</p>\n</blockquote>\n<p><code>simp +contextual</code> is one such tactic <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>Very insightful.<br>\nSo in this case <code>simp</code> would internally use <code>rw</code>s? And automatically uses  lemmas and hypotheses in the context (what we can see in the debugger window)?<br>\nSo whenever developing something bigger, I should mark lemmas with <code>@[simp]</code>?</p>",
        "id": 483892088,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732275528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483892088\">said</a>:</p>\n<blockquote>\n<p>in this case <code>simp</code> would internally use <code>rw</code>s?</p>\n</blockquote>\n<p>No, <code>simp</code> has a very different algorithm to <code>rw</code></p>\n<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483892088\">said</a>:</p>\n<blockquote>\n<p>automatically uses lemmas and hypotheses in the context</p>\n</blockquote>\n<p>Yes, exactly</p>\n<p><span class=\"user-mention silent\" data-user-id=\"672170\">Michael Bucko</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Intro-exact.2C.20intro-obtain-exact/near/483892088\">said</a>:</p>\n<blockquote>\n<p>whenever developing something bigger, I should mark lemmas with <code>@[simp]</code>?</p>\n</blockquote>\n<p>Yes!</p>",
        "id": 483892326,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1732275608
    },
    {
        "content": "<p>Since we're using the term <code>rewrites</code> in the context of <code>rw</code> and <code>simp</code>, and apparently the algorithms are different, do there exist ways of using lower-level instructions (on the algorithm level)?</p>\n<p>Also, does there exist a tree of dependencies on the tactic level? Sth like this (might be very wrong here)</p>\n<ul>\n<li><code>simp</code> → <code>rw</code>, <code>dsimp</code>, <code>norm_num</code></li>\n<li><code>rw</code> → <code>subst</code></li>\n<li><code>apply</code> → <code>intro</code>, <code>assumption</code></li>\n<li><code>induction</code> → <code>cases</code>, <code>intro</code></li>\n<li><code>constructor</code> → <code>apply</code>, <code>intro</code></li>\n</ul>",
        "id": 483893346,
        "sender_full_name": "Michael Bucko",
        "timestamp": 1732275978
    },
    {
        "content": "<p>At a high level, I might say the layers are \"tactics\", \"term elaboration\", and \"meta\", going down in abstraction. Most tactics use these two lower layers rather than calling each other. Most tactics have a \"tactic tactic\" (the frontend) and a \"meta tactic\" (the backend). In the Lean source, this is <code>Lean.Elab.Tactic</code> vs <code>Lean.Meta.Tactic</code>.</p>\n<p>For example, simp has some frontends that call the core simp algorithm. There are lots of tactics that use this core simp algorithm. <code>norm_num</code> is one. The <code>dsimp</code> tactic is another. (Maybe more precisely, the core simp algorithm has a core dsimp algorithm as well that it calls.)</p>\n<p><code>rw</code> uses its own algorithm and it is unrelated to <code>simp</code>. <code>subst</code> is also fairly unrelated, and it is closer to <code>cases</code>.</p>\n<p><code>induction</code> and <code>cases</code> are similar, and they share a number of internal parts, but neither strictly calls the other.</p>\n<p><code>apply</code> has no relation to <code>intro</code> or <code>assumption</code>, neither in the code nor logically speaking. <code>apply f</code> is more like <code>refine</code>, but it figures out how many <code>?_</code>'s to apply.</p>\n<p><code>constructor</code> is like <code>apply</code> in spirit, but it doesn't need this <code>?_</code> inference. It uses its own meta code.</p>",
        "id": 484017487,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1732324440
    }
]