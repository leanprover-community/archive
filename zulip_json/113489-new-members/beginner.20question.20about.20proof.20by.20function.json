[
    {
        "content": "<p>I am trying to learn about \"dependent type theory\" and ideas like \"functions as proof\".</p>\n<p>I was watching this computerphile video: \"Propositions as Types\" <a href=\"https://www.youtube.com/watch?v=SknxggwRPzU\">https://www.youtube.com/watch?v=SknxggwRPzU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"SknxggwRPzU\" href=\"https://www.youtube.com/watch?v=SknxggwRPzU\"><img src=\"https://uploads.zulipusercontent.net/044a01057d48d713eebc1b26dcac70b99003bc2e/68747470733a2f2f692e7974696d672e636f6d2f76692f536b6e7867677752507a552f64656661756c742e6a7067\"></a></div><p>A key point made is that a computer can't complete a proof of \"for all natural numbers <code>n</code> a property <code>P(n)</code> holds\" simply by verifying it for 0, 1, 2, 3, .. and so on.</p>\n<p>So that motivates another kind of proof.</p>\n<p>This is the point where I am less certain. </p>\n<p>I think the idea is that :</p>\n<ul>\n<li><code>n</code> is of type <code>ℕ</code> and the proposition <code>P(n)</code> is of type <code>Prop</code>.</li>\n<li>We need to show that if an object has type <code>ℕ</code> then there exists a function that maps it to an object of type <code>P(n)</code></li>\n<li>Because this is \"there exists\" any function will do, as long as it is indeed <code>ℕ → Prop(n)</code>.</li>\n</ul>\n<p>Is this correct? Is funding such a function sufficient? It seems \"too good to be true\". </p>\n<p>I guess my uncertainty arises from the fact that from a set theory perspective, proving equality of sets usually means showing both directions <code>x∈A → f(x)∈B</code> and <code>y∈B → f{^-1}x∈A</code>.  </p>\n<p>Could there be be elements of <code>P(n)</code> that aren't in <code>ℕ</code>?</p>",
        "id": 493917761,
        "sender_full_name": "rzeta0",
        "timestamp": 1736945093
    },
    {
        "content": "<p>As you say, <code>n : ℕ</code> gives you <code>P(n):Prop</code>. This means we have <code>P : ℕ -&gt; Prop</code>, meaning that <code>n</code> <em>has to be of type <code>ℕ</code></em> or else <code>P(n)</code> doesn't type check!</p>",
        "id": 493930448,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736948791
    },
    {
        "content": "<blockquote>\n<p>We need to show that if an object has type ℕ then there exists a function that maps it to an object of type P(n) </p>\n</blockquote>\n<p>This is a bit verbose of a way to say it, you could just say \"We need to show there exists a function that maps it to an object of type P(n)</p>\n<blockquote>\n<p>Because this is \"there exists\" any function will do, as long as it is indeed <code>ℕ → Prop(n)</code>.</p>\n</blockquote>\n<p>Yes. By way of analogy, there are many <a href=\"https://www.cut-the-knot.org/pythagoras/index.shtml\">different proofs of the Pythagorean theorem</a>, but you only need one.</p>\n<blockquote>\n<p>Could there be be elements of <code>P(n)</code> that aren't in <code>ℕ</code>?</p>\n</blockquote>\n<p>Well, the elements of <code>P(n)</code> are elements of <code>P(n)</code>, <del>I'm not sure why you would think they would be in <code>ℕ</code>.</del> If you mean are there arguments to <code>P</code> that aren't in <code>ℕ</code>, then Edward is right, the answer is no.</p>",
        "id": 493931582,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736949108
    },
    {
        "content": "<p>btw, i feel there is an important distinction between <code>ℕ → P(n)</code> and <code>(n : ℕ) → P(n)</code></p>",
        "id": 493932793,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736949440
    },
    {
        "content": "<p>strictly speaking, the proof that for all <code>n</code>, <code>P(n)</code> is true has type <code>(n : ℕ) → P(n)</code></p>",
        "id": 493933015,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736949496
    },
    {
        "content": "<p>Thanks both. </p>\n<p>Edward - yes I can see the distinction, thanks.</p>\n<p>Bolton - thanks for clarifying. This is all new and unfamiliar so it will take some time to sink in.</p>\n<p>What I think will help is a \"plain English\" of a \"proof by function\" - and I can't seem to think of one.</p>\n<hr>\n<p>Here is me thinking aloud:</p>\n<ul>\n<li>Task: prove that <code>1 + 2 + 3 + ... k</code> is <code>k * (k+1)/2</code>, where <code>k</code> is a natural number.</li>\n<li>A few days ago I would have done this by induction or algebra.</li>\n<li>Now I need to find a function that maps from something to something. What is the <strong>domain</strong> and <strong>range</strong> of this <strong>function</strong>?</li>\n<li>Since I want to prove \"for all natural numbers k\" I guess the domain of that function must be <code>(k:ℕ)</code>, as Edward clarified above.</li>\n<li>Actually I think the previous line is <strong>wrong</strong>. We need to prove for all expressions of the form \"1 + 2 + .. + k\". So the domain is the set of expressions of the form \"1 + 2 + .. + k\". This happens to match 1-2-1 to all natural numbers <code>k</code>.</li>\n<li>The range is the set of expressions of the form \"k*(k+1)/2\". </li>\n<li>\n<p>So what does such a function look like? It takes, for example an input \"1+2\" and outputs \"2*(2+1)/2\".</p>\n</li>\n<li>\n<p>Here is a python example of such a function : </p>\n</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">expression</span><span class=\"p\">):</span>\n    <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">expression</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">:]</span>\n    <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">k</span><span class=\"o\">+</span><span class=\"s2\">\"*(\"</span><span class=\"o\">+</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"s2\">\"+1)/2\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">out</span>\n</code></pre></div>\n<p>This takes an input <code>1+2</code> and returns <code>2*(2+1)/2</code>, or an input <code>1+2+3</code> to <code>3*(3+1)/2</code>, and so on.</p>\n<p>However this function is not a proof. It is just string manipulation. </p>\n<p>So I'm clearly missing something important - help?!</p>",
        "id": 493977565,
        "sender_full_name": "rzeta0",
        "timestamp": 1736961278
    },
    {
        "content": "<p>This <code>k*(k+1)/2</code> example is tricky because the usual proof is by induction, and it is hard to wrap your mind around the idea that you are constructing a function that produces a proof of equality, but no actual data. </p>\n<p>The example that helps me when thinking about propositions as types is <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Nat/Prime/Infinite.html#Nat.exists_infinite_primes\">\"there are infinitely many primes\"</a>. In various Lean tutorials and in mathlib, this proposition is written as </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">exists_infinite_primes</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Prime</span><span class=\"w\"> </span><span class=\"n\">p</span>\n</code></pre></div>\n<p>If you read this closely, you see that what this is saying more precisely is \"for all natural numbers n, there exists a p such that p  is at least n and p is prime\".</p>\n<p>So what does a proof of this fact look like? In the proposition-as-types philosophy, it is a function that takes a natural number n and returns another natural number p. (Technically, it also returns other things like a proof that p &gt;= n and a proof that p is prime, but if that is confusing, I would ignore it temporarily until you understand the function between the naturals)</p>",
        "id": 493987736,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736964491
    },
    {
        "content": "<p>What concretely is this function that takes a natural n and returns a prime greater than n? To find out you have to look at the proof. The answer is:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Spoiler</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>It's the function which takes input n and computes the minimum prime factor of n! + 1</p>\n</div></div>",
        "id": 493990020,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736965296
    },
    {
        "content": "<p>If lean were not finicky, you would actually be able to evaluate this by doing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_infinite_primes</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n</code></pre></div>\n<p>To get 11. Alas, the creators of Lean have no sense of adventure.</p>",
        "id": 493990375,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736965419
    },
    {
        "content": "<p>Once you understand this, you can go deeper. You realize that <code>n ≤ p</code> is defined as \"there exists a natural a such that <code>n + a = p</code>\". So actually, the return type of <code>Nat.exists_infinite_primes</code> contains two naturals hidden within it.</p>",
        "id": 493990981,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736965637
    },
    {
        "content": "<p>But the confusing part is maybe \"what is the type of proofs of <code>n + a = p</code>\"? At this point, we are sort of at the primitive base of type theory. I'm not sure there's a better explanation than to say that for any x and y, if x really does equal y, we pretend that there is a set containing one element which is \"the definitive proof that x equals y\", and the set containing this one element is \"the set of proofs that x = y\", which is what we write in Lean/Type theory as simply <code>x = y</code>. If x isn't really equal to y, we declare by fiat that  \"the definitive proof that x equals y\" doesn't exist, and that the \"the set of proofs that x = y\" is empty.</p>",
        "id": 493991796,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736965924
    },
    {
        "content": "<p>So to return to your question:</p>\n<blockquote>\n<ul>\n<li>Now I need to find a function that maps from something to something. What is the <strong>domain</strong> and <strong>range</strong> of this <strong>function</strong>?</li>\n<li>Since I want to prove \"for all natural numbers k\" I guess the domain of that function must be <code>(k:ℕ)</code>, as Edward clarified above.</li>\n</ul>\n</blockquote>\n<p>Yes, the domain is the type of natural numbers. The range is funny because it is different depending on what the input is (that's why they call it <em>dependent</em> type theory). But for input <code>k</code>, the range is simply \"the set of proofs that <code>1 + 2 + 3 + ... k =k * (k+1)/2</code>\". This may strike you as talking in circles <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>.</p>\n<p>The range isn't a set of expressions. It's prudent to think that for every value of k, the corresponding range set will have exactly either 0 elements or 1 element.</p>",
        "id": 493992813,
        "sender_full_name": "Bolton Bailey",
        "timestamp": 1736966323
    },
    {
        "content": "<p><a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/How.20does.20one.20actually.20construct.20proofs.20without.20using.20.22by.22.3F\">#new members &gt; How does one actually construct proofs without using \"by\"?</a>  might be of interest</p>",
        "id": 493996786,
        "sender_full_name": "nrs",
        "timestamp": 1736967769
    },
    {
        "content": "<p>A great way to learn how to construct proof terms is to play this game: <a href=\"https://adam.math.hhu.de/#/g/trequetrum/lean4game-logic\">https://adam.math.hhu.de/#/g/trequetrum/lean4game-logic</a></p>",
        "id": 494003426,
        "sender_full_name": "Mitchell Lee",
        "timestamp": 1736970327
    },
    {
        "content": "<p>Thanks again everyone for the replies. I will have to get my head around it slowly and also try the links you suggested.</p>\n<p>I'm also watching YouTube videos to see if someone says a form of words that give me the \"aha\" moment!</p>",
        "id": 494154048,
        "sender_full_name": "rzeta0",
        "timestamp": 1737036204
    },
    {
        "content": "<blockquote>\n<p>However this function is not a proof. It is just string manipulation.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"724904\">@rzeta0</span> In a sense it <em>is</em> a proof... it's a proof that if you have a string, you can produce a string. In other words, it's a proof that the type <code>String</code> is nonempty.</p>\n<p>In fact, you can think of <em>any</em> function as a proof that the return type of the function is nonempty, with the output serving as the witness to this fact.</p>",
        "id": 494596746,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1737256425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/493977565\">said</a>:</p>\n<blockquote>\n<ul>\n<li>A few days ago I would have done this by induction or algebra.</li>\n<li>Now I need to find a function that maps from something to something. What is the <strong>domain</strong> and <strong>range</strong> of this <strong>function</strong>?</li>\n</ul>\n</blockquote>\n<p>These two are not exclusive to each other. The way you'll implement that function will likely be by using induction (also called recursion when using functions). Just like when you compute a Fibonacci number you can use <code>F (n - 1)</code> to get the <code>n-1</code>th Fibonacci number, when doing proofs using functions you can (kinda) use <code>my-theorem (n - 1)</code> to get a proof that the theorem holds for the case <code>n - 1</code>.</p>\n<p>(In practice you won't exactly use <code>my-theorem (n - 1)</code> because <code>n - 1</code> might not be defined, but the idea is similar and will also involve handling the base case where <code>n = 0</code>)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/493977565\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Since I want to prove \"for all natural numbers k\" I guess the domain of that function must be <code>(k:ℕ)</code>, as Edward clarified above.</li>\n<li>Actually I think the previous line is <strong>wrong</strong>. We need to prove for all expressions of the form \"1 + 2 + .. + k\". So the domain is the set of expressions of the form \"1 + 2 + .. + k\". This happens to match 1-2-1 to all natural numbers <code>k</code>.</li>\n</ul>\n</blockquote>\n<p>There isn't much of a difference between the two, because considering all nutural numbers <code>k</code>s  and then the expression <code>1 + 2 + ... + k</code> is equivalent to considering all the expressions in the shape <code>1 + 2 + ... + k</code>, except the former is much easier to state.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/493977565\">said</a>:</p>\n<blockquote>\n<p>So what does such a function look like? It takes, for example an input \"1+2\" and outputs \"2*(2+1)/2\".</p>\n</blockquote>\n<p>This is wrong. The function should not output <code>2 * (2 + 1) / 2</code> but instead a proof that <code>1 + 2</code> is equal to <code>2 * (2 + 1) / 2</code>. This means the return *<em>type</em> should be <code>1 + 2 = 2 * (2 + 1) / 2</code>.</p>",
        "id": 494627316,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1737281579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494596746\">said</a>:</p>\n<blockquote>\n<p>In fact, you can think of <em>any</em> function as a proof that the return type of the function is nonempty, with the output serving as the witness to this fact.</p>\n</blockquote>\n<p>This is zooming into the core of my misunderstanding. I can understand that such a function provides a witness and therefore is useful for a \"there exists ∃\" proof. </p>\n<p>But what kind of functions can support a \"for all ∀\" proof?</p>",
        "id": 494643392,
        "sender_full_name": "rzeta0",
        "timestamp": 1737294630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"728068\">Giacomo Stevanato</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494627316\">said</a>:</p>\n<blockquote>\n<p>This is wrong. The function should not output <code>2 * (2 + 1) / 2</code> but instead a proof that <code>1 + 2</code> is equal to <code>2 * (2 + 1) / 2</code>. This means the return *<em>type</em> should be <code>1 + 2 = 2 * (2 + 1) / 2</code>.</p>\n</blockquote>\n<p>OK - this is again zooming into the core of my misunderstanding. We have found something I didn't understand so will spend some time thinking about this specific point - that the return type must be  A=B, not just B.</p>",
        "id": 494643559,
        "sender_full_name": "rzeta0",
        "timestamp": 1737294800
    },
    {
        "content": "<p>I'm trying to read the overview  paper by P Wadler lots of sources link to (<a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf\">pdf</a>).</p>\n<p>It is a great and generally not too difficult to read paper - except it introduces this topic a bit too quickly for me. Perhaps everyone else \"gets it\" and I just don't.</p>\n<blockquote>\n<p>In 1934, Curry observed a curious fact, relating a theory of func-<br>\ntions to a theory of implication [13]. Every type of a function<br>\n(A →B) could be read as a proposition (A⊃B), and under this<br>\nreading the type of any given function would always correspond to<br>\na provable proposition. Conversely, for every provable proposition<br>\nthere was a function with the corresponding type. Subsequently,<br>\nCurry and Feys [14] extended the correspondence from not merely<br>\ntypes and propositions to also include term and proofs, and to hint<br>\nat the relation between evaluation of terms and simplification of<br>\nproofs.</p>\n</blockquote>",
        "id": 494644054,
        "sender_full_name": "rzeta0",
        "timestamp": 1737295262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/stream/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494643392\">said</a>:</p>\n<blockquote>\n<p>But what kind of functions can support a \"for all ∀\" proof?</p>\n</blockquote>\n<p>A theorem statement with a <code>∀ x</code> is just another way of saying that it is a function that takes an argument <code>x</code></p>",
        "id": 494644473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737295631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494596746\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> In a sense it <em>is</em> a proof... it's a proof that if you have a string, you can produce a string. In other words, it's a proof that the type <code>String</code> is nonempty.</p>\n</blockquote>\n<p>Actually, it is not even that. You can define the identity function on an empty type. (It does prove that if you have a string then you can produce a string, but that in itself does not prove that strings exist)</p>",
        "id": 494652763,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1737301784
    },
    {
        "content": "<p>I would suggest that you read (again?) Chapters 3 and 4 of TPIL.  The ideas are all there, although it may take time to wrap your mind around them.  The key points are:</p>\n<ol>\n<li>If <code>P</code> is a proposition, then it is a type, and an object of type <code>P</code> is a proof of <code>P</code>.  This may seem strange.  You might think it would make more sense to say that for each proposition <code>P</code>, there is a <em>corresponding</em> type of proofs of <code>P</code>.  But it turns out to be convenient to say that <code>P</code> is literally the type of proofs of <code>P</code>.  In particular, it leads to the following simplifications:</li>\n<li>The arrow for implication is literally the same as the arrow for function types.  In other words, if <code>P</code> and <code>Q</code> are propositions, then the implication <code>P → Q</code> is the type of functions from <code>P</code> to <code>Q</code>.  Again, this seems strange, but it is convenient because it means that all rules for using functions apply to implications.  For example, consider the following rule for working with functions: if you have <code>f : α → β</code> and <code>x : α</code>, then <code>x</code> is in the domain of <code>f</code>, so you can apply <code>f</code> to <code>x</code> to get <code>f x</code>, which has type <code>β</code>.  Similarly, if you have <code>h1 : P → Q</code> and <code>h2 : P</code>, then <code>h2</code> is in the domain of <code>h1</code>, so you can apply <code>h1</code> to <code>h2</code>, getting the term <code>h1 h2</code>, which has type <code>Q</code>.  This is the logical rule modus ponens: if you have proofs of <code>P → Q</code> and <code>P</code>, then you can combine them to get a proof of <code>Q</code>.  So there is no need to tell Lean the modus ponens rule; you get it for free by identifying implications with function types.  Also, if you can show how, given a proof of <code>P</code>, to produce a proof of <code>Q</code>, then you are justified in asserting the implication <code>P → Q</code>.  (This is the \"introduction rule\" for <code>→</code>.)   There is no need to tell Lean this; you get it for free, because you can use the <code>fun</code> notation to define a function mapping proofs of <code>P</code> to proofs of <code>Q</code>, and that function will have type <code>P → Q</code>, which means it is a proof of <code>P → Q</code>.</li>\n<li>The universally quantified proposition <code>∀ (x : α), P x</code> is, literally, the function type <code>(x : α) → P x</code>.  Again, this means that there is no need to state the logical rules for dealing with universal quantifiers; you get them for free from the rules for functions.  For example, if you have <code>h : ∀ (x : α), P x</code>, which means <code>h : (x : α) → P x</code>, then if you also have <code>a : α</code>, then <code>a</code> is in the domain of <code>h</code>, so you can apply <code>h</code> to <code>a</code> to get <code>h a</code>, which has type <code>P a</code>.  This is the logical rule of universal instantiation (or universal elimination): if you know <code>∀ (x : α), P x</code>, then you can conclude <code>P a</code>, for any <code>a</code> of type <code>α</code>.  Also, if you can show how, given an arbitrary <code>x</code> of type <code>α</code>, to produce a proof of <code>P x</code>, then you are justified in concluding <code>∀ (x : α), P x</code>.  (This is the introduction rule for the universal quantifier.)  There is no need to define this as a new rule in Lean; you can use <code>fun</code> notation to define a function that, given any <code>x</code> of type <code>α</code>, produces a proof of <code>P x</code>, and that function has type <code>(x : α) → P x</code>, which is the same as <code>∀ (x : α), P x</code>, so it is a proof of <code>∀ (x : α), P x</code>.</li>\n</ol>\n<p>Things didn't have to be done that way in Lean.  Implication and universal quantification could have been defined more like the way the other logical symbols are defined.  But then you'd need logical rules for working with them.  Those rules would say, in effect, that implication and universal quantification work just like function types.  The designers of Lean decided that, if implication and universal quantification were going to work just like function types, then it was simpler to simply define them to be function types.  It takes a little getting used to, but it is actually quite convenient.</p>",
        "id": 494653758,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1737302516
    },
    {
        "content": "<p>Thanks Dan for taking the time to write out a significant explanation. </p>\n<p>I will print it out and work through it with pen and paper tomorrow.</p>\n<p>(Wadler's paper section 6 finally clarified what introduction and elimination rules are - I think it is very well explained there, if any other beginner is struggling with TPIL's explanation).</p>",
        "id": 494660900,
        "sender_full_name": "rzeta0",
        "timestamp": 1737308001
    },
    {
        "content": "<p>Soon enough you will have better understanding than I do. <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span> </p>\n<p>I just follow my nose, tinkering with Rocq prover (formerly Coq) and now Lean for many years helps. Without much deeper understanding, just \"intuition\".</p>",
        "id": 494662106,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1737308840
    },
    {
        "content": "<p><a href=\"https://www.cambridge.org/core/books/type-theory-and-formal-proof/0472640AAD34E045C7F140B46A57A67C\">https://www.cambridge.org/core/books/type-theory-and-formal-proof/0472640AAD34E045C7F140B46A57A67C</a> is also a resource you may be interested in. It's an introductory book that introduces type theory, develops a pen-and-paper dependent-type formal system, and then actually goes and writes some proofs in it. I read it as I was getting started with Lean and it helped clear up some ideas.</p>",
        "id": 494664215,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1737310400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"726077\">Philippe Duchon</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494652763\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494596746\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> In a sense it <em>is</em> a proof... it's a proof that if you have a string, you can produce a string. In other words, it's a proof that the type <code>String</code> is nonempty.</p>\n</blockquote>\n<p>Actually, it is not even that. You can define the identity function on an empty type. (It does prove that if you have a string then you can produce a string, but that in itself does not prove that strings exist)</p>\n</blockquote>\n<p>Good point, you're right. A function <code>String → String</code> is more like <code>Nonempty.intro</code>: if you give me a value of type <code>String</code>, then I can give you a proof that <code>String</code> is nonempty.</p>",
        "id": 494666874,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1737312552
    },
    {
        "content": "<p>I have now re-read both Dan's reply and Wadler's exposition paper.</p>\n<p>I am happy with almost everything that has been said and have narrowed down my confusion to the following.</p>\n<p>I think the error I was making before was trying to think of examples in my head that used simple objects and not propositions. </p>\n<p>For example, given a proof objective P → Q, I was trying to think of a function that is the proof, and I was imagining P to be something like 3:ℕ and Q to be something like <code>5:ℝ</code>. </p>\n<p>I now understand P and Q need to be propositions, which seem obvious in retrospect. And the function-as-a-proof needs to take a proposition as input, and a proposition as output. In fact a proposition of type P as input and a proposition of type Q as output.</p>\n<p>So here is a better (I hope) example:</p>\n<ul>\n<li>proof objective: \"n is a natural number\" → \"2n is even\"</li>\n<li>this is of the form P → Q</li>\n<li>we need to find a function that maps P → Q</li>\n<li>I had trouble with this if I think about functions like y(x) = x^2 </li>\n<li>I think the solution to this trouble is to think of programs with procedural steps - BUT which also conform to commonly agreed logically valid steps</li>\n<li>so I can now use things like lemmas and logical inferences in my function ... which is unfamiliar when thinking about school functions like y(x)=x^2 .. indeed I can use the introduction and elimination rules we have talked about</li>\n<li>this allows me to take the input \"n is a natural number\" and construct \"2n is a natural number\", we can think of this a a function <code>g1</code></li>\n<li>I can then construct a proposition \"there exists a k natural number such that 2k = 2n\", evidenced by choosing k=n\", which confirms to the definition of \"even\". I can call this step a function <code>g2</code></li>\n<li>so applying <code>g1</code> and then <code>g2</code> (function composition) to the input P gives me the output Q</li>\n<li>and so my function is indeed a function-as-proof</li>\n</ul>\n<p>Have I finally got that right?</p>\n<hr>\n<p>As a thought experiment I'm trying to think what elements (terms) of type \"n is a natural number\" look like. I can't think of any.</p>",
        "id": 494848996,
        "sender_full_name": "rzeta0",
        "timestamp": 1737389516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"724904\">rzeta0</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494848996\">said</a>:</p>\n<blockquote>\n<p>And the function-as-a-proof needs to take a proposition as input, and a proposition as output.</p>\n</blockquote>\n<p>One small correction: it takes a <em>proof</em> of a proposition as input, and gives a <em>proof</em> of a proposition as output.</p>\n<p>I know that when you see <code>h : P</code> in the tactic state, it is tempting to think that means that <code>h</code> is the proposition <code>P</code>.  But what it really means is that <code>h</code> is a proof of the proposition <code>P</code>.</p>",
        "id": 494852942,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1737390807
    },
    {
        "content": "<p>Another minor bit of pedantry is that \"n is a natural number\" is not a proposition, nor is <code>n : \\N</code> a proof of a proposition, so strictly speaking you might instead think of \"n, a natural number, with no other restriction\" or something as your proposition, (or otherwise you have to again widen what you've learned to realize P can be any type and then your example function is correct as-is).</p>",
        "id": 494855529,
        "sender_full_name": "Julian Berman",
        "timestamp": 1737391520
    },
    {
        "content": "<p>Another way to put Julian's point:  Your example \"if n is a natural number then 2n is even\" would probably be written in Lean as <code>∀ (n : ℕ), Even (2 * n)</code>--a universally quantified statement, not an implication.  But it still the case that a proof of this proposition is a function; it takes a natural number <code>n</code> as input, and gives a proof of <code>Even (2 * n)</code> as output.</p>",
        "id": 494858987,
        "sender_full_name": "Dan Velleman",
        "timestamp": 1737392484
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453098\">Dan Velleman</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494852942\">said</a>:</p>\n<blockquote>\n<p>One small correction: it takes a <em>proof</em> of a proposition as input, and gives a <em>proof</em> of a proposition as output.</p>\n<p>I know that when you see <code>h : P</code> in the tactic state, it is tempting to think that means that <code>h</code> is the proposition <code>P</code>.  But what it really means is that <code>h</code> is a proof of the proposition <code>P</code>.</p>\n</blockquote>\n<p>Yeah - I'm still getting used to this :)</p>",
        "id": 494861244,
        "sender_full_name": "rzeta0",
        "timestamp": 1737393207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"761203\">Vlad Tsyrklevich</span> <a href=\"#narrow/channel/113489-new-members/topic/beginner.20question.20about.20proof.20by.20function/near/494664215\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://www.cambridge.org/core/books/type-theory-and-formal-proof/0472640AAD34E045C7F140B46A57A67C\">https://www.cambridge.org/core/books/type-theory-and-formal-proof/0472640AAD34E045C7F140B46A57A67C</a> is also a resource you may be interested in. It's an introductory book that introduces type theory, develops a pen-and-paper dependent-type formal system, and then actually goes and writes some proofs in it. I read it as I was getting started with Lean and it helped clear up some ideas.</p>\n</blockquote>\n<p>I got a copy of this - and I'm only a few pages in, and so far it is really good. </p>\n<p>If there is a list of recommended resources on the lean main website, this should be on there, imho.</p>\n<p>It provides a \"from basics\" explanation of lambda calculus, and works up to the calculus of constructions.</p>\n<p>More than the content itself, it is written (so far) in an easy to read way, and I think it will answer all those questions about \"how does it work\" newcomers to Lean like me have - all in one coherent place.</p>",
        "id": 497206653,
        "sender_full_name": "rzeta0",
        "timestamp": 1738451392
    }
]