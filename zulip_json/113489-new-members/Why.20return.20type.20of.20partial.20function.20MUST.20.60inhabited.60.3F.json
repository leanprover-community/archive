[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ListNode</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">next?</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">none</span>\n\n<span class=\"c1\">-- A meaningless function</span>\n<span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">checkMyList</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">next?</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">nextNode</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">isValid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">checkMyList</span><span class=\"w\"> </span><span class=\"n\">nextNode</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">isValid</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">isValid</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">node</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In the above example, if we don't have <code>deriving Inhabited</code> or:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">ListNode</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">none</span>\n</code></pre></div>\n<p>Then we will get the following error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"n\">definition</span><span class=\"w\"> </span><span class=\"bp\">'</span><span class=\"n\">ListNode</span><span class=\"bp\">.</span><span class=\"n\">checkMyList'</span><span class=\"o\">,</span>\n<span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">inhabited</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">non</span><span class=\"w\"> </span><span class=\"n\">empty</span>\n</code></pre></div>\n<p>I want to know, why must the return type of a <code>partial definition</code> be <code>Inhabited</code> and <code>non empty</code>?</p>",
        "id": 477905312,
        "sender_full_name": "White Chen",
        "timestamp": 1729438921
    },
    {
        "content": "<p>i think this has to do with the soundness of the type system...</p>",
        "id": 477906468,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729439844
    },
    {
        "content": "<p>Indeed, otherwise you could do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 477909102,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729442137
    },
    {
        "content": "<p>That error message is a bit redundant, inhabited and nonempty mean basically the same thing (and what lean actually checks for is <code>Nonempty A</code>, not <code>Inhabited A</code>, so \"inhabited or nonempty\" would be more correct than \"inhabited and nonempty\")</p>",
        "id": 477917435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729450046
    },
    {
        "content": "<p>It would be better if it used the actual lean names <code>Inhabited</code> and <code>Nonempty</code> since that would clue you in to try giving an instance of one of these</p>",
        "id": 477917526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1729450130
    },
    {
        "content": "<p>Is this clear enough?</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to compile partial definition 'checkMyList', could not prove that type is nonempty\n\nPossible solutions:\n- Ensure that there is an 'Inhabited' or 'Nonempty' instance for\n    Bool × ListNode\n- Add such an instance to the parameter list.\n- Add a parameter of this type to the parameter list.\n</code></pre></div>",
        "id": 477918458,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729450941
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5780\">lean4#5780</a></p>",
        "id": 477918890,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729451373
    },
    {
        "content": "<p>What's the difference between those last two points?</p>",
        "id": 477919276,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729451740
    },
    {
        "content": "<p>i guess the difference between <code>[inst]</code> and <code>{inst}</code> or <code>(inst)</code>?</p>",
        "id": 477919363,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729451815
    },
    {
        "content": "<p>or maybe the difference between <code>[inst]</code> and <code>(a:returntype)</code></p>",
        "id": 477919437,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1729451874
    },
    {
        "content": "<p>Yeah, the latter. It makes use of parameters:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>",
        "id": 477919693,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729452064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Do you think it's useful to make that explicit in point 2 and 3? Like so:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to compile partial definition 'checkMyList', could not prove that type is nonempty\n\nPossible solutions:\n- Ensure that there is an 'Inhabited' or 'Nonempty' instance for\n    Bool × ListNode\n- Add an instance `[Nonempty (Bool × ListNode)]` to the parameter list.\n- Add a parameter of type `Bool × ListNode` to the parameter list.\n</code></pre></div>",
        "id": 478050615,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729514662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"690858\">Daniel Weber</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20return.20type.20of.20partial.20function.20MUST.20.60inhabited.60.3F/near/477909102\">said</a>:</p>\n<blockquote>\n<p>Indeed, otherwise you could do</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Could you please clarify this?  As I'm trying to learn this myself, I was under the impression that the example you gave is the reason for requiring totality/termination, rather than a type being inhabited. </p>\n<p>Would you be able to perhaps clarify your example a little more, please?</p>",
        "id": 478368296,
        "sender_full_name": "Tom",
        "timestamp": 1729631717
    },
    {
        "content": "<p>A related question is the following:  The example in FPIL <a href=\"https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html?highlight=inhabi#messages-you-may-meet\">here</a> explains that the return type needs to be inhabited.</p>\n<p>Are there any examples of when one would want to work with types which are <em>not</em> inhabited?  I can see that perhaps I could create an Array of <code>Prop</code>s which may be true or false; however, I can't think of an example when this would be possible/useful to refer to an container of an uninhabited type.</p>",
        "id": 478368899,
        "sender_full_name": "Tom",
        "timestamp": 1729632006
    },
    {
        "content": "<p>If you could define this, then you could prove <code>False</code>: for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Simulates the `partial` if it were to be allowed:</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 478369651,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729632400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> That's a good idea, but I'm worried about it getting out of hand if the expression is big. It also turns out that there's more to the strategies it uses, where saying it's looking for particular instances is misleading. Here's how it looks now:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to compile 'partial' definition 'checkMyList', could not prove that the type\n  ListNode → Bool × ListNode\nis nonempty.\n\nThis process uses multiple strategies:\n- It looks for a parameter that matches the return type.\n- It tries synthesizing 'Inhabited' and 'Nonempty' instances for the return type.\n- It tries unfolding the return type.\n\nIf the return type is defined using the 'structure' or 'inductive' command, you can try\nadding a 'deriving Nonempty' clause to it.\n</code></pre></div>\n<p>(As this message says, I'm throwing in a new feature where it will unfold type synonyms while trying to prove nonemptiness.)</p>",
        "id": 478379765,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729638021
    },
    {
        "content": "<p>This is still a little misleading because it actually looks for <code>Inhabited</code> and <code>Nonempty</code> instances for every suffix of the whole type, so for both <code>Bool × ListNode</code> and <code>ListNode → Bool × ListNode</code> in this case.</p>",
        "id": 478379891,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729638083
    },
    {
        "content": "<p>Maybe error messages can also link to an external reference for people who want full details</p>",
        "id": 478420377,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729664473
    },
    {
        "content": "<p>But this is already a huge improvement</p>",
        "id": 478420396,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1729664490
    },
    {
        "content": "<p>Yeah, looking forward to links!</p>",
        "id": 478420768,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729664697
    },
    {
        "content": "<p>I also think that with some more work, <code>partial</code> could be able to auto-derive an <code>Inhabited</code>/<code>Nonempty</code> instance, making seeing this message even less likely.</p>",
        "id": 478422354,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729665573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/channel/113489-new-members/topic/Why.20return.20type.20of.20partial.20function.20MUST.20.60inhabited.60.3F/near/478369651\">said</a>:</p>\n<blockquote>\n<p>If you could define this, then you could prove <code>False</code>: for example</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Simulates the `partial` if it were to be allowed:</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Hi <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> ,</p>\n<p>Thanks for the reply.  I am sorry but I don't quite get it.  As I'm learning more about Lean and TT, I think I understand that e.g. a non-total/terminating function could lead to the ability to e.g. prove False basically for the reason you demonstrated.  However, to the best of my understanding, <code>partial</code> functions cannot be used in proofs?  So why would it matter if a partial function could prove <code>False</code>?  For example, this is clearly invalid for the above reasons:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>but the example from <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> doesn't</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 478424828,
        "sender_full_name": "Tom",
        "timestamp": 1729666764
    },
    {
        "content": "<p><code>partial</code> can be used in proofs, but you can't prove that they are equal to their definition — from the perspective of proofs they might as well be defined by simply using choice to arbitrarily choose an element of the output type, and that requires <code>Nonempty</code>/<code>Inhabited</code>.</p>",
        "id": 478425137,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729666894
    },
    {
        "content": "<p>There is also <code>unsafe</code>, which can prove <code>False</code>/<code>Empty</code>, and can't be used in proofs at all</p>",
        "id": 478425258,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1729666935
    },
    {
        "content": "<p>@Tom The <code>partial</code> keyword is a way to write this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>\n<p>and automatically do the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">fImpl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">implemented_by</span><span class=\"w\"> </span><span class=\"n\">fImpl</span><span class=\"kd\">]</span>\n<span class=\"kn\">opaque</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n</code></pre></div>\n<p>You can use <code>f</code> in proofs, but it is opaque (meaning it can't be unfolded), and the <code>fImpl</code> implementation is not part of the function's specification.</p>\n<p>The <code>opaque</code> command is like <code>axiom</code>, but it requires that the thing being introduced could exist. This way you're not adding extra assumptions to the system.</p>",
        "id": 478532261,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729699415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"670422\">@White Chen</span> With <a href=\"https://github.com/leanprover/lean4/pull/5821\">lean4#5821</a>, you won't need to prove nonemptiness for your <code>checkMyList</code> function.</p>\n<p>All <code>partial</code> needs to do is prove that the function's type is <code>Inhabited</code> or <code>Nonempty</code>. Certainly <code>ListNode → Bool × ListNode</code> is nonempty, witnessed by <code>fun x =&gt; (default, x)</code>, and it will see this automatically.</p>",
        "id": 478538376,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729701344
    },
    {
        "content": "<p>Wow, thanks <span class=\"user-mention\" data-user-id=\"690858\">@Daniel Weber</span> and <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> - TIL!</p>",
        "id": 478575881,
        "sender_full_name": "Tom",
        "timestamp": 1729714486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Why.20return.20type.20of.20partial.20function.20MUST.20.60inhabited.60.3F/near/478379765\">said</a>:</p>\n<blockquote>\n<p>(As this message says, I'm throwing in a new feature where it will unfold type synonyms while trying to prove nonemptiness.)</p>\n</blockquote>\n<p>I'm not sure if this feature is a good idea, though using it to inform an error message suggesting a missing instance would be</p>",
        "id": 478673637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729762566
    },
    {
        "content": "<p>What is your concern <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>?</p>",
        "id": 478750121,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729785547
    },
    {
        "content": "<p>2 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/channel/113489-new-members/topic/Specifying.20typeclasses.20for.20.27obvious.27.20cases\">#new members &gt; Specifying typeclasses for 'obvious' cases</a> by <span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span>.</p>",
        "id": 478768642,
        "sender_full_name": "Notification Bot",
        "timestamp": 1729791611
    },
    {
        "content": "<p>Mainly a \"principle of least surprise\" aspect, that if typeclass inference doesn't unfold in general (which is a good thing), then it shouldn't do so for <code>partial</code> either</p>",
        "id": 478779775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729796096
    },
    {
        "content": "<p>If you warn/error when this succeeds (as opposed to succeeding silently), then you encourage the user to write the instance that they should have written in the first place</p>",
        "id": 478779818,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1729796120
    },
    {
        "content": "<ul>\n<li>The <code>partial</code> mechanism isn't just looking for an instance. It's basically a tactic that looks for an inhabitant of the function's type by some means.</li>\n<li>In my experience, people are surprised by the fact that <code>partial</code> can't prove a type is nonempty. Figuring out how to write a <code>Nonempty</code> instance for type synonyms with <code>inferInstanceAs</code> is a hurdle that people don't initially know how to do. Plus it's awkard.</li>\n<li>There are a number of users of Lean who are using it for programming. They don't benefit from having to write these instances themselves.</li>\n<li>There is no harm in synthesizing the 'wrong' inhabitant of the type here. It's only used to get the <code>opaque</code> definition to go through.</li>\n<li>I've found that these hand-written <code>Inhabited</code>/<code>Nonempty</code> instances can be <em>very</em> specific to the situation, and you write it as a <code>local instance</code> to not pollute the global instances. It's better to just not have to write them.</li>\n</ul>",
        "id": 478781018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729796550
    },
    {
        "content": "<p>Granted, the <code>inferInstanceAs</code> problem could be addressed with some better automation.</p>",
        "id": 478781142,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1729796607
    }
]