[
    {
        "content": "<p>I am trying to understand how promotion of indices to parameters works precisely, using <code>Eq</code> as an example. It seems to me (based on #print) that these two definitions are the equivalent: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq₁</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq₁</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq₂</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq₂</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>That is, names of arguments are irrelevant. Is this correct?</p>\n<p>Another related question: Is it possible to define an inductive type that is equivalent to <code>Eq</code> while having <code>inductive.autoPromoteIndices false</code>? The following gets quite close, but its <code>refl</code> has two implicit parameters, rather than one implicit and one explicit. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">.</span><span class=\"n\">autoPromoteIndices</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 574800302,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771526930
    },
    {
        "content": "<p><code>  | refl (a) : Eq' a a</code></p>",
        "id": 574809466,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1771530067
    },
    {
        "content": "<p>In case it's useful, just yesterday I merged some additional documentation for auto-promotion of indices: <a href=\"https://github.com/leanprover/lean4/blob/ace52b38f2d6c38fd112c6e903f79c9248fa9710/src/Lean/Elab/MutualInductive.lean#L426\">https://github.com/leanprover/lean4/blob/ace52b38f2d6c38fd112c6e903f79c9248fa9710/src/Lean/Elab/MutualInductive.lean#L426</a></p>",
        "id": 574810007,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771530272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819062\">Lauri Oksanen</span> <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/near/574800302\">said</a>:</p>\n<blockquote>\n<p>That is, names of arguments are irrelevant. Is this correct?</p>\n</blockquote>\n<p>Correct, only the types are relevant, and the order of arguments.</p>",
        "id": 574810175,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771530335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/near/574809466\">said</a>:</p>\n<blockquote>\n<p><code>  | refl (a) : Eq' a a</code></p>\n</blockquote>\n<p>I think this doesn't work unfortunately; parameter binder kind updates are for <code>structure</code> fields. It might be reasonable adding it to <code>inductive</code> constructors too (and the <code>structure</code> constructor if that doesn't already work).</p>",
        "id": 574810613,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771530490
    },
    {
        "content": "<p>One workaround is to define a separate constructor with the correct binder kinds.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">.</span><span class=\"n\">autoPromoteIndices</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"bp\">.</span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 574811014,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771530650
    },
    {
        "content": "<p>Thanks a lot! Right, I tried variations like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">set_option</span><span class=\"w\"> </span><span class=\"kn\">inductive</span><span class=\"bp\">.</span><span class=\"n\">autoPromoteIndices</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq'</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>This doesn't compile (Mismatched inductive type parameter ...). </p>\n<p>If I understand correctly the workaround is sort of swapping the roles of rfl and refl, right?</p>\n<p>My guess at the beginning was that <code>inductive.autoPromoteIndices true</code> is just for convenience, but it seems now that it has some fundamental importance. Is this correct?</p>",
        "id": 574811551,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771530878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819062\">Lauri Oksanen</span> <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/near/574811551\">said</a>:</p>\n<blockquote>\n<p>If I understand correctly the workaround is sort of swapping the roles of rfl and refl, right?</p>\n</blockquote>\n<p>In particular, the workaround is to define a constructor with the binder kinds set up the way you desire them, to override the choices made by <code>inductive</code>. I just chose <code>rfl</code>/<code>refl</code> because those are the names you see for <code>Eq</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"819062\">Lauri Oksanen</span> <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/near/574811551\">said</a>:</p>\n<blockquote>\n<p>it seems now that it has some fundamental importance. Is this correct?</p>\n</blockquote>\n<p>No, it's for convenience. The fact that you can set the binder kinds for parameters in the constructors by taking advantage of <code>inductive.autoPromoteIndices</code> is more of an accidental feature.</p>\n<p>Being able to override binder kinds using the syntax that Aaron was hopeful would work is a likely feature at some point. Deciding whether or not to implement that feature will not take this behavior of <code>inductive.autoPromoteIndices</code> into consideration. (What I mean is, relying on index autopromotion isn't intended to be the way you control implicitness/explicitness.)</p>",
        "id": 574815055,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771532376
    },
    {
        "content": "<p>Thanks a lot! It could be argued that <code>Eq'</code> is not quite the same as <code>Eq</code> as the constructors play a special role (and also there is an extra definition in its namespace). So are we forced to conclude that <code>Eq</code>, a very fundamental type, relies on an accidental feature? I am writing lecture notes on basics of Lean, and I don't quite know how to explain this.</p>",
        "id": 574817315,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771533341
    },
    {
        "content": "<p>I think it can also be argued that <code>Eq'</code> and <code>Eq</code> are the same, since implicit/explicit annotations are for elaboration purposes.</p>",
        "id": 574817821,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771533528
    },
    {
        "content": "<p>If <code>Eq</code> didn't rely on <code>autoPromoteIndices</code>, you'd probably see <code>Eq.rfl</code> as the constructor and <code>Eq.refl</code> as the theorem.</p>\n<p>I also could be wrong about motivations during early Lean development; I'm speaking from the perspective of someone who thinks Aaron's feature ought to exist. I see that <a href=\"https://github.com/leanprover/lean4/commit/1f4039a25d255eb21a1a00b1ec91f6d4cbf3d845\">Leo in this commit</a> <em>did</em> intentionally use <code>autoPromoteIndices</code>. I don't know if he took advantage of it as a hack, or if this is what <code>autoPromoteIndices</code> is for.</p>",
        "id": 574818484,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771533794
    },
    {
        "content": "<p>I can see in the history that Leo did make a couple of fixes to autoPromoteIndices before removing this <code>{}</code> Lean-3-era constructor feature and then changing <code>Eq</code>. As far as I can tell though, the intent was to remove the <code>{}</code> feature rather than being the intent of autoPromoteIndices itself.</p>",
        "id": 574819071,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"819062\">Lauri Oksanen</span> <a href=\"#narrow/channel/113489-new-members/topic/About.20parameters.2C.20indices.2C.20and.20inductive.2EautoPromoteIndices/near/574817315\">said</a>:</p>\n<blockquote>\n<p>I am writing lecture notes on basics of Lean, and I don't quite know how to explain this.</p>\n</blockquote>\n<p>Perhaps you could talk about a different type? This seems like a quirk that's subject to change rather than something fundamental about Lean.</p>",
        "id": 574819218,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534085
    },
    {
        "content": "<p>Here's an explanation though, without getting into the quirks potential for engineering specific binder kinds: \"For parameters, Lean will make them be implicit for each constructor. When indices are promoted to parameters, Lean won't override the explicit/implicit binders you've already given constructor fields.\"</p>",
        "id": 574819709,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534308
    },
    {
        "content": "<p>It's a good point that <code>Eq'</code> and <code>Eq</code> don't differ from the point of view of the kernel. Perhaps I will just tell the story with <code>refl</code> and <code>rfl</code> swapped. I have been sticking to <code>Nat</code>, <code>Prod</code> and <code>Eq</code> in all my examples. Also I want to explain how equality really works, and reimplementing it illustrates this pretty well. I wouldn't like to explain <code>autoPromoteIndices</code> though.</p>",
        "id": 574820112,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771534502
    },
    {
        "content": "<p>The original motivation for <code>autoPromoteIndices</code> is the <code>autoImplicits</code> feature: <a href=\"https://github.com/leanprover/lean4/commit/4ee131981d7fe5d410ebdd31593c4e889a0d8e3b\">https://github.com/leanprover/lean4/commit/4ee131981d7fe5d410ebdd31593c4e889a0d8e3b</a></p>",
        "id": 574820187,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534530
    },
    {
        "content": "<p>The problem is that if autoimplicits are created after the colon, they might likely be better as parameters.</p>",
        "id": 574820314,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534578
    },
    {
        "content": "<p>This has an impact on universe levels for the inductive type. Any type autoimplicits that remain as indices will need to be constructor fields, which forces the inductive type's universe level to be large enough to accommodate these types.</p>\n<p>If they can be promoted to be parameters, then this universe level constraint goes away.</p>",
        "id": 574820528,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534659
    },
    {
        "content": "<p>This universe consideration does not apply to <code>Eq</code> (nor does it involve any autoimplicits).</p>",
        "id": 574820561,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771534677
    },
    {
        "content": "<p>Here's a way you can work around needing to say anything about autoPromoteIndices itself:</p>\n<ol>\n<li>Everything before the colon in the inductive type header is implicitly added as additional parameters to every constructor</li>\n<li>The <em>parameters</em> of an inductive type consist of the largest prefix of parameters shared by the type constructor and all the constructors. Certainly this includes everything added in 1. When computing this prefix only the types matter (up to definitional equality).</li>\n<li>In the type constructor, everything after the parameters are <em>type indices</em>. In the constructors, everything after the parameters are <em>constructor fields</em>.</li>\n</ol>\n<p>Then autopromotion isn't a special feature. There's nothing inherently special about the colon in an inductive type definition — it's convention that this is where parameters stop and indices begin, without needing to devise new syntax.</p>",
        "id": 574821784,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771535152
    },
    {
        "content": "<p>Pedagogically, I wonder if initially presenting an index-only way to define types makes sense, like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Prod'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prod'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>Then since <code>α</code> and <code>β</code> are the same across all constructors, and line up with the first parameters to <code>Prod'</code>, Lean sees this as being a parameterized family of types. These first two fields aren't \"stored\" by the <code>Prod'.mk</code> constructor, so the universe of <code>Prod'</code> doesn't need to be <code>Type (max (u + 1) (v + 1))</code>. Moving the parameters before the <code>:</code> is a convenience:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Prod'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prod'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n</code></pre></div>\n<p>with the caveat that Lean now chooses binders for these parameters to be implicit for you. An additional convenience is that it gives you the assurance that these parameters won't bump the universe level.</p>\n<p>I know this is all backwards historically when it comes to inductive families, but maybe it's not backwards for presenting it?</p>",
        "id": 574824431,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771536188
    },
    {
        "content": "<p>(I have to admit that with this index-first perspective I'm starting to come around to your idea that autoPromoteIndices is of fundamental importance <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>)</p>",
        "id": 574824972,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771536401
    },
    {
        "content": "<p>I like your idea a lot. In the case of functions, I already framed moving arguments before : as syntactic sugar. </p>\n<p>Here is my draft in the hope that you have time to read it. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c\">/-</span>\n<span class=\"cm\"># Type constructors with arguments</span>\n\n<span class=\"cm\">The encoding of Cartesian product is an example of an inductive type with parameters. It can be</span>\n<span class=\"cm\">defined as follows.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">We view the type constructor `Prod` as a function taking two arguments and having the codomain</span>\n<span class=\"cm\">`Type (max u v)`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Prod</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">The only constructor `Prod.mk` has the type</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">In terms of the types of their arguments, `Prod` and `@Prod.mk` have the common prefix</span>\n<span class=\"cm\">`Type u → Type v`. We can even write</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">  </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Prod</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">The _parameters_ of an inductive type consist of the largest prefix of arguments shared by the type</span>\n<span class=\"cm\">constructor and all the constructors. The remaining arguments of the type constructor are called</span>\n<span class=\"cm\">_indices_, and the remaining arguments of a constructor are called _fields_. `Prod` has the</span>\n<span class=\"cm\">parameters `Type u` and `Type v`, but no indices. The fields of `Prod.mk` are `fst : α` and `snd : β`.</span>\n\n<span class=\"cm\">Earlier we considered the product of ℕ with itself and used the notation `(0, 1)`, which is syntactic</span>\n<span class=\"cm\">sugar for `Prod.mk 0 1`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"c\">/-</span>\n\n<span class=\"cm\">The following syntax is also provided.{margin}[This can not quite be called syntactic sugar, see</span>\n<span class=\"cm\">[promotion of indices][auto-promote-indices] to parameters.]</span>\n\n<span class=\"cm\">[auto-promote-indices]: https://lean-lang.org/doc/reference/latest/The-Type-System/Inductive-Types/#inductive___autoPromoteIndices</span>\n\n<span class=\"cm\">-/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Prod'</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Prod'</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span>\n<span class=\"c\">/-</span>\n\n\n<span class=\"cm\"># Parameters and indices</span>\n\n<span class=\"cm\">{ref \"sec-definitional-equality-naive\"}[Recall] that `a = a` is syntactic sugar for `Eq a a`. `Eq` can</span>\n<span class=\"cm\">be defined as follows.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Demo</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">We view `@Eq` as a function taking three arguments and having the codomain `Prop`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Eq</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">The only constructor `@Eq.refl` has the type</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">The common prefix is `(α : Sort u) → (a : α)`. Hence, `α` and `a` are parameters, while the third</span>\n<span class=\"cm\">argument of `@Eq` is an index. The constructor `@Eq.refl` has no fields.</span>\n\n<span class=\"cm\">The evaluation of the constructor `Eq.refl` at an expression `a` gives `Eq a a`, where the</span>\n<span class=\"cm\">parameter and index of type `α` take the same value `a`. As a result, we can construct terms of</span>\n<span class=\"cm\">type `Eq a a` for any expression `a`, but we cannot construct terms of type `Eq a b` when `a` and</span>\n<span class=\"cm\">`b` are distinct (modulo definitional equality). In this way, `Eq` encodes the equality between</span>\n<span class=\"cm\">expressions.</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 574838328,
        "sender_full_name": "Lauri Oksanen",
        "timestamp": 1771542635
    },
    {
        "content": "<p>(Correction to my earlier messages, which I've updated: I misremembered the logic, and parameters always become implicit in constructors. In any case, <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>'s suggestion for binder updates is now implemented in <a href=\"https://github.com/leanprover/lean4/pull/12603\">lean4#12603</a>)</p>",
        "id": 574880290,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1771572854
    }
]