[
    {
        "content": "<p>Looking at the definition of <code>Iff</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>I realized I don't actually understand what <code>: Prop</code> means before <code>where</code>.</p>\n<p>Here's what I <em>do</em> understand:</p>\n<ul>\n<li>Structures let us group data and proofs (which are, in a way, data too) together</li>\n<li>Proving a proposition means constructing a term of that proposition's type</li>\n<li>So for example having an instance of <code>Iff</code> means we have proofs of <code>mp</code> and <code>mpr</code></li>\n<li>Structures can extend other structures (as a way to avoid copy paste and, in case of multiple inheritance, to work around the diamond problem without adding verbosity)</li>\n</ul>\n<p>What I <em>don't</em> understand here, again, is what <code>: Prop</code> stands for. Is an <code>Iff</code> a proposition on its own, <em>in addition</em> to being a structure? I guess this kind of makes sense because it's a logical statement? And it implies both <code>mp</code> and <code>mpr</code> because otherwise we wouldn't have been able to construct it?</p>\n<p>This is still confusing to me though. Where does this <code>: Prop</code> show up — presumably it's a type, but a type <em>of what?</em> How does it come up when dealing with <code>Iff</code>? What would break if we were to omit <code>: Prop</code> from its definition? What <em>else</em> could it be other than <code>Prop</code>?</p>",
        "id": 504267729,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741434172
    },
    {
        "content": "<p><code>Iff a b</code> is a Proposition, which is a kind of type. <code>Iff</code> is a function <code>Prop -&gt; Prop -&gt; Prop</code>.</p>",
        "id": 504267930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741434330
    },
    {
        "content": "<p>You are just saying  that <code>Iff a b</code> is a <code>Prop</code>.</p>",
        "id": 504267942,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434335
    },
    {
        "content": "<p>Note</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n</code></pre></div>\n<p>They have the same definition, but end up being different things, because they're both \"the empty thing\" but in different type universes.</p>",
        "id": 504268079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741434424
    },
    {
        "content": "<p>Also, if you omit <code>: Prop</code> the result is the same, I think Lean automatically put the smallest possible universe.</p>",
        "id": 504268244,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434569
    },
    {
        "content": "<p>Ok so I see if I remove <code>: Prop</code> from its definition and then do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>then <code>x</code> is a <code>Type</code>, which is presumably a default when defining structures.</p>\n<p>By declaring <code>: Prop</code>, I made that a <code>Prop</code> instead.</p>\n<p>Is that literally all there is to it? What other things could I put there? It doesn't look like, for example, I can put <code>: ℕ</code> into that spot. So is it limited to universes?</p>",
        "id": 504268266,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741434581
    },
    {
        "content": "<p>Mmm, I think <code>x</code> would be a <code>Prop</code> in that case.</p>",
        "id": 504268400,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434666
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"c1\">--Prop</span>\n</code></pre></div>",
        "id": 504268412,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434680
    },
    {
        "content": "<p>Yes, an inductive type (and in particular a structure) must be a sort, so <code>Sort u</code> for a universe <code>u</code>. In practice it can be <code>Prop</code>, <code>Type</code>, <code>Type 1</code>, <code>Type 2</code> and so on.</p>",
        "id": 504268533,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434770
    },
    {
        "content": "<p>Interestingly, this doesn't match what I'm seeing with <code>4.5.0-rc1</code>. </p>\n<p><a href=\"/user_uploads/3121/Xy92cz17u6odk3HqWAAbmd_R/Screenshot-2025-03-08-at-20.52.57.png\">Screenshot 2025-03-08 at 20.52.57.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Xy92cz17u6odk3HqWAAbmd_R/Screenshot-2025-03-08-at-20.52.57.png\" title=\"Screenshot 2025-03-08 at 20.52.57.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1566x564\" src=\"/user_uploads/thumbnail/3121/Xy92cz17u6odk3HqWAAbmd_R/Screenshot-2025-03-08-at-20.52.57.png/840x560.webp\"></a></div>",
        "id": 504268550,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741434787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> has marked this topic as resolved.</p>",
        "id": 504268562,
        "sender_full_name": "Notification Bot",
        "timestamp": 1741434798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"418569\">Dan Abramov</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20How.20to.20think.20about.20.60structure.20X.20.3A.20Y.60/near/504268550\">said</a>:</p>\n<blockquote>\n<p>Interestingly, this doesn't match what I'm seeing with <code>4.5.0-rc1</code>. </p>\n<p><a href=\"/user_uploads/3121/Xy92cz17u6odk3HqWAAbmd_R/Screenshot-2025-03-08-at-20.52.57.png\">Screenshot 2025-03-08 at 20.52.57.png</a></p>\n</blockquote>\n<p>That's weird!</p>",
        "id": 504268580,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741434824
    },
    {
        "content": "<p>For me it is a <code>Prop</code> even on <code>4.5.0-rc1</code>. I don't know, maybe it is because of something else in the file?</p>",
        "id": 504268904,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741435048
    },
    {
        "content": "<p>There was a well-known and long-standing bug (when some structures which should be Props were created as Types) which also existed in Lean 3 and which got fixed at some point which I can believe was under a year ago.</p>",
        "id": 504268909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741435051
    },
    {
        "content": "<p>No, sorry, I had the <code>: Prop</code>.</p>",
        "id": 504268985,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1741435083
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5517\">lean4#5517</a> probably</p>",
        "id": 504269011,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1741435107
    },
    {
        "content": "<p>Ah I see, if I understand this correctly</p>\n<blockquote>\n<p>A <code>Prop</code>-valued inductive type is a syntactic subsingleton if it has at most one constructor and all the arguments to the constructor are in <code>Prop</code>. Such types have large elimination, so they could be defined in <code>Type</code> or <code>Prop</code> without any trouble, though users tend to expect that such types define a <code>Prop</code> and need to learn to insert <code>: Prop</code>.</p>\n</blockquote>\n<p>this seems to be saying that if the constructor only takes some props, there's no reason for the thing it produces to be placed \"higher\" in the universe hierarchy, and it may as well also be a prop?</p>",
        "id": 504269288,
        "sender_full_name": "Dan Abramov",
        "timestamp": 1741435252
    },
    {
        "content": "<p>Right, if mathematically you just mean \"you can have a term of this type if you can prove a bunch of theorems\" then what you have there is a theorem, not a set.</p>",
        "id": 504269678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1741435507
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/lean4/pull/5517\">lean4#5517</a> made it into Lean 4.14 (<a href=\"https://github.com/leanprover/lean4/blob/master/releases/v4.14.0.md\">https://github.com/leanprover/lean4/blob/master/releases/v4.14.0.md</a>)</p>",
        "id": 504299736,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741455352
    },
    {
        "content": "<p>The PR description is informative in theory, but here's a more practical way to describe the situation:</p>\n<p>When you define a structure</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty1</span>\n<span class=\"w\">  </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty2</span>\n</code></pre></div>\n<p>where <code>U</code> is some universe, you need to be able to define projection functions <code>S.f1 (self : S) : Ty1</code> and <code>S.f2 (self : S) : Ty2</code>.</p>\n<p>If <code>U</code> is <code>Type</code> or above, then there's no complication at all. (The kernel defines a <code>S.recOn</code> function with a <code>motive</code> argument that \"eliminates\" into any universe. That's to say, it's easy to define all the projection functions.)</p>\n<p>However, if <code>U</code> is <code>Prop</code>, then the kernel-defined <code>S.recOn</code> will usually only \"eliminate\" into <code>Prop</code>. It's not generally possible to define projection functions unless <code>Ty1 : Prop</code> and <code>Ty2 : Prop</code> as well.</p>\n<p>Or, without reference to recursors, practically it's about whether the rules allow this sort of <code>match</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ty1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"n\">f1</span><span class=\"w\"> </span><span class=\"n\">f2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f1</span>\n</code></pre></div>\n<p>Except in special circumstances, that's not allowed if <code>Ty1 : Type _</code> and <code>S : Prop</code>.</p>\n<p>Before 4.14, when you omit <code>: U</code>, the <code>structure</code> command would find the smallest <code>Type _</code> that would work. After 4.14, it will use <code>Prop</code> if it makes sense to. Still, in no cases will it use <code>Sort _</code> since that makes universe levels more complicated (with <code>imax</code> level expressions). You have to opt in.</p>",
        "id": 504301195,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741456479
    },
    {
        "content": "<p>One more detail: you can think of the <code>structure</code> command as being a nice interface to the <code>inductive</code> command, one that also defines projection functions and that keeps track of which structures have which fields, to support dot notation and <code>extends</code> clauses.</p>\n<p>The command</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"bp\">::</span>\n<span class=\"w\">  </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span>\n</code></pre></div>\n<p>essentially does</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>Though, technically, it does</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">MyIff</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n</code></pre></div>\n<p>which gives the same result but which is slightly different (it's telling Lean that <code>a</code> and <code>b</code> must be \"parameters\" instead of \"indices\").</p>\n<p>It seems like you already get the function of <code>: Prop</code>, but I thought I'd make this connection, so you can see that more strongly that it's part of the type signature for the type constructor <code>MyIff</code>.</p>",
        "id": 504301626,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741456749
    },
    {
        "content": "<p>Just noticed that in type classes one can also append a <code>: Prop</code> like this example in MIL Ch7.2</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">SubmonoidClass₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monoid</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">SetLike</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n</code></pre></div>\n<p>so this conversation was very useful. For type classes presumably it means the instance objects are of type Prop.</p>",
        "id": 504474522,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1741583981
    },
    {
        "content": "<p>Yeah, <code>class</code> basically means <code>@[class] structure</code> (though there are some differences), so <code>: Prop</code> means <code>SubmonoidClass S M</code> is a <code>Prop</code>. Instances are instead proofs. Like always, the instances would be of type <code>SubmonoidClass S M</code>.</p>",
        "id": 504477010,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1741585259
    }
]