[
    {
        "content": "<p>How do I find out where a coercion happens and what it does? For example, Mathlib seems to have a coercion from <code>Nat</code> to <code>Nat -&gt; Bool</code>, which seems to always return true. (There is also one to <code>Bool -&gt; Nat</code>, apparently constant function returning the coerced number).   I tried synthesizing the <code>Coe</code> instances but it didn't work. How can I find out what is happening?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"c1\">-- true for all inputs?</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"o\">(</span><span class=\"n\">Coe</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">))</span>  <span class=\"c1\">-- fails</span>\n<span class=\"bp\">#</span><span class=\"n\">synth</span> <span class=\"o\">(</span><span class=\"n\">CoeFun</span> <span class=\"n\">Nat</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">))</span>  <span class=\"c1\">-- fails</span>\n</code></pre></div>\n<p>I found this after some time debugging why my program crashed when I unfortunately mixed up <code>List.findIdx?</code>and <code>List.indexOf?</code> and assumed it can't be wrong because \"surely that would be a type error\". (I'm still not sure why this crashes but the coercion is at fault)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">argmaxValOfSum</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span>\n    <span class=\"o\">:</span> <span class=\"n\">Option</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n    <span class=\"o\">:=</span>\n        <span class=\"k\">let</span> <span class=\"n\">sums</span> <span class=\"o\">:=</span> <span class=\"n\">l.map</span> <span class=\"n\">List.sum</span>\n        <span class=\"k\">let</span> <span class=\"n\">maximum</span><span class=\"bp\">?</span> <span class=\"o\">:=</span> <span class=\"n\">sums.maximum</span><span class=\"bp\">?</span>\n        <span class=\"k\">match</span> <span class=\"n\">maximum</span><span class=\"bp\">?</span> <span class=\"k\">with</span>\n        <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n        <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">maximum</span> <span class=\"bp\">=&gt;</span>\n            <span class=\"c1\">--dbg_trace \"sums {sums}\"</span>\n            <span class=\"c1\">--dbg_trace \"maximum {maximum}\"</span>\n            <span class=\"k\">let</span> <span class=\"n\">argmax</span> <span class=\"o\">:=</span> <span class=\"n\">sums.findIdx</span><span class=\"bp\">?</span> <span class=\"n\">maximum</span>\n            <span class=\"k\">match</span> <span class=\"n\">argmax</span> <span class=\"k\">with</span>\n            <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">amax</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">amax</span><span class=\"o\">,</span> <span class=\"n\">maximum</span><span class=\"o\">)</span>\n            <span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">none</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">argmaxValOfSum</span>  <span class=\"o\">[[</span><span class=\"mi\">10000</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 400310395,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1699113867
    },
    {
        "content": "<p>Does it return true for <code>0 : ℕ</code>?</p>",
        "id": 400310590,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1699113988
    },
    {
        "content": "<p>When you type <code>(5 : T)</code> whats happening isn't  really a coercion from Nat to <code>T</code>. Instead Lean is looking for an instance <code>OfNat T 5</code>.</p>",
        "id": 400310648,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1699114037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/113489-new-members/topic/Debugging.20coercions/near/400310590\">said</a>:</p>\n<blockquote>\n<p>Does it return true for <code>0 : ℕ</code>?</p>\n</blockquote>\n<p>Indeed, it does not.</p>",
        "id": 400310805,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1699114193
    },
    {
        "content": "<p>Is there a way to \"print whatever conversion is happening\" without having to individually check <code>Coe</code>, <code>CoeFun</code>, <code>OfNat</code>, (maybe a lot more things?!...)?</p>",
        "id": 400310990,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1699114353
    },
    {
        "content": "<p>Sure -- just hover over the <code>5</code> in the infoview.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">5</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">Bool</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 400312562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1699115952
    },
    {
        "content": "<p>That helps a lot, thanks. I never noticed that one can actually chain hover-tooltips in the infoview, i.e., get tooltips for terms in tooltips of tooltips...</p>\n<p>To stay with my example and hopefully provide some content to this thread meriting the title, I tried to find out where this \"conversion\" (what's the most general term for what happens in <code>(x : T)</code>?) is defined:</p>\n<ul>\n<li>write <code>#check (5 : Bool → Nat)</code> and hover over the <code>5</code> in the infoview. This gives <code>@OfNat.ofNat (Bool → ℕ) 5 instOfNat : Bool → ℕ</code>. </li>\n<li>click on<code>instOfNat</code> to see the instance definition. </li>\n<li>It 's <code>instance instOfNat [NatCast R] [Nat.AtLeastTwo n] : OfNat R n := ...</code> where <code>R : Type*</code> </li>\n<li>Now assume (non-automatic step!) that I need <code>NatCast (Bool → ℕ)</code></li>\n<li><code>#synth NatCast (Bool → ℕ)</code> gives <code>instance natCast : NatCast (∀ a, π a) := { natCast := fun n _ ↦ n }</code>, which looks like it will give the constant function <code>_ =&gt; 5</code>.</li>\n</ul>\n<p>Is there a better way to do this? Some kind of stack-trace for what functions are called when doing <code>(5 : Bool → Nat)</code>? I'm not sure this process is guaranteed to give me what I want in all cases (and some of the steps are prone to error if I misunderstand the code I'm reading, although that might be quite a lot harder to address)</p>\n<p>Another question: <strong>can one turn off some rarer implicit conversions?</strong> Type stability is useful for finding errors and implicit conversions (often considered problematic in some other programming languages) make that harder. This is what tripped me up in the \"crash\" example above. Lean wholeheartedly embraces implicit conversions, which probably makes a lot of sense given its aims and applications, but there still might be some tools to manage that.</p>",
        "id": 400313845,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1699117276
    },
    {
        "content": "<p><code>OfNat</code> isn't generally considered to be a conversion -- it's the mechanism that implements how natural number literals are interpreted with respect to a particular type.</p>\n<p>Mathlib's putting an OfNat instance on <code>Bool</code> seems suspect... <code>(0 : Bool)</code> is <code>false</code> and <code>(1 : Bool)</code> is <code>true</code>, but then <code>(2 : Bool)</code> is <code>false</code> again -- it's whether the natural number is odd. It goes against a convention in many programming languages that <code>0</code> represents <code>false</code> and anything non-zero is <code>true</code>.</p>\n<p>If you do <code>fun (n : Nat) =&gt; (n : Bool)</code> then you can see an actual coercion from <code>Nat</code> to <code>Bool</code>. It has the same properties.</p>",
        "id": 400319131,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699123029
    },
    {
        "content": "<p>You can see a trace of all instance problems by setting an option:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.Meta.synthInstance</span> <span class=\"n\">true</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span><span class=\"o\">))</span> <span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 400319171,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699123078
    },
    {
        "content": "<blockquote>\n<p>Lean wholeheartedly embraces implicit conversions</p>\n</blockquote>\n<p>I wouldn't say it's wholehearted. If there is a canonical function from one type to another, mathlib is generally happy to have a Coe instance for it.</p>\n<p>I think a problem you're experiencing is that <code>Bool</code> has a semiring structure put on it, and semirings have a canonical function from <code>Nat</code>, so mathlib has a coercion. Mathematically, this is the right thing to do, but in your context you are not viewing <code>Bool</code> as being a semiring -- it's just meant to represent a truth value. It makes me wonder whether mathlib should have a <em>different</em> <code>Bool</code> that's the boolean ring, leaving the Lean 4 core <code>Bool</code> for programming.</p>",
        "id": 400319574,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699123525
    },
    {
        "content": "<p>Is there a difference between implicit and explicit conversions/coercions in Lean? I would call <code>(x : T)</code> \"explicit\"and for <code>f : X -&gt; Y</code>, and <code>x : Z</code> which can be coerced into <code>X</code>, I would call <code>f x</code> \"implicit\". I'm mostly worried about the implicit ones. In modern C++ programming, for example, implicit casts (too many terms used loosely here) are often \"considered evil\" across the board, and for good reason (although I personally don't agree with a blanket ban).</p>\n<p>Are there ways to locally turn off some of these implicit conversions (without manually purging each individual instance, which apparently can have a wide variety of names)? Or to define a specific conversion/coercion as opt-in or explicit-only?</p>",
        "id": 400319866,
        "sender_full_name": "Adomas Baliuka",
        "timestamp": 1699123813
    },
    {
        "content": "<p>I think right now the only thing you can do is turning off instances one at a time (or getting support to change the library itself).</p>\n<p>It's worth considering that in mathlib definitions don't come without accompanying theorems, so while these coercions that might be \"evil\" in C++, where nothing's proved, they turn out to be fine in mathlib. It can be frustrating though if you're just trying to write a program.</p>",
        "id": 400320285,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699124302
    },
    {
        "content": "<p>You might also consider importing just the parts of mathlib you need, which helps a bit with reducing the number of instances you need to be aware of. Mathlib developers don't recommend importing all of mathlib in general, even for mathematical applications.</p>",
        "id": 400320396,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699124426
    },
    {
        "content": "<p>It might be worth figuring out a design to get the coercion system be able to differentiate between explicit and implicit coercions. One way would be for there to be two typeclasses, with the implicit coercions typeclass providing all its instances to the explicit one, and then functions like <code>elabTermEnsuringType</code> could take an additional parameter for whether when ensuring the type it's OK to use explicit coercions.</p>",
        "id": 400320896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1699124860
    }
]