[
    {
        "content": "<p>After a lot of trial and error I figured out that I can import the <code>HashMap</code> data structure by importing <code>Std.Data.HashMap.Basic</code> and referencing it like <code>Std.HashMap</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">MyMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<p>and I can avoid the <code>Std</code> prefix by <code>open</code>ing <code>Std</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">MyMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">String</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n</code></pre></div>\n<ol>\n<li>\n<p>But why is <code>HashMap</code> in the <code>Std</code> namespace when it's defined in <code>Std.Data.HashMap.Basic</code>?</p>\n</li>\n<li>\n<p>It looks like I can skip the <code>Basic</code> in the import path. Is that because <code>lean/Std/Data/HashMap.lean</code> imports <code>Std.Data.HashMap.Basic</code>? Does that mean that importing <code>Std.Data.HashMap</code> includes everything <code>HashMap.lean</code> imports, i.e. it works sort of like an include?</p>\n</li>\n<li>\n<p>Even if that's the case, I still don't get how <code>import Std</code> works, because there is no <code>lean/Std.lean</code> file, so what module does that import actually reference?</p>\n</li>\n</ol>",
        "id": 503002212,
        "sender_full_name": "aron",
        "timestamp": 1741001308
    },
    {
        "content": "<ol>\n<li>There is no one-to-one correspondence between namespaces and files.</li>\n<li>Yes, imports are transitive.</li>\n<li>There is in fact such a file: <a href=\"https://github.com/leanprover/lean4/blob/master/src/Std.lean\">https://github.com/leanprover/lean4/blob/master/src/Std.lean</a></li>\n</ol>",
        "id": 503002643,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1741001457
    },
    {
        "content": "<p>Also, <code>import</code> gives you access to the declarations in a given file, regardless of their namespace.  <code>open</code> allows you to refer to the available declarations by shorter names depending on what you opened.  The two mechanisms are independent of each other, although modules and namespaces tend to have similar names, since those are often chosen semantically.</p>",
        "id": 503009914,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1741003606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>:</p>\n<ol>\n<li>so when I import a module I'm referring to a file <em>location</em>, not a namespace? but hm yeah I can see now that <code>lean/Std/Data/HashMap/Basic.lean</code> type declares the <code>HashMap</code> type as being in <code>namespace Std</code></li>\n<li>ok <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </li>\n<li>oh yeah you're right <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span> I was looking at the wrong location (inside the <code>lean/Std/</code> directory instead of inside <code>lean/</code>)</li>\n</ol>",
        "id": 503011834,
        "sender_full_name": "aron",
        "timestamp": 1741004205
    },
    {
        "content": "<p>I'll be honest I find it very confusing that you import based on file location but you reference a type/value based on namespace. That seems inconsistent.</p>\n<p>In the .NET world for example if you want to import a type, you import and qualify the type name by the same thing: its full module name (which is namespace based)</p>",
        "id": 503012443,
        "sender_full_name": "aron",
        "timestamp": 1741004408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"814082\">aron</span> <a href=\"#narrow/channel/113489-new-members/topic/Don't.20understand.20imports.20and.20opens.3F/near/503011834\">said</a>:</p>\n<blockquote>\n<ol>\n<li>so when I import a module I'm referring to a file <em>location</em>, not a namespace?</li>\n</ol>\n</blockquote>\n<p>Yes, this is correct. I would say this makes sense in Lean because we must make sure that there is some notion of \"before\" such that every declaration only refers to declarations that came before it, to prevent introducing logical inconsistencies through circular reasoning. A natural way to ensure this is by having files import each other and forbidding cyclic imports.</p>",
        "id": 503017958,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1741006175
    }
]