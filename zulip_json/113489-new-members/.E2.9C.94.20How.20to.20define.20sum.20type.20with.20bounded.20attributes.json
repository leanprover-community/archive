[
    {
        "content": "<p>Hi, I'm just learning and I'm wondering how to define a sum type where one variant has a <code>Nat</code> attribute that's bounded to a certain range, checked at compile time. Thanks in advance.</p>\n<p>If there are better places to task these kind of introductory language-feature-type questions please also let me know.</p>\n<p>To elaborate I'm trying to achieve something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jumpdest</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jump</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">JumpIf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OpsOps</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n</code></pre></div>",
        "id": 456347879,
        "sender_full_name": "Philogy",
        "timestamp": 1722787649
    },
    {
        "content": "<p>what you put down should compile provided you switch <code>OpsOps</code> for <code>Ops</code>...</p>",
        "id": 456353906,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722789799
    },
    {
        "content": "<p>although i'm not sure i understand what you want to do</p>",
        "id": 456353985,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722789843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20define.20sum.20type.20with.20bounded.20attributes/near/456353906\">said</a>:</p>\n<blockquote>\n<p>what you put down should compile provided you switch <code>OpsOps</code> for <code>Ops</code>...</p>\n</blockquote>\n<p>Yeah made a typo while copying, the error I have is when trying to actually construct the variant. I get the following error when doing <code>#eval Ops.Swap 3</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">expression</span>\n<span class=\"w\">  </span><span class=\"n\">Ops</span><span class=\"bp\">.</span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n<span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">type</span>\n<span class=\"w\">  </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ops</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"kn\">instance</span>\n<span class=\"w\">  </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Eval</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"o\">)</span>\n<span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">synthesized</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">instructs</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">how</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">display</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">resulting</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">recall</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">implementing</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"ss\">`Repr</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">also</span><span class=\"w\"> </span><span class=\"n\">implements</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"ss\">`Lean.Eval</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"kn\">class</span>\n</code></pre></div>\n<p>I'm trying to define an enum where there's 16 variants of Swap with different depths with numbers 1-16. I want Lean to enforce at compile-time that the number can only be 1-16. Thanks again for your help</p>",
        "id": 456394892,
        "sender_full_name": "Philogy",
        "timestamp": 1722806975
    },
    {
        "content": "<p><code>Ops.Swap</code> isn't a type; it's a dependently-typed function that takes an <code>n: Nat</code> and a proof that <code>1 ≤ n ∧ n ≤ 16</code> and returns an <code>Ops</code>. <code>Ops.Swap 3</code> is therefore actually a partially applied function, not an <code>Ops</code>. </p>\n<p>If you were going to do this in \"production\" code, I'd say \"don't do this at all, use</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>instead, as that has much more robust library support.\"</p>",
        "id": 456430264,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722828639
    },
    {
        "content": "<p>For the sake of the exercise, however: you could either provide the proof at the point of call, which is preferred if the proof is more complicated than simple bounds checking:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jumpdest</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jump</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">JumpIf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Ops</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"bp\">.</span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_add_right_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_add_right_le</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">le_of_eq</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456430613,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722828904
    },
    {
        "content": "<p>or, more realistically,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"bp\">.</span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 456430685,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722828924
    },
    {
        "content": "<p>Alternatively, since we have a tactic (several, in fact) that would work here without parameters in most use cases, we can encode that tactic into the function as a first resort. This is called an <code>autoParam</code>, a variant of an optional argument, and would be expressed with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">OpsAuto</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jumpdest</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jump</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">JumpIf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OpsAuto</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OpsAuto</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">OpsAuto</span><span class=\"bp\">.</span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"mi\">3</span>\n</code></pre></div>",
        "id": 456431144,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722829041
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> Thanks for clarifying!</p>\n<p>Good to know that even when the resolution of a theorem is \"obvious\" Lean still needs you to tell it that you want it solved.</p>\n<p>Side question where do I find more information on<code>Fin</code> and <code>NeZero</code> and how do I import the latter?</p>",
        "id": 456453115,
        "sender_full_name": "Philogy",
        "timestamp": 1722839257
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fin#doc\">docs#Fin</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=NeZero#doc\">docs#NeZero</a></p>",
        "id": 456453209,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722839283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20define.20sum.20type.20with.20bounded.20attributes/near/456430264\">said</a>:</p>\n<blockquote>\n<p>If you were going to do this in \"production\" code, I'd say \"don't do this at all, use</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">NeZero</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>i think you mean <code>Fin 17</code>, as <code>Fin n</code> is the type corresponding with <code>{m:Nat | m &lt; n} </code>. However, i'd recommend to look into working with <code>Fin 16</code> anyway and shifting everything over, rather than working with the odd <code>NeZero n</code> requirement. ofcourse, it could be that your use case does work better with <code>Fin 17</code> and <code>NeZero n</code>, but i'd say that's not the case in general.</p>",
        "id": 456464450,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722843332
    },
    {
        "content": "<p>Am I doing something wrong? Lean doesn't seem to raise any errors when I do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jumpdest</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Jump</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">JumpIf</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Ops</span><span class=\"bp\">.</span><span class=\"n\">Swap</span><span class=\"w\"> </span><span class=\"mi\">178</span>\n</code></pre></div>",
        "id": 456465582,
        "sender_full_name": "Philogy",
        "timestamp": 1722843617
    },
    {
        "content": "<p>Constructing a <code>Fin n</code> is done modulo <code>n</code>; what you've actually done there is created a <code>Ops.Swap 2</code></p>",
        "id": 456465870,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722843684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"684366\">@Edward van de Meent</span> Oops, you're quite right!</p>",
        "id": 456465900,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722843696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span>  why in practice is it better to have a \"wrapping type\" like <code>Fin n</code> that'll accept any n and just wrap vs. enforcing specific bounds at construction via <code>(n : Nat) -&gt; (ok: 1 &lt;= n ^ n &lt;= 16) -&gt; Ops</code>?</p>\n<p>If I had to guess it'd be the convenience of construction but I imagine if you want to write some function that constructs Ops the explicit bounds check would make it less footgun prone?</p>",
        "id": 456467275,
        "sender_full_name": "Philogy",
        "timestamp": 1722844051
    },
    {
        "content": "<p>actually, <code>Fin n</code> doesn't accept any <code>n</code>; that's only the case when using literals. for example, this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div>",
        "id": 456467921,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722844202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"739332\">Philogy</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20define.20sum.20type.20with.20bounded.20attributes/near/456467275\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"359992\">Robert Maxton</span>  why in practice is it better to have a \"wrapping type\" like <code>Fin n</code> that'll accept any n and just wrap vs. enforcing specific bounds at construction via <code>(n : Nat) -&gt; (ok: 1 &lt;= n ^ n &lt;= 16) -&gt; Ops</code>?</p>\n<p>If I had to guess it'd be the convenience of construction but I imagine if you want to write some function that constructs Ops the explicit bounds check would make it less footgun prone?</p>\n</blockquote>\n<p>... Sorry, I made an error in my previous explanation. Constructing a <code>Fin n</code> is <em>not</em> usually done modulo <code>n</code>; however, the instance for <code>OfNat</code>, that Lean uses under the hood to turn numeric literals into various compatible types, has a <code>% n</code> in it. When you use <code>Ops.Swap</code> in a proof with variables, you will either have something of type <code>Fin n</code> already, or you will have a <code>ℕ</code> that you will have to separately prove that is <code>&lt; n</code>.</p>",
        "id": 456468049,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722844235
    },
    {
        "content": "<p>and Edward beat me to it lol</p>",
        "id": 456468150,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722844265
    },
    {
        "content": "<p>*<code>&lt; n</code></p>",
        "id": 456468233,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1722844285
    },
    {
        "content": "<p>shh &gt;.&gt;;</p>",
        "id": 456468358,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1722844306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/stream/113489-new-members/topic/How.20to.20define.20sum.20type.20with.20bounded.20attributes/near/456467921\">said</a>:</p>\n<blockquote>\n<p>actually, <code>Fin n</code> doesn't accept any <code>n</code>; that's only the case when using literals. for example, this doesn't work:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">n</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Makes sense, thank you both! (cc: <span class=\"user-mention\" data-user-id=\"359992\">@Robert Maxton</span> )</p>",
        "id": 456468668,
        "sender_full_name": "Philogy",
        "timestamp": 1722844350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"739332\">Philogy</span> has marked this topic as resolved.</p>",
        "id": 456468720,
        "sender_full_name": "Notification Bot",
        "timestamp": 1722844359
    }
]