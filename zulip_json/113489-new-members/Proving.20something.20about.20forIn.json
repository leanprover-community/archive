[
    {
        "content": "<p>I'm challenging myself to prove that <code>doNothing</code> is the identity function, where</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">doNothing</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">as</span> <span class=\"k\">do</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r.push</span> <span class=\"n\">a</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n</code></pre></div>\n<p>What I attempted:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">doNothing</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">as</span> <span class=\"k\">do</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r.push</span> <span class=\"n\">a</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">pop_concat_last_eq</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">as.size</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">as.pop</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">as.data.getLast</span> <span class=\"o\">(</span><span class=\"n\">List.length_pos.mp</span> <span class=\"n\">h</span><span class=\"o\">)]</span> <span class=\"bp\">=</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Array.ext'</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">exact</span> <span class=\"n\">List.dropLast_append_getLast</span> <span class=\"o\">(</span><span class=\"n\">List.length_pos.mp</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">doNothing_eq_id</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">doNothing</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">as.size</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">as</span>\n  <span class=\"bp\">.</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">List.length_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">Array.ext'</span> <span class=\"n\">h</span>\n    <span class=\"n\">subst</span> <span class=\"n\">this</span>\n    <span class=\"n\">trivial</span>\n  <span class=\"bp\">.</span> <span class=\"k\">let</span> <span class=\"n\">bs</span> <span class=\"o\">:=</span> <span class=\"n\">as.pop</span>\n    <span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">as.data.getLast</span> <span class=\"o\">(</span><span class=\"n\">List.length_pos.mp</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_sub_eq_succ</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">bs</span> <span class=\"bp\">++</span> <span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">]</span> <span class=\"bp\">=</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">pop_concat_last_eq</span> <span class=\"n\">as</span> <span class=\"o\">(</span><span class=\"n\">Nat.lt_of_sub_eq_succ</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">]</span>\n    <span class=\"n\">replace</span> <span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"n\">doNothing</span> <span class=\"n\">bs</span> <span class=\"bp\">=</span> <span class=\"n\">bs</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">bs</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Array.size_pop</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">Nat.succ_sub_succ_eq_sub</span><span class=\"o\">,</span> <span class=\"n\">nonpos_iff_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">tsub_zero</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">])</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">doNothing</span><span class=\"o\">,</span> <span class=\"n\">Id.run</span><span class=\"o\">,</span> <span class=\"n\">forIn</span><span class=\"o\">]</span>\n    <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I'm hitting a brick wall here. Not sure if this is the right approach.</p>",
        "id": 403475489,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700607067
    },
    {
        "content": "<p>These \"how to prove that a completely basic program has no bugs\" questions remind me of the Lean chat in summer 2017 when it was mostly \"how to prove that a completely basic maths question (such as 2+2&lt;500.678) is true\" and there was no norm_num.</p>",
        "id": 403479265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1700609195
    },
    {
        "content": "<p>I’d say that doing proofs over monadic code like this will be very painful, without suitable tactics and program logics. I expect there is a way to push this through, but I don’t expect it to be practical.</p>\n<p>If you start your proof with <code>unfold doNothing</code> you’ll see that it ’s defined using a function called <code>forIn</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">as</span><span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">Id.run</span>\n    <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span><span class=\"bp\">;</span>\n    <span class=\"k\">do</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"bp\">←</span>\n      <span class=\"n\">forIn</span> <span class=\"n\">as</span> <span class=\"n\">r</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span>\n          <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span><span class=\"bp\">;</span>\n          <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">Array.push</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"bp\">;</span>\n          <span class=\"k\">do</span>\n          <span class=\"n\">pure</span> <span class=\"n\">PUnit.unit</span>\n          <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"n\">ForInStep.yield</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n    <span class=\"k\">let</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n    <span class=\"n\">pure</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">as</span>\n</code></pre></div>\n<p>So I expect you’ll need to define a helper lemma about that <code>forIn</code>, prove that by induction, and then use it outside.</p>",
        "id": 403556010,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700646457
    },
    {
        "content": "<p>Practically speaking, if you want to verify basic programs, write them in a pure functional style, e.g. using recursion.</p>",
        "id": 403556412,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1700646578
    },
    {
        "content": "<p>So it looks like it's not just me, and we don't have (yet) the tools to do this. Thanks!</p>",
        "id": 403600433,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700662392
    },
    {
        "content": "<p>It is definitely possible but not that straightforward as one would hope. Here is version for <code>List</code>. For <code>Array</code> I have to think about it a bit more.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">doNothing</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">as</span> <span class=\"k\">do</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r.concat</span> <span class=\"n\">a</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">forIn_concat_append</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"n\">as'</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">forIn</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:=</span><span class=\"n\">Id</span><span class=\"o\">)</span> <span class=\"n\">as</span> <span class=\"n\">as'</span> <span class=\"k\">fun</span> <span class=\"n\">a'</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ForInStep.yield</span> <span class=\"o\">(</span><span class=\"n\">List.concat</span> <span class=\"n\">r</span> <span class=\"n\">a'</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">as'.append</span> <span class=\"n\">as</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">revert</span> <span class=\"n\">as'</span>\n  <span class=\"n\">induction</span> <span class=\"n\">as</span>\n  <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span>\n  <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">a'</span> <span class=\"n\">as</span> <span class=\"n\">h</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">List.concat</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"o\">]</span>\n    <span class=\"n\">intro</span> <span class=\"n\">as'</span>\n    <span class=\"n\">induction</span> <span class=\"n\">as'</span>\n    <span class=\"n\">case</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">List.concat</span><span class=\"o\">]</span>\n    <span class=\"n\">case</span> <span class=\"n\">cons</span> <span class=\"n\">a''</span> <span class=\"n\">as'</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">,</span><span class=\"n\">List.concat</span><span class=\"o\">,</span><span class=\"n\">List.append</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">doNothing</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span>\n  <span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">doNothing</span><span class=\"o\">,</span><span class=\"n\">Id.run</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I think having some induction principle for lists or arrays that is peeling off elements from the right would be helpful.</p>",
        "id": 403613002,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1700666081
    },
    {
        "content": "<p>I think for arrays it would be helpful to prove this simp theorem analogous to <code>List.forIn_cons</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">Array.forIn_cons</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n    <span class=\"o\">:</span> <span class=\"n\">forIn</span> <span class=\"o\">(</span><span class=\"n\">Array.mk</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">))</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"k\">fun</span> <span class=\"bp\">|</span> <span class=\"n\">ForInStep.done</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">ForInStep.yield</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">forIn</span> <span class=\"o\">(</span><span class=\"n\">Array.mk</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 403618919,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1700667943
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"582393\">@Yongyi Chen</span> btw it would be helpful if your example code would be self contained and work with the <code>View in Lean 4 playground</code> button in the top right corner of every code block</p>",
        "id": 403619208,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1700668038
    },
    {
        "content": "<p>Oh, I'll add in the necessary imports!</p>",
        "id": 403619275,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700668064
    },
    {
        "content": "<p>Unfortunately with more complicated code you want to maintain an invariant inside of the for loop. Then it gets hard and there is not much tooling for that right now.</p>",
        "id": 403620291,
        "sender_full_name": "Tomas Skrivan",
        "timestamp": 1700668435
    },
    {
        "content": "<p>Yeah, going through the code and showing invariants is how a proof in a typical CS class would go.</p>",
        "id": 403623315,
        "sender_full_name": "Yongyi Chen",
        "timestamp": 1700669172
    },
    {
        "content": "<p>Every time this exercise comes up we find a few more lemmas for Std. I was able to reduce the proof to this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Std.Data.Array.Lemmas</span>\n\n<span class=\"c1\">--- for std</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">Array.forIn_eq_data_forIn</span> <span class=\"o\">[</span><span class=\"n\">Monad</span> <span class=\"n\">m</span><span class=\"o\">]</span>\n    <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n    <span class=\"n\">forIn</span> <span class=\"n\">as</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">forIn</span> <span class=\"n\">as.data</span> <span class=\"n\">b</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- proof omitted</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">appendList_nil</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">arr</span> <span class=\"bp\">++</span> <span class=\"o\">([]</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">arr</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ext'</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span> <span class=\"kd\">theorem</span> <span class=\"n\">appendList_cons</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">arr</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">arr.push</span> <span class=\"n\">a</span> <span class=\"bp\">++</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">Array.ext'</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">doNothing</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">Id.run</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">as</span> <span class=\"k\">do</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r.push</span> <span class=\"n\">a</span>\n  <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">doNothing_eq_id</span> <span class=\"o\">(</span><span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">doNothing</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"n\">as</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">doNothing</span><span class=\"o\">,</span> <span class=\"n\">Array.forIn_eq_data_forIn</span><span class=\"o\">]</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">Id</span> <span class=\"o\">(</span><span class=\"n\">ForInStep</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">ForInStep.yield</span> <span class=\"o\">(</span><span class=\"n\">Array.push</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">forIn</span> <span class=\"n\">l</span> <span class=\"n\">r</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">++</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"n\">generalizing</span> <span class=\"n\">r</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Array.ext'</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">Id.run</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 403657460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700683190
    },
    {
        "content": "<p>added in <a href=\"https://github.com/leanprover/std4/commit/282e3a13e84b8ba1ea994e517e9e04cf7e7239bf\"><code>282e3a1</code></a></p>",
        "id": 403658299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700683556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346070\">Tomas Skrivan</span> <a href=\"#narrow/stream/113489-new-members/topic/Proving.20something.20about.20forIn/near/403620291\">said</a>:</p>\n<blockquote>\n<p>Unfortunately with more complicated code you want to maintain an invariant inside of the for loop. Then it gets hard and there is not much tooling for that right now.</p>\n</blockquote>\n<p>There is <em>always</em> an invariant when proving things about loops of any kind, and this one is no exception. It is the inductive hypothesis, and in this case I have written it as saying that <code>forIn l r f = r ++ (l : List α)</code>, that is, the effect of the loop is to append <code>as</code> to the initial value <code>r</code></p>",
        "id": 403659398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700684118
    },
    {
        "content": "<p>I have struggled with such problems several times, too. IMO, it is convenient to relate <code>@forIn m ρ α _ β</code> loop with <code>ρ.foldlM (m:=StateT (ForInStep β) m)</code> (e.g. in the case <code>ρ=List α</code> or <code>Array α</code>) or its combination with a \"proof attacher\" like <code>List.pmap</code>. If <code>ρ.foldlM</code> has a good induction principle, then we can just use it. I believe that <code>Std.Range</code> also admits such a good <code>foldM</code>.</p>",
        "id": 403793223,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1700747622
    },
    {
        "content": "<p>From this point of view, it may be worth having some analogue of Haskell's <code>MonoFoldable</code> class.</p>",
        "id": 403793717,
        "sender_full_name": "Jun Yoshida",
        "timestamp": 1700747807
    }
]