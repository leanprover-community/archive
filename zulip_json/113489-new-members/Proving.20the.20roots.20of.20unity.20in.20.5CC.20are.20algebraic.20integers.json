[
    {
        "content": "<p>Working on proving that complex characters of a finite group are algebraic integers. Shouldn't be too hard right? Digging around I found some related theorems such as <code>IsPrimitiveRoot.isIntegral</code> (why do we only have this for the primitive roots?). </p>\n<p>If we don't have a theorem ready, it should be easy enough to just show that we have a root of X^n - 1 and that is monic? What is the endgame here though? I'd thought of using <code>IsIntegral.of_aeval_monic</code> but I'm not sure that helps since we still need to construct <code>(hx : IsIntegral R ((aeval x) p))</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">universe</span><span class=\"w\"> </span><span class=\"n\">u</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">BigOperators</span><span class=\"w\"> </span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">ComplexConjugate</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">End</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Multiset</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Polynomial</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">LinearMap</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">root_unity_alg_int</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hz</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hnez</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hm</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monic</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">monic_X_pow_sub_C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">hnez</span>\n<span class=\"w\">  </span><span class=\"c1\">-- now what... IsIntegral.of_aeval_monic ?  AdjoinRoot.isIntegral_root' ?</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 538730200,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757534575
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 538730737,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757534762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"952891\">@Ryan Smith</span> you've actually pointed out one of the (in my opinion) bigger flaws that exist: the underlying definition itself is not visible during Loogle search.</p>\n<p>In this case, you need to look \"under the definition\" of <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IntegralClosure/IsIntegral/Defs.html#IsIntegral\">IsIntegral</a> and see that it is actually <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/RingTheory/IntegralClosure/IsIntegral/Defs.html#RingHom.IsIntegralElem\">IsIntegralElem</a> which is actually <code>∃ (p : Polynomial R), p.Monic ∧ Polynomial.eval₂ f x p = 0</code>.</p>",
        "id": 538734951,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757536682
    },
    {
        "content": "<p>but even if you didn't know that, you could actually follow the path you were on, which is via <code>IsIntegral.of_aeval_monic</code>, because the result of <code>aeval</code> should be zero, and then you know that zero is integral</p>",
        "id": 538735060,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757536739
    },
    {
        "content": "<p>also, please PR this</p>",
        "id": 538735386,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757536898
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"879979\">@Chengyan Hu</span> was doing something similar, you two might need to figure out what to do with the PR</p>",
        "id": 538735669,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1757537040
    },
    {
        "content": "<p>Yes it seems like we proved something similar.</p>",
        "id": 538736294,
        "sender_full_name": "Chengyan Hu",
        "timestamp": 1757537324
    },
    {
        "content": "<p><a href=\"https://github.com/bourbaki120205/mathlib4/blob/project/Chengyan/Test%20copy%202.lean\">https://github.com/bourbaki120205/mathlib4/blob/project/Chengyan/Test%20copy%202.lean</a></p>",
        "id": 538736404,
        "sender_full_name": "Chengyan Hu",
        "timestamp": 1757537358
    },
    {
        "content": "<p>This is the link toward my previous work.</p>",
        "id": 538736458,
        "sender_full_name": "Chengyan Hu",
        "timestamp": 1757537377
    },
    {
        "content": "<p>I’m currently on holiday with my family  and I’ll PR that as soon as I have time to read that long document</p>",
        "id": 538736637,
        "sender_full_name": "Chengyan Hu",
        "timestamp": 1757537458
    },
    {
        "content": "<p>Thanks for the link, I hope the PR gets approved soon. This is so much shorter and more elegant than what I had. </p>\n<p>How does this prove the lemma exactly? It looks like we're using a constructor, obviously we have the monic polynomial that \\zeta satisfies as the first argument, and then the second is a proof that polynomials of this type are integral, but how does the third parameter fit in? What are we exact passing arguments to with these brackets?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isIntegral_of_roots</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hpos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ζ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hζ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ζ</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"n\">ζ</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">⟨</span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">monic_X_pow_sub_C</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">ne_of_lt</span><span class=\"w\"> </span><span class=\"n\">hpos</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hζ</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 538742431,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757540561
    },
    {
        "content": "<p>It's the eval_2 condition that Kenny mentions a few messages ago</p>",
        "id": 538745280,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757542485
    },
    {
        "content": "<p>The brackets contain first the witness for the Exists and then the two proofs for each side of the And</p>",
        "id": 538745381,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1757542545
    },
    {
        "content": "<p>I see, and the constructor separated out the And clause so we end up with three arguments.</p>",
        "id": 538751569,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757547339
    },
    {
        "content": "<p>One code question I've had for a while about arguments. This snippet now runs (yes!) but I find myself sometimes writing very long have blocks which I only ever use once and then throw away, like the way we do it here. </p>\n<p>Is there a way to combine my last two statements (have and exact) together? It's not important for the correctness of this theorem but there's a lot of short hand in mathlib so I'm trying to understand.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">char_value_is_integral</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">exists_char_eigenvalue_ms</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">char_eq_eigenvalue_ms_sum</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">toEnumFinset</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">hμ</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">heig</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEigenvalue</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">ρ</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">mem_eigen_ms_eigenvalue</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Multiset</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_toEnumFinset</span><span class=\"w\"> </span><span class=\"n\">hμ</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hrunity</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_root_unity</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">μ</span><span class=\"w\"> </span><span class=\"n\">heig</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hpos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">isIntegral_of_roots</span><span class=\"w\"> </span><span class=\"n\">hpos</span><span class=\"w\"> </span><span class=\"n\">hrunity</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"bp\">.</span><span class=\"n\">sum</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">this</span>\n</code></pre></div>",
        "id": 538759076,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757553864
    },
    {
        "content": "<p>It's hard to say because there's no <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>, but probably you can do something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">char_value_is_integral</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FDRep</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"n\">character</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">exists_char_eigenvalue_ms</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">char_eq_eigenvalue_ms_sum</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">hs</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">IsIntegral</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n<span class=\"w\">  </span><span class=\"n\">rintro</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">μ</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">hμ</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">isIntegral_of_roots</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">card_pos</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">eigenvalue_root_unity</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">mem_eigen_ms_eigenvalue</span>\n</code></pre></div>\n<p>I don't think there's anything wrong with the original style though.</p>",
        "id": 538761259,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1757555794
    },
    {
        "content": "<p>That's interesting, you can apply a function without specifying the arguments and they become goals?</p>",
        "id": 538762185,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757556703
    },
    {
        "content": "<p>yes, and check out <code>refine</code> for a more flexible alternative</p>",
        "id": 538762547,
        "sender_full_name": "Lawrence Wu (llllvvuu)",
        "timestamp": 1757557109
    },
    {
        "content": "<p>That's really neat, when I read about <code>refine</code> before it made no sense at all tbh but that's really useful. One webpage describes it as \"exact with holes\" which makes a lot of sense</p>",
        "id": 538762795,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757557377
    },
    {
        "content": "<p>One other trick that can be useful is using the short-hand anonymous function syntax (no idea if that is what it is called in lean), if you need to provide some args but let move the rest into goals, e.g. if f needs 5 args <code>apply (f x . y . z)</code> will provide 3 and leave the other two. But again <code>refine f x ?_ y ?_ z</code> is probably more ideomatic.</p>",
        "id": 538765213,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1757559797
    },
    {
        "content": "<p>Thanks, these sort of \"deferred arguments\" make it easier to avoid defining stuff I'll never use again.</p>",
        "id": 538768359,
        "sender_full_name": "Ryan Smith",
        "timestamp": 1757563141
    }
]