[
    {
        "content": "<p>Hi, I'm brand new to Lean. I've read most of \"functional programming in lean\" and I'm trying to do last year's advent of code with it. For the first puzzle I have a list of pairs of Ints. I want to unzip this list into two arrays of ints, sort them, and then zip them back together. I'm struggling to figure out what the type signatures would be for the zip and unzip functions, though-- I want to specify that the arrays produced by unzip have equal length, enforce that the arrays produced by zipping have equal length, and somehow assert that sorting the arrays didn't change their length. I don't need a full solution (I'm using this as a learning project) but can anyone provide me with some pointers?</p>",
        "id": 497318421,
        "sender_full_name": "Joseph Junker",
        "timestamp": 1738550925
    },
    {
        "content": "<p>This is certainly not the only way to do it, but instead of <code>Array</code>, you could use <code>Vector</code>, which is an <code>Array</code> with a \"known size\". Then you can accept an <code>n : Nat</code> and two terms of type <code>Vector Î± n</code>, and return a <code>Vector _ n</code>. This takes advantage of Lean's dependent types.</p>\n<p>Another way to do it is to define the zip operation for all pairs of arrays, even ones with different size, but then make proofs about the arrays that only hold when the inputs have equal size. This approach of defining the function to have as wide a domain as possible but proving some properties only about a subset of that domain is very common in Mathlib.</p>",
        "id": 497319727,
        "sender_full_name": "Niels Voss",
        "timestamp": 1738551827
    },
    {
        "content": "<p>I see. I didn't want to use <code>Vector</code> because I'm not seeing a built-in way to sort them, and I wanted to dip my toes in before trying to write sorting algorithms. The second approach sounds really straightforward though, and is probably what I'll do. I legitimately forgot that just because the language allows everything to be typed and proven precisely, that doesn't mean that I have to make the types completely perfect in a case like this <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 497320397,
        "sender_full_name": "Joseph Junker",
        "timestamp": 1738552301
    },
    {
        "content": "<p>The core zip/unzip functions are <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.zip#doc\">docs#Array.zip</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Array.unzip#doc\">docs#Array.unzip</a></p>\n<p>Or if you work with List, there's <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.zip#doc\">docs#List.zip</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.unzip#doc\">docs#List.unzip</a>. A benefit of these is that they have theory like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.length_zip#doc\">docs#List.length_zip</a></p>\n<p>One Lean design pattern is that you don't need to encode all the invariants in the types of the functions themselves. You can prove facts about your functions afterwards.</p>",
        "id": 497320960,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1738552764
    },
    {
        "content": "<p>Thank you both for your help!</p>",
        "id": 498509718,
        "sender_full_name": "Joseph Junker",
        "timestamp": 1739027518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873696\">Joseph Junker</span> has marked this topic as resolved.</p>",
        "id": 498509779,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739027534
    }
]