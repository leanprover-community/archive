[
    {
        "content": "<p><strong>Questions/guidance on proof methods</strong></p>\n<p>I am trying to prove that the boolean AND of two boolean palindromes of the same length are also a palindrome.  </p>\n<p>I feel a bit lost with the proof method because I am unsure if I am even using the best approach or if there are other approaches that would be better for the way I have things set up.  That being said, if there is a better way to set things up I am also interested in what people have to say.  </p>\n<p>Some uncertainties I have are:</p>\n<ol>\n<li>Should I define <code>List.And</code> differently to make this type of proof easier?</li>\n<li>Instead of pattern matching on the boolean lists <code>A</code> and <code>B</code>, should I be pattern matching on something else?  Should I be pattern matching at all?</li>\n<li>If not pattern matching, is using induction in some form or another a better method? Why?</li>\n</ol>\n<p>The idea for the proof that I am trying here is pattern matching and then would like to try and show that since <code>A</code> and <code>B</code> are boolean palindromes of the same length then both ends of these lists are the same, making the boolean AND of both the ends also the same.</p>\n<p>Here is what I have so far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Palindrome</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">List</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">List.And</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span> <span class=\"bp\">→</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">[]</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span> <span class=\"bp\">=&gt;</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">::</span> <span class=\"n\">List.And</span> <span class=\"n\">as</span> <span class=\"n\">bs</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">List.And</span> <span class=\"o\">[]</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"c1\">-- []</span>\n<span class=\"k\">#eval</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"c1\">-- [true, false]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">true</span><span class=\"o\">,</span> <span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"c1\">-- [true, false]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Palindrome</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Palindrome</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Palindrome</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">false</span><span class=\"o\">]</span> <span class=\"c1\">-- true</span>\n<span class=\"k\">#eval</span> <span class=\"n\">Palindrome</span> <span class=\"bp\">&lt;|</span> <span class=\"n\">List.And</span> <span class=\"o\">[</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">false</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">,</span><span class=\"n\">true</span><span class=\"o\">]</span> <span class=\"c1\">-- false</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">reverse_eq'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">Palindrome</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">))</span>\n    <span class=\"o\">:</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Palindrome.reverse_eq</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">of_reverse_eq'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Palindrome</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">exact</span> <span class=\"n\">Palindrome.of_reverse_eq</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">iff_reverse_eq'</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">Palindrome</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">reverse</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n  <span class=\"n\">Iff.intro</span> <span class=\"n\">reverse_eq'</span> <span class=\"n\">of_reverse_eq'</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bool_palindrome_and_bool_palindrome_is_palindrome</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Bool</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A.length</span> <span class=\"bp\">=</span> <span class=\"n\">B.length</span><span class=\"o\">)</span>\n   <span class=\"o\">:</span> <span class=\"n\">Palindrome</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">Palindrome</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">Palindrome</span> <span class=\"o\">(</span><span class=\"n\">List.And</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hA</span> <span class=\"n\">hB</span>\n  <span class=\"k\">match</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">[]</span>  <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">length_eq_zero</span> <span class=\"n\">h</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"o\">[],</span> <span class=\"n\">B</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">Iff.mp</span> <span class=\"n\">length_eq_zero</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">Eq.symm</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n  <span class=\"bp\">|</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">cons_ne_nil</span> <span class=\"n\">a</span> <span class=\"n\">as</span>\n    <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">cons_ne_nil</span> <span class=\"n\">b</span> <span class=\"n\">bs</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">as</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span> <span class=\"bp\">∧</span> <span class=\"n\">bs</span> <span class=\"bp\">=</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">·</span> <span class=\"c1\">-- as = [] ∧ bs = []</span>\n      <span class=\"k\">have</span> <span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::[])</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">hn.1</span>\n      <span class=\"k\">have</span> <span class=\"n\">h6</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::</span><span class=\"n\">bs</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">::[])</span> <span class=\"o\">:=</span> <span class=\"n\">congrArg</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">hn.2</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h5</span><span class=\"o\">,</span> <span class=\"n\">h6</span><span class=\"o\">]</span>\n      <span class=\"n\">exact</span> <span class=\"n\">of_reverse_eq'</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">·</span> <span class=\"c1\">-- as ≠ [] ∨ bs ≠ []</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">not_and_or</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">hn</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">hn</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">hn1</span> <span class=\"bp\">|</span> <span class=\"n\">hn2</span><span class=\"o\">)</span>\n      <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n      <span class=\"bp\">·</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 384399660,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1691903498
    },
    {
        "content": "<p>I'm not at a computer, so my suggestions will be very coarse.  I think that <code>List.And</code> is <code>List.zipWith (And \\. \\.) _ _</code> (<a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=List.zipWith#doc\">docs#List.zipWith</a>).</p>\n<p>Also, do you really need to do all the trivial cases separately?  Couldn't you do the <code>cons, cons</code> case first and then lump together all the rest in a single case?</p>",
        "id": 384401697,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1691904769
    },
    {
        "content": "<p>Yes, <code>List.zipWith (and \\. \\.) _ _</code> does replace what I have for <code>List.And</code>.  </p>\n<p>In terms of making the proof more concise, yes I probably can do something as you mention with <code>cons, cons</code>.  I am more interested in seeing what the preferred proof method is between pattern matching, induction, or some other way.  </p>\n<p>For example, I tried a bunch of different things such as regular <code>induction</code> and <code>bidirectionalRecOn</code> etc. but I kept running into the issue that I need to be able to iterate over <code>A</code> and <code>B</code> (at least afaict).</p>",
        "id": 384403174,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1691905781
    },
    {
        "content": "<p>So I have thought about this some more and this question is probably rather trivial for most of the bright minds here.  This is what I have come up with (which in hindsight I feel I should have known but sometimes asking stupid questions will make you realize it faster) as a rule of thumb, which may be helpful to any other beginners who come upon this in the future:</p>\n<ol>\n<li>Pattern matching is basically doing <code>cases</code> on inductive types in your hypothesis during the proof. </li>\n<li>If you need an actual induction step in your proof, use <code>induction</code> or  one its variants.  Which one is <em>best</em> for you will depend on the <em>proof</em> at hand.</li>\n</ol>\n<p>Basically main difference between the two is the induction step since <code>cases</code> deconstructs the inductive data types just like we get with <code>induction</code>, but with <code>induction</code> we get that added induction hypothesis to help us with the induction step if needed.</p>",
        "id": 384489567,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1691931654
    },
    {
        "content": "<p>There is no actual difference between pattern matching and induction. You can emulate induction with the <code>cases</code> tactic by doing a recursive call to your theorem and calling the resulting value <code>ih</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">Nat.example_zero_add</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">rfl</span>\n  <span class=\"bp\">|</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"k\">let</span> <span class=\"n\">ih</span> <span class=\"o\">:=</span> <span class=\"n\">Nat.example_zero_add</span> <span class=\"n\">m</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Nat.add_succ</span><span class=\"o\">]</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><code>induction</code> basically \"just\" automates this concept for you by using a certain kind of induction scheme (and it has a default one that is automatically generated for each inductive type). That said if you are not willing to come up with the generalized scheme for the proof that you are doing you can still just resolve to using a case + recursive call.</p>",
        "id": 384492767,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1691932441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span> thanks for the response.  In addition, the example you gave, from what I understand, is strong or complete induction, correct?</p>",
        "id": 384555303,
        "sender_full_name": "Newell Jensen",
        "timestamp": 1691949857
    },
    {
        "content": "<p>I guess you can call it that if you want to yes.</p>",
        "id": 384555581,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1691949947
    }
]