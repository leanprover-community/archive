[
    {
        "content": "<p>Hi,</p>\n<p>I am newly working with Lean and try different formalizations of finite sets. (I know that there is a definition for finite sets in mathlib already). I get the type mismatch error and can't make any sense of why this is.  My example is below.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">Kuratowski</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">empty</span><span class=\"o\">:</span> <span class=\"n\">Kuratowski</span>\n<span class=\"bp\">|</span> <span class=\"n\">singleton</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span>\n<span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"n\">Kuratowski</span>  <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span>  <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span>\n\n<span class=\"kd\">variable</span> <span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">notation</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span><span class=\"n\">emptyset</span><span class=\"o\">)</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"n\">Kuratowski.empty</span>\n<span class=\"kd\">notation</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">Kuratowski.singleton</span> <span class=\"n\">a</span>\n<span class=\"kd\">notation</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">union</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">Kuratowski.union</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">kuratowski_member</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"n\">false</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">x</span><span class=\"bp\">=</span><span class=\"n\">y</span>\n<span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∪</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">kuratowski_member</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">kuratowski_member</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:=</span> <span class=\"n\">kuratowski_member</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">kuratowski_member</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">comprehension</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span>\n<span class=\"bp\">|</span> <span class=\"n\">ϕ</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"n\">ϕ</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">ϕ</span> <span class=\"n\">a</span> <span class=\"k\">then</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"n\">ϕ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">comprehension</span> <span class=\"n\">ϕ</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">comprehension</span> <span class=\"n\">ϕ</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">intersection</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Kuratowski</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span><span class=\"o\">:=</span> <span class=\"n\">comprehension</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span>\n</code></pre></div>\n<p>I receive the following error (line 26 is the definition of the intersection.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">none</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">overloads</span> <span class=\"n\">are</span> <span class=\"n\">applicable</span>\n<span class=\"n\">error</span> <span class=\"n\">for</span> <span class=\"n\">kuratowski_member</span>\n<span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">kuratowski_member</span> <span class=\"n\">a</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">a</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"n\">error</span> <span class=\"n\">for</span> <span class=\"n\">has_mem.mem</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">has_mem</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">Kuratowski</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"n\">Additional</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">johannes</span><span class=\"bp\">/</span><span class=\"n\">finSets</span><span class=\"bp\">/</span><span class=\"n\">Test.lean</span><span class=\"o\">:</span><span class=\"mi\">26</span><span class=\"o\">:</span><span class=\"mi\">96</span><span class=\"o\">:</span> <span class=\"n\">context</span><span class=\"o\">:</span> <span class=\"n\">switched</span> <span class=\"n\">to</span> <span class=\"n\">basic</span> <span class=\"n\">overload</span> <span class=\"n\">resolution</span> <span class=\"n\">where</span> <span class=\"n\">arguments</span> <span class=\"n\">are</span> <span class=\"n\">elaborated</span> <span class=\"n\">without</span> <span class=\"n\">any</span> <span class=\"n\">information</span> <span class=\"n\">about</span> <span class=\"n\">the</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">because</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">was</span> <span class=\"n\">not</span> <span class=\"n\">available</span>\n</code></pre></div>\n<p>This only partially makes sense for me. I can understand the second part, because I use my own membership function and not the one from a standard library, so it doesn't know what to use, but I don't understand why my member function is refusing my definition and requires some obscure type. (λ (a:A), a ∈ y) takes an element from A and returns a boolean and y is a constant and then comprehension  also gets a correct function and a fitting Kuratowski set object. I don't see why a should be a Type object.</p>\n<p>If I remove the type definition from the lambda, it then asks for a proof of decidable_eq a, but I don't see how to give this in for some general a.<br>\nHow to interprete this error and solve it ?</p>",
        "id": 360798534,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1684936749
    },
    {
        "content": "<p>Probably the first argument should be <code>A</code> and then <code>a</code> can be the second?</p>",
        "id": 360799152,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1684936868
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/Type.20mismatch.20expected.20to.20have.20type.20.20.20Type.20.3F.20.3A.20Type.20.28.3F.2B1.29/near/360799152\">schrieb</a>:</p>\n<blockquote>\n<p>Probably the first argument should be <code>A</code> and then <code>a</code> can be the second?</p>\n</blockquote>\n<p>Hi, thanks for answering<br>\nCan you state that a bit more precise for what statement as the first argument ? As the first argument for<code>\\in</code> ? I don't see how this works with the custom notation. If I write instead <code>kuratowski_member A a y</code>I get another type mismatch as it then tries to find <code>A \\in a</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">comprehension</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">∈</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"bp\">∈</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">y</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">Additional</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"bp\">/</span><span class=\"n\">home</span><span class=\"bp\">/</span><span class=\"n\">johannes</span><span class=\"bp\">/</span><span class=\"n\">finSets</span><span class=\"bp\">/</span><span class=\"n\">Kuratowski.lean</span><span class=\"o\">:</span><span class=\"mi\">95</span><span class=\"o\">:</span><span class=\"mi\">72</span><span class=\"o\">:</span> <span class=\"n\">context</span><span class=\"o\">:</span> <span class=\"n\">switched</span> <span class=\"n\">to</span> <span class=\"n\">simple</span> <span class=\"n\">application</span> <span class=\"n\">elaboration</span> <span class=\"n\">procedure</span> <span class=\"n\">because</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">use</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">to</span> <span class=\"n\">elaborate</span> <span class=\"n\">it</span><span class=\"o\">,</span> <span class=\"n\">error</span> <span class=\"n\">message</span>\n  <span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n    <span class=\"n\">comprehension</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span>\n  <span class=\"n\">has</span> <span class=\"n\">type</span>\n    <span class=\"n\">Kuratowski</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">→</span> <span class=\"n\">Kuratowski</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n  <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n    <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>",
        "id": 360801383,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1684937283
    },
    {
        "content": "<p>Oh, I misread partially. You need <code>A</code> as the first argument to <code>comprehension</code>, but the lambda then still goes wrong</p>",
        "id": 360807180,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1684938542
    },
    {
        "content": "<p>Trying to override the core <code>∈</code> is only making your life harder here</p>",
        "id": 360807410,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1684938594
    },
    {
        "content": "<p>So you can replace that by <code>kuratowski_member A a y</code> inside the lambda</p>",
        "id": 360807582,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1684938618
    },
    {
        "content": "<p>Thank you this works. I assumed that the type is read off from the other inputs. Is it possible to hide \"normal set\" languages so I can use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span> ?</p>",
        "id": 360809533,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1684939062
    },
    {
        "content": "<p>The type is read off from the other inputs if you specify that. You declared \"variables A : Type u\". That makes A an explicit argument. I think you might want \"variables {A : Type u}\" instead.</p>",
        "id": 360818356,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1684940879
    },
    {
        "content": "<p>Note that this formalization of finite sets doesn't work. You would need to take a quotient in order to say that some of the ways to build a set actually give you the same thing. For example, if you take <code>a b : A</code>, put them into singletons and then union, you get different elements of kuratowski based on which order you put them in the union.</p>",
        "id": 361152946,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1685043953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/113489-new-members/topic/Type.20mismatch.20expected.20to.20have.20type.20.20.20Type.20.3F.20.3A.20Type.20.28.3F.2B1.29/near/361152946\">schrieb</a>:</p>\n<blockquote>\n<p>Note that this formalization of finite sets doesn't work. You would need to take a quotient in order to say that some of the ways to build a set actually give you the same thing. For example, if you take <code>a b : A</code>, put them into singletons and then union, you get different elements of kuratowski based on which order you put them in the union.</p>\n</blockquote>\n<p>Thank you for your help, but I think I dealt with this. I have added axioms like these</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">axiom</span> <span class=\"n\">union_comm</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Kuratowski</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"n\">x</span> <span class=\"bp\">∪</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∪</span> <span class=\"n\">x</span>\n<span class=\"kd\">axiom</span> <span class=\"n\">union_singleton_idem</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">):</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to my code, but they didn't seem to be relevant here and I didn't want to clutter the example more.</p>",
        "id": 361291781,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1685099464
    },
    {
        "content": "<p>I'm pretty sure that will allow you to prove false</p>",
        "id": 361293044,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685099772
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">union_singleton_idem</span> <span class=\"o\">()</span>\n</code></pre></div>",
        "id": 361293724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685099942
    },
    {
        "content": "<p>The general rule is \"don't add axioms unless you really know what you're doing\"! Mathlib contains no <code>axiom</code>s.</p>",
        "id": 361293876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685099979
    },
    {
        "content": "<p>As <span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> says, if you want to make these things equal you need to take the quotient</p>",
        "id": 361294007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1685100006
    },
    {
        "content": "<p>I'll take a look at this</p>",
        "id": 361294409,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1685100114
    }
]