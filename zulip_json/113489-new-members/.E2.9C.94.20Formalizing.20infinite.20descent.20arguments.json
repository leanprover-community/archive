[
    {
        "content": "<p>I have always found it surprisingly hard to formalize facts about finite types/sets. So much so that in a side project to formalize some basic things about order theory (even if they already exist in Mathlib) I have been skipping the results about finite orders. </p>\n<p>But I want to get  better at it, so I'd like to revisit some of the results I skipped. I found myself trying to formalize a simple fact about the <code>CovBy</code> relation (written <code>x ⋖ y</code>) which means that <code>x &lt; y</code> and there is no other intermediate element. As is the case for many such  results, the typical \"math\" proof is by infinite descent. You start to construct a descending chain, notice that the process can continue indefinitely, therefore contradiction. </p>\n<p>What would be a decent way of adapting such an infinite descent argument below? Is there a good way to use well-founded induction somehow?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">exists_covBy_of_lt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">push_neg</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"c1\">-- From x &lt; a, get x &lt; x₁ &lt; a</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">na</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_covBy_iff</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">na</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h11</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h12</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">na</span>\n<span class=\"w\">  </span><span class=\"c1\">-- From x &lt; x₁ &lt; a, get x &lt; x₂ &lt; x₁ &lt; a</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">x₁</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_covBy_iff</span><span class=\"w\"> </span><span class=\"n\">h11</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">x₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h21</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h22</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h2</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This can continue for ever, contradicting finiteness</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 484777269,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732731989
    },
    {
        "content": "<p>For natural numbers, infinite descent is just strong induction if you squint at it. Not sure what it would look like in this context, though</p>",
        "id": 484778176,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732732342
    },
    {
        "content": "<p>Right. Strong induction is more generally called well-founded induction. Mathlib has <code>Finite.to_wellFoundedLT</code> that says <code>&lt;</code> is well-founded for finite preorders. But I can't figure out the right way to leverage <code>WellFoundedLT P</code> for my example.</p>",
        "id": 484778824,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732732639
    },
    {
        "content": "<p>Maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT.induction#doc\">docs#WellFoundedLT.induction</a> ?</p>",
        "id": 484779643,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1732732977
    },
    {
        "content": "<p>I guess I'm really asking two questions. </p>\n<p>1) What's the proper way to turn \"infinite descent\" into \"well-founded induction\"<br>\n2) How to use well-founded induction in Lean?</p>\n<p>That seems to answer the second, but I'm still stuck on the \"math\" part before the formalization</p>",
        "id": 484780594,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732733393
    },
    {
        "content": "<p>Well, firstly, do you know that <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Fintype.toLocallyFiniteOrder#doc\">docs#Fintype.toLocallyFiniteOrder</a> exists, but not as an instance? That means you can use it in your proof. In particular, this gives you access to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Ico#doc\">docs#Finset.Ico</a>, and then you could presumably do induction on that.</p>\n<p>Also, once you have the instance I just mentioned, you also have access to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_iff_transGen_covBy#doc\">docs#lt_iff_transGen_covBy</a>. Then presumably you could just do induction on <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Relation.TransGen#doc\">docs#Relation.TransGen</a>.</p>",
        "id": 484783550,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732734587
    },
    {
        "content": "<p>Also, this exists in the library: <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=LT.lt.exists_le_covby#doc\">docs#LT.lt.exists_le_covby</a>, which I found with:</p>\n<p><span class=\"user-mention\" data-user-id=\"644391\">@loogle</span> CovBy, Exists, <a href=\"http://LT.lt\">LT.lt</a></p>\n<p>Note: this requires <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=IsStronglyAtomic#doc\">docs#IsStronglyAtomic</a> for which there's an instance given <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WellFoundedLT#doc\">docs#WellFoundedLT</a>, and as you mentioned, you can get that from <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finite.to_wellFoundedLT#doc\">docs#Finite.to_wellFoundedLT</a></p>",
        "id": 484784342,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732734939
    },
    {
        "content": "<p><span aria-label=\"search\" class=\"emoji emoji-1f50d\" role=\"img\" title=\"search\">:search:</span> <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Cover.html#exists_lt_lt_of_not_covBy\">exists_lt_lt_of_not_covBy</a>, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Order/Cover.html#LT.lt.exists_lt_lt\">LT.lt.exists_lt_lt</a>, and <a href=\"https://loogle.lean-lang.org/?q=CovBy%2C%20Exists%2C%20LT.lt\">12 more</a></p>",
        "id": 484784344,
        "sender_full_name": "loogle",
        "timestamp": 1732734940
    },
    {
        "content": "<p>(sorry, I was finding an element below a given one, and you want one <em>above</em>, so just turn all of these around).</p>",
        "id": 484784578,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732735057
    },
    {
        "content": "<p>Huh, I didn't realize <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_iff_transGen_covBy#doc\">docs#lt_iff_transGen_covBy</a> existed. In fact, I was working my way up to proving it for finite orders. Since my main goal is not to prove the result, but to gain facility at proving such results, I'll study everything you just linked to. Thanks!</p>",
        "id": 484784717,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732735110
    },
    {
        "content": "<p>Despite that your main goal is not to prove the result, here is a proof using the library lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">exists_covBy_of_lt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">to_wellFoundedGT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hw₁</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hw₂</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"bp\">.</span><span class=\"n\">exists_covby_le</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hw₁</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 484785132,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732735275
    },
    {
        "content": "<p>As a real answer to your question, I think the main thing to do in this case (if you were going to bash through a proof instead of using the handy classes / lemmas in Mathlib) is to use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>, or maybe <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.Nonempty.cons_induction#doc\">docs#Finset.Nonempty.cons_induction</a></p>",
        "id": 484785448,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732735412
    },
    {
        "content": "<p>Nice, thanks! It seems that <code>exists_covBy_le</code> requires an instance of <code>IsStronglyAtomic</code> which seems to be doing the heavy lifting here since that instance is essentially what I'm trying to show.</p>",
        "id": 484785659,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732735497
    },
    {
        "content": "<p>yes, indeed.</p>",
        "id": 484785698,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732735511
    },
    {
        "content": "<p>Probably what you want to do is look at the proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=instIsStronglyAtomicOfWellFoundedLT#doc\">docs#instIsStronglyAtomicOfWellFoundedLT</a></p>",
        "id": 484785763,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732735546
    },
    {
        "content": "<p>Yep, that's where I'm looking now.</p>",
        "id": 484785846,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732735567
    },
    {
        "content": "<p>For posterity, here's a verbosely commented solution that extract the main principles from Jireh's use of <code>exists_covby_le</code> above (i.e., spells out what that invocation is doing). </p>\n<p>In short, it relies on the fact that any set with a well-founded relation <code>R</code> has an <code>R</code>-minimal element. We get such an element with <code>WellFounded.min</code>. This is, of course, the natural way mathematically to short cut an infinite descent argument when you have a well-founded relation.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">exists_covBy_of_lt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_isMax_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Since P is finite, &lt; is well-founded</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Finite</span><span class=\"bp\">.</span><span class=\"n\">wellFounded_of_trans_of_irrefl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">))</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Sets with well-founded relations have minimal members.</span>\n<span class=\"w\">  </span><span class=\"c1\">-- We use a minimal member w of Set.Ioc = { a | x &lt; a ≤ y }</span>\n<span class=\"w\">  </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"bp\">.</span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"c1\">-- This minimal element is a member of the set, so x &lt; w and w ≤ y</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">hmem1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hmem2</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">WellFounded</span><span class=\"bp\">.</span><span class=\"n\">min_mem</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">⟩</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"c1\">-- To show x ⋖ w, we show that</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"c1\">-- x &lt; w</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hmem1</span>\n<span class=\"w\">  </span><span class=\"c1\">-- there is no c, s.t. x &lt; c &lt; w,</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">lt</span><span class=\"w\"> </span><span class=\"n\">nlt</span>\n<span class=\"w\">    </span><span class=\"c1\">-- any such c is in Set.Ioc x y</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">cmem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">nlt</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"n\">hmem2</span><span class=\"bp\">⟩</span>\n<span class=\"w\">    </span><span class=\"c1\">-- but since c &lt; w, this contradicts the minimality of w</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">WellFounded</span><span class=\"bp\">.</span><span class=\"n\">not_lt_min</span><span class=\"w\"> </span><span class=\"n\">wf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioc</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hy</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">cmem</span><span class=\"w\"> </span><span class=\"n\">nlt</span>\n</code></pre></div>",
        "id": 484800470,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732742170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300396\">Paul Rowe</span> has marked this topic as resolved.</p>",
        "id": 484800482,
        "sender_full_name": "Notification Bot",
        "timestamp": 1732742174
    },
    {
        "content": "<p>Even easier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">exists_covBy_of_lt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">exists_covBy_of_wellFoundedLT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not_isMax_iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>using a lemma I recently introduced (to show noetherian + artinian -&gt; finite length).</p>",
        "id": 484818589,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1732753191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span> because you wanted to know, here is how you would complete your argument via infinite descent:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">exists_covBy_of_lt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PartialOrder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_isMax_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra!</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">no_min</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoMinOrder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"bp\">?_⟩</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_covBy_iff</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">nonempty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nonempty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hc</span><span class=\"bp\">⟩⟩</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_finite</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>By showing that the subtype <code>Set.Ioi x</code> is nonempty and has no minimum, it has a <code>Infinite</code> instance, and because it is a subtype of a finite type, it has a <code>Finite</code> instance, and therefore we get a contradiction using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=not_finite#doc\">docs#not_finite</a>.</p>",
        "id": 484837858,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732767477
    },
    {
        "content": "<p>The point is still this: you really don't want to have to roll everything yourself. The \"hard\" lemma underlying the reasoning in the proof above is <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=exists_strictMono%27#doc\">docs#exists_strictMono'</a>. From this you get a strictly monotone, hence injective, function from <code>ℕ</code>, which allows you to conclude that a nonempty type with no minimum is infinite.</p>",
        "id": 484838838,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732768112
    },
    {
        "content": "<p>Here's a proof where you <em>do</em> build the function manually. It's not terrible, but not trivial either. <code>choose</code> is a very handy tactic.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">IsMax</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">⋖</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">not_isMax_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra!</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hz'</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">not_covBy_iff</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">&lt;|</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hz'</span><span class=\"bp\">⟩</span>\n<span class=\"w\">  </span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">key</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Ioi</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">f</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">not_injective_infinite_finite</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">strictAnti_nat_of_succ_lt</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">injective</span>\n</code></pre></div>\n<p>Here we're using the fact that there is no injective function from an infinite type (<code>ℕ</code>) to a finite type (<code>Set.Ioi x</code>), which contradicts that we just built one.</p>",
        "id": 484840307,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732769376
    },
    {
        "content": "<p>Cool, thanks. It’s certainly not my aim to roll everything myself. I’m not surprised it works to explicitly build the function, but I certainly wanted to figure out how to avoid it without just using a lemma with essentially the same content. These examples of different ways to prove it are super helpful!</p>",
        "id": 484941375,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732806545
    },
    {
        "content": "<p>The proof of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=lt_iff_transGen_covBy#doc\">docs#lt_iff_transGen_covBy</a> also has an interesting pattern. It does a recursive descent on <code>Ico x y</code> and uses the fact that at each step the size of the finite set is strictly smaller to show termination.</p>",
        "id": 484942356,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732806844
    },
    {
        "content": "<p>yes, the proof of <code>lt_iff_transGen_covBy</code> is essentially the first one I thought of. That was the source of my comment about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>.</p>",
        "id": 484953476,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732810646
    },
    {
        "content": "<p>Right. But I found it interesting that the proof doesn’t actually invoke <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.induction_on#doc\">docs#Finset.induction_on</a>. That is, it’s more recursive than inductive (which amounts to the same thing logically, of course).</p>",
        "id": 484958410,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732812558
    },
    {
        "content": "<p>I wouldn't say it does \"recursive descent on <code>Ico x y</code>\", although I understand why you used this langauge. I would say it does recursion on the inductive predicate <code>Relation.TransGen (· ⋖ ·)</code>, i.e., on the transitive closure of <code>CovBy</code>.</p>\n<p>Note, there is still some (very small) work to actually connect this up to prove the result you originally stated.</p>\n<p>The comment with <code>Finset.induction_on</code> is that you can use that to prove your result directly, without touching <code>Relation.TransGen</code>.</p>",
        "id": 484961663,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1732813835
    },
    {
        "content": "<p>Oh, I think I meant to point to <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=transGen_covBy_of_lt#doc\">docs#transGen_covBy_of_lt</a> instead. That’s the one that takes <code>Ico x y</code> and descends to <code>Ico x z</code>. When <code>x &lt; z</code> it invokes a recursive call. Regardless, I now have a nice set of examples to apply/adapt to other theorems.</p>",
        "id": 484963358,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1732814583
    }
]