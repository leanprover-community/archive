[
    {
        "content": "<p>So I want to turn a Finset into a list.  I found a function in finset called to_list that seems to do what I want, but I can't seem to access it.  For example, if X : Finset a, I tried <code>X.val.to_list</code>,  <code>X.1.to_list</code>,  and <code>X.to_list</code>.  In each occasion Lean complains that the field to_list is not in the environment. That is Finset.to_list and Multiset.to_list is not in the environment.</p>\n<p>Why can't I use to_list?  And is this a proper way to turn a Finset to a list?</p>",
        "id": 358841857,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269184
    },
    {
        "content": "<p>Are you looking at the mathlib3 docs instead of the mathlib4 docs? <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.toList#doc\">docs4#Finset.toList</a> is the mathlib4 one and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.to_list\">docs#finset.to_list</a> is the mathlib3 one.</p>",
        "id": 358842123,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684269290
    },
    {
        "content": "<p>I'm actually using the Github <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/finset/basic.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/data/finset/basic.lean</a> , whcih I thought was Lean 4.</p>",
        "id": 358842372,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269369
    },
    {
        "content": "<p>That's mathlib3 (generally, no number right now means version 3, and for version 4 you want to see a 4)</p>",
        "id": 358842551,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684269428
    },
    {
        "content": "<p>Notice also all the names are lower-case. Mathlib 4 naming convention is upper case types.</p>",
        "id": 358842608,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684269449
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Sort.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Finset/Sort.html</a> might be useful too for turning a finset into a list, since this can actually be computed, if you're wanting to evaluate things</p>",
        "id": 358842663,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684269476
    },
    {
        "content": "<p>Ah, I see.  It's toList.  Thanks!</p>",
        "id": 358842671,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269479
    },
    {
        "content": "<p>I noticed that that also has an (unsafe) <code>Repr</code> instance for <code>Finset</code>, which might be useful for debugging.</p>",
        "id": 358842758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684269492
    },
    {
        "content": "<p>Ah, great. I'll play around with it and see how it works.</p>",
        "id": 358842891,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269541
    },
    {
        "content": "<blockquote>\n<p>And is this a proper way to turn a Finset to a list?</p>\n</blockquote>\n<p>For what purpose? Sometimes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sort#doc\">docs4#Finset.sort</a> is a better choice</p>",
        "id": 358842972,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684269574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358842972\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>And is this a proper way to turn a Finset to a list?</p>\n</blockquote>\n<p>For what purpose? Sometimes <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Finset.sort#doc\">docs4#Finset.sort</a> is a better choice</p>\n</blockquote>\n<p>I'm just trying to print the Finset.  If I try <code>X.toList.map toString</code> I get the message \"invalid field notation, type is not of the form (C ...) where C is a constant...\"</p>",
        "id": 358843469,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269768
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"n\">Finset.sort.map</span> <span class=\"n\">toString</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">graph_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"k\">fun</span> <span class=\"n\">G</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"{Vertices = \"</span> <span class=\"bp\">++</span>\n            <span class=\"n\">String.intercalate</span> <span class=\"s2\">\", \"</span> <span class=\"o\">(</span><span class=\"n\">G.vertices.toList.map</span> <span class=\"n\">toString</span> <span class=\"o\">)</span> <span class=\"bp\">++</span>\n            <span class=\"s2\">\" : ¬ Edges = \"</span> <span class=\"bp\">++</span>\n            <span class=\"n\">String.intercalate</span> <span class=\"s2\">\", \"</span> <span class=\"o\">(</span><span class=\"n\">G.edges.map</span> <span class=\"n\">toString</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n            <span class=\"s2\">\"}\"</span>\n<span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Lean actually underlines the name of the instance and says that IR check failed at 'graph_to_string' unknown declaration at 'Finset.toList'.</p>",
        "id": 358843756,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684269878
    },
    {
        "content": "<p>I think you need to add <code>unsafe</code> before the word <code>instance</code></p>",
        "id": 358844172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270036
    },
    {
        "content": "<p>Well that certainly makes me feel safe about what I'm doing <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  What exactly does <code>unsafe</code> do?</p>",
        "id": 358844370,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270093
    },
    {
        "content": "<p>Though this sounds a bit like an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem; can you just add <code>deriving Repr</code> to your <code>Graph</code></p>",
        "id": 358844427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270116
    },
    {
        "content": "<p>But unsafe still doesn't seem to fix it.</p>",
        "id": 358844447,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270123
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>\n<p>You mean like this?</p>",
        "id": 358844573,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270167
    },
    {
        "content": "<p>Oh, I guess it gets unhappy about <code>property</code>?</p>",
        "id": 358846005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270633
    },
    {
        "content": "<p>Or does that just work?</p>",
        "id": 358846047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270651
    },
    {
        "content": "<p>It doesn't work.  Here is what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">vertex_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">v.name</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">edge_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">Edge</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">e</span> <span class=\"bp\">=&gt;</span>  <span class=\"s2\">\"(\"</span> <span class=\"bp\">++</span> <span class=\"n\">e.edge.fst.name</span> <span class=\"bp\">++</span> <span class=\"s2\">\", \"</span> <span class=\"bp\">++</span> <span class=\"n\">e.edge.snd.name</span> <span class=\"bp\">++</span> <span class=\"s2\">\")\"</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>\n<p>And at deriving Repr, Lean complains because there's not a Repr instance of vertex_list_to_string and edge_list_to_string.  I created the instances for vertices and edges, but not for a multiset of vertices and a list of string.</p>",
        "id": 358846350,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270768
    },
    {
        "content": "<p>You need to put <code>deriving Repr</code> on all of the <code>structures</code></p>",
        "id": 358846508,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270811
    },
    {
        "content": "<p>It used to work until I added <code>property</code> in Graph.  I needed to add this property because I wrote a program and couldn't prove it to be correct because I couldn't prove that each endpoint of the edges were in the vertices.  Hence, I had to define Graph as a structure that carried with it a proof that the endpoints of each edge were vertices of G.</p>",
        "id": 358846570,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270836
    },
    {
        "content": "<p>(I'm not at lean right now, so can't actually give you working code!)</p>",
        "id": 358846708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270884
    },
    {
        "content": "<p>When I put deriving Repr on Vertex, it tells me that it \"expected 'instance'\".  </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>",
        "id": 358846748,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270905
    },
    {
        "content": "<p>I think the syntax is <code>deriving Foo, Bar</code> not <code>deriving Foo, deriving Bar</code></p>",
        "id": 358846776,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684270921
    },
    {
        "content": "<p>It feels like I need to have more \"set up\" before I can use deriving Repr</p>",
        "id": 358846829,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684270927
    },
    {
        "content": "<p>Does fixing the syntax still not work?</p>",
        "id": 358846988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684271004
    },
    {
        "content": "<p>It doesn't appear to be working.  Is Bar supposed to be the name of the instance?  Like <code>deriving Repr, vertex_to_string</code>  doesn't seem to work.  It still says expected instance.</p>",
        "id": 358847113,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271052
    },
    {
        "content": "<p>I also tried <code>deriving Repr, instance vertex_to_string</code> and the same result followed.</p>",
        "id": 358847157,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271074
    },
    {
        "content": "<p>Yeah that's nonsense</p>",
        "id": 358847182,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684271087
    },
    {
        "content": "<p>I mean <code>deriving DecidableEq, Repr</code></p>",
        "id": 358847199,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684271098
    },
    {
        "content": "<p>Ohhh, okay that it.  That worked.</p>",
        "id": 358847254,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271117
    },
    {
        "content": "<p>Can I maybe chime in and go back to your definition of <code>Vertex</code>: do you really want it to be a string?</p>",
        "id": 358847256,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271117
    },
    {
        "content": "<p>I think that if you want to be able to \"print\" your vertices, you should put a <code>Repr</code> instance on the type on whose terms you build the graph.</p>",
        "id": 358847426,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358847256\">said</a>:</p>\n<blockquote>\n<p>Can I maybe chime in and go back to your definition of <code>Vertex</code>: do you really want it to be a string?</p>\n</blockquote>\n<p>I'm new and picked a mathematical object to define and work with.  At the current moment, without the wisdowm and foresight of an experienced user, I chose to define a vertex as simply an object with a label.  I'm sure that more sophisticated approaches would define things a bit differently but I was just trying to define things the way that I learned them in an undergraduate course.  </p>\n<p>Moreover, I also wanted to define algorithms on these graphs and prove that the algorithms are correct.  Hence, I kind of need some labeling system on the vertices and edges.  Hence the reason why I have them as structs with a field for a string.</p>",
        "id": 358847538,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271245
    },
    {
        "content": "<p>Looking at your code, maybe you could define an <code>Edge</code> to have a <code>source</code> and a <code>target</code>, rather than an ordered pair.</p>",
        "id": 358847541,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271248
    },
    {
        "content": "<p>So, let's see if we can get you started with something that will be easier.</p>",
        "id": 358847675,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271299
    },
    {
        "content": "<p>Okay, but remember I'm a new user and things can quickly become esoteric.  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 358847748,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271340
    },
    {
        "content": "<p>I've been worried about finding the easiest implementation to work with because in some instances an easier implementation might not be the canonical interpretation of the object in a math class.   And I just want the implementation to be readable to regular math students with little to no computer science back ground.  There seems to be a delicate balance between the two that I haven't quite found.</p>",
        "id": 358848256,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684271528
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myEdge</span> <span class=\"o\">:</span> <span class=\"n\">Edge</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Edge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span>\n    <span class=\"n\">exact</span> <span class=\"n\">toString</span> <span class=\"n\">e.source</span> <span class=\"bp\">++</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">e.target</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">myEdge</span>\n</code></pre></div>",
        "id": 358849027,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271868
    },
    {
        "content": "<p>You get an <code>Edge (a type)</code> by providing a pair of elements of <code>type</code>.</p>",
        "id": 358849232,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271929
    },
    {
        "content": "<p>For instance, the <code>def</code> construct an Edge on the natural numbers.</p>",
        "id": 358849298,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684271953
    },
    {
        "content": "<p>Next, you define a <code>ToString</code> instance on an <code>Edge</code>, by assuming that there already is a <code>ToString</code> instance on the type whose elements you are considering.  You get to define how you want to represent the edge joining <code>a</code> to <code>b</code>.  I chose to represent it by using the representation for <code>a</code> then a comma, then the representation for <code>b</code>.</p>",
        "id": 358849563,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272033
    },
    {
        "content": "<p>(note the point in my <code>Repr</code> comments was \"you can get a default representation of your object without doing any work\". If you want to customize how it looks, rolling your own instead is fine)</p>",
        "id": 358849679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684272077
    },
    {
        "content": "<p>In the <code>exact</code> line, you get to choose what you want.  If you prefer a \"list-style\" printing, you could say instead</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"n\">exact</span> <span class=\"s2\">\"[\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">e.source</span> <span class=\"bp\">++</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">e.target</span> <span class=\"bp\">++</span> <span class=\"s2\">\"]\"</span>\n</code></pre></div>",
        "id": 358849708,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272088
    },
    {
        "content": "<p>This way, you \"outsource\" the printing to the target type.  You are likely going to define graphs on Nat, on String, on some enumerated inductive type.  In each case, you can leverage a \"printing\" instance on the type of the vertices to get your printed version.</p>",
        "id": 358850221,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272255
    },
    {
        "content": "<p>Here is another example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myEdge</span> <span class=\"o\">:</span> <span class=\"n\">Edge</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n    <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myStringEdge</span> <span class=\"o\">:</span> <span class=\"n\">Edge</span> <span class=\"n\">String</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"s2\">\"sou\"</span>\n    <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"s2\">\"tar\"</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">ToString</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Edge</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span>\n    <span class=\"n\">exact</span> <span class=\"s2\">\"[\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">e.source</span> <span class=\"bp\">++</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">++</span> <span class=\"n\">toString</span> <span class=\"n\">e.target</span> <span class=\"bp\">++</span> <span class=\"s2\">\"]\"</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">myEdge</span>   <span class=\"c1\">--  [1,2]</span>\n<span class=\"k\">#eval</span> <span class=\"n\">myStringEdge</span>  <span class=\"c1\">--  [sou,tar]</span>\n</code></pre></div>",
        "id": 358850440,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272343
    },
    {
        "content": "<p>Lean already knows how to print <code>Nat</code> and <code>String</code>, I simply told it how to print an edge, given that notion.</p>",
        "id": 358850548,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272369
    },
    {
        "content": "<p>In my definition I pushed the parameter into the structure and forced it to be a string, because I didn't think that I would ever really care about the type of the vertex, I just wanted to let them all be strings.  I reasoned that if they're all strings, I wouldn't have to worry about the printing procedure as much since printing strings has been taken care of in Lean. </p>\n<p>What is the point of letting Edge be an \"edge of ___\"?  Is it just going to make things easier to work with?</p>",
        "id": 358850948,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684272526
    },
    {
        "content": "<p>I think this is the line of reasoning that gives you things like <code>sh</code> where the <em>only</em> type of variables is strings :)</p>",
        "id": 358851038,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684272572
    },
    {
        "content": "<p>What if you want a graph where the nodes are natural numbers and there are edges whenever one node divides another?</p>",
        "id": 358851250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684272666
    },
    {
        "content": "<p>For instance, if you wanted to define the \"divisibility graph\", having access to <code>Nat</code> as a vertex set is useful...</p>",
        "id": 358851328,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272701
    },
    {
        "content": "<p>Another thing about the implementation that you posted is that I get error messages if I try to add <code>deriving DecidableEq</code> and while I've been working on this stuff, I've found that I certainly want there to be a decidable equality between these edges and manually defining the decidable equality was a bit of work.</p>",
        "id": 358851470,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684272752
    },
    {
        "content": "<p>Or if you wanted to work with a finite graph and use dec_trivial, it might be helpful to work with enumerated types.  For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">vertSet</span> <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">C</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">vertSet</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"bp\">|</span> <span class=\"n\">vertSet.A</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"A\"</span> <span class=\"bp\">|</span> <span class=\"n\">vertSet.B</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"B\"</span> <span class=\"bp\">|</span> <span class=\"n\">vertSet.C</span> <span class=\"bp\">=&gt;</span> <span class=\"s2\">\"C\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myIndEdge</span> <span class=\"o\">:</span> <span class=\"n\">Edge</span> <span class=\"n\">vertSet</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"n\">vertSet.A</span>\n    <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"n\">vertSet.B</span> <span class=\"o\">}</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">myIndEdge</span>\n</code></pre></div>",
        "id": 358851478,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272755
    },
    {
        "content": "<p>I think that you can derive DecidableEq if you assume it for the base type.</p>",
        "id": 358851590,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272802
    },
    {
        "content": "<p>Great examples of why I would want the parameter.</p>",
        "id": 358851621,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684272812
    },
    {
        "content": "<p>Note that the implementation of the instance is a completely arbitrary choice: I do not have to use the string \"A\" for the vertex called <code>vertSet.A</code>, of course.</p>",
        "id": 358851697,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272843
    },
    {
        "content": "<p>(I mean the <code>ToString</code> instance on <code>vertSet</code>, though for sanity it is helpful to use the same name, of course!)</p>",
        "id": 358851767,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684272877
    },
    {
        "content": "<p>Does <code>deriving ToString</code> on <code>vertSet</code> do that for you?</p>",
        "id": 358851876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1684272925
    },
    {
        "content": "<p>Sorry it's taking a minute to respond.  I'm reading through everything.</p>",
        "id": 358852062,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684273005
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span> <span class=\"n\">vertSet</span> <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">C</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">ToString</span>\n<span class=\"c1\">--  default handlers have not been implemented yet, class: 'ToString' types: [vertSet]</span>\n</code></pre></div>",
        "id": 358852118,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273026
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , so no!</p>",
        "id": 358852167,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273050
    },
    {
        "content": "<p>I think Kyle has implemented a handler that covers this</p>",
        "id": 358852674,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1684273235
    },
    {
        "content": "<p>Aren't there going to be issues with leaving the vertices undefined?  For example, when I do </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">proof</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">source</span> <span class=\"n\">and</span> <span class=\"n\">target</span> <span class=\"n\">are</span> <span class=\"k\">in</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I feel like there's going to be problems at <code>Finset Vertex</code>.  So I would need to change the way that I define the Graph too.</p>",
        "id": 358852946,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684273343
    },
    {
        "content": "<p>I probably would define a structure <code>Graph (of a type)</code> and simply assume that every term of the type is a vertex.  If you assume that the type is finite, you have a finset of vertices.</p>",
        "id": 358853166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273451
    },
    {
        "content": "<p>Ah, okay I'll work on implementing these ideas.</p>",
        "id": 358853381,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684273550
    },
    {
        "content": "<p>So, something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"o\">(</span><span class=\"n\">Edge</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 358853459,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273567
    },
    {
        "content": "<p>But wouldn't that prevent me from being able to talk about G - v, where v is a vertex?</p>",
        "id": 358853686,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684273670
    },
    {
        "content": "<p>Then, every term of <code>α</code> is a vertex.  Some of these vertices appear as endpoints of edges.</p>",
        "id": 358853709,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358852674\">said</a>:</p>\n<blockquote>\n<p>I think Kyle has implemented a handler that covers this</p>\n</blockquote>\n<p>There's <code>deriving ToExpr</code> and I think you can maybe use <code>toString (toExpr x)</code>?</p>",
        "id": 358853811,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684273719
    },
    {
        "content": "<p>Here, there might be a difference between a subgraph and a graph that happens to be a subgraph.</p>",
        "id": 358853822,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273723
    },
    {
        "content": "<p>So, \"the mathlib way\" would probably be to define a \"Type of Subgraphs\", whose terms are <em>not</em> Graphs, but that have coercions to a Graph.</p>",
        "id": 358853930,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358853686\">said</a>:</p>\n<blockquote>\n<p>But wouldn't that prevent me from being able to talk about G - v, where v is a vertex?</p>\n</blockquote>\n<p>No, it simply means G - v won't be of the same type as G (it will have type <code>Graph {a // a \\ne v}</code>)</p>",
        "id": 358853931,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1684273774
    },
    {
        "content": "<p>This is all quite fiddly, and it's hard to find a working design that's not mathlib's.</p>",
        "id": 358854081,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1684273824
    },
    {
        "content": "<p>This means that you will get more or less for free that the Type of Subgraphs is a lattice, and you can get the machinery of lattices to help you with inductions, unions, intersections... without having to redefine these notions from scratch.</p>",
        "id": 358854118,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <code>toExpr</code> is an <code>unknown identifier</code>: should I <code>import</code>/<code>open</code> something?</p>",
        "id": 358854367,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684273929
    },
    {
        "content": "<p>You need to import <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/DeriveToExpr.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/DeriveToExpr.html</a> for <code>derive ToExpr</code> and then I think it's <code>ToExpr.toExpr</code></p>",
        "id": 358854501,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684273990
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"472585\">@Jonathan Whitehead</span> the constructions of Subgraphs that I am thinking of is entirely analogous to the one of several, similar ones in mathlib, for instance <code>submodule</code>.</p>",
        "id": 358854529,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358853930\">said</a>:</p>\n<blockquote>\n<p>So, \"the mathlib way\" would probably be to define a \"Type of Subgraphs\", whose terms are <em>not</em> Graphs, but that have coercions to a Graph.</p>\n</blockquote>\n<p>In practice the algebra hierarchy design doesn't really work for graphs. Most algebraic objects \"are\" a type, but a graph isn't a type. The coercion design depends on the fact that there is a coercion from a subobject to a type, and that type can be given the additional structure through typeclass inference.</p>",
        "id": 358855047,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684274262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358854529\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> the constructions of Subgraphs that I am thinking of is entirely analogous to the one of several, similar ones in mathlib, for instance <code>submodule</code>.</p>\n</blockquote>\n<p>Okay, I'm going to work on these ideas and reread all of your comments.  I'm just worried that the framework will be pigeon-hole me into writing an implementation that isn't very \"mathematician\" friendly.  Personally, I don't mind because I'm learning a lot of new ideas, but if things get too strange it will deter some of my friends.</p>",
        "id": 358855187,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684274335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Also, you might want a coercion from subgraphs to graphs, but, at least last I experimented, you can't make a <code>Coe</code> instance that goes to <code>Graph ?_</code> and have it solve for <code>?_</code>. It had something to do with universe variables not getting unified, if I remember correctly.</p>",
        "id": 358855395,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684274432
    },
    {
        "content": "<p>For the record, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.DeriveToExpr</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">vertSet</span>\n  <span class=\"bp\">|</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"n\">B</span> <span class=\"bp\">|</span> <span class=\"n\">C</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">ToExpr</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"n\">vertSet</span> <span class=\"n\">where</span>\n  <span class=\"n\">toString</span> <span class=\"o\">:=</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">toString</span> <span class=\"o\">(</span><span class=\"n\">toExpr</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">vertSet.A</span>  <span class=\"c1\">--  vertSet.A</span>\n</code></pre></div>",
        "id": 358855407,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274446
    },
    {
        "content": "<p>Sure, I have thought about how to define graphs in mathlib only after this thread started...</p>",
        "id": 358855505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"472585\">@Jonathan Whitehead</span> keep in mind that \"finite\" and \"concrete\" structures have a tendency of being hard to work with.  It is often the case that the more abstract something is, the easier it will be to formalize.</p>",
        "id": 358855894,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358855894\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"472585\">Jonathan Whitehead</span> keep in mind that \"finite\" and \"concrete\" structures have a tendency of being hard to work with.  It is often the case that the more abstract something is, the easier it will be to formalize.</p>\n</blockquote>\n<p>Ah, never thought about how concrete things tend to be more difficult.  Good to know.</p>",
        "id": 358856055,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684274754
    },
    {
        "content": "<p>I suppose another way to think about Graphs is to define the vertex to be a list of vertices with an adjacency relation on them...  But that might be stranger and harder to work with.  But it seems like it might be easier to do things like vertex deletion and to talk about isolated vertices?</p>",
        "id": 358856242,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684274840
    },
    {
        "content": "<p>I have not really though about this, but maybe, following what you say, it might make sense to have the edges be a symmetric relation on a type.</p>",
        "id": 358856484,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274958
    },
    {
        "content": "<p>(or not symmetric, if you want to do directed graphs)</p>",
        "id": 358856526,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684274978
    },
    {
        "content": "<p>Definitions are hard.</p>",
        "id": 358856677,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1684275047
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358856484\">said</a>:</p>\n<blockquote>\n<p>I have not really though about this, but maybe, following what you say, it might make sense to have the edges be a symmetric relation on a type.</p>\n</blockquote>\n<p>Yeah, I was also thinking about this when we defined edges to have sources and targets.   I realize that these are just identifiers and can be changed but they seem to imply directedness.</p>",
        "id": 358856690,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684275054
    },
    {
        "content": "<p>So, I do not know if this will work, but it might be fun to experiment with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">adj</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">adj</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 358856718,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275070
    },
    {
        "content": "<p>And with graphs, there are a ton of things to define. Maybe pick a theorem first and see what definitions lend itself to it?</p>",
        "id": 358856751,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1684275088
    },
    {
        "content": "<p>Do you know about <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph#doc\">docs4#SimpleGraph</a> <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> ?</p>",
        "id": 358856795,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275109
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I just learned about it!  And, while I was typing the definition, I was wondering if I wanted to include irreflexivity or reflexivity as a condition!</p>",
        "id": 358856940,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275173
    },
    {
        "content": "<p>Ok, so you might also just be discovering <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Subgraph#doc\">docs4#SimpleGraph.Subgraph</a> ?</p>",
        "id": 358857021,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275216
    },
    {
        "content": "<p>It seems like I got the capitalization wrong...</p>",
        "id": 358857031,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358857021\">said</a>:</p>\n<blockquote>\n<p>Ok, so you might also just be discovering <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Subgraph#doc\">docs4#SimpleGraph.Subgraph</a> ?</p>\n</blockquote>\n<p>This seems exactly where I was headed...</p>",
        "id": 358857130,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275253
    },
    {
        "content": "<p>For Jonathan's purposes, a problem with using a relation on a type is that it has no computational content. I've gotten the sense that he wants to do some computations (with <code>#eval</code> for example), and it'd be better to avoid <code>Prop</code> and instead use some actual data for that.</p>",
        "id": 358857205,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275295
    },
    {
        "content": "<p>You <em>can</em> do computations with <code>SimpleGraph</code>, but it takes defining Decidable instances, which are sort of a lot to master when you're just learning Lean.</p>",
        "id": 358857272,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358856751\">said</a>:</p>\n<blockquote>\n<p>And with graphs, there are a ton of things to define. Maybe pick a theorem first and see what definitions lend itself to it?</p>\n</blockquote>\n<p>My goal is to write programs for some algorithms and show that they're correct.   I took a course where \"proofs\" of algorithms were given (e.g. augmenting path, blosom algorithms, etc.), but the proofs were very hand wavey.  So I wanted to see if I could formalize the algorithms and prove they are correct.</p>",
        "id": 358857282,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684275342
    },
    {
        "content": "<p>I would suggest ignoring how mathlib does things for that and write a <code>Graph</code> type that will suit your own purposes for some algorithm</p>",
        "id": 358857408,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275401
    },
    {
        "content": "<p>As you implement a few algorithms, you can revisit whether you made a good choice in your design, and iterate.</p>",
        "id": 358857432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275419
    },
    {
        "content": "<p>It's too hard to come up with the right definition up front. You need to know where it's all going to know where you were supposed to start</p>",
        "id": 358857479,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275450
    },
    {
        "content": "<p>And maybe even start with something moderately simple, like showing that a connected graph on 3 vertices must have at least 2 edges.</p>",
        "id": 358857573,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358857408\">said</a>:</p>\n<blockquote>\n<p>I would suggest ignoring how mathlib does things for that and write a <code>Graph</code> type that will suit your own purposes for some algorithm</p>\n</blockquote>\n<p>Yes!  This is what I've been doing.  I wrote some simple programs and proved them, but then I wrote a certain program that I couldn't prove without modifying my definition of a graph to include a proof that the end points of edges are in the vertex set.  Hence, I went back to modify my definition of a Graph and then things started breaking <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 358857608,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684275526
    },
    {
        "content": "<p>That might sound simple <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> (most simple things in combinatorics do), but connectivity takes some work to develop to be usable</p>",
        "id": 358857680,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275572
    },
    {
        "content": "<p>It should be pretty straightforward with the mathlib SimpleGraph library though, and that would be a welcome lemma if anyone wants to prove it</p>",
        "id": 358857712,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275601
    },
    {
        "content": "<p>I think that the first project that I worked on was to show something about connected graphs and it was hard...</p>",
        "id": 358857834,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275633
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SimpleGraph.Connected#doc\">docs4#SimpleGraph.Connected</a> is the connectivity predicate</p>",
        "id": 358857916,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275683
    },
    {
        "content": "<p>By the way, speaking of a computation, in the mathlib3 archive there's <a href=\"https://github.com/leanprover-community/mathlib/blob/master/archive/100-theorems-list/54_konigsberg.lean\">the Konigsberg bridges problem</a></p>",
        "id": 358858070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684275751
    },
    {
        "content": "<p>I certainly did not define Preconnected and went straight to Connected!</p>",
        "id": 358858077,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684275755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Here's the well-known \"Damiano's lemma\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">G.edgeSet</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">damiano</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">G.Connected</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.edgeFinset.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fintype.two_lt_card_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.one_lt_card_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_toFinset</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">exists_and_left</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim_path</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">pab</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">cases</span> <span class=\"n\">pab</span>\n  <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">hab</span>\n  <span class=\"n\">rename_i</span> <span class=\"n\">v</span> <span class=\"n\">hav</span> <span class=\"n\">pvb</span>\n  <span class=\"n\">cases</span> <span class=\"n\">pvb</span>\n  <span class=\"bp\">·</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G.mem_edgeSet.mpr</span> <span class=\"n\">hav</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">pca</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n    <span class=\"n\">cases</span> <span class=\"n\">pca</span>\n    <span class=\"bp\">·</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">hac</span>\n    <span class=\"bp\">·</span> <span class=\"n\">rename_i</span> <span class=\"n\">hcv</span> <span class=\"n\">_</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G.mem_edgeSet.mpr</span> <span class=\"n\">hcv</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_or</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n  <span class=\"bp\">·</span> <span class=\"n\">rename_i</span> <span class=\"n\">w</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G.mem_edgeSet.mpr</span> <span class=\"n\">hav</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">G.mem_edgeSet.mpr</span> <span class=\"n\">hvw</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Walk.cons_isPath_iff</span><span class=\"o\">,</span> <span class=\"n\">Walk.support_cons</span><span class=\"o\">,</span> <span class=\"n\">List.find</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">not_or</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hp</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">Sym2.rel_iff</span><span class=\"o\">,</span> <span class=\"n\">hp.2.1</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">]</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hp</span>\n</code></pre></div>\n<p><em>Edit:</em> Refined a very little</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">SimpleGraph.Adj.mem_edgeSet</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.Adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edgeSet</span> <span class=\"o\">:=</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">G.edgeSet</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">damiano</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">G.Connected</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.edgeFinset.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Fintype.two_lt_card_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.one_lt_card_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_toFinset</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">exists_and_left</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim_path</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">pab</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"n\">cases</span> <span class=\"n\">pab</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">hab</span>\n  <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">hav</span> <span class=\"n\">pvb</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">cases</span> <span class=\"n\">pvb</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hav.mem_edgeSet</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">pca</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n      <span class=\"n\">cases</span> <span class=\"n\">pca</span> <span class=\"k\">with</span>\n      <span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">hac</span>\n      <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">hcv</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hcv.mem_edgeSet</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">not_or</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">]</span>\n    <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">hvw</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hav.mem_edgeSet</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hvw.mem_edgeSet</span><span class=\"o\">,</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">⟩</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Walk.cons_isPath_iff</span><span class=\"o\">,</span> <span class=\"n\">Walk.support_cons</span><span class=\"o\">,</span> <span class=\"n\">List.find</span><span class=\"bp\">?</span><span class=\"o\">,</span> <span class=\"n\">List.mem_cons</span><span class=\"o\">,</span> <span class=\"n\">not_or</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hp</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Quotient.eq</span><span class=\"o\">,</span> <span class=\"n\">Sym2.rel_iff</span><span class=\"o\">,</span> <span class=\"n\">hp.2.1</span><span class=\"o\">,</span> <span class=\"n\">false_and</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">]</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n      <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 358862341,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684277994
    },
    {
        "content": "<p>The proof is a rough draft, and there are likely some hidden lemmas just waiting to be extracted</p>",
        "id": 358862515,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1684278072
    },
    {
        "content": "<p>Kyle, I simply extracted one lemma from your proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Combinatorics.SimpleGraph.Connectivity</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">SimpleGraph</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">SimpleGraph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Fintype</span> <span class=\"n\">G.edgeSet</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">G.Connected</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Connected.mem_edgeSet_of_ne</span> <span class=\"o\">(</span><span class=\"n\">hva</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edgeSet</span> <span class=\"n\">G</span> <span class=\"bp\">∧</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"n\">v</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim_path</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">⟨</span><span class=\"n\">pab</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"k\">match</span> <span class=\"n\">pab</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Walk.nil</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"n\">absurd</span> <span class=\"n\">rfl</span> <span class=\"n\">hva</span>\n  <span class=\"bp\">|</span> <span class=\"n\">Walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">Connected.one_lt_of_two_lt</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Fintype.card</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">G.edgeFinset.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Finset.one_lt_card_iff</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_toFinset</span><span class=\"o\">,</span> <span class=\"n\">ne_eq</span><span class=\"o\">,</span> <span class=\"n\">exists_and_left</span><span class=\"o\">]</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">hac</span><span class=\"o\">,</span> <span class=\"n\">hbc</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">Fintype.two_lt_card_iff.mp</span> <span class=\"n\">hv</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">,</span> <span class=\"n\">ae</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc.mem_edgeSet_of_ne</span> <span class=\"n\">hab</span>\n  <span class=\"n\">use</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">e</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">pv</span>\n  <span class=\"bp\">.</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">af</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc.mem_edgeSet_of_ne</span> <span class=\"n\">hbc.symm</span>\n    <span class=\"n\">use</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hac.symm</span><span class=\"o\">,</span> <span class=\"n\">hbc.symm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">af</span>\n  <span class=\"bp\">.</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">be</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hc.mem_edgeSet_of_ne</span> <span class=\"n\">hab.symm</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"k\">fun</span> <span class=\"n\">ef</span> <span class=\"bp\">↦</span> <span class=\"n\">pv</span> <span class=\"o\">((</span><span class=\"n\">Sym2.mem_and_mem_iff</span> <span class=\"n\">hab</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">⟨</span><span class=\"n\">ae</span><span class=\"o\">,</span> <span class=\"n\">ef</span> <span class=\"bp\">▸</span> <span class=\"n\">be</span><span class=\"o\">⟩)⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">SimpleGraph</span>\n</code></pre></div>",
        "id": 358875258,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684285282
    },
    {
        "content": "<p>I know we discussed defining things differently, but it really bothers me that I can't get this simple print function to work.  So I kept working on it and I feel like there's an issue happening with the printing module for Finsets and Multisets.  Below is the code that I wrote and the error message I receive is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">IR</span> <span class=\"n\">check</span> <span class=\"n\">failed</span> <span class=\"n\">at</span> <span class=\"bp\">'</span><span class=\"n\">finsetToList.loop._rarg'</span><span class=\"o\">,</span> <span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">unknown</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">Finset.toList'</span>\n</code></pre></div>\n<p>The reason why I feel like something is going on with porting some code from Lean 3 to 4 is because sometimes the tool tips mention to_list and sometimes they mention toList.  I can #check toList, but the error says toList is unknown. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">finset_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String.intercalate</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">$</span> <span class=\"n\">f.toList.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v.name</span><span class=\"o\">)</span>\n<span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 358906948,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684306875
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 358907435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307044
    },
    {
        "content": "<p>I also tried creating my own function to send a Finset to List but Lean kept complaining that it couldn't determine if the program terminated:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">partial</span> <span class=\"kd\">def</span> <span class=\"n\">finsetToList</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">DecidableEq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">rec</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">s.to_list</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">l.reverse</span>\n    <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">loop</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s.erase</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"n\">loop</span> <span class=\"o\">[]</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 358907500,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307077
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.List.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Finset.Basic</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Vertex</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Edge</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">Vertex</span> <span class=\"bp\">×</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n  <span class=\"n\">deriving</span> <span class=\"n\">DecidableEq</span><span class=\"o\">,</span> <span class=\"n\">Repr</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">finset_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String.intercalate</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">$</span> <span class=\"n\">f.toList.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v.name</span><span class=\"o\">)</span>\n<span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">edge_list_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"n\">l</span> <span class=\"bp\">=&gt;</span>  <span class=\"n\">String.intercalate</span> <span class=\"s2\">\", \"</span> <span class=\"bp\">$</span> <span class=\"n\">l.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">edge</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">edge.name</span><span class=\"o\">)</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Graph</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">vertices</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Edge</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">edges</span><span class=\"o\">,</span> <span class=\"n\">Prod.fst</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span> <span class=\"bp\">∧</span> <span class=\"n\">Prod.snd</span> <span class=\"n\">e.edge</span> <span class=\"bp\">∈</span> <span class=\"n\">vertices</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Repr</span>\n</code></pre></div>",
        "id": 358907622,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307139
    },
    {
        "content": "<p>I think that the issue is that <code>f.toList</code> is interpreted as <code>Finset.toList</code>, since <code>f</code> has Type <code>Finset ...</code>.  This is simply saying that <del>there is no function to go from a <code>Finset</code> to a <code>List</code></del> there is one.</p>",
        "id": 358907714,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684307172
    },
    {
        "content": "<p>For the graph, <code>deriving Repr</code> says that it fails to find an instance of Repr (Finset Vertex), so I'm trying to make one.</p>",
        "id": 358907723,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307178
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 358907799,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307212
    },
    {
        "content": "<p>I was missing an import, let me keep digging!</p>",
        "id": 358907915,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684307267
    },
    {
        "content": "<p>Thanks, I'll keep trying too.</p>",
        "id": 358907994,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307285
    },
    {
        "content": "<p>the issue is that <code>Finset.toList</code> exists but is <code>noncomputable</code>. That's why the error is reported in a weird place, the compiler is complaining, not the typechecker</p>",
        "id": 358908004,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358908004\">said</a>:</p>\n<blockquote>\n<p>the issue is that <code>Finset.toList</code> exists but is <code>noncomputable</code>. That's why the error is reported in a weird place, the compiler is complaining, not the typechecker</p>\n</blockquote>\n<p>Ah, yes, I remember seeing that it was noncomputable.  Is there some work around?</p>",
        "id": 358908045,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307322
    },
    {
        "content": "<p>Mario beat me to it!  You can add <code>noncomputable</code> before the <code>instance</code> to get it to compile.</p>",
        "id": 358908100,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684307347
    },
    {
        "content": "<p>Like I said, I even tried making my own toList function, but couldn't figure out how to convince lean that it terminated.</p>",
        "id": 358908101,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307347
    },
    {
        "content": "<p>Yes!  You guys just fixed my problem in a couple minutes that I worked on for hours <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 358908186,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307389
    },
    {
        "content": "<p>the power of a good <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> :)</p>",
        "id": 358908219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307403
    },
    {
        "content": "<p>Will I have to worry about it being noncomputable in any of my concrete examples?</p>",
        "id": 358908312,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307430
    },
    {
        "content": "<p>I guess I'm not really relying on printing stuff out, it's just for the user experience.</p>",
        "id": 358908349,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307446
    },
    {
        "content": "<p>probably, if you want to run the <code>toString</code> instance</p>",
        "id": 358908351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307446
    },
    {
        "content": "<p>for a <code>ToString</code> instance it is generally useless if it is not computable</p>",
        "id": 358908430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307481
    },
    {
        "content": "<p>Ah, but I guess declaring that it's noncomputable didn't fix the <code>deriving Repr</code> in the Graph structure.</p>",
        "id": 358908439,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307484
    },
    {
        "content": "<p>Yeah, letting it be noncomputable makes lean top complaining, but makes it unusable.</p>",
        "id": 358908832,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307645
    },
    {
        "content": "<p>Also, I think that <code>Finset Vertex</code> does not mean what you think it does...</p>",
        "id": 358908939,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684307702
    },
    {
        "content": "<p>here's a computable implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">finset_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsTrans</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsAntisymm</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsTotal</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String.intercalate</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">$</span> <span class=\"n\">f.val.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v.name</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 358909003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1684307736
    },
    {
        "content": "<p>Mario is being very conservative with the choice of names for his <code>let</code>s...</p>",
        "id": 358909454,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684307910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113489-new-members/topic/Using.20the.20Mathlib.2C/near/358909003\">said</a>:</p>\n<blockquote>\n<p>here's a computable implementation:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">finset_to_string</span> <span class=\"o\">:</span> <span class=\"n\">ToString</span> <span class=\"o\">(</span><span class=\"n\">Finset</span> <span class=\"n\">Vertex</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsTrans</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsAntisymm</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">let</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">IsTotal</span> <span class=\"n\">String</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">fun</span> <span class=\"n\">f</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">String.intercalate</span> <span class=\"s2\">\",\"</span> <span class=\"bp\">$</span> <span class=\"n\">f.val.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">v.name</span><span class=\"o\">)</span> <span class=\"bp\">|&gt;.</span><span class=\"n\">sort</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">·</span><span class=\"o\">)</span>\n<span class=\"o\">⟩</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>When I try to use it I get an error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"bp\">'</span><span class=\"n\">sort'</span><span class=\"o\">,</span> <span class=\"n\">the</span> <span class=\"n\">environment</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"n\">contain</span> <span class=\"bp\">'</span><span class=\"n\">Multiset.sort'</span>\n  <span class=\"n\">Multiset.map</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">v</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">m.3236</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"n\">f.val</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Multiset</span>\n</code></pre></div>",
        "id": 358909622,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684307988
    },
    {
        "content": "<p><code>import Mathlib.Data.Multiset.Sort</code></p>",
        "id": 358909791,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684308041
    },
    {
        "content": "<p>Ah yeah, thanks I'll work on looking through it.   I'll also look into understanding the Finset a little better.</p>",
        "id": 358909934,
        "sender_full_name": "Jonathan Whitehead",
        "timestamp": 1684308103
    },
    {
        "content": "<p>Here is an example, in case it is helpful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">attempt</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span><span class=\"o\">[⟨</span><span class=\"s2\">\"hello\"</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"s2\">\"world\"</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"s2\">\"!\"</span><span class=\"o\">⟩]</span><span class=\"bp\">⟧</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">attempt</span>  <span class=\"c1\">--  !,hello,world</span>\n</code></pre></div>",
        "id": 358912229,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684308969
    },
    {
        "content": "<p>I do not think that the design is particularly ergonomic, but I found this funny and confusing!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">getWords</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Finset</span> <span class=\"n\">Vertex</span> <span class=\"n\">where</span>\n  <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"bp\">⟦</span> <span class=\"n\">S.splitOn.map</span> <span class=\"k\">fun</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"bp\">⟧</span>\n  <span class=\"n\">nodup</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">getWords</span> <span class=\"s2\">\"My words are the vertices of a graph\"</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">getWords</span> <span class=\"s2\">\"     \"</span><span class=\"o\">)</span>\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">getWords</span> <span class=\"s2\">\" , , \"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 358915518,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1684310252
    }
]