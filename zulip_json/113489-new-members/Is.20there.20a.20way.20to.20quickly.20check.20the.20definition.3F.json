[
    {
        "content": "<p>Is there a quick way of checking how, say, an inner product is defined? Here's an example: I want to see what these two definitions expand to without going to the documentation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟫_</span><span class=\"n\">ℝ</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟫_</span><span class=\"n\">ℂ</span>\n</code></pre></div>",
        "id": 465089047,
        "sender_full_name": "jsodd",
        "timestamp": 1724651194
    },
    {
        "content": "<p>If you guess how they are defined, you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟫_</span><span class=\"n\">ℝ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n</code></pre></div>",
        "id": 465089223,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724651312
    },
    {
        "content": "<p>Well, if I could always guess the definitions, I probably wouldn't need this <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 465089385,
        "sender_full_name": "jsodd",
        "timestamp": 1724651425
    },
    {
        "content": "<p>My point is that you only need to know what the outermost symbol is (eg the above works for both <code>⟪x, y⟫_ℂ := ∑ i, conj (x i) * y i</code> and <code>⟪x, y⟫_ℂ := ∑ i, x i * conj (y i)</code> . In this specific case, since there is no notation typeclass you can just Go to definition by eg Ctrl+click</p>",
        "id": 465089612,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724651543
    },
    {
        "content": "<p>Well, even the outermost symbol depends on the way things are implemented in mathlib, which I don't expect to be in perfect correspondence  to how I think about them. And trying out several choices quickly gets slower than looking for the definition in the docs.</p>",
        "id": 465090380,
        "sender_full_name": "jsodd",
        "timestamp": 1724652046
    },
    {
        "content": "<p>By the way, your code doesn't work for me, maybe I forgot to open something...</p>",
        "id": 465090450,
        "sender_full_name": "jsodd",
        "timestamp": 1724652069
    },
    {
        "content": "<p>I mean, I would usually just look in the docs, but you asked for a doc-less way <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 465090641,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1724652151
    },
    {
        "content": "<p>I honestly thought there would be something like <code>#eval#</code> or <code>#print</code> for this...</p>",
        "id": 465090697,
        "sender_full_name": "jsodd",
        "timestamp": 1724652195
    },
    {
        "content": "<p>What's wrong with the mentioned Go to definition?</p>",
        "id": 465091848,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1724652774
    },
    {
        "content": "<p>If you click on Go to definition (on the brackets or on what?), lean first sends you to the definition of inner product notation, then to the general inner products and so on. There seems to be no easy way to see the exact way it is defined in the current context</p>",
        "id": 465092322,
        "sender_full_name": "jsodd",
        "timestamp": 1724653003
    },
    {
        "content": "<p>You can go to the definition of <code>EuclideanSpace</code> instead and then go through the definitions of <code>PiLp</code> and <code>WithLp</code> just  to find how the inner product is defined</p>",
        "id": 465092644,
        "sender_full_name": "jsodd",
        "timestamp": 1724653177
    },
    {
        "content": "<p>Seems to be too much for a thing that simple</p>",
        "id": 465092700,
        "sender_full_name": "jsodd",
        "timestamp": 1724653201
    },
    {
        "content": "<p><code>#reduce ⟪x, y⟫_ℝ</code><br>\nshows the definition, but at a very low level</p>",
        "id": 465093010,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724653339
    },
    {
        "content": "<p><code>#whnf ⟪x, y⟫_ℝ</code>, perhaps?</p>",
        "id": 465093080,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724653375
    },
    {
        "content": "<p>A new command would have to make the exact same decisions of what to unfold and what not, there is no straightforward answer here. The one tool other than unfolding nothing we have is to unfold everything, which is <code>#reduce</code> as just mentioned</p>",
        "id": 465093088,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1724653381
    },
    {
        "content": "<p>Let's say I've redefined it for myself somewhere, but don't remember where. I'd like to be able to quickly check</p>",
        "id": 465093092,
        "sender_full_name": "jsodd",
        "timestamp": 1724653383
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EuclideanSpace</span><span class=\"w\"> </span><span class=\"n\">ℂ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">}</span>\n<span class=\"bp\">#</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">⟫_</span><span class=\"n\">ℝ</span>\n</code></pre></div>\n<p>works in here, but that's only thanks to the simp lemma <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=PiLp.inner_apply#doc\">docs#PiLp.inner_apply</a></p>",
        "id": 465093140,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1724653415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110024\">Sebastian Ullrich</span> <a href=\"https://leanprover.zulipchat.com#narrow/stream/113489-new-members/topic/Is.20there.20a.20way.20to.20quickly.20check.20the.20definition.3F/near/465093088\">said</a>:</p>\n<blockquote>\n<p>A new command would have to make the exact same decisions of what to unfold and what not, there is no straightforward answer here. The one tool other than unfolding nothing we have is to unfold everything, which is <code>#reduce</code> as just mentioned</p>\n</blockquote>\n<p>Maybe some command which would allow me to manually unfold it? Just without guessing names of what must be unfolded</p>",
        "id": 465093374,
        "sender_full_name": "jsodd",
        "timestamp": 1724653530
    }
]