[
    {
        "content": "<p>I want to view the proof term generated by a tactic. </p>\n<p>I thought <a href=\"https://lean-lang.org/doc/reference/latest/Tactic-Proofs/Tactic-Reference/#show_term\">show_term</a> may have done this, but in the <a href=\"#narrow/channel/113489-new-members/topic/Proof.20of.20sum.20of.20Fintype.20broke.20after.20updating.20lean/with/561467001\">example</a> I tried, replacing <code>rfl</code> with the output of <code>show_term rfl</code>, <code>exact Eq.refl my_sum</code>, did not give a valid proof.</p>",
        "id": 561472646,
        "sender_full_name": "Michael Fishman",
        "timestamp": 1764695002
    },
    {
        "content": "<p><code>#print my_theorem_name</code></p>",
        "id": 561477782,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764696384
    },
    {
        "content": "<p>That's not going to be appreciably different <span class=\"user-mention\" data-user-id=\"133339\">@Mirek Olšák</span>. It uses the same mechanism as <code>show_term</code>, the pretty printer.</p>",
        "id": 561477936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764696422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"655293\">@Michael Fishman</span> Pretty printing isn't guaranteed to round-trip, which can be unfortunate for this use case, but you can try adding flags like <code>set_option pp.explicit true</code>, or more strongly <code>set_option pp.all true</code>. There are other options too.</p>",
        "id": 561478098,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1764696472
    },
    {
        "content": "<p>If the issue is that the irreducible constants are not expanded by the elaborator, it is an \"issue\" of the elaborator, and not a proof not being valid.</p>",
        "id": 561478834,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764696669
    },
    {
        "content": "<p>For example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n</code></pre></div>\n<p>is a valid proof term. Kernel would accept it if there was not for the high-level type checker that errors out because it doesn't expand <code>Rat.add</code> (and there are ways to convince the elaborator without changing the term).</p>",
        "id": 561481915,
        "sender_full_name": "Mirek Olšák",
        "timestamp": 1764697528
    }
]