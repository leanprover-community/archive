[
    {
        "content": "<p>So I've been trying for ages to solve this. <br>\nI only need need to proof now that there is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">apply</span> <span class=\"n\">CompactIccSpace.mk'</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">c</span>\n  <span class=\"n\">intro</span> <span class=\"n\">d</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">isCompact_iff_compactSpace</span><span class=\"o\">]</span>\n</code></pre></div>\n<p><code>⊢ CompactSpace ↑(Set.Icc b c)</code><br>\nBut I can't any proof for that, nor for isCompact. I really desperate for help, I spend way too much time on that now ):</p>\n<p>regards</p>",
        "id": 398467871,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698234411
    },
    {
        "content": "<p>A <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (with imports) is helpful</p>",
        "id": 398468135,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698234523
    },
    {
        "content": "<p>That doesn't seem too hard. Will give it a stab tonight if nobody beats me to it</p>",
        "id": 398468561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1698234700
    },
    {
        "content": "<p>Hint: it takes only two calls to <code>apply?</code> after <code>intro d</code></p>",
        "id": 398469690,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698235114
    },
    {
        "content": "<p>... and there is a proof that is exactly 100 characters long, including the statement!  <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span></p>",
        "id": 398471968,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698235957
    },
    {
        "content": "<p>I've got a proof in <del>81</del> 80, if we're counting :)</p>",
        "id": 398473846,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698236695
    },
    {
        "content": "<p>Is the 81 vs 80 difference due to <code>=&gt;</code> vs <code>↦</code>?  <span aria-label=\"man facepalming\" class=\"emoji emoji-1f926-200d-2642\" role=\"img\" title=\"man facepalming\">:man_facepalming:</span></p>",
        "id": 398474527,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698236939
    },
    {
        "content": "<p>Oh no, that would bring me down to 79 :)</p>",
        "id": 398475913,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698237417
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>proofs</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isClosed_Icc.isCompact</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"bp\">.</span><span class=\"n\">mk'</span> <span class=\"k\">fun</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isClosed_Icc.isCompact</span>\n</code></pre></div>\n</div></div>",
        "id": 398475985,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698237442
    },
    {
        "content": "<p>I am still not used to the \"anonymous dot-notation\".</p>",
        "id": 398476535,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698237636
    },
    {
        "content": "<p>To be clear, <span class=\"user-mention\" data-user-id=\"640752\">@Robert hackman</span> , this talk about the number of characters is extremely unimportant, except maybe as a puzzle for people who enjoy it</p>",
        "id": 398478705,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698238468
    },
    {
        "content": "<p>Besides being unimportant, it is actually obfuscating and pedagogically wrong, especially at the level where it got to here!</p>",
        "id": 398479171,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698238634
    },
    {
        "content": "<p>thx so much... I think approaching Lean without having ever touched functional programming was the mistake haha <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span> . The math part really is a peace of cake but I'm lacking the PHD in Type Theory ):</p>",
        "id": 398639425,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698308843
    },
    {
        "content": "<p>Fwiw, I did a little bit of functional programming a number of years sago (that I don't care to count right now :)) and I didn't enjoy it at all</p>",
        "id": 398644696,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698310744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"640752\">@Robert hackman</span> I think the only type theory you ever really need to know, if you just want to do mathematics in Lean, is covered in <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> .</p>",
        "id": 398645063,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698310862
    },
    {
        "content": "<p>it's not about the \"how\" (though it is too) but more about a different way of thinking, I think only experience(or smartness - I don't have) can compensate</p>",
        "id": 398648986,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698312229
    },
    {
        "content": "<p>but regarding the solution above, what I don't understand is why you can call <code>isCompact</code> on <code>isClosed_Icc</code> because <code>isClosed_Icc</code> returns a proposition and <code>isCompact</code> needs a set to be called on...</p>",
        "id": 398649403,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698312367
    },
    {
        "content": "<p>If you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> I can try and help with your question. But honestly, for questions like this you can usually just solve them by hovering over things and thinking \"OK so what inputs are round brackets?</p>",
        "id": 398656350,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698314885
    },
    {
        "content": "<p>Oh, you just mean this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"k\">fun</span> <span class=\"o\">{</span><span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">isClosed_Icc.isCompact</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p><code>isClosed_Icc</code> returns a proof, not a proposition (which is a statement). Does this help? Do you understand the difference between <code>{}</code> inputs to functions (\"Lean will work this out\") and <code>()</code> inputs (\"the user must supply these\")? Honestly I recommend you read <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">#tpil</a> rather than just trying to work out everything yourself by staring at more complex examples.</p>",
        "id": 398656503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698314951
    },
    {
        "content": "<p>The version I came up with from your code was roughly</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">apply</span> <span class=\"n\">CompactIccSpace.mk'</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">c</span>\n  <span class=\"n\">intro</span> <span class=\"n\">d</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsClosed.isCompact</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isClosedIcc</span>\n</code></pre></div>\n<p>If you see how that works, you're 90% of the way there</p>",
        "id": 398657213,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698315202
    },
    {
        "content": "<p><code>isClosed_Icc returns a proof, not a proposition (which is a statement).</code>ahhh ok so now it makes sense...I was initially confused about why it returned an instance of itself... thanks! (I will go through tplil again.. )</p>",
        "id": 398661078,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698316759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/113489-new-members/topic/CompactIccSpace.20for.20unitInterval/near/398657213\">said</a>:</p>\n<blockquote>\n<p>The version I came up with from your code was roughly</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">apply</span> <span class=\"n\">CompactIccSpace.mk'</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">c</span>\n  <span class=\"n\">intro</span> <span class=\"n\">d</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsClosed.isCompact</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isClosedIcc</span>\n</code></pre></div>\n<p>If you see how that works, you're 90% of the way there</p>\n</blockquote>\n<p>ok so that also resolves my question, thx!</p>",
        "id": 398661114,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698316778
    },
    {
        "content": "<p>Ok another small question, when Lean cannot find an instance but I cannot use <code>instance</code> because I'm in a tactic block for example but for the instance proof I need a variable from the tactic block, how can I provide a hin to the type resolution if I cannot use instance. Sure I can use have but that doesn't help lean to find the instance \"hint\"</p>",
        "id": 398668475,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698319779
    },
    {
        "content": "<p>I don't follow the question. Can you share the code?</p>",
        "id": 398669004,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698319977
    },
    {
        "content": "<p>The best way to ask questions here is via <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> s</p>",
        "id": 398675781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698322256
    },
    {
        "content": "<p>Sorry for the late reply.<br>\nMy problem is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.SetIntegral</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousFunction.Basic</span>\n\n <span class=\"n\">abbrev</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousMap</span> <span class=\"n\">unitInterval</span> <span class=\"n\">ℝ</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">):</span>  <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"k\">let</span> <span class=\"n\">bound</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n   <span class=\"k\">let</span> <span class=\"n\">μ</span><span class=\"o\">:</span> <span class=\"n\">MeasureTheory.Measure</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n   <span class=\"k\">let</span> <span class=\"n\">hint</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.IntegrableOn.integrable</span> <span class=\"o\">(</span><span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>which throws:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">typeclass</span> <span class=\"kd\">instance</span> <span class=\"n\">problem</span> <span class=\"n\">is</span> <span class=\"n\">stuck</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">is</span> <span class=\"n\">often</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">metavariables</span>\n  <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"bp\">?</span><span class=\"n\">m.55068</span>\n</code></pre></div>\n<p>To solve this I want to declare instance IsLocallyFiniteMeasure on μ. The problem is that the instance keyword only works outside the tactic context but I don't have μ available there. If I do <code>instance : IsLocallyFiniteMeasure (MeasureTheory.Measure unitInterval) := sorry</code> that throws:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">Measure</span> <span class=\"bp\">↑</span><span class=\"n\">unitInterval</span><span class=\"o\">)</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">Measure</span> <span class=\"bp\">↑</span><span class=\"n\">unitInterval</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Measure</span> <span class=\"bp\">?</span><span class=\"n\">m.31956</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">u.31955</span>\n</code></pre></div>\n<p>First I thought that is because <code>MeasureTheory.Measure unitInterval</code> is not proofed but then I found that Measure does not return prop but a type. Then I thought it would be best to look for <code>volume</code>and what it does but I couldn't find it in the docs nor in the source code... Now I'm a bit out of ideas again</p>",
        "id": 399150160,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698583413
    },
    {
        "content": "<p>Wait wait</p>",
        "id": 399150199,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698583441
    },
    {
        "content": "<p>This sounds more like lean can't figure out which type you want to be <code>IsLocallyFiniteMeasure</code> rather than the instance not existing</p>",
        "id": 399150264,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698583472
    },
    {
        "content": "<p>so what does that mean? :D Do you mean that there is ambiguity in <code>Continuous.integrableOn_Icc (bound.continuous)</code>?</p>",
        "id": 399150346,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698583540
    },
    {
        "content": "<p>If so, declaring the instance would resolve that wouldn't it?</p>",
        "id": 399150380,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698583558
    },
    {
        "content": "<p>Can you share a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> that shows the <code>typeclass instance problem is stuck</code>?</p>",
        "id": 399150657,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698583795
    },
    {
        "content": "<p>I get <code>unexpected token '...'; expected term</code>. Can you make a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> <span class=\"user-mention\" data-user-id=\"640752\">@Robert hackman</span> ? We need to be able to see the same thing as you to answer the question properly. Check your example in a new Lean file or the web editor before posting.</p>",
        "id": 399178900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1698606887
    },
    {
        "content": "<p>Ok so that's a working #mve. It's rather big which is why I didn't post it, but when shrinking it the context is diverted and the error changes.<br>\nAlso I'm sorry for replying so inconsistently, but I'm currently on a very tight time budget.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Haar.OfBasis</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousFunction.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.SetIntegral</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Intervals.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UnitInterval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">StronglyMeasurable</span>\n<span class=\"kn\">open</span> <span class=\"n\">Num</span>\n<span class=\"kn\">open</span> <span class=\"n\">Group</span>\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n<span class=\"kn\">open</span> <span class=\"n\">ENNReal</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">NatCast</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">Measure</span>\n\n\n<span class=\"c1\">-- -------------</span>\n<span class=\"c1\">-- Auf dem Raum der stetigen Funktionen C([0,1]) ist durch ∥f∥L1 = R1|f(x)|dx eine Normdefiniert.</span>\n<span class=\"c1\">-- (Dies brauchen Sie nicht zu zeigen.) Zeigen Sie, dass eine Funktionenfolge (fn) in C([0, 1]),</span>\n<span class=\"c1\">-- die gleichma ̈ßig gegen f konvergiert, auch bezu ̈glich der Norm ∥ · ∥L1 gegen f konvergiert.</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousMap</span> <span class=\"n\">unitInterval</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">|</span>\n\n<span class=\"c1\">-- Define the L1 space</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"n\">L1_norm</span> <span class=\"n\">f</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Define the uniform convergence</span>\n<span class=\"kd\">def</span> <span class=\"n\">uniform_convergent</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">normedAddCommGroup</span>\n<span class=\"c1\">-- instance : IsLocallyFiniteMeasure (MeasureTheory.Measure unitInterval) := sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">apply</span> <span class=\"n\">CompactIccSpace.mk'</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">c</span>\n  <span class=\"n\">intro</span> <span class=\"n\">d</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsClosed.isCompact</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isClosed_Icc</span>\n\n<span class=\"c1\">-- Theorem: If (fn) converges uniformly to f, then it also converges in L1 norm to f.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">uniform_convergence_implies_L1_convergence</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_uniform</span> <span class=\"o\">:</span> <span class=\"n\">uniform_convergent</span> <span class=\"n\">f</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">L1_norm</span> <span class=\"n\">limit</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c1\">-- We need to show that the L1 norms converge to the L1 norm of the limit</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Metric.tendsto_atTop</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span> <span class=\"n\">ε</span> <span class=\"n\">ε_pos</span>\n    <span class=\"c1\">-- Use the uniform convergence property to find N</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">hN</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h_uniform</span> <span class=\"n\">ε</span> <span class=\"n\">ε_pos</span>\n    <span class=\"n\">use</span> <span class=\"n\">N</span>\n    <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n    <span class=\"c1\">-- Use the definition of the L1 norm</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">L1_norm</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hN</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">hN</span><span class=\"o\">)</span>\n\n    <span class=\"c1\">-- rw[← L1.dist_eq_integral_dist]</span>\n\n    <span class=\"c1\">-- Apply the Lebesgue Dominated Convergence Theorem</span>\n    <span class=\"c1\">-- integral_le_integral_of_le</span>\n    <span class=\"c1\">-- exact integral_le_integral_of_le (ContinuousMap.abs_sub_integral_le _ _ h₁)</span>\n\n\n    <span class=\"k\">let</span> <span class=\"n\">bound</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n    <span class=\"k\">let</span> <span class=\"n\">μ</span><span class=\"o\">:</span> <span class=\"n\">MeasureTheory.Measure</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n\n\n\n    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">ns</span>\n      <span class=\"n\">exact</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">ContinuousMap.measurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)))</span>\n    <span class=\"c1\">-- show vv</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hint</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.IntegrableOn.integrable</span> <span class=\"o\">(</span><span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">))</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hbound</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∀ᵐ</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"n\">bound</span> <span class=\"n\">a</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">let</span> <span class=\"n\">hlim</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᵐ</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"n\">a</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tendsto_integral_of_dominated_convergence</span> <span class=\"n\">bound</span> <span class=\"n\">hmeas</span> <span class=\"n\">hint</span> <span class=\"n\">hbound</span> <span class=\"n\">hlim</span>\n</code></pre></div>",
        "id": 399244088,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698652857
    },
    {
        "content": "<p>According to the infoview, <code>bound</code> is a term of <code>C</code>, that is a <del>real number in the unit interval</del>EDIT: sorry I misread!  What should <code>bound.continuous</code> represent?  Lean is confused by the fact that you are supplying this for a proof that a function is continuous.</p>",
        "id": 399258136,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1698657543
    },
    {
        "content": "<p>First step: isolate the thing that goes wrong:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If you hover over <code>Continuous.integrableOn_Icc</code>, you can see it requires <code>IsLocallyFiniteMeasure μ</code> which seems likely to have created the goal that lean has trouble with (<code>IsLocallyFiniteMeasure ?m.7695</code>). What happened here is that lean can't tell what <code>μ</code> should be. So you can pass it explicitly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but this still complains that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"kd\">instance</span>\n  <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"n\">volume</span>\n</code></pre></div>\n<p>Hovering over <code>volume</code> shows it's the <code>volume</code> for <code>unitInterval</code>.  The next thing I'd try is adding</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">unitInterval</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and look what happens next. Unfortunately it still can't figure out <em>which</em> <code>Icc</code> you want to talk about, so you can try this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which allows you to move forward</p>",
        "id": 399266998,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698660128
    },
    {
        "content": "<p>This is an awful proof for the instance, which I'm posting hoping that someone will reply with a one-line proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">unitInterval</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">IsFiniteMeasure.toIsLocallyFiniteMeasure</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n  <span class=\"n\">constructor</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">Real.isFiniteMeasure_restrict_Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">MeasurableSet.map_coe_volume</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">this.measure_univ_lt_top</span>\n  <span class=\"n\">convert</span> <span class=\"n\">this</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">volume_set_coe_def</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">comap_subtype_coe_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_comap_subtype_coe</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">restrict_apply</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Set.image_univ</span><span class=\"o\">,</span> <span class=\"n\">Subtype.range_coe_subtype</span><span class=\"o\">,</span> <span class=\"n\">ge_iff_le</span><span class=\"o\">,</span> <span class=\"n\">zero_le_one</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">,</span> <span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span> <span class=\"n\">Set.mem_Icc</span><span class=\"o\">,</span>\n    <span class=\"n\">Set.univ_inter</span><span class=\"o\">,</span> <span class=\"n\">volume_Icc</span><span class=\"o\">,</span> <span class=\"n\">sub_zero</span><span class=\"o\">,</span> <span class=\"n\">ofReal_one</span><span class=\"o\">]</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">Set.Icc_def</span><span class=\"o\">]</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">simp</span>\n  <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 399271106,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698661456
    },
    {
        "content": "<p>thank you very much! I misinterpreted the error and thought that it knew μ but couldn't synthesise the instance on it but it absolutely makes sense now that it couldn't find it</p>",
        "id": 399272710,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698661886
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">application</span> <span class=\"n\">type</span> <span class=\"n\">mismatch</span>\n  <span class=\"n\">tendsto_integral_of_dominated_convergence</span> <span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">bound</span><span class=\"o\">)</span> <span class=\"n\">hmeas</span> <span class=\"n\">hint</span>\n<span class=\"n\">argument</span>\n  <span class=\"n\">hint</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">Integrable</span> <span class=\"bp\">↑</span><span class=\"n\">bound</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">Integrable</span> <span class=\"bp\">↑</span><span class=\"n\">bound</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>Usually I bang my head against a problem until either the problem or my head is gone, and then I ask, but with the next error I get, there is not much to bang against...<br>\nUpdated MVE would then be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.Haar.OfBasis</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Order.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Nat.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.ContinuousFunction.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Integral.SetIntegral</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Measure.MeasureSpace</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Set.Intervals.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.UnitInterval</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.StronglyMeasurable.Basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.MeasureTheory.Function.LocallyIntegrable</span>\n<span class=\"kn\">import</span> <span class=\"n\">Mathlib.Topology.Algebra.Order.Compact</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">StronglyMeasurable</span>\n<span class=\"kn\">open</span> <span class=\"n\">Num</span>\n<span class=\"kn\">open</span> <span class=\"n\">Group</span>\n<span class=\"kn\">open</span> <span class=\"n\">Real</span>\n<span class=\"kn\">open</span> <span class=\"n\">BigOperators</span>\n<span class=\"kn\">open</span> <span class=\"n\">Topology</span>\n<span class=\"kn\">open</span> <span class=\"n\">ENNReal</span>\n<span class=\"kn\">open</span> <span class=\"n\">Finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kn\">open</span> <span class=\"n\">NatCast</span>\n<span class=\"kn\">open</span> <span class=\"n\">Function</span>\n<span class=\"kn\">open</span> <span class=\"n\">MeasureTheory</span>\n<span class=\"kn\">open</span> <span class=\"n\">Measure</span>\n\n<span class=\"c1\">-- -------------</span>\n<span class=\"c1\">-- Auf dem Raum der stetigen Funktionen C([0,1]) ist durch ∥f∥L1 = R1|f(x)|dx eine Normdefiniert.</span>\n<span class=\"c1\">-- (Dies brauchen Sie nicht zu zeigen.) Zeigen Sie, dass eine Funktionenfolge (fn) in C([0, 1]),</span>\n<span class=\"c1\">-- die gleichma ̈ßig gegen f konvergiert, auch bezu ̈glich der Norm ∥ · ∥L1 gegen f konvergiert.</span>\n\n<span class=\"n\">abbrev</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">ContinuousMap</span> <span class=\"n\">unitInterval</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"bp\">∫</span> <span class=\"n\">x</span><span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">|</span>\n\n<span class=\"c1\">-- Define the L1 space</span>\n<span class=\"kd\">def</span> <span class=\"n\">L1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">|</span> <span class=\"n\">L1_norm</span> <span class=\"n\">f</span> <span class=\"bp\">≥</span> <span class=\"mi\">0</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Define the uniform convergence</span>\n<span class=\"kd\">def</span> <span class=\"n\">uniform_convergent</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">unitInterval</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">NormedAddCommGroup</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">normedAddCommGroup</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">IsLocallyFiniteMeasure</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">unitInterval</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">CompactIccSpace</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">unitInterval</span>\n  <span class=\"n\">apply</span> <span class=\"n\">CompactIccSpace.mk'</span>\n  <span class=\"n\">intro</span> <span class=\"n\">b</span>\n  <span class=\"n\">intro</span> <span class=\"n\">c</span>\n  <span class=\"n\">intro</span> <span class=\"n\">d</span>\n  <span class=\"n\">apply</span> <span class=\"n\">IsClosed.isCompact</span>\n  <span class=\"n\">apply</span> <span class=\"n\">isClosed_Icc</span>\n\n<span class=\"c1\">-- Theorem: If (fn) converges uniformly to f, then it also converges in L1 norm to f.</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">uniform_convergence_implies_L1_convergence</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_uniform</span> <span class=\"o\">:</span> <span class=\"n\">uniform_convergent</span> <span class=\"n\">f</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">L1_norm</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">L1_norm</span> <span class=\"n\">limit</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"c1\">-- We need to show that the L1 norms converge to the L1 norm of the limit</span>\n    <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">Metric.tendsto_atTop</span><span class=\"o\">]</span>\n    <span class=\"n\">intros</span> <span class=\"n\">ε</span> <span class=\"n\">ε_pos</span>\n    <span class=\"c1\">-- Use the uniform convergence property to find N</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">hN</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h_uniform</span> <span class=\"n\">ε</span> <span class=\"n\">ε_pos</span>\n    <span class=\"n\">use</span> <span class=\"n\">N</span>\n    <span class=\"n\">intros</span> <span class=\"n\">n</span> <span class=\"n\">hn</span>\n    <span class=\"c1\">-- Use the definition of the L1 norm</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">L1_norm</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Set.Icc</span> <span class=\"mi\">0</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">limit</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"bp\">|</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">specialize</span> <span class=\"n\">hN</span> <span class=\"n\">n</span> <span class=\"n\">hn</span> <span class=\"n\">x</span> <span class=\"n\">hx</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">le_of_lt</span> <span class=\"n\">hN</span><span class=\"o\">)</span>\n\n    <span class=\"c1\">-- rw[← L1.dist_eq_integral_dist]</span>\n\n    <span class=\"c1\">-- Apply the Lebesgue Dominated Convergence Theorem</span>\n    <span class=\"c1\">-- integral_le_integral_of_le</span>\n    <span class=\"c1\">-- exact integral_le_integral_of_le (ContinuousMap.abs_sub_integral_le _ _ h₁)</span>\n\n\n    <span class=\"k\">let</span> <span class=\"n\">bound</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n    <span class=\"k\">let</span> <span class=\"n\">μ</span><span class=\"o\">:</span> <span class=\"n\">MeasureTheory.Measure</span> <span class=\"n\">unitInterval</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span>\n\n\n\n\n    <span class=\"k\">let</span> <span class=\"n\">hmeas</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">AEStronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">intro</span> <span class=\"n\">ns</span>\n      <span class=\"n\">exact</span> <span class=\"n\">AEMeasurable.aestronglyMeasurable</span> <span class=\"o\">(</span><span class=\"n\">Measurable.aemeasurable</span> <span class=\"o\">(</span><span class=\"n\">ContinuousMap.measurable</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">ns</span><span class=\"o\">)))</span>\n    <span class=\"c1\">-- show vv</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hint</span> <span class=\"o\">:=</span> <span class=\"n\">MeasureTheory.IntegrableOn.integrable</span> <span class=\"o\">(</span><span class=\"n\">Continuous.integrableOn_Icc</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:=</span> <span class=\"n\">volume</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bound.continuous</span><span class=\"o\">))</span>\n\n    <span class=\"k\">let</span> <span class=\"n\">hbound</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">∀ᵐ</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span> <span class=\"bp\">‖</span><span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"bp\">‖</span> <span class=\"bp\">≤</span> <span class=\"n\">bound</span> <span class=\"n\">a</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">let</span> <span class=\"n\">hlim</span> <span class=\"o\">:</span> <span class=\"bp\">∀ᵐ</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span><span class=\"o\">,</span> <span class=\"n\">Filter.Tendsto</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↦</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">Filter.atTop</span> <span class=\"o\">(</span><span class=\"bp\">𝓝</span> <span class=\"o\">(</span><span class=\"n\">limit</span> <span class=\"n\">a</span><span class=\"o\">))</span>  <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n    <span class=\"n\">exact</span> <span class=\"n\">tendsto_integral_of_dominated_convergence</span> <span class=\"n\">bound</span> <span class=\"n\">hmeas</span> <span class=\"n\">hint</span> <span class=\"n\">hbound</span> <span class=\"n\">hlim</span>\n</code></pre></div>",
        "id": 399273631,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698662130
    },
    {
        "content": "<p>Hmm, <code>IntegrableOn.integrable</code> introduces a <code>restrict</code> in the measure. Not sure how to deal with that</p>",
        "id": 399275731,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1698662847
    },
    {
        "content": "<p>well, so does that mean my approach is invalid or is it \"just a hard problem\"?</p>",
        "id": 399705709,
        "sender_full_name": "Robert hackman",
        "timestamp": 1698837743
    }
]