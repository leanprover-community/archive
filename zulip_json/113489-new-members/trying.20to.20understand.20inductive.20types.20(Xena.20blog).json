[
    {
        "content": "<p>I've returned to untangling my thinking around inductive types, and am re-reading the previously recommended Xena blog post on the subject: <a href=\"https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/\">https://xenaproject.wordpress.com/2021/04/03/induction-and-inductive-types/</a></p>\n<p>I won't ask all my questions right now, I'll do that step-by-step as this thread progresses.</p>\n<hr>\n<p>The following code declares <code>X</code> as a type, and in fact an <code>inductive</code> type. It also establishes a single element of that type, <code>p</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span>\n</code></pre></div>\n<p>I'm new to this so I did a <code>#check X</code> which returns <code>X : Type</code> as expected. All good so far.</p>\n<p>Now, the blog suggests that all inductive types automatically come with the machinery of induction.</p>\n<p>So I tried <code>`#check X.rec</code> which gave me the following:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>X.rec.{u} {motive : X → Sort u} (p : motive p) (t : X) : motive t\n</code></pre></div>\n<p><strong>Question 1:</strong> How I interpret this? Sadly the blog was too advanced for me.  What is <code>motive</code> ?</p>\n<p>Let me try anyway. I expect Lean to create an \"iterator\" for elements of <code>X</code>, allowing me to select all elements of <code>X</code>, albeit using a recursive method rather than an actual (possibly) infinite enumeration. I'm thinking of the constructor of the definition of <code>inductive Nat</code>. </p>\n<p>This is different from what the blog has, notice there is no <code>motive</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Sort</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><strong>Question 2:</strong> Why is the output different in the blog? </p>\n<p>I did try <code>#check @X.rec</code> but I don't know what <code>@</code> really does. Here's the different output:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>@X.rec : {motive : X → Sort u_1} → motive p → (t : X) → motive t\n</code></pre></div>\n<p><strong>Question 3:</strong> What is <code>@</code> and why is the output different?</p>\n<hr>\n<p>As further experimentation with <code>Nat</code>, because it is more familiar, I tried <code>#check Nat.rec</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Nat.rec.{u} {motive : ℕ → Sort u} (zero : motive Nat.zero) (succ : (n : ℕ) → motive n → motive n.succ) (t : ℕ) :\n  motive t\n</code></pre></div>\n<p>I'm still struggling to interpret this, despite having the advantage of knowing how induction on natural numbers is supposed to work.</p>",
        "id": 492340467,
        "sender_full_name": "rzeta0",
        "timestamp": 1736266337
    },
    {
        "content": "<p>Q1: <code>motive</code> is the same as <code>C</code> and this is probably just a Lean 3 / Lean 4 issue. <code>X.rec</code> says \"if you have a family of types C_x (or motive(x)) parametrised by x in X, and you have an element of C_p (which unfortunately for you is also called p) then for any t in T you can get an element of C_t</p>\n<p>Q2: probably a Lean 3 v Lean 4 issue?</p>\n<p>Q3 @ just means \"don't attempt to fill in any implicit arguments, tell me all the inputs, even the ones I'm supposed to be guessing\"</p>",
        "id": 492341500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736266648
    },
    {
        "content": "<p>Nat.rec says \"given a family motive(n) of types or theorem statements, i.e. motive(0), motive(1), motive(2), ..., given an element of motive(0), and a way to get an element of motive(n+1) from motive(n), then for any t we can get an element of motive(t)\"</p>",
        "id": 492341727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736266714
    },
    {
        "content": "<p>This covers both recursion and induction. For induction motive(n) is a theorem statement about n (e.g. \"sum of i from 0 to n-1 is n(n-1)/2\"), and then the element of motive(0) is a proof of motive(0) and the way to get an element of motive(n+1) from an element of motive(n) is just a proof that motive(n) implies motive(n+1).</p>",
        "id": 492342108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1736266814
    },
    {
        "content": "<p>Thanks Kevin - your reply filled in some gaps in my knowledge. I will go back and re-read the blog with this added information.</p>\n<p>I've set myself a goal to understand this machinery of induction/recursion even if it is outside my comfort zone.</p>\n<p>(The other goal I've set myself is to get at least a surface understanding of what dependent type theory is, and I'm going to read your blog <a href=\"https://www.ma.imperial.ac.uk/~buzzard/lean_together/source/appendix/type_theory.html\">https://www.ma.imperial.ac.uk/~buzzard/lean_together/source/appendix/type_theory.html</a> and the TPIL chapter again )</p>",
        "id": 492474859,
        "sender_full_name": "rzeta0",
        "timestamp": 1736331971
    }
]