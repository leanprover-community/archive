[
    {
        "content": "<p>Hello everyone,</p>\n<p>Iâ€™m a retired research engineer (ex-Inria, Coq/Rocq community), and<br>\nIâ€™ve been formalizing mathematics in Coq for many years.</p>\n<p>Some projects Iâ€™ve completed in Rocq:</p>\n<ul>\n<li>a formal proof of Puiseuxâ€™s theorem (~30k lines),</li>\n<li>Banachâ€“Tarski (~10k lines, plus an article), and</li>\n<li>a â€œÏ€-free trigonometryâ€ where angles are pairs (x,y) with xÂ²+yÂ²=1.</li>\n</ul>\n<p>Iâ€™m interested in exchanging ideas with people working on unusual or<br>\nfoundational aspects of formalized mathematics. Not here to learn<br>\nLean, but curious to share and discuss with the Lean/Mathlib<br>\ncommunity.</p>\n<p>Cheers,</p>\n<p>Daniel de Rauglaudre</p>",
        "id": 535219535,
        "sender_full_name": "Daniel de Rauglaudre",
        "timestamp": 1755649399
    },
    {
        "content": "<p>Welcome! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>\n<p>You may be interested in:<br>\n<a href=\"https://github.com/Bergschaf/lean-banach-tarski\">https://github.com/Bergschaf/lean-banach-tarski</a></p>",
        "id": 535221511,
        "sender_full_name": "Yan Yablonovskiy ğŸ‡ºğŸ‡¦",
        "timestamp": 1755651120
    },
    {
        "content": "<p>Hi Yan,</p>\n<p>Thanks for the pointer! Iâ€™m aware of other Banachâ€“Tarski formalizations, but my work in Rocq/Coq is quite different. Iâ€™m exploring â€œring-likeâ€ algebra (a unifying framework covering semirings, rings, and fields, with optional operations like subtraction or inverses), trig without Ï€, and other constructionsâ€”more focused on frameworks and methods than reproducing known results.</p>\n<p>Cheers,</p>\n<p>Daniel</p>",
        "id": 535222004,
        "sender_full_name": "Daniel de Rauglaudre",
        "timestamp": 1755651574
    },
    {
        "content": "<p>Interesting, well depending what you mean by ring-like, i am working on some formalisations of Algebraic Wheels in <a href=\"https://github.com/YanYablonovskiy/AlgebraicWheelTheory\">https://github.com/YanYablonovskiy/AlgebraicWheelTheory</a> ,  these contain  certain semi-rings and are kind of like generalisations.</p>\n<p>I hesitated to reply in thread, figured will wait for others to be more helpful(its a timezone thing, this time is  less active)</p>",
        "id": 535222704,
        "sender_full_name": "Yan Yablonovskiy ğŸ‡ºğŸ‡¦",
        "timestamp": 1755652157
    },
    {
        "content": "<p>Let me explain briefly what I mean by <em>ring-like</em>.</p>\n<p>In my framework, instead of defining separately semirings, rings,<br>\nordered rings, fields, etc., I use a single structure with boolean<br>\nflags to indicate which extra operations or axioms are available.</p>\n<p>For example:<br>\nâ€“ <code>has_opp</code> says whether additive inverses exist (so a semiring with<br>\n<code>has_opp = false</code>, a ring with <code>has_opp = true</code>).<br>\nâ€“ <code>mul_is_comm</code> tells whether multiplication is commutative.<br>\nâ€“ <code>is_ordered</code> says whether there is a compatible order.<br>\nâ€“ <code>has_subt</code> for primitive subtraction, etc.</p>\n<p>This way, I can state many theorems in a more general setting, without<br>\nhaving to duplicate them for each algebraic structure.</p>\n<p>In this framework, axioms themselves can be conditional.<br>\nFor instance:<br>\nâ€“ <code>mul_assoc</code> is unconditional:<br>\n<code>âˆ€ a b c, a * (b * c) = (a * b) * c</code>.<br>\nâ€“ <code>mul_comm</code> is conditional: it has type<br>\n<code>if mul_is_comm then âˆ€ a b, a * b = b * a else not_applicable</code>.</p>\n<p>This makes it possible to capture in one unified system both<br>\ncommutative and non-commutative structures, ordered and unordered<br>\nones, etc., without duplicating the whole theory.</p>\n<p>My whole library is here: <a href=\"https://roglo.github.io/rocq_ring_like/\">https://roglo.github.io/rocq_ring_like/</a></p>",
        "id": 535244926,
        "sender_full_name": "Daniel de Rauglaudre",
        "timestamp": 1755670332
    },
    {
        "content": "<p>I think Lean uses the <code>extends</code> keyword to avoid this duplication, for instance see <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CommRing#src\">src#CommRing</a></p>",
        "id": 535264077,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755678660
    },
    {
        "content": "<p>The advantage of this approach is that you don't have to commit to every axiom that could exist up front</p>",
        "id": 535264139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755678682
    },
    {
        "content": "<p>(eg, if you want to talk about rings that are alternative but not associative like the octonions)</p>",
        "id": 535264595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1755678842
    },
    {
        "content": "<p>The slowdowns at <a href=\"https://github.com/leanprover-community/mathlib4/pull/28604\">#28604</a> and <a href=\"https://github.com/leanprover-community/mathlib4/pull/28532\">#28532</a> makes me think whether we should unbundle associativity and commutativity; unbundling <code>one</code> and <code>neg</code> may be harder. Interestingly I was able to control the slowdown from NonAssocCommSemiring down to 0.05/0.12% by using priority 10 instances, but once I added NonAssocCommRing it jumps to 0.35/0.245% again.</p>",
        "id": 535305988,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1755693928
    }
]