[
    {
        "content": "<p>Hi, I have this snippet of code: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsCompl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>Lean is mad at the 2nd line and says \"tactic 'induction' failed, recursor 'Exists.casesOn' can only eliminate into Prop\". What is the proper way to extract n from the hypothesis h then?</p>",
        "id": 456192075,
        "sender_full_name": "VayusElytra",
        "timestamp": 1722705591
    },
    {
        "content": "<p>You should use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose#doc\">docs#Exists.choose</a></p>",
        "id": 456194390,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722706293
    },
    {
        "content": "<p>... along with <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Exists.choose_spec#doc\">docs#Exists.choose_spec</a></p>",
        "id": 456194415,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1722706313
    },
    {
        "content": "<p>It's unusual to be using <code>obtain</code> to construct data in the first place; what's the context of this \"proof\"?</p>",
        "id": 456199134,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722708145
    },
    {
        "content": "<p>I am attempting to write the Fitting lemma in a different form. </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">ExistsFittingfit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">IsIsomorphic</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsCompl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I have proper code to prove h, but for the purpose of an MWE sorry is sufficient. <br>\nAfter this, I should just need to extract an n that satisfies this condition from h to use it to prove the result.</p>",
        "id": 456200757,
        "sender_full_name": "VayusElytra",
        "timestamp": 1722708837
    },
    {
        "content": "<p><code>obtain</code> will work fine for that example</p>",
        "id": 456205106,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722711396
    },
    {
        "content": "<p>Can you provide a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> where it fails?</p>",
        "id": 456205236,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722711512
    },
    {
        "content": "<p>I just tried on my end again, and it does indeed work. Here's the code where it did not, uncensored: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">FittingLemma</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">IsCompl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LinearMap</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_n</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">prodEquivOfIsCompl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I believe the issue is that the statement of the theorem is faulty here. There is an n in it that is completely undefined.</p>",
        "id": 456207880,
        "sender_full_name": "VayusElytra",
        "timestamp": 1722712739
    },
    {
        "content": "<p>I recommend using <code>set_option autoImplicit false</code> to avoid that type of mistake</p>",
        "id": 456208316,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722712934
    },
    {
        "content": "<p>Ignoring the fact that this is indeed likely mis-stated, the reason for the error here is that this is a <code>def</code> and not a <code>theorem</code>, because <code>≃ₗ[R]</code> is a <code>Type</code> not a <code>Prop</code>; in that scenario Yael's advice about <code>choose</code> applies.</p>",
        "id": 456208522,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722713035
    },
    {
        "content": "<p>I think I've run into this issue before. What is the reason to implement isomorphisms as a type and not a prop? (I assume there is probably a Prop version elsewhere...) <br>\nI would also be curious to understand the distinction between def/lemma/theorem better. As it stands i am using them mostly like I would in normal maths, but id like to know a little bit more.</p>",
        "id": 456230458,
        "sender_full_name": "VayusElytra",
        "timestamp": 1722723801
    },
    {
        "content": "<p><code>def</code> produces data. <code>lemma</code> and <code>theorem</code> are the same, they prove statements.</p>",
        "id": 456257042,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722738143
    },
    {
        "content": "<p>We use equivalences in <code>Type*</code>, because sometimes the actual formula matters. E.g., for <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Equiv.prodAssoc#doc\">docs#Equiv.prodAssoc</a> you want to know that the equivalence sends <code>((a, b), c)</code> to <code>(a, (b, c))</code>, not something else.</p>",
        "id": 456257059,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722738161
    },
    {
        "content": "<p>If you want <em>existence</em> of an isomorphism, then you can use something like <code>Nonempty (α ≃ β)</code>.</p>",
        "id": 456257114,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1722738197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"715864\">VayusElytra</span> <a href=\"#narrow/stream/113489-new-members/topic/Obtain.2Frcases.20can.20only.20eliminate.20into.20prop/near/456230458\">said</a>:</p>\n<blockquote>\n<p>I think I've run into this issue before. What is the reason to implement isomorphisms as a type and not a prop? (I assume there is probably a Prop version elsewhere...) <br>\nI would also be curious to understand the distinction between def/lemma/theorem better. As it stands i am using them mostly like I would in normal maths, but id like to know a little bit more.</p>\n</blockquote>\n<p>\"Here is a map which is an isomorphism\" is different to \"these things happen to be isomorphic\". The first is data so it's a def. The second is a true-false statement so it's a theorem. <code>Equiv</code>s are concrete isomorphisms so they're defs. Your lemma isn't a lemma, it's not the statement that something is isomorphic to M, it's the data of the isomorphism itself. The phenomenon is like mis-stating the first isomorphism theorem in group theory as \"G / kernel is isomorphic to image\". That's not what you want, you want \"this explicit map from G / kernel to the image is an isomorphism\" rather than \"an unspecified isomorphism exists\".</p>",
        "id": 456356539,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1722790920
    },
    {
        "content": "<p>Thank you, that makes perfect sense.</p>",
        "id": 459499503,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723215919
    },
    {
        "content": "<p>The <code>Prop</code>-valued version is <code>Nonempty ...</code>, but usually the other one is better.</p>",
        "id": 459500184,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1723216054
    },
    {
        "content": "<p>I stumbled upon another situation where rcases failed, so I'm providing it as an MWE. Choose does work in this instance. (The goal and proofs are dummies). </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">MWE</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">DivisionRing</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ModuleCat</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">θ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hmem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">θ</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">):=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">hmem</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"w\">  </span><span class=\"c1\">--rcases does not give a z that satisfies hmem</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose</span><span class=\"w\"> </span><span class=\"n\">hmem</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hz</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">θ</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Exists</span><span class=\"bp\">.</span><span class=\"n\">choose_spec</span><span class=\"w\"> </span><span class=\"n\">hmem</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 459500889,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723216198
    },
    {
        "content": "<p>Not tested, but does <code>rcases hmem with ⟨z, hz⟩</code> work?</p>",
        "id": 459503902,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1723216847
    },
    {
        "content": "<p>It does, thank you!</p>",
        "id": 459714497,
        "sender_full_name": "VayusElytra",
        "timestamp": 1723303981
    }
]