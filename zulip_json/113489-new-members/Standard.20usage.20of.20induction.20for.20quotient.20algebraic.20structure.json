[
    {
        "content": "<p>In the middle of a proof, to treat some element of a quotient type as an application of the canonical quotient map,  <code>Quotient.inductionOn</code> is used. For example, in the tactic mode,</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">induction'</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>where <code>y</code> is an element in a quotient type.</p>\n<p>I'm wondering if there is a standard way to lift elements of a quotient algebraic structure such as quotient groups and quotient modules. I notice that there are corresponding <code>induction_on</code>-like theorems in Mathlib, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span>\n</code></pre></div>\n<p>Are they supposed to be used for induction purpose? In practice I see lots of people still use <code>Quotient.inductionOn</code> directly when working with quotient algebraic structures. Up to definitional equality this won't make a difference, But I'm still interested in a textbook approach.</p>\n<p>Another question is that, since we have upgraded versions of <code>Quotient.lift</code> in Mathlib that lift the bundled homomorphisms</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">QuotientGroup</span><span class=\"bp\">.</span><span class=\"n\">lift</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">liftQ</span>\n</code></pre></div>\n<p>why there aren't any upgraded version of <code>Quotient.inductionOn</code> that, for example, allow us to treat any element in a quotient module <code>M ⧸ p</code> as some application of <code>p.mkQ</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Ring</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">AddCommGroup</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Submodule</span><span class=\"bp\">.</span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">my_induction_on</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"bp\">⧸</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">mkQ</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Quotient</span><span class=\"bp\">.</span><span class=\"n\">inductionOn'</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">H</span>\n</code></pre></div>\n<p>After all, it respects scalar multiplication and addition. Wouldn't this be a better induction rule to live in Mathlib?</p>\n<p>Appreciate your help!</p>",
        "id": 565916865,
        "sender_full_name": "Xingyu Zhong",
        "timestamp": 1767201250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"934807\">Xingyu Zhong</span> <a href=\"#narrow/channel/113489-new-members/topic/Standard.20usage.20of.20induction.20for.20quotient.20algebraic.20structure/near/565916865\">said</a>:</p>\n<blockquote>\n<p>why there aren't any upgraded version of <code>Quotient.inductionOn</code> that, for example, allow us to treat any element in a quotient module <code>M ⧸ p</code> as some application of <code>p.mkQ</code>?</p>\n</blockquote>\n<p>You can use <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.mkQ_surjective#doc\">docs#Submodule.mkQ_surjective</a></p>",
        "id": 565917308,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1767201602
    },
    {
        "content": "<p>We will have general quotient lemmas if we can merge <a href=\"https://github.com/leanprover-community/mathlib4/pull/30668\">#30668</a>. <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>",
        "id": 565930197,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1767212674
    },
    {
        "content": "<p>Ah, bundled homomorphisms still need to be defined separately. But bundled <code>mkQ</code> is usually simp to a non-bundled function. Currently <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=QuotientGroup.coe_mk%27#doc\">docs#QuotientGroup.coe_mk'</a> <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Submodule.mkQ_apply#doc\">docs#Submodule.mkQ_apply</a> are simp lemmas.</p>",
        "id": 565930924,
        "sender_full_name": "Yuyang Zhao",
        "timestamp": 1767213365
    }
]