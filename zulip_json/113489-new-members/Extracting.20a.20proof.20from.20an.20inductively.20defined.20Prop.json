[
    {
        "content": "<p>I have the following code, where the component of <code>TransCompose</code> is constructed with some state <code>sa1, sa2</code>, their properties <code>ta</code> and <code>ha</code>.<br>\nNow in <code>extractEq₀</code>,  I want to extract <code>ha</code> from an instance of <code>TransCompose</code> using match.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">Io</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">genProp</span><span class=\"o\">:</span> <span class=\"n\">Io</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">R₁</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"bp\">-&gt;</span><span class=\"n\">α</span><span class=\"bp\">-&gt;</span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">TransCompose</span>\n  <span class=\"o\">(</span><span class=\"n\">getR₁Io</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R₁</span> <span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Io</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span>  <span class=\"n\">where</span>\n<span class=\"bp\">|</span> <span class=\"n\">TransPara</span> <span class=\"n\">sa1</span> <span class=\"n\">sa2</span> <span class=\"o\">(</span><span class=\"n\">ta</span><span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"n\">sa1</span> <span class=\"n\">sa2</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"o\">:</span> <span class=\"n\">genProp</span> <span class=\"o\">(</span><span class=\"n\">getR₁Io</span> <span class=\"n\">sa1</span> <span class=\"n\">sa2</span> <span class=\"n\">ta</span><span class=\"o\">)):</span>\n      <span class=\"n\">TransCompose</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">sa1</span> <span class=\"n\">sa2</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">getR₁Io</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">R₁</span> <span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">Io</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">extractEq₀</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">tn</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">TransCompose</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">match</span> <span class=\"n\">tn</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">TransPara</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ta</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ha</span>\n</code></pre></div>\n<p>However, the aforementioned code won't work, with the following error message on the last line:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mistmatch</span><span class=\"o\">,</span> <span class=\"n\">alternative</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">genProp</span> <span class=\"o\">(</span><span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">ta</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m.200</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">TransCompose</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"bp\">?</span><span class=\"n\">u.198</span>\n</code></pre></div>\n<p>It seems that lean cannot figure out the actual type of <code>ha</code>, and my guess is that it is a result of <code>ha</code> depending on <code>ta</code>, which is embed in the inductive constructor. It is however confusing that I can use the same code to extract <code>ta</code> (replace <code>=&gt;ha</code> with <code>=&gt;ta</code>). So I'm not sure what is fundamentally different between <code>ta</code> and <code>ha</code>.<br>\nAlso, I'm wondering what I can do to extract the proof <code>ha</code>. thanks!</p>",
        "id": 401298526,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699599632
    },
    {
        "content": "<p>Ok, I tried to roll my custom <code>motive</code>, and it seems working as the type I want:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">motive</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">TransCompose</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">ta</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">TransPara</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ta</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ta</span>\n  <span class=\"n\">genProp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">ta</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">extractEq₁</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">tn</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">TransCompose</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">TransCompose.casesOn</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"o\">(</span><span class=\"n\">motive</span> <span class=\"n\">R₁</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"n\">tn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ta</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>And it seems that if I let lean derive the motive, it essentially gives similar, if not the same, message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">extractEq₁'</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">tn</span><span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">TransCompose</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">TransCompose.casesOn</span> <span class=\"n\">α</span> <span class=\"n\">Io</span> <span class=\"n\">genProp</span> <span class=\"n\">R₁</span> <span class=\"n\">getR₁Io</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">_</span> <span class=\"n\">tn</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">ta</span> <span class=\"n\">ha</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">type mismatch</span>\n<span class=\"cm\">  ha</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  genProp (getR₁Io x x' ta) : Prop</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  ?m.468 x x' tn (_ : TransCompose R₁ getR₁Io x x') : Sort ?u.459</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>But I'm still not so sure what is preventing me from using <code>match</code>. This would be quite tedious to work with.</p>",
        "id": 401321099,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699608412
    },
    {
        "content": "<p>I don't you can match on proofs. Someone who feels more confident about their type theory than me can explain the why, but it boils down to there being no distinction between two proofs of the same prop.</p>",
        "id": 401346358,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1699614099
    },
    {
        "content": "<p>You can.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"k\">match</span> <span class=\"n\">x</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"n\">Or.inl</span> <span class=\"n\">p</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"n\">Or.inr</span> <span class=\"n\">q</span> <span class=\"bp\">=&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>works. But the proposition must be an inductively defined proposition, and it eliminates only to <code>Prop</code> (unless it is a syntactic subsingleton)</p>",
        "id": 401347194,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1699614366
    },
    {
        "content": "<p>Yeah, I agree that something has to do with proof irrelevance here.  IIRC, practically this means that I can have functions transforming <code>Prop</code> to <code>Prop</code>, or <code>Type</code> to <code>Prop</code>, but not <code>Prop</code> to <code>Type</code>. This limitation is in someway enforced in the <code>casesOn/recOn</code> signatures for inductively defined <code>Prop</code>. </p>\n<p>In my example, I'm indeed trying to transform a <code>Prop</code> (the destructed <code>TransCompose</code>) to another <code>Prop</code> (the <code>genProp (...)</code>). So to me this should be valid, and the manually provided <code>motive</code>/ <code>extractEq₁</code> also shows that this transformation is ok (if my motive is correct...)</p>\n<p>I'm wondering ways where I can make <code>match</code> work, so I don't have to write <code>motive</code>. :)</p>",
        "id": 401367679,
        "sender_full_name": "Z. Wu",
        "timestamp": 1699619636
    }
]