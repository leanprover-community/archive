[
    {
        "content": "<p>I'm working on a project that makes frequent use of <code>UInt64</code>, and, unfortunately, it seems like omega doesn't support it (yet?):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"bp\">.</span><span class=\"n\">one_plus_one_eq_two</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">UInt64</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span><span class=\"w\"> </span><span class=\"c1\">-- omega could not prove the goal</span>\n</code></pre></div>\n<p>Is there any way to make omega 'just work' for <code>UInt64</code> proofs? For example, is there some way to convert goals about <code>UInt64</code> to goals about <code>Nat</code>? Alternatively, is there some other proof automation technique I'm not aware of that would help here?</p>",
        "id": 514006865,
        "sender_full_name": "Michael MacLeod",
        "timestamp": 1745467594
    },
    {
        "content": "<p>If you are willing to trust a formally verified LRAT proof checker, <code>bv_decide</code> can handle the type I believe.</p>",
        "id": 514010793,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1745469762
    },
    {
        "content": "<p>I wasn't aware of that tactic, and it seems like it work well for my usecases. Thanks Kyle!</p>",
        "id": 514011236,
        "sender_full_name": "Michael MacLeod",
        "timestamp": 1745470031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"730008\">Michael MacLeod</span> has marked this topic as resolved.</p>",
        "id": 514011682,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745470285
    },
    {
        "content": "<p>Update (for anyone interested): after a bit of more exploring and experience I decided to avoid using <code>bv_decide</code>. This was because:</p>\n<ul>\n<li>The numerous uses of <code>bv_decide</code> slowed compilation of the program. (I could use <code>bv_check</code>, but it was annoyingly fragile, breaking whenever I would edit something in the program above it).</li>\n<li>Using <code>bv_decide</code> produced long strings in the compiled code, some that were over a million characters long, slowing the startup of any running program importing the affected module.</li>\n</ul>\n<p>Basically, <code>bv_decide</code> made both compile time and runtime slow.</p>\n<p>The alternative approach was to find a way to transform goals about <code>USize</code> (I am using <code>USize</code> now, instead of <code>UInt64</code>) into goals about <code>Fin</code>, and then close them with <code>omega</code>, which proved to be much faster, albeit a lot more tedious to do. The end result looks something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">lt_self_plus_one_of_lt</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits</span><span class=\"o\">)}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits_eq</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">reducePow</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">lt_self_plus_one_of_lt</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">}</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">lt_self_plus_one_of_lt</span><span class=\"w\"> </span><span class=\"n\">h</span>\n</code></pre></div>\n<p>There are a bunch of these in my program now, all taking roughly the same form except with different arguments. I needed to resort to the mess of case splitting code before <code>omega</code> in the <code>Fin</code> proof because <code>omega</code> didn't seem to like dealing with the type <code>Fin (2 ^ System.Platform.numBits)</code>. I ended up creating a tactic to do this automatically, which made writing the code a little less tedious.</p>\n<p>I still use <code>bv_decide</code>, but only when writing code, essentially as a way to help discover, from a large set of hypotheses, which are actually necessary to close a goal. I do this by removing hypotheses until <code>bv_decide</code> can't close the goal anymore, at which point I know that the hypothesis in question is necessary. I would do the same with <code>omega</code>, but, of course, <code>omega</code> doesn't work with <code>USize</code>.</p>\n<p>My only thought about how to make this whole process easier is to write a tactic that does this <code>USize -&gt; Fin</code> reduction automatically, although that would be slightly complicated by the fact that sometimes a bit of massaging is required to convert the <code>USize</code> terms into <code>Fin</code> terms.</p>",
        "id": 522274144,
        "sender_full_name": "Michael MacLeod",
        "timestamp": 1749018220
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"730008\">Michael MacLeod</span> <a href=\"#narrow/channel/113489-new-members/topic/.E2.9C.94.20Omega.20and.20UInt64/near/522274144\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Using <code>bv_decide</code> produced long strings in the compiled code</li>\n</ul>\n</blockquote>\n<p>(Is this something you're aware of <span class=\"user-mention\" data-user-id=\"395550\">@Henrik Böving</span>?)</p>",
        "id": 522437760,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1749066129
    },
    {
        "content": "<p>Yes that is by design and currently not avoidable. In the future a synergy of the compiler and the module system will fix this.</p>",
        "id": 522440524,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1749067141
    }
]