[
    {
        "content": "<p>Section 7.1 of the Mathematics in Lean tutorial discusses the \"bad diamond\" formed when we define two different instances of <code>Module₁ ℤ ℤ</code>. The rest of the section discusses how to solve the issue, but it's pretty unclear to me what changing the definition of <code>AddMonoid</code> has to do with modules or bad diamonds; in fact, we don't find the term \"module\" or \"bad diamond\" anywhere in S7.1 after the paragraph beginning \"In our concrete case.\" May I have some clarification on what the problem and solution in this section actually are?</p>",
        "id": 456692892,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1722888018
    },
    {
        "content": "<p>I wrote a little more about this specific example in <a href=\"http://eric-wieser.github.io/thesis/eric-wieser-thesis.pdf\">my thesis</a>, section 4.5 or more specifically 4.5.2.</p>",
        "id": 456699187,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1722889715
    },
    {
        "content": "<p>I took a look through that section but I'm still stuck on a few points. I think the problem being solved is that <code>a \\bu b</code> has an ambiguous meaning when <code>a b : Int</code>, and defining the scalar multiplication in <code>addGroup</code> instances rather than in <code>Module</code> instances allows us to reconcile the two definitions and provide a proof that they're equivalent. But then how do we implement the rest of the module axioms for scalar multiplication of <code>Int</code> on itself? And do we abandon the module instances <code>selfModule</code> and <code>addCommGroup</code>, even though they make elementary and important mathematical observations?</p>",
        "id": 456954076,
        "sender_full_name": "Nick Attkiss",
        "timestamp": 1722977826
    },
    {
        "content": "<p>So, the thing is: an <code>AddGroup</code>, or more pedantically, a <code>SubNegMonoid</code> gives rise to a scalar multiplication by Int ( <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=SubNegMonoid.SMulInt#doc\">docs#SubNegMonoid.SMulInt</a> ), namely z \\bu x = x + ... + x (z times). The trick is that we don't literally define the scalar multiplication as x + ... + x, but instead any time you define an instance of <code>SubNegMonoid</code>, you have to define a zsmul function that just happens to behave as (be propositionally equal to) x + ... + x. In the case of Int ( <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Int.instAddCommGroup#doc\">docs#Int.instAddCommGroup</a> ), this zsmul is defined to be z * x instead.</p>\n<p>This happens to match <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Semiring.toModule#doc\">docs#Semiring.toModule</a> (actually <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Monoid.toMulAction#doc\">docs#Monoid.toMulAction</a> ), which also defines a \\bu b as a * b</p>\n<p>That is, the problem we had is that the two scalar multiplications int \\bu int are mathematically the same (z * x vs x + ... + x), but defined differently, and we've solved it by making the definition of SubNegMonoid.SMulInt more flexible</p>\n<p>Does that help?</p>",
        "id": 456970694,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1722983961
    }
]