[
    {
        "content": "<p>I'm making a data structure to store disjoint sets of keys that point to values:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHash</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHash</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- This maps from _sets_ of `k`s to `v`s -/</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- How to merge values together when key sets are merged -/</span>\n<span class=\"w\">  </span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysNew</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span>\n</code></pre></div>\n<p>However for this data structure to be correct I want to include a proof in the <code>DisjointSetMap</code> structure that:</p>\n<ul>\n<li>none of the hashsets are empty</li>\n<li>no two hashsets have any overlap. In other words, that for every single key there is at most one key set that contains that key</li>\n</ul>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Here's the full code, including my attempt at a proof so far</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashMap</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span>\n\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHash</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hash</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">toArray</span>\n\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">intersection_mem_both</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">EquivBEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulHashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">intersection</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">âˆ¨</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆ§</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">fold_eq_foldl_toList</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">mem_iff_contains</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">q</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">hv</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">ht</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">mem_insert</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">|</span><span class=\"n\">h</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BEq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">?_âŸ©</span>\n<span class=\"w\">          </span><span class=\"n\">rwa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">mem_iff_contains</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">â†</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">contains_congr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">      </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"bp\">Â·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"bp\">âŸ¨</span><span class=\"n\">Or</span><span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"bp\">âŸ©</span>\n\n\n\n\n<span class=\"sd\">/-- Gets the items in `a` that are not in `b` -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">HashSet</span><span class=\"bp\">.</span><span class=\"n\">diff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">âˆ˜</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">contains</span><span class=\"o\">)</span>\n\n\n\n\n\n\n\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instBeq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHash</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n\n\n\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NoEmptyKeys</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">keySetInMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">keySetNotEmpty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoEmptyKeys</span><span class=\"w\"> </span><span class=\"n\">map</span>\n\n<span class=\"sd\">/-- @TODO: Need help with this ğŸ‘‡ -/</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">mk</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">allPairsDisjoint</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"w\">                </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">âˆ‰</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">                </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"n\">map</span>\n\n\n\n<span class=\"sd\">/-- The vacuously true case for `NoKeyOverlap` where the map is empty. -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h1</span>\n\n\n\n\n\n\n\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BEq</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Hashable</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- This maps from _sets_ of `k`s to `v`s -/</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- A proof that the inner map has no key overlap -/</span>\n<span class=\"w\">  </span><span class=\"n\">noKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"n\">innerMap</span>\n<span class=\"w\">  </span><span class=\"sd\">/-- How to merge values together when key sets are merged -/</span>\n<span class=\"w\">  </span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysNew</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n\n\n\n\n\n\n\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span>\n\n\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">innerMap</span>\n<span class=\"w\">  </span><span class=\"bp\">|&gt;.</span><span class=\"n\">fold</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">keySet</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">map'</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n\n\n\n<span class=\"sd\">/-- A map with a separate key for each key in `d.innerMap`'s key sets.</span>\n\n<span class=\"sd\">A projection from the inner map to a map of individual keys to key sets _and_ values; so we can:</span>\n<span class=\"sd\">  a) find items in the map by a single key by doing `d.outerMap[key]`</span>\n<span class=\"sd\">  b) which then returns the full set of keys that the single key belongs to, as well as the value stored for that set. The values in this map have type `HashSet k Ã— v`</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">outerMap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">Ã—</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">getOuterMapFromInnerMap</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysNew</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span>\n<span class=\"w\">    </span><span class=\"n\">noKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">addSet</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">newKeySet</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">overlappingSets</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">newKeySet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"c1\">-- The no overlap case, so there's nothing to add here</span>\n<span class=\"w\">        </span><span class=\"n\">acc</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"c1\">-- If there is some overlap, we snowball the current set in the accumulated set, and include the value of the newly merged set in the list of values to merge later</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">union</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n\n\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">overlappingSets</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- No overlaps, just insert the new set with its value</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">newKeySet</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mergedSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">valuesToMerge</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Merge all overlapping sets and their values</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mergedValue</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">valuesToMerge</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">mergedSet</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Remove old sets</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hasOverlap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"bp\">.</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">newKeySet</span><span class=\"bp\">.</span><span class=\"n\">contains</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hasOverlap</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">newInnerMap</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"n\">newInnerMap</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- And insert the new snowballed merged set with its combined value</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">mergedSet</span><span class=\"w\"> </span><span class=\"n\">mergedValue</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n\n\n\n<span class=\"sd\">/-- This merges multiple sets without adding a new value. If none of the keys are in the map then this is a no-op because we have no value to set for it! -/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysToMerge</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">overlappingSets</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keysToMerge</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[]))</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">      </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"bp\">âˆ…</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"c1\">-- The no overlap case, so there's nothing to add here</span>\n<span class=\"w\">        </span><span class=\"n\">acc</span>\n<span class=\"w\">      </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"c1\">-- If there is some overlap, we snowball the current set in the accumulated set, and include the value of the newly merged set in the list of values to merge later</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"bp\">.</span><span class=\"n\">union</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"n\">union</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">)</span>\n\n\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">overlappingSets</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- No overlaps, none of the keys are in the map so we do nothing because we have no value to set for it</span>\n<span class=\"w\">    </span><span class=\"n\">d</span>\n\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mergedSet</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">firstVal</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">restValsToMerge</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Merge all overlapping sets and their values</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mergedValue</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">restValsToMerge</span><span class=\"bp\">.</span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">firstVal</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">mergeFn</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">mergedSet</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Remove old sets</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">innerMap</span><span class=\"bp\">.</span><span class=\"n\">fold</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"bp\">.</span><span class=\"n\">empty</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">hasOverlap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">currSet</span><span class=\"bp\">.</span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">keysToMerge</span><span class=\"bp\">.</span><span class=\"n\">contains</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">hasOverlap</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">          </span><span class=\"n\">newInnerMap</span><span class=\"bp\">.</span><span class=\"n\">erase</span><span class=\"w\"> </span><span class=\"n\">currSet</span>\n<span class=\"w\">        </span><span class=\"k\">else</span>\n<span class=\"w\">          </span><span class=\"n\">newInnerMap</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- And insert the new snowballed merged set with its combined value</span>\n<span class=\"w\">    </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">innerMap</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">newInnerMap</span><span class=\"bp\">.</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">mergedSet</span><span class=\"w\"> </span><span class=\"n\">mergedValue</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">find?</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">outerMap</span><span class=\"o\">[</span><span class=\"n\">key</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span>\n\n\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">find</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">key</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">outerMap</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"bp\">.</span><span class=\"n\">outerMap</span><span class=\"o\">[</span><span class=\"n\">key</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">|&gt;.</span><span class=\"m\">2</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap</span>\n</code></pre></div>\n</div></div>\n<p>but I don't think I'm going down the right path here. Is there a better and ideally simpler way to prove this property?</p>",
        "id": 511236455,
        "sender_full_name": "aron",
        "timestamp": 1744222284
    },
    {
        "content": "<p>why are your predicates defined as inductives? why not define them like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NoEmptyKeys</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"n\">keySet</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">Â¬</span><span class=\"n\">keySet</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet1</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span>\n</code></pre></div>",
        "id": 511294024,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744249203
    },
    {
        "content": "<p>also, notice that <code>NoKeyOverlap</code> doesn't need to check if the sets are nonempty because <code>NoEmptyKeys</code> already takes care of that (assuming you include <code>NoEmptyKeys</code> in the <code>DisjointSetMap</code> structure)</p>",
        "id": 511294106,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1744249271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/Proof.20that.20HashSets.20don't.20have.20any.20overlap/near/511294024\">said</a>:</p>\n<blockquote>\n<p>why are your predicates defined as inductives?</p>\n</blockquote>\n<p>Good point â€“ because I needed them to be inductives for this <a href=\"#narrow/channel/113489-new-members/topic/How.20to.20encode.20a.20tree.20in.20a.20Std.2EHashMap.20and.20prove.20no.20cycles.3F/with/506000447\">other data structure</a> I made, but you're right that since this property isn't recursive it can just be a regular function</p>",
        "id": 511387876,
        "sender_full_name": "aron",
        "timestamp": 1744286085
    },
    {
        "content": "<p>Your definition of <code>NoKeyOverlap</code> looks good, but I probably also need a proof that <code>keySet1</code> and <code>keySet2</code> are not the same key set, right?</p>\n<p>So something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NoKeyOverlap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DisjointSetMap'</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">âˆ€</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HashSet</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">âˆˆ</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"bp\">â†’</span>\n<span class=\"w\">  </span><span class=\"n\">keySet1</span><span class=\"w\"> </span><span class=\"bp\">â‰ </span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"w\"> </span><span class=\"bp\">â†’</span><span class=\"w\"> </span><span class=\"c1\">-- &lt;-- distinctness proof</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">keySet1</span><span class=\"bp\">.</span><span class=\"n\">intersection</span><span class=\"w\"> </span><span class=\"n\">keySet2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">isEmpty</span>\n</code></pre></div>",
        "id": 511389122,
        "sender_full_name": "aron",
        "timestamp": 1744286410
    },
    {
        "content": "<p>Why would you need that? If they are equal their intersection won't be empty (as long as not both are empty)</p>",
        "id": 511390007,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1744286639
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"619540\">@Johannes Tantow</span> right but if you don't require <code>keySet1</code> and <code>keySet2</code> to be different sets then you could never construct a valid proof because you could not prove that <code>(keySet1.intersection keySet2).isEmpty</code> for <em>all</em> keySets â€“ namely when <code>keySet1 = keySet2</code></p>",
        "id": 511456573,
        "sender_full_name": "aron",
        "timestamp": 1744302613
    },
    {
        "content": "<p>I have missed the forall true. I thought it is just a property for two general hash sets</p>",
        "id": 511458167,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1744303060
    },
    {
        "content": "<p>In that case, you are right and can ignore everything I said</p>",
        "id": 511459153,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1744303319
    },
    {
        "content": "<p>Though perhaps <code>map.keys.Pairwise (fun x y =&gt; (x.intersection y).isEmpty)</code> might be more succint, but that is probably not an easier proof.</p>",
        "id": 511461657,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1744304117
    }
]