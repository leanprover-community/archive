[
    {
        "content": "<p>Been playing around with proving some of the logic I learned in undergrad many moons ago.<br>\nCame up with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">or_assoc</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"k\">have</span> <span class=\"n\">mp</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Or.elim</span> <span class=\"bp\">·</span>\n    <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"bp\">∘</span> <span class=\"n\">Or.inl</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">Or.elim</span> <span class=\"bp\">·</span> <span class=\"o\">(</span><span class=\"n\">Or.inl</span> <span class=\"bp\">∘</span> <span class=\"n\">Or.inr</span><span class=\"o\">)</span> <span class=\"n\">Or.inr</span><span class=\"o\">))</span>\n  <span class=\"k\">have</span> <span class=\"n\">mpr</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Or.elim</span> <span class=\"bp\">·</span>\n    <span class=\"o\">(</span><span class=\"n\">Or.elim</span> <span class=\"bp\">·</span> <span class=\"n\">Or.inl</span> <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"bp\">∘</span> <span class=\"n\">Or.inl</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"n\">Or.inr</span> <span class=\"bp\">∘</span> <span class=\"n\">Or.inr</span><span class=\"o\">))</span>\n  <span class=\"o\">⟨</span><span class=\"n\">mp</span><span class=\"o\">,</span><span class=\"n\">mpr</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>Thumbs up!</p>\n<p>Looking into the mathlib solution, it looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">or_assoc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">c</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">∨</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">⟨</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">imp_right</span> <span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"bp\">∘</span> <span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"o\">),</span> <span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"bp\">∘</span> <span class=\"bp\">.</span><span class=\"n\">inl</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">imp_left</span> <span class=\"bp\">.</span><span class=\"n\">inr</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<hr>\n<p>These are quite similar (which is nice). I can see how <code>Or.imp_right</code> is implemented, but I can't find Or.rec defined anywhere. I also can't find anything about this dotted identifier notation where you can omit the the <code>Or</code> from Or.rec.</p>\n<p>I seems <code>.rec</code> must be just reordering the parameters on <code>Or.elim</code>, but I can't find the function anywhere.</p>",
        "id": 404897861,
        "sender_full_name": "Treq",
        "timestamp": 1701273193
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Or.elim#doc\">docs#Or.elim</a> is implemented in terms of <code>Or.rec</code>!</p>",
        "id": 404897993,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701273240
    },
    {
        "content": "<p>You can't find it because it is defined by the <code>inductive</code> keyword</p>",
        "id": 404898094,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701273266
    },
    {
        "content": "<p><code>Or.rec</code> is an axiom of the construction of <code>Or</code>, basically</p>",
        "id": 404898146,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701273280
    },
    {
        "content": "<p>Or.elim is just a match on the two options</p>",
        "id": 404898168,
        "sender_full_name": "Treq",
        "timestamp": 1701273290
    },
    {
        "content": "<p>Is <code>.rec</code> something just auto-magically defined for inductive types?</p>",
        "id": 404898424,
        "sender_full_name": "Treq",
        "timestamp": 1701273364
    },
    {
        "content": "<p>Yep</p>",
        "id": 404898607,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1701273431
    },
    {
        "content": "<p>What's it doing? Is it short for something? It must be related to match statements, you do a match without a term for the type your matching... something like that?</p>",
        "id": 404899128,
        "sender_full_name": "Treq",
        "timestamp": 1701273587
    },
    {
        "content": "<p>Usually, <code>match</code> statements elaborate to a <code>rec</code> invocation</p>",
        "id": 404903393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1701274900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"664276\">Treq</span> has marked this topic as resolved.</p>",
        "id": 404931262,
        "sender_full_name": "Notification Bot",
        "timestamp": 1701284252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"664276\">Treq</span> <a href=\"#narrow/stream/113489-new-members/topic/.E2.9C.94.20Or.2Erec/near/404899128\">said</a>:</p>\n<blockquote>\n<p>Is it short for something?</p>\n</blockquote>\n<p><code>rec</code> is short for \"recursor\", it is a primitive which describes how to recurse over the inductive type or break it into its components</p>",
        "id": 404962786,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701297884
    }
]