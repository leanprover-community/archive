[
    {
        "content": "<p>Apologies if this is a silly question (I'm a beginner!), but here goes:</p>\n<p>I’ve seen the statement \"the kernel of a homomorphism ϕ : G → H is a subgroup of G\" formalized as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span>\n</code></pre></div>\n<p>Now, if we treat the proof as a black box:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It doesn’t seem to say anything specifically about the kernel, does it?</p>\n<p>More precisely, my reading of \"(φ : G →* H) : Subgroup G\" is: \"given a homomorphism φ : G → H, I can construct a subgroup of G\".</p>\n<p>So, what am I missing here?</p>\n<p>Is there a way to formalize the statement \"the kernel of a homomorphism ϕ : G → H is a subgroup of G\" such that we don’t have to look inside the proof itself to confirm it’s really saying that it is specifically <em>the kernel</em> that is a subgroup of G?</p>",
        "id": 495601492,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1737673637
    },
    {
        "content": "<p>Maybe something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 495602534,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737674239
    },
    {
        "content": "<p>This does not work. Typing are not Lean statements. What you want to do here is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSubgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 495604551,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1737675454
    },
    {
        "content": "<p>I guess I’m trying to figure out whether there’s a deeper reason experts formalize the statement as <code>example (φ : G →* H) : Subgroup G := φ.ker</code> (such as in this example <a href=\"https://github.com/ImperialCollegeLondon/formalising-mathematics-2024/blob/0eb9abdd52bde8f2ebb6fc1d4568d7f8f559c32a/FormalisingMathematics2024/Section07subgroupsAndHomomorphisms/Sheet2.lean#L82\">Formalizing Mathematics 2024</a>), or if it’s simply a brief example where it’s assumed that whoever reads it will look at both the statement and the proof together to piece together the overall statement.</p>",
        "id": 495604659,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1737675501
    },
    {
        "content": "<p>This is not really a formalization of the fact you're talking about, it's just an example that this works. <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=MonoidHom.ker#doc\">docs#MonoidHom.ker</a> is defined to be a subgroup, this is where it is formalized.</p>",
        "id": 495604939,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1737675697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"703970\">Etienne Marion</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/495604551\">said</a>:</p>\n<blockquote>\n<p>This does not work. Typing are not Lean statements. What you want to do here is this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">IsSubgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for the helpful comment, would you mind explaining why it doesn't work?<br>\nThat is, i can form the statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>And my answer was about how to annotate his example, for it not to be a black box and to say that the kernel is a subgroup. So anything informative would be greatly appreciated!</p>",
        "id": 495605610,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737676121
    },
    {
        "content": "<p>The conclusion of the the theorem should go on the right side of the <code>:</code>. In this case, you have <code>(φ.ker:Subgroup G)</code>. This means that you are trying to make an element of type <code>(φ.ker:Subgroup G)</code>. In other words, an element of <code>φ.ker</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- `φ.ker` is a `Subgroup`, so in particular it must contain `1`.</span>\n</code></pre></div>\n<p>Writing <code>(φ.ker:Subgroup G)</code> is called a type annotation and it means something like \"<code>φ.ker</code>, which is a <code>Subgroup G</code>\". So for example I could write <code>(1 : Rat) = 1 + 0</code> and it would mean \"<code>1</code> (which is a <code>Rat</code>) equals <code>1 + 0</code>\". In Lean this is not a statement that could be true or false, but rather a judgement that must be true or your code won't compile.</p>",
        "id": 495607415,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737677097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/495607415\">said</a>:</p>\n<blockquote>\n<p>The conclusion of the the theorem should go on the right side of the <code>:</code>. In this case, you have <code>(φ.ker:Subgroup G)</code>. This means that you are trying to make an element of type <code>(φ.ker:Subgroup G)</code>. In other words, an element of <code>φ.ker</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MulOneClass</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"o\">:</span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"c1\">-- `φ.ker` is a `Subgroup`, so in particular it must contain `1`.</span>\n</code></pre></div>\n<p>Writing <code>(φ.ker:Subgroup G)</code> is called a type annotation and it means something like \"<code>φ.ker</code>, which is a <code>Subgroup G</code>\". So for example I could write <code>(1 : Rat) = 1 + 0</code> and it would mean \"<code>1</code> (which is a <code>Rat</code>) equals <code>1 + 0</code>\". In Lean this is not a statement that could be true or false, but rather a judgement that must be true or your code won't compile.</p>\n</blockquote>\n<p>I was simply answering the question, of treating it like a black box, and formalising the statement saying that it is the kernel thats the subgroup.</p>",
        "id": 495607635,
        "sender_full_name": "Abraham Solomon",
        "timestamp": 1737677218
    },
    {
        "content": "<p>As Aaron pointed out, <code>example (φ : G →* H) : (φ.ker:Subgroup G)</code> does not mean \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi><mo stretchy=\"false\">(</mo></mrow><mi>ϕ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ker(}\\phi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ker</span><span class=\"mopen\">(</span></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> is a subgroup of G\" but merely \"there exists an element in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi></mrow><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{ker}(\\phi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ker</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span>\". It is the same as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span>\n</code></pre></div>",
        "id": 495608048,
        "sender_full_name": "Etienne Marion",
        "timestamp": 1737677494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/495607635\">said</a>:</p>\n<blockquote>\n<p>I was simply answering the question, of treating it like a black box, and formalising the statement saying that it is the kernel thats the subgroup.</p>\n</blockquote>\n<p>How would you write the opposite statement, \"<code>φ.ker</code> is not a <code>Subgroup G</code>\"?</p>",
        "id": 495608257,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1737677641
    },
    {
        "content": "<p>I also think that there is a related discussion here that might be relevant.</p>",
        "id": 495672201,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1737711861
    },
    {
        "content": "<p>Correctness of <em>definitions</em> is up to the human: you are in charge of making sure that your code describes what you want.</p>",
        "id": 495672233,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1737711871
    },
    {
        "content": "<p>Correctness of <em>proofs</em> is left to the computer.</p>",
        "id": 495672297,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1737711885
    },
    {
        "content": "<p>The theorem statements should encode enough properties of your definitions that they uniquely characterise them, so that you can be \"sure\" that you defined what you wanted.</p>",
        "id": 495672309,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1737711888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"776452\">@Abraham Solomon</span> To formalize the statement: \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ker(\\phi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> is a subgroup\" we must first agree on what the formal definition of \"kernel\" is.<br>\nIn mathlib, the kernel of a group homomorphism is a subgroup by <em>definition</em>. So there is nothing left to prove.</p>\n<p>However, if you say the kernel is only a subset, then there is of course something left to prove.</p>\n<p>This means that one way to formalize your claim is to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>or alternatively something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>ker</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">x \\in \\ker(\\phi) \\iff \\phi(x) = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\">ker</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟺</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>.</p>",
        "id": 495677961,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737713622
    },
    {
        "content": "<p>I was going to suggest looking at the definition of <code>ker</code>, but it's not very beginner-friendly. Alternatively you can build it yourself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"n\">hb</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n</code></pre></div>\n<p>(And note that Johan is confusing the kernel of additive and multiplicative groups)</p>",
        "id": 495688887,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1737716844
    },
    {
        "content": "<p>Does it help to think about how you might state \"the addition of two natural numbers is a natural number\"? In both cases, the return type of the operation in question makes the mathematical question vacuous.</p>",
        "id": 495693251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1737718426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/495677961\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"776452\">Abraham Solomon</span> To formalize the statement: \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mi>e</mi><mi>r</mi><mo stretchy=\"false\">(</mo><mi>ϕ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">ker(\\phi)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϕ</span><span class=\"mclose\">)</span></span></span></span> is a subgroup\" we must first agree on what the formal definition of \"kernel\" is.</p>\n</blockquote>\n<p>That is indeed a good point; I should have made it clearer in my original post. The undergraduates I will show this to are accustomed to the definitions in Dummit &amp; Foote, so I will use the following definition and result:</p>\n<p><strong>Definition.</strong> If ϕ is a homomorphism ϕ: G → H, the kernel of ϕ is the set { g ∈ G | ϕ(g)=1 } and will be denoted by ker ϕ (here 1 is the identity of H).</p>\n<p><strong>Theorem.</strong> Let G and H be groups and let ϕ: G → H be a homomorphism. ker ϕ is a subgroup of G.</p>",
        "id": 495987519,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1737914108
    },
    {
        "content": "<p>When I give this exercise to my undergraduates, I just write</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 495988788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737915094
    },
    {
        "content": "<p>alternatively, you could ask them to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 495991460,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1737917361
    },
    {
        "content": "<p>It might be helpful to note that in Mathlib, a subgroup is a <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C06_Structures.html\">structure</a> consisting of 4 fields, only one of which (called the \"carrier\") is a set. The other 3 fields are proofs that the carrier obeys certain properties. E.g. when defining the subgroup of rotations of a dihedral group I have to give the definition of the carrier (which is 1 line long) and then 3 proofs (which are longer):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">GroupTheory</span><span class=\"bp\">.</span><span class=\"n\">SpecificGroups</span><span class=\"bp\">.</span><span class=\"n\">Dihedral</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">DihedralGroup</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Rot</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">DihedralGroup</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ZMod</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">a_is_ri</span><span class=\"w\"> </span><span class=\"n\">b_is_ri</span>\n<span class=\"w\">    </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">a_is_ri</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"n\">r_i1_is_a</span>\n<span class=\"w\">    </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">b_is_ri</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i2</span><span class=\"w\"> </span><span class=\"n\">r_i1_is_b</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i2</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">r_i1_is_a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">r_i1_is_b</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">r_mul_r</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">x_in_A</span>\n<span class=\"w\">    </span><span class=\"n\">cases'</span><span class=\"w\"> </span><span class=\"n\">x_in_A</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">ri_is_x</span>\n<span class=\"w\">    </span><span class=\"n\">use</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">i</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">ri_is_x</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So the translation of the definition of a kernel is more like:</p>\n<p><strong>Definition</strong>. If ϕ is a homomorphism ϕ: G → H, the kernel of ϕ, denoted by φ.ker is a structure consisting of four fields:</p>\n<ul>\n<li>φ.ker.carrier, a set defined as { g ∈ G | ϕ(g)=1 }</li>\n<li>φ.ker.mul_mem', a proof that <code>(ker φ).carrier</code> is closed under multiplication</li>\n<li>φ.ker.one_mem', a proof that <code>(ker φ).carrier</code> contains 1</li>\n<li>φ.ker.inv_mem', a proof that <code>(ker φ).carrier</code> is closed under inversion</li>\n</ul>\n<p>The slightly awkward thing is that the only way built-in to access the carrier set without redefining it is to say <code>φ.ker.carrier</code>, which is taking the \"set + proofs\" objects and forgetting the proofs</p>",
        "id": 495993556,
        "sender_full_name": "Li Xuanji",
        "timestamp": 1737919066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/495988788\">said</a>:</p>\n<blockquote>\n<p>When I give this exercise to my undergraduates, I just write</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In this case, <code>simp</code> seems way too powerful for this to make up an exercise. It looks a bit like Lean's version of \"just write what you need to prove and check that it works\", except in this case you don't even have to write what you need to prove.</p>",
        "id": 495994237,
        "sender_full_name": "Philippe Duchon",
        "timestamp": 1737919585
    },
    {
        "content": "<p>If you don't want the simplifier to be able to do it then make your own groups. I also set this as an exercise, I use five axioms (left and right identity, left and right inverse, associativity). Or make your own group homomorphisms, I do this too (but using Lean's groups)</p>",
        "id": 496016595,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737938332
    },
    {
        "content": "<p>Thanks for the very helpful replies. I have now written this in three different ways. Do they look reasonable?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Definition:</span>\n<span class=\"c1\">--   If ϕ is a homomorphism ϕ: G → H, the kernel of ϕ is the set { g ∈ G | ϕ(g)=1 } and</span>\n<span class=\"c1\">--   will be denoted by ker ϕ (here 1 is the identity of H).</span>\n<span class=\"c1\">-- Theorem:</span>\n<span class=\"c1\">--   Let G and H be groups and let ϕ: G → H be a homomorphism. ker ϕ is a subgroup of G.</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSubgroup</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"bp\">.</span><span class=\"n\">ker</span><span class=\"bp\">.</span><span class=\"n\">isSubgroup</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Group</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"bp\">→*</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Subgroup</span><span class=\"w\"> </span><span class=\"n\">G</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"o\">{</span>\n<span class=\"w\">    </span><span class=\"n\">carrier</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">φ</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">},</span>\n<span class=\"w\">    </span><span class=\"n\">mul_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">one_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"n\">inv_mem'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 496228806,
        "sender_full_name": "Isak Colboubrani",
        "timestamp": 1738020336
    },
    {
        "content": "<p>Yes, these look good to me.<br>\nNote that the kernel of a group in Mathlib is defined more generally where the codomain is  any type where <code>1</code> is a two-sided identity to multiplication, not just a group (which also has stuff like associativity and inverses).</p>",
        "id": 496229813,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738020845
    },
    {
        "content": "<p><code>IsSubgroup</code> is deprecated and about to be deleted</p>",
        "id": 496269903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738048272
    },
    {
        "content": "<p>Note also that <code>by exact</code> does nothing: <code>by</code> switches from term mode to tactic mode and <code>exact</code> switches from tactic mode to term mode.</p>",
        "id": 496270130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738048407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/channel/113489-new-members/topic/The.20kernel.20of.20a.20homomorphism.20.CF.95.20.3A.20G.20.E2.86.92.20H.20is.20a.20subgroup.20of.20G/near/496269903\">said</a>:</p>\n<blockquote>\n<p><code>IsSubgroup</code> is deprecated and about to be deleted</p>\n</blockquote>\n<p>Really? How do you say a set forms a subgroup then?</p>",
        "id": 496325826,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738068150
    },
    {
        "content": "<p>You don't. You build the set as a subgroup instead</p>",
        "id": 496325912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1738068181
    },
    {
        "content": "<p>What about for something like <code>∀ᶠ n in atTop, IsSubgroup (f n)</code></p>",
        "id": 496327305,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1738068677
    },
    {
        "content": "<p>That happens in theory but in 1.5 million lines of mathlib it doesn't seem to happen in practice.</p>",
        "id": 496345166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738073773
    },
    {
        "content": "<p>And if it really did happen, you could just say stuff like <code>\\forall a b \\in f n, a * b \\in f n</code> or whatever</p>",
        "id": 496345326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738073821
    },
    {
        "content": "<p>Or simply: <code>∀ᶠ in atTop, ∃ H : Subgroup G, (H : Set G) = f n</code> (assuming <code>f : ℕ → Set G</code> or some other index set).</p>",
        "id": 496348210,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1738074530
    },
    {
        "content": "<p>Even better!</p>",
        "id": 496358757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738077104
    },
    {
        "content": "<p>In fact what happened in practice was that there were things which were <em>always</em> group homomorphisms but which had been defined as plain functions; the fix nowadays is just to make another definition, defining the group homomorphism as well.</p>",
        "id": 496359461,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1738077302
    }
]