[
    {
        "content": "<p>Cannot prove <code>4</code> is a square using <code>decide</code> in <code>v4.16.0</code>.<br>\nBut in the latest version <code>decide</code> can solve this, I was wondering which PR fixes this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- !failed</span>\n</code></pre></div>\n<p>It produce the following error:</p>\n<blockquote>\n<p>tactic 'decide' failed for proposition<br>\n  IsSquare 4<br>\nsince its 'Decidable' instance<br>\n  Nat.instDecidablePredIsSquare 4<br>\ndid not reduce to 'isTrue' or 'isFalse'.<br>\nAfter unfolding the instances 'decidable_of_decidable_of_iff', 'decidable_of_iff'', 'instDecidableEqBool', 'instDecidableEqNat', 'Bool.decEq', 'Nat.decEq', 'Nat.decLe' and 'Nat.instDecidablePredIsSquare', reduction got stuck at the 'Decidable' instance<br>\n  match h : (Nat.sqrt 4 * Nat.sqrt 4).beq 4 with<br>\n  | true =&gt; isTrue ⋯<br>\n  | false =&gt; isFalse ⋯</p>\n</blockquote>\n<p>In the latest version, if I use <code>decide</code> to prove <code>1600</code> is a square it will reach maximum recursion depth which is upseting.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"c1\">-- !failed</span>\n</code></pre></div>\n<p>If I change maximum recursion depth, it is very slow to <code>decide</code> that <code>1600</code> is a square.</p>",
        "id": 513561938,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1745314366
    },
    {
        "content": "<p>if you know it's square, you might as well prove it by providing the square root, and only ask lean to do the calculation</p>",
        "id": 513566594,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745315718
    },
    {
        "content": "<p>the main reason lean takes long here is that lean needs to figure out if there is a square root, which can take a while depending on what kind of sound algorithm you want to use</p>",
        "id": 513566971,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745315839
    },
    {
        "content": "<p>from looking at the implementation of <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.instDecidablePredIsSquare#doc\">docs#Nat.instDecidablePredIsSquare</a> (and <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sqrt#doc\">docs#Nat.sqrt</a>), it seems the algorithm is already decently efficient (imo)</p>",
        "id": 513567681,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745316026
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"c1\">-- 40</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"c1\">-- max recursion depth</span>\n</code></pre></div>",
        "id": 513578961,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745319733
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">native_decide</span><span class=\"w\"> </span><span class=\"c1\">-- works quickly</span>\n</code></pre></div>",
        "id": 513579042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745319763
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"mi\">40</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"c1\">-- works quickly</span>\n</code></pre></div>\n<p>so the problem is that the kernel can't do the square root, by the looks of things.</p>",
        "id": 513579191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745319822
    },
    {
        "content": "<p>But this is kernel-verified, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"c1\">-- 40, quickly</span>\n</code></pre></div>\n<p>so someone who understands what's going on should be able to fix this</p>",
        "id": 513579472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1745319909
    },
    {
        "content": "<p>I'm guessing <code>norm_num</code> computes the square root efficiently with the compiler, and then uses something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.eq_sqrt#doc\">docs#Nat.eq_sqrt</a> to pass to the kernel.</p>",
        "id": 513579965,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745320057
    },
    {
        "content": "<p>I checked out what <code>norm_num</code> is outputting, it's</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">IsNat</span><span class=\"bp\">.</span><span class=\"n\">to_eq</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">isNat_sqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">isNat_ofNat</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">nat_sqrt_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">40</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 513580642,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745320295
    },
    {
        "content": "<p>the proof basically says \"1600.sqrt is equal to 40, because 40*40 + 0 = 1600 and 0 &lt; 2 * 40\", and from there just completes the proof</p>",
        "id": 513583817,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745321338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Cannot.20decide.204.20is.20a.20square.20in.20v4.2E16.2E0/near/513580642\">said</a>:</p>\n<blockquote>\n<p>I checked out what <code>norm_num</code> is outputting, it's</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">IsNat</span><span class=\"bp\">.</span><span class=\"n\">to_eq</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">isNat_sqrt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Meta</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">isNat_ofNat</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">NormNum</span><span class=\"bp\">.</span><span class=\"n\">nat_sqrt_helper</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"o\">)))</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"w\"> </span><span class=\"mi\">40</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>there's a bunch of implicit arguments here which make it not immediately clear which values are calculated; something like <code>set_option pp.explicit true</code> should show that indeed it uses <code>nat_sqrt_helper</code> with the arguments i said</p>",
        "id": 513584178,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745321447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Cannot.20decide.204.20is.20a.20square.20in.20v4.2E16.2E0/near/513579965\">said</a>:</p>\n<blockquote>\n<p>I'm guessing <code>norm_num</code> computes the square root efficiently with the compiler, and then uses something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.eq_sqrt#doc\">docs#Nat.eq_sqrt</a> to pass to the kernel.</p>\n</blockquote>\n<p>So I can use <code>norm_num</code> to prove <code>IsSquare 1600</code> efficiently. That's what I want, thanks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">isSquare_iff</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"n\">sqrt</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp_rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">IsSquare</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">exists_mul_self</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">eq_comm</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSquare</span><span class=\"w\"> </span><span class=\"mi\">1600</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">isSquare_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">norm_num</span>\n</code></pre></div>",
        "id": 513585514,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1745321856
    },
    {
        "content": "<p>This is because the innards of Nat.sqrt are now irreducible</p>",
        "id": 513626171,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745332285
    },
    {
        "content": "<p>This is pretty unfortunate, because it means things like <code>(Finset.range 10).filter IsSquare = {0, 1, 4, 9}</code> is decidable but not provable by <code>decide</code></p>",
        "id": 513626484,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745332347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/113489-new-members/topic/Cannot.20decide.204.20is.20a.20square.20in.20v4.2E16.2E0/near/513626171\">said</a>:</p>\n<blockquote>\n<p>This is because the innards of Nat.sqrt are now irreducible</p>\n</blockquote>\n<p>which innards do you mean? it looks to me like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.sqrt.iter#doc\">docs#Nat.sqrt.iter</a> is marked semireducible?</p>",
        "id": 513626951,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1745332451
    },
    {
        "content": "<p>Only as of two weeks ago</p>",
        "id": 513627180,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745332513
    },
    {
        "content": "<p>So not in any tagged release of mathlib</p>",
        "id": 513627220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745332523
    },
    {
        "content": "<p>Thanks for the fix <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>!</p>",
        "id": 513627279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1745332538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"757121\">Zhang Qinchuan</span> has marked this topic as resolved.</p>",
        "id": 513893825,
        "sender_full_name": "Notification Bot",
        "timestamp": 1745420125
    }
]