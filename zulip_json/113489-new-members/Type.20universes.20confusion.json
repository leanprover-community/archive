[
    {
        "content": "<p>Let's start with this valid Lean code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>since <code>#check Nat</code> tells me <code>Nat</code> is of type <code>Type = Type 0</code>, I can abstract like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>So far so good, but when I repeat this one more time - type of <code>Type</code> is <code>Type 1</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I get a Lean error. What am I missing that explains this behavior?</p>",
        "id": 555269242,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763011299
    },
    {
        "content": "<p>Why do you think that if <code>(T: T')</code> then <code>T</code> is a type?</p>",
        "id": 555274783,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763014914
    },
    {
        "content": "<p>What else could it be?</p>",
        "id": 555274938,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763014996
    },
    {
        "content": "<p>It is a term of type <code>T'</code></p>",
        "id": 555275004,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015035
    },
    {
        "content": "<p>Well, ok, in this example we can have <code>T' = Type</code>.<br>\nThen <code>Type : Type 1</code> ok, <code>T : Type</code> ok</p>",
        "id": 555275118,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015113
    },
    {
        "content": "<p>Yes, I am just generalizing the types that were previously accepted</p>",
        "id": 555275177,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763015163
    },
    {
        "content": "<p>But I suppose that if <code>T' : Type 1</code> is any other thing than <code>T' = Type</code> then terms of <code>T'</code> are just that: terms? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 555275184,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015165
    },
    {
        "content": "<p>Yes, I was wondering what would those other things be, because the error doesn’t specify. Also the error is in x: T only so T:T’ is accepted</p>",
        "id": 555275409,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763015284
    },
    {
        "content": "<p>Well, another thing it can be is <code>T' = ℕ × Type</code>,  for example. Then <code>T' : Type 1</code> ok, <code>T : ℕ × Type</code> ok, but <code>x : T</code> not ok. <code>T</code> isn't a type, it's a pair (natural number + type)</p>",
        "id": 555276047,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015657
    },
    {
        "content": "<p>I think <code>T : Type 1</code> is more like \"<code>T</code> is a type so large it doesn't fit into <code>Type</code>\" than \"<code>T</code> is a metatype whose terms are types\"</p>",
        "id": 555276151,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015715
    },
    {
        "content": "<p>I don't know if there is a way to say the latter in Lean, that's an interesting question</p>",
        "id": 555276205,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1763015745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488971\">@Rado Kirov</span> <code>T'</code> could be <code>Cardinal.{0}</code>, for instance. In that case <code>T</code> would be a specific cardinal, and it wouldn't make sense to say <code>x : T</code></p>",
        "id": 555438651,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763061355
    },
    {
        "content": "<blockquote>\n<p>Also the error is in x: T only so T:T’ is accepted</p>\n</blockquote>\n<p>This isn't too surprising... you've declared that <code>T'</code> is a type, so it makes sense to say that you have a term <code>T</code> of type <code>T'</code>. The problem arises when you try to assume that <code>T</code> is also a type.</p>",
        "id": 555441368,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763062164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488971\">Rado Kirov</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555275177\">said</a>:</p>\n<blockquote>\n<p>Yes, I am just generalizing the types that were previously accepted</p>\n</blockquote>\n<p>well, that's not how maths/lean works...<br>\nthe only time you can ever do a double colon is with <code>Prop</code> and <code>Type _</code> (both are collective called <code>Sort _</code>)</p>",
        "id": 555442171,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763062376
    },
    {
        "content": "<p>Would it be accurate to say that there's only a single type at any non-zero universe level whose terms are also types?</p>",
        "id": 555443048,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763062636
    },
    {
        "content": "<p>that's circular, what does \"at universe level X\" mean</p>",
        "id": 555443317,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763062727
    },
    {
        "content": "<p>like one of the terms of <code>Type 10</code> is <code>Type 9</code>, which itself has types as terms, but the other terms of <code>Type 10</code> don't... though now that I say this, I'm realizing that it doesn't take <code>ULift</code> into consideration</p>",
        "id": 555443725,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763062855
    },
    {
        "content": "<p>like you could also lift <code>Type 5</code> so that it's a term of <code>Type 10</code> (I think?)</p>",
        "id": 555443987,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763062936
    },
    {
        "content": "<p>I see, yes that's correct (if we believe in unique typing)</p>",
        "id": 555444251,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763063011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555443725\">said</a>:</p>\n<blockquote>\n<p>like one of the terms of <code>Type 10</code> is <code>Type 9</code>, which itself has types as terms, but the other terms of <code>Type 10</code> don't... though now that I say this, I'm realizing that it doesn't take <code>ULift</code> into consideration</p>\n</blockquote>\n<p>This isn't a question you can ask in Lean</p>",
        "id": 555449094,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763064574
    },
    {
        "content": "<p>\"does term x have type T\" isn't a question you can ask in Lean</p>",
        "id": 555449213,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763064616
    },
    {
        "content": "<p>I'm not sure I follow... I'm not asking if a term has a specific type, I'm asking if a term is a type</p>",
        "id": 555449576,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763064747
    },
    {
        "content": "<p>is it not accurate to say that some types are type universes and other types are just types?</p>",
        "id": 555449684,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763064791
    },
    {
        "content": "<p>You would have to say what a universe is</p>",
        "id": 555449738,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763064808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555449576\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I follow... I'm not asking if a term has a specific type, I'm asking if a term is a type</p>\n</blockquote>\n<p>The way to say a term <code>t</code> is a type is to write <code>t : Type _</code> so that's the same thing</p>",
        "id": 555449856,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763064853
    },
    {
        "content": "<p>You're asking if <code>t</code> has type <code>Type _</code></p>",
        "id": 555449922,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763064881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> note that this code does not compile:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">IsSort</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsSort</span><span class=\"w\"> </span><span class=\"n\">T</span>\n</code></pre></div>",
        "id": 555450122,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763064961
    },
    {
        "content": "<p>I'm just saying that <code>Type (u+1)</code> has a single term called <code>Type u</code> whose terms are also types, and the rest of the terms of <code>Type (u+1)</code> do not seem to have this property... I understand that this isn't a mathematical fact that one could prove in Lean, but is actually the structure of Lean itself</p>",
        "id": 555450542,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763065137
    },
    {
        "content": "<p>What does it mean for a term to \"be a type\"</p>",
        "id": 555450656,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763065185
    },
    {
        "content": "<p>I confirmed that above, saying that it's true if we assume unique typing</p>",
        "id": 555450657,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1763065185
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"380294\">@Matt Diamond</span> 's question makes a lot of sense to me.</p>\n<p>When I write something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"o\">:</span><span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">False</span>\n</code></pre></div>\n<p>Lean errors with <code>type expected, got (3 : ℕ)</code> which basically is saying <code>3</code> is not a type. Same with my example</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T'</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T'</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Clearly this has nothing to do with the LHS of the : it is just the name of the free variable, so there is some internal determination on <code>what is a type</code>, i.e. what can I write RHS of : and what not.</p>",
        "id": 555450847,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763065255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I know, I'm just responding to <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>'s question about whether or not what I'm saying is sufficiently defined</p>",
        "id": 555450949,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763065288
    },
    {
        "content": "<p>basically, <code>x : t</code> does not typecheck unless inferring the type of <code>t</code> gives you a <code>Sort _</code></p>",
        "id": 555451041,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763065322
    },
    {
        "content": "<p>yes, that's what it means for <code>t</code> to be a type</p>",
        "id": 555451106,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763065348
    },
    {
        "content": "<p>and this property of <code>t</code> is not preserved under definitional equality</p>",
        "id": 555451129,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763065361
    },
    {
        "content": "<p>could you give me an example of that? it does sound like it complicates the picture I had of what makes something a type</p>",
        "id": 555451340,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763065455
    },
    {
        "content": "<p>I didn't realize you could have a situation where <code>x : t</code> typechecks but <code>y : u</code> doesn't even though <code>t</code> and <code>u</code> are definitionally equal</p>",
        "id": 555451737,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763065596
    },
    {
        "content": "<p>I am not totally sure, but I think that the point is that you can have two terms <code>t</code> and <code>u</code> that are ideally definitionally equal (the \"true\" definitional equality\"), but Lean fails to realize so, and in practice you can write <code>x : t</code> but not <code>x : u</code></p>",
        "id": 555454626,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1763066671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"380294\">Matt Diamond</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555451340\">said</a>:</p>\n<blockquote>\n<p>could you give me an example of that? it does sound like it complicates the picture I had of what makes something a type</p>\n</blockquote>\n<p>I just checked and it seems to have been patched out</p>",
        "id": 555458756,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763068116
    },
    {
        "content": "<p>so maybe it was a bug</p>",
        "id": 555459214,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1763068301
    },
    {
        "content": "<p>hmm... so maybe the distinction between \"X is a type\" and \"X is not a type\" is mostly clear-cut, at least for now <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 555460411,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763068806
    },
    {
        "content": "<p>I am (almost) sure that there is theorem/axiom/whatever in type theory saying that if you have <code>x : t</code> and <code>y : u</code> with <code>x ≡ y</code> then <code>t ≡ u</code>, where <code>≡</code> is the ideal definitional equality (the one that is transitive but undecidable in Lean).</p>",
        "id": 555464307,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1763070310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555454626\">said</a>:</p>\n<blockquote>\n<p>I am not totally sure, but I think that the point is that you can have two terms <code>t</code> and <code>u</code> that are ideally definitionally equal (the \"true\" definitional equality\"), but Lean fails to realize so, and in practice you can write <code>x : t</code> but not <code>x : u</code></p>\n</blockquote>\n<p>This is discussed in Section 3.1.1 of Mario's thesis. Specifically, the form of definitional equality actually checked by Lean isn't transitive.</p>",
        "id": 555482539,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763079589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/113489-new-members/topic/Type.20universes.20confusion/near/555464307\">said</a>:</p>\n<blockquote>\n<p>I am (almost) sure that there is theorem/axiom/whatever in type theory saying that if you have <code>x : t</code> and <code>y : u</code> with <code>x ≡ y</code> then <code>t ≡ u</code>, where <code>≡</code> is the ideal definitional equality (the one that is transitive but undecidable in Lean).</p>\n</blockquote>\n<p>I think you're thinking of unique typing, which is a metatheoretical property, rather than something you posit explicitly.</p>",
        "id": 555482920,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763079813
    },
    {
        "content": "<p>My original question is answered (thank you all that contributed) - (T : ?) (x : T) is accepted if ? is Sort _ otherwise not. A good counter example is Nat x Type (or Nat -&gt; Type). The terminology “? Is a type” when the property above is true is probably bad and confusing, but I don’t know what else to call it.</p>",
        "id": 555483716,
        "sender_full_name": "Rado Kirov",
        "timestamp": 1763080237
    },
    {
        "content": "<p>I'm still curious about <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span>'s claim that \"X is a type\" is an ambiguous statement... it seems like Lean is able to discriminate between something that \"is a type\" and \"is not a type\" when you get the error message \"type expected, got...\" but I'm wondering if this distinction is more superficial than it appears</p>",
        "id": 555483825,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1763080289
    },
    {
        "content": "<p>I would argue that \"X is a type\" is merely <em>not a proposition internal to Lean</em>, but it certainly is a proposition at a meta level<br>\nIt's a little Godelian, in that it may be a true statement but it's not something you can prove within Lean.</p>",
        "id": 555732285,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1763200805
    },
    {
        "content": "<p>I wouldn't really call it 'Gödelian' per se. The distinction between propositions and judgments is a pretty intentional design choice baked into the formalism of Martin-Löf type theory. So a statement like \"X is a type\" isn't even formalizable in type theory as a proposition. A Gödelian thing would be something that is formalizable and is true in intended models of the theory, but isn't provable.</p>",
        "id": 556612845,
        "sender_full_name": "James E Hanson",
        "timestamp": 1763219867
    }
]