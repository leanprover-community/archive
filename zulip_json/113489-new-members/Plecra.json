[
    {
        "content": "<p>Heya! I'm just starting to get into lean, have got through a few of the natural number/set theory games, here looking for help learning some details that I'm struggling with.<br>\nI'm particularly interested in separation logics and am aiming to get my own version of a system like HTT running soon to poke at and tweak - the end goal is putting together my own take on user-friendly dependent session protocols.</p>",
        "id": 562890659,
        "sender_full_name": "Plecra",
        "timestamp": 1765354045
    },
    {
        "content": "<p>I'm trying to use <code>cases</code> at the moment - I've got an inductive type, and I want to case split on <code>v = Variant1 | v = Variant2</code> - but the tactic immediately substitutes the equality into the goal, then doesnt add the hypothesis to the context. For my own sake, I'd like to be able to name that hypothesis and keep it around to help me keep track of which state I'm in - is there a way to insist to cases that the hypothesis is given a name?</p>",
        "id": 562891030,
        "sender_full_name": "Plecra",
        "timestamp": 1765354163
    },
    {
        "content": "<p>If you hover over <code>cases</code> in your editor, the docstring will tell you</p>\n<blockquote>\n<p><code>cases h : e</code>, where <code>e</code> is a variable or an expression, performs cases on <code>e</code> as above, but also adds a hypothesis <code>h : e = ...</code> to each hypothesis, where <code>...</code> is the constructor instance for that particular case.</p>\n</blockquote>\n<p>An example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `h : n = 0`</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- `h : n = m + 1`</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 562891882,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1765354416
    },
    {
        "content": "<p>right. I'm using the unstructured cases', I've got quite a bit of nesting so the automatic structure is handy, and I couldnt figure out how to get the same behaviour</p>",
        "id": 562899440,
        "sender_full_name": "Plecra",
        "timestamp": 1765356584
    },
    {
        "content": "<p><code>cases'</code> supports the same syntax. I'm not sure what you mean by \"automatic structure\", if you could share some code it might be possible to figure out whether what you want can also be achieved using <code>cases</code>.</p>",
        "id": 562900111,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1765356754
    },
    {
        "content": "<p>ah, fantastic thankyou :) I must have confused myself at some point</p>",
        "id": 562900271,
        "sender_full_name": "Plecra",
        "timestamp": 1765356801
    },
    {
        "content": "<p><a href=\"https://gist.github.com/Plecra/ef1c2301f8a2fefc5626949fbbb1afc2\">https://gist.github.com/Plecra/ef1c2301f8a2fefc5626949fbbb1afc2</a><br>\nit's not particularly concise I'm afraid, but here's the project I'm on atm. checking a parse rule against the behaviour I want. I'm sure there're plenty of ways it can be really improved - all notes are very welcome :)</p>\n<p>Atm have got stuck on <code>unfold</code>ing - I want to unfold <code>LE.le</code> just once, but I'm only finding docs for lean 3's unfold1</p>",
        "id": 562904694,
        "sender_full_name": "Plecra",
        "timestamp": 1765358005
    },
    {
        "content": "<p>ooh this does the trick for now</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_indentation_iff_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Indentation</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Whitespace.Indentation</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- LE.le is automatically unfolded, but the transparency rules ig?</span>\n<span class=\"w\">  </span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"n\">instPreorderWhitespace</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 562905192,
        "sender_full_name": "Plecra",
        "timestamp": 1765358119
    },
    {
        "content": "<p>Does this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_indentation_iff_le</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">Indentation</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">Whitespace</span><span class=\"bp\">.</span><span class=\"n\">Indentation</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"ss\">`simp</span><span class=\"w\"> </span><span class=\"o\">[(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"o\">)]</span><span class=\"bp\">`</span>\n</code></pre></div>",
        "id": 562916160,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1765361017
    },
    {
        "content": "<p>no, it doesnt. Actual error is that it hits the recursion limit.</p>\n<p>The trouble I was having before was that unfolding LE.le also unfolded m &lt;= n to its typeclass instance, which then wasnt equivalent to the instance of le for Whitespace</p>",
        "id": 562918004,
        "sender_full_name": "Plecra",
        "timestamp": 1765361631
    },
    {
        "content": "<p>You should write an \"unfolding lemma\" for LE on whitespace</p>",
        "id": 562929707,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1765365310
    },
    {
        "content": "<p>I did it! <a href=\"https://gist.github.com/Plecra/6771b592feba551dc5bd6299df518846\">https://gist.github.com/Plecra/6771b592feba551dc5bd6299df518846</a> :) The main result is \"yep2\"<br>\nwasnt at all sure if it was even true so it's great to have this shown, will be using the implementation now</p>",
        "id": 562931807,
        "sender_full_name": "Plecra",
        "timestamp": 1765365986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/113489-new-members/topic/Plecra/near/562929707\">said</a>:</p>\n<blockquote>\n<p>You should write an \"unfolding lemma\" for LE on whitespace</p>\n</blockquote>\n<p>that makes sense! Can definitely have that in mind for isolating single steps next time</p>",
        "id": 562931887,
        "sender_full_name": "Plecra",
        "timestamp": 1765366011
    },
    {
        "content": "<p>If anyone would, I'd really appreciate some guidance on how to improve the quality of the proof ^^ Making it shorter/more understandable/less redundant.<br>\nI think I'll try going through it myself and see what I can clean up now it's done, but I can't tell how far I am from a 'good' version of it yet</p>",
        "id": 562932392,
        "sender_full_name": "Plecra",
        "timestamp": 1765366181
    },
    {
        "content": "<p>woah, adding @[simp] lemmas is really powerful lmao</p>",
        "id": 562957814,
        "sender_full_name": "Plecra",
        "timestamp": 1765374102
    },
    {
        "content": "<p><a href=\"https://gist.github.com/Plecra/ce89d698401547ef59236d00094a96eb\">https://gist.github.com/Plecra/ce89d698401547ef59236d00094a96eb</a><br>\nquite a lot better now~ almost halved the length of the main proof itself, gave everything better names, switched to some clearer definitions</p>",
        "id": 562969918,
        "sender_full_name": "Plecra",
        "timestamp": 1765377321
    },
    {
        "content": "<p>Translated it to automation using a few iterations of split/simp/grind, much simpler to write :D</p>",
        "id": 563012119,
        "sender_full_name": "Plecra",
        "timestamp": 1765387799
    }
]