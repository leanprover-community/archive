[
    {
        "content": "<p>Hi all,</p>\n<p>Loving the Lean4 language and Theorem proving book so far. Working my way through the Math book too, but I wanted to ask some general questions at this point.</p>\n<p>I am a bit confused on the different options we have for tactics. So I know how to craft value based (non tactics based) proofs for most simple things - e.g. for existential, construct a (witness, proof) pair using Exists.intro; e.g. for universals, construct a function that produces the proof when given the desired input terms; e.g. to produce a proof for a Prop, it suffices to write the code that can, under a type-checker, produce a term of that type.</p>\n<p>Ok onto some questions:</p>\n<p>Where can I find some formal definitions and nuanced examples of the tactics? I went through the theorem proving book and only really got a rough understanding. For example, I know/think that if I have a goal h, then:</p>\n<ul>\n<li><code>exact XYZ</code> will work if XYZ is exact same type as h</li>\n<li><code>rewrite [XYZ]</code> will use an XYZ of type LHS [-&gt;,=,...] RHS and rewrite the symbols in \"h\" from LHS to RHS (and &lt;- to go the other way), changing the goal to h'.</li>\n<li><code>intro XYZ</code> will change a goal h of type (fun x -&gt; ... something with x ...) into a concrete goal of \"... something with XYZ...\" (x is changed to XYZ, and it's no longer a function form\". This is also the form to unpack a universal quantifier.</li>\n<li><code>use XYZ</code> will change a goal h of type \"exists x, ...something with x...\" into a specific goal of \"...something with XYZ...\" (x Is changed to XYZ, and the existential is dropped)</li>\n<li><code>calc</code> is a way to break a goal of some transitive relation into a sequence of subgoals, and allow the user to organize their proofs with milestones for those.</li>\n<li><code>have</code> also allow use to introduce an additional sub-lemma into the context to use towards the goal</li>\n</ul>\n<p>What I'm not understanding is:</p>\n<ul>\n<li>what is \"apply\" exactly? I don't quite get the operational rules of this thing - I just roughly pattern match and sometimes a relevant theorem works. For example, how is this different from rewrite/rw?</li>\n<li>How does <code>cases</code> work? How does the <code>\\cdot</code> work? Sometimes I see <code>apply</code> with a what looks like a partial expression, followed by new line and either cases or \\cdot, but I couldn't quite find or understand the pattern to how it works.</li>\n<li>What happens when we have multiple goals? Do the tactics just operate on the first applicable goal at a time? Is there a way to say - \"I want the next few tactics to work for the first goal, then I want the next few tactics to work on the second goal\"?</li>\n<li>I don't quite understand the differences and cases for <code>linarith</code>, <code>dsimp</code> (or <code>simp</code>?), and <code>ring</code> (or <code>ring_nf</code>?). In my mind they seem to be \"magic ways to do automated expression solving/simplification\" but I can't quite make out a more formal description than that.</li>\n<li>There's a bunch more tactics, it seems, than the ones in the lean book. Are they necessary? Or they just sugar? e.g. aesop, refine, push_neg</li>\n</ul>\n<p>Further, I'm having some general questions about workflow:</p>\n<ul>\n<li>In most ordinary set theory math, we generally operate at very high level, and always omit basic operational steps (like the equivalent of ring, dsimp, etc.). Does having to account for the basics and name the exact steps get in the way of doing real work in Lean?</li>\n<li>The structure of a proof by contradiction is very simple in traditional maths. You just assume the opposite of your hypothesis, then you arrive at something that's incompatible with a known fact. And it's common to reach for it unless you really value a constructive proof. But in Lean, you assume (hypothesis -&gt; False). It's not really clear how to use this fact to start the proof. Not sure if this is a real question but maybe just asking some advice - how common are these in doing real math in Lean? any advice here?</li>\n<li>Is there a better way to search for theorems than to just know some assumptions about naming scheme? For example in Haskell there's Hoogle, which allows users to search by type. Or is it generally assumed we need to know a basic repertoire and then the specifics of the field we're working in?</li>\n</ul>\n<p>Thanks in advance for any help!</p>",
        "id": 490953590,
        "sender_full_name": "screentime",
        "timestamp": 1735280142
    },
    {
        "content": "<p>Currently there seems no offical materials to cover the gap between TPIL/MIL and real world formalization.</p>\n<p>But there are some non-offical materials may help.</p>\n<ol>\n<li>Introduction to basic tactics to handle logic structure:<a href=\"https://github.com/madvorak/lean4-tactics\">Lean 4 spellbook</a>.</li>\n<li>References for all available tactics in mathlib:<a href=\"https://seasawher.github.io/mathlib4-help/tactics/\">Mathlib4 Tactics</a>.</li>\n</ol>",
        "id": 490954490,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735280822
    },
    {
        "content": "<p>For search theorems efficiently, there are:</p>\n<ol>\n<li><a href=\"https://leansearch.net/\">LeanSearch</a></li>\n<li><a href=\"https://www.moogle.ai/\">Moogle</a></li>\n<li><a href=\"https://loogle.lean-lang.org/\">Loogle</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/\">Mathlib4Docs</a></li>\n</ol>",
        "id": 490955244,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735281347
    },
    {
        "content": "<p>Thank you! The Mathlib4 Tactics seems to have a good (or at least somewhat formal) definition of <code>apply</code>. It seems to say <code>apply e</code> matches <code>e</code>'s conclusion with the current goal. And then it replaces the current goal with all of <code>e</code>'s premises? So for example, if I have <code>e : LHS -&gt; RHS</code>, and I have a goal that looks like RHS, <code>apply e</code> will replace current goal with <code>LHS</code>?</p>\n<p>I should also clarify that I liked the <code>simp</code> section in the theorem book. It seems to apply \"simplifications\" as defined by some canonical order by walking through a DAG of simplification rules. I guess I don't really get what <code>dsimp</code>'s relation is to <code>simp</code>.  Mathlib4 link seems to suggest <code>dsimp</code> works on a subset of <code>simp</code>'s rules? If so why would I ever use <code>dsimp</code>? And I think I 've hit cases in going through examples in the Math book where <code>dsimp</code> was suggested, and it works; but <code>simp</code> fails to type check in the same line.</p>\n<p>Also the theorem search links are great! Anyone integrate that into VSCode?</p>",
        "id": 490956806,
        "sender_full_name": "screentime",
        "timestamp": 1735282630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113488-general/topic/General.20Newbie.20Advice.2FQuestions/near/490956806\">said</a>:</p>\n<blockquote>\n<p>Thank you! The Mathlib4 Tactics seems to have a good (or at least somewhat formal) definition of <code>apply</code>. It seems to say <code>apply e</code> matches <code>e</code>'s conclusion with the current goal. And then it replaces the current goal with all of <code>e</code>'s premises? So for example, if I have <code>e : LHS -&gt; RHS</code>, and I have a goal that looks like RHS, <code>apply e</code> will replace current goal with <code>LHS</code>?</p>\n<p>I should also clarify that I liked the <code>simp</code> section in the theorem book. It seems to apply \"simplifications\" as defined by some canonical order by walking through a DAG of simplification rules. I guess I don't really get what <code>dsimp</code>'s relation is to <code>simp</code>.  Mathlib4 link seems to suggest <code>dsimp</code> works on a subset of <code>simp</code>'s rules? If so why would I ever use <code>dsimp</code>? And I think I 've hit cases in going through examples in the Math book where <code>dsimp</code> was suggested, and it works; but <code>simp</code> fails to type check in the same line.</p>\n<p>Also the theorem search links are great! Anyone integrate that into VSCode?</p>\n</blockquote>\n<p>Loogle and Moogle are already in VSCode. You can click the \"forall\" button to see them in the menu.</p>\n<p>If you are using the latest mathlib4, you can also use <a href=\"https://seasawher.github.io/mathlib4-help/tactics/#leansearch\">#leansearch</a> in VSCode.</p>",
        "id": 490957323,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735283016
    },
    {
        "content": "<p>Correct re <code>apply</code></p>",
        "id": 490958607,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735283897
    },
    {
        "content": "<p><code>dsimp</code> is indeed a weaker version of <code>simp</code> which only uses equalities that are true in the stronger sense of \"definitional equality\"</p>",
        "id": 490958764,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1735284005
    },
    {
        "content": "<p>This webpage is about <a href=\"https://leanprover-community.github.io/extras/simp.html\">simp</a>.</p>\n<p>Sometimes <code>simp</code> will oversimplify your goal, hence you need <code>dsimp</code>, <code>simp only [thm]</code> or <code>simp [-thm]</code> to prevent from oversimplification.</p>",
        "id": 490958973,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735284139
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/General.20Newbie.20Advice.2FQuestions\">#general &gt; General Newbie Advice/Questions</a> by <span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span>.</p>",
        "id": 490985716,
        "sender_full_name": "Notification Bot",
        "timestamp": 1735301919
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"813720\">@screentime</span> hopefully <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html#using-theorems-and-lemmas\">https://leanprover-community.github.io/mathematics_in_lean/C02_Basics.html#using-theorems-and-lemmas</a> contains answers to some of your questions about <code>apply</code> and the focusing dots.</p>",
        "id": 490985898,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735302038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>How does <code>cases</code> work? How does the <code>\\cdot</code> work? Sometimes I see <code>apply</code> with a what looks like a partial expression, followed by new line and either cases or \\cdot, but I couldn't quite find or understand the pattern to how it works.</li>\n</ul>\n</blockquote>\n<p><code>cases</code> is one of the tricky tactics for beginners because it is much more tied to the foundations than other tactics. If you are not happy with instructions simply telling you when to use it without seeing the global picture then your best option is probably to carefully read <a href=\"https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html\">https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html</a></p>",
        "id": 490986313,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735302312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>What happens when we have multiple goals? Do the tactics just operate on the first applicable goal at a time? Is there a way to say - \"I want the next few tactics to work for the first goal, then I want the next few tactics to work on the second goal\"?</li>\n</ul>\n</blockquote>\n<p>Yes, almost all tactics work on the first goal. If you sometimes struggle to see what is the first goal and use VSCode you can set the option <code>Lean 4 &gt; Infoview: Emphasize First Goal</code>. If you want to work on another goal (which is very rare) then you can take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Tactic/PermuteGoals.html\">https://leanprover-community.github.io/mathlib4_docs/Batteries/Tactic/PermuteGoals.html</a></p>",
        "id": 490986634,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735302531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I don't quite understand the differences and cases for <code>linarith</code>, <code>dsimp</code> (or <code>simp</code>?), and <code>ring</code> (or <code>ring_nf</code>?). In my mind they seem to be \"magic ways to do automated expression solving/simplification\" but I can't quite make out a more formal description than that.</li>\n</ul>\n</blockquote>\n<p><code>linarith</code> stands for “linear arithmetic”, it will prove equalities or inequalities that follow from linear combination of your assumptions and the fact you provide (if any). See <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Linarith/Frontend.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Linarith/Frontend.html</a>. <code>ring</code> will close goal that follow from the axioms of commutative (semi)-rings, see <a href=\"https://leanprover-community.github.io/mathematics_in_lean/C08_Groups_and_Rings.html#rings\">https://leanprover-community.github.io/mathematics_in_lean/C08_Groups_and_Rings.html#rings</a> and <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Ring/Basic.html\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Ring/Basic.html</a></p>",
        "id": 490986958,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735302745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>There's a bunch more tactics, it seems, than the ones in the lean book. Are they necessary? Or they just sugar? e.g. aesop, refine, push_neg</li>\n</ul>\n</blockquote>\n<p>In a very precise sense, <em>all</em> tactics are sugar. The Lean kernel consumes only proof terms so you technically <em>never</em> need to use any tactic. Of course in practice tactics are unavoidable if you want to be really productive and you are not some kind of alien (yes, we do have one here). So there is always a trade-off when learning Lean between learning tons of tactics or focusing on the most generally useful ones.</p>",
        "id": 490987187,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735302897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>In most ordinary set theory math, we generally operate at very high level, and always omit basic operational steps (like the equivalent of ring, dsimp, etc.). Does having to account for the basics and name the exact steps get in the way of doing real work in Lean?</li>\n</ul>\n</blockquote>\n<p>There is nothing like ordinary set theory math. Ordinary math is foundation-independent. And I don’t understand your question. The tactics you mention are precisely tactics allowing you to omit operational steps. And of course the answer to “does it get in the way” is: just look at what was achieved already.</p>",
        "id": 490987397,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735303015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490953590\">said</a>:</p>\n<blockquote>\n<ul>\n<li>The structure of a proof by contradiction is very simple in traditional maths. You just assume the opposite of your hypothesis, then you arrive at something that's incompatible with a known fact. And it's common to reach for it unless you really value a constructive proof. But in Lean, you assume (hypothesis -&gt; False). It's not really clear how to use this fact to start the proof. Not sure if this is a real question but maybe just asking some advice - how common are these in doing real math in Lean? any advice here?</li>\n</ul>\n</blockquote>\n<p>I don’t think you can get a useful answer to this question without being more specific. The <code>by_contra</code> tactic seems to be doing exactly what you ask for. What is your question? Do you have a specific example where you struggle with this?</p>",
        "id": 490987531,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1735303101
    },
    {
        "content": "<p>Here's an example of using the <code>apply</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">maj</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">min₁</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">min₂</span>\n\n<span class=\"c1\">-- compare the above proof with the following one</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">maj</span><span class=\"w\"> </span><span class=\"n\">min₁</span><span class=\"w\"> </span><span class=\"n\">min₂</span>\n</code></pre></div>",
        "id": 490993172,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1735306879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490986634\">said</a>:</p>\n<blockquote>\n<p>Yes, almost all tactics work on the first goal. If you sometimes struggle to see what is the first goal and use VSCode you can set the option <code>Lean 4 &gt; Infoview: Emphasize First Goal</code>. If you want to work on another goal (which is very rare) then you can take a look at <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Tactic/PermuteGoals.html\">https://leanprover-community.github.io/mathlib4_docs/Batteries/Tactic/PermuteGoals.html</a></p>\n</blockquote>\n<p>You can also use the notation <code>case &lt;tag&gt; =&gt; &lt;tactics&gt;</code> to choose the goal you want Lean to focus on:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hl</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hl</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">right</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hr</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">left</span><span class=\"w\">  </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hl</span>\n</code></pre></div>",
        "id": 490994388,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1735307718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/490987531\">said</a>:</p>\n<blockquote>\n<p>I don’t think you can get a useful answer to this question without being more specific. The <code>by_contra</code> tactic seems to be doing exactly what you ask for. What is your question? Do you have a specific example where you struggle with this?</p>\n</blockquote>\n<p>Here's an example of using the <code>by_contra</code> tactic:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Batteries.Tactic.Init</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">by_contra</span><span class=\"w\"> </span><span class=\"n\">hnp</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">hnp</span>\n\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">Classical.byContradiction</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"c1\">-- `¬¬p` and `¬p → False` are definitionally equal</span>\n<span class=\"kd\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬¬</span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 490996869,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1735309428
    },
    {
        "content": "<p>Thanks all! This is a great community. This clarifies a lot already - more to explore and read now.</p>",
        "id": 491007849,
        "sender_full_name": "screentime",
        "timestamp": 1735316769
    },
    {
        "content": "<p>RE: multiple goals. I suppose my question was more about organizing the proof. Like in traditional math we put separate subgoals under different paragraphs or headings, so when we read the proof it's organized. But if you've finished a Lean proof, and you're now reading it, isn't it a bit confusing which lines correspond to what goal?  Or is the idea that you have to read a Lean proof inside an editor (as opposed to, say printed onto paper)? I think <span class=\"user-mention\" data-user-id=\"417769\">@Bulhwi Cha</span>  's comment addresses what I was looking for - I'll have to try to understand the <code>constructor</code> breakdown better.</p>\n<p>RE: linarith/ring/etc. - if we have a \"trivial\" operation that should be obvious but requires some combination of these special tactics, what's the advice? Should we manually break it up into multiple <code>have : ...</code> steps each using a single one of these tactics? I'm thinking something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">&gt;=</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"n\">z</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"bp\">*</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">ring</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">sq_nonneg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">+</span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n</code></pre></div>\n<p>(EDIT: hmm maybe this isn't a great example - I can remove the ring step and it still works)</p>\n<p>RE <code>apply</code> <span class=\"user-mention\" data-user-id=\"417769\">@Bulhwi Cha</span> 's example - it makes a lot of sense! Why do you have the <code>\\cdot</code>s there? In VSCode, I tried removing them and it equally works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₁</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min₂</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">maj</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">maj</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">min₁</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">min₂</span>\n</code></pre></div>",
        "id": 491008821,
        "sender_full_name": "screentime",
        "timestamp": 1735317479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/stream/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/491008821\">said</a>:</p>\n<blockquote>\n<p>RE: multiple goals. I suppose my question was more about organizing the proof. Like in traditional math we put separate subgoals under different paragraphs or headings, so when we read the proof it's organized. But if you've finished a Lean proof, and you're now reading it, isn't it a bit confusing which lines correspond to what goal?  Or is the idea that you have to read a Lean proof inside an editor (as opposed to, say printed onto paper)?</p>\n</blockquote>\n<p>This is the point of <code>\\cdot</code>s — they focus on the first subgoal, so you know all of the tactics there work on this subgoal. Mathlib coding style recommends never having multiple subgoals active, using <code>\\cdot</code>s to focus on each one whenever they appear</p>",
        "id": 491009521,
        "sender_full_name": "Daniel Weber",
        "timestamp": 1735317961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"813720\">screentime</span> <a href=\"#narrow/channel/113489-new-members/topic/General.20Newbie.20Advice.2FQuestions/near/491008821\">said</a>:</p>\n<blockquote>\n<p>RE: multiple goals. I suppose my question was more about organizing the proof. Like in traditional math we put separate subgoals under different paragraphs or headings, so when we read the proof it's organized. But if you've finished a Lean proof, and you're now reading it, isn't it a bit confusing which lines correspond to what goal?  Or is the idea that you have to read a Lean proof inside an editor (as opposed to, say printed onto paper)? I think <span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span>  's comment addresses what I was looking for - I'll have to try to understand the <code>constructor</code> breakdown better.</p>\n</blockquote>\n<p>There are many layers of organizing a proof. </p>\n<p>For complex and large theorem, there is blueprint. For exmaple, the blueprint of FLT:<a href=\"https://imperialcollegelondon.github.io/FLT/blueprint/\">https://imperialcollegelondon.github.io/FLT/blueprint/</a>. You need to split your proof into many files and put them into different directories.</p>\n<p>For proof abount serval hunders lines of code, it is recommended to split it into small lemmas and then combine them to get the big one.</p>\n<p>Finally, inside a <code>theorem</code> you can use <code>.</code>(i.e. dot focus), <code>have</code>, <code>show</code> and comments to make your proof more structural.</p>",
        "id": 491010003,
        "sender_full_name": "Zhang Qinchuan",
        "timestamp": 1735318304
    }
]