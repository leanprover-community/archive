[
    {
        "content": "<p>I read <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>'s RFC here (<a href=\"#narrow/stream/270676-lean4/topic/RFC.3A.20change.20how.20named.20arguments.20suppress.20explicit.20parameters/near/472600768\">https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/RFC.3A.20change.20how.20named.20arguments.20suppress.20explicit.20parameters/near/472600768</a>), the associated GH issues and and the ensuing discussion).</p>\n<p>While I am not the target audience, I have an observation/usability question.  First, let me try and motivate: </p>\n<p>I love the fact that the \"signature\" of the function is \"carried over\" after currying.  This is an awesome feature with named parameters:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simple_partial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">simple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">simple_partial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">20</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">simple_partial</span><span class=\"w\"> </span><span class=\"c1\">-- returns `simple_partial (x : Nat) : Nat`</span>\n</code></pre></div>\n<p>This also works with e.g. structures where the type can be inferred during the initial call:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Point_partial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Point</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:=</span><span class=\"mi\">10</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Point_partial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:=</span><span class=\"mi\">20</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, it does not work with functions or structures where there are implicit/type parameters:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>e.g. unlike the above, the following is not valid:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:=</span><span class=\"mf\">1.0</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This also applies to e.g. generic types, such as <code>Prod</code> or <code>Sigma</code>, i.e. this doesn't work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Prod_partial</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and the output of the partial application is not \"super helpful\".  Specifically, it has lost the type name/information from the original function signature.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">Prod</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"o\">)</span><span class=\"w\">        </span><span class=\"c1\">-- fun fst =&gt; (fst, 10) : ?m.2068 → ?m.2068 × Nat</span>\n</code></pre></div>\n<p>How is this related to the RFC?  Aside from the inconsistent behavior, part of the confusion seems to have been caused by the fact that users weren't sure what the remaining parameters were/should have been.  If after the partial application of a named parameter the signature would more clearly indicate what the \"remaining signature is\" (including the original type params), perhaps it would also help user to self-diagnose.</p>\n<p>I am sure someone will tell me why this is hard <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 472767693,
        "sender_full_name": "Tom",
        "timestamp": 1727295381
    },
    {
        "content": "<p>This isn't related to the RFC beyond having to do with app elaboration, though it does touch on the same region of code.</p>\n<p>You're talking about the \"eta expansion\" feature. Currently it only applies to explicit parameters — implicit parameters are always elaborated as fresh metavariables.</p>\n<p>An expectation of implicit parameters is that they should be eagerly turned into fresh metavariables. If we were to make it so <code>α</code> were eta expanded as well, the type of <code>f (y := 1.0)</code> would be <code>{α : Sort _} -&gt; (x : α) -&gt; α</code>, against expectations. One could imagine that strict implicit arguments could be subject to eta expansion, so for example the resulting type could be <code>{{α : Sort _}} -&gt; (x : α) -&gt; α</code>.</p>\n<p>Your example does surface an unfriendly error message with a bug though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">don't know how to synthesize implicit argument 'α'</span>\n<span class=\"cm\">  @f ?m.469 Nat _fvar.467 Nat.zero</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>We shouldn't bee seeing <code>_fvar.467</code>. That indicates that the error didn't capture the correct local context. (Could you please report it?)</p>",
        "id": 472769727,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727296284
    },
    {
        "content": "<blockquote>\n<p>This isn't related to the RFC beyond having to do with app elaboration, though it does touch on the same region of code.</p>\n</blockquote>\n<p>That was my understanding and also the reason why I posted here rather than under the RFC, because it seemed tangential.</p>\n<blockquote>\n<p>An expectation of implicit parameters is that they should be eagerly turned into fresh metavariables. &lt;snip&gt;</p>\n</blockquote>\n<p>Could you please clarify this paragraph?  What \"expectation\" are you referring to mention here?  <br>\nAnd why would <code>{α : Sort _} -&gt; (x : α) -&gt; α</code> be against expectations?</p>\n<p>Also, is there a reason why Lean can't infer the type of <code>g</code> and have the partial application succeed?</p>\n<blockquote>\n<p>Your example does surface an unfriendly error message with a bug though:</p>\n</blockquote>\n<p>Sorry, I seem to keep breaking things! <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>   I will file.  However, what version of Lean did you try this with?  I'm on 4.11 stable and I get a different error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">invalid occurrence of universe level 'u_1' at '_example', it does not occur at the declaration type,</span>\n<span class=\"cm\">nor it is explicit universe level provided by the user, occurring at expression</span>\n<span class=\"cm\">  f.{u_1, 1} x Nat.zero</span>\n<span class=\"cm\">at declaration body</span>\n<span class=\"cm\">  fun (x : ?m.48) =&gt; f x Nat.zero</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p>Maybe it's a regression?</p>",
        "id": 472777462,
        "sender_full_name": "Tom",
        "timestamp": 1727300068
    },
    {
        "content": "<p>I see, I'm on a more recent build that changes when universe level errors are reported. You should be able to reproduce it with</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 472777907,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727300341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515083\">Tom</span> <a href=\"#narrow/stream/113489-new-members/topic/Question.20about.20currying.20.28was.3A.20RFC.3A.20change.20how.20named.20.2E.2E.2E.29/near/472777462\">said</a>:</p>\n<blockquote>\n<p>What \"expectation\" are you referring to mention here?</p>\n</blockquote>\n<p>The one where implicit arguments are eagerly inserted. The type of an elaborated term doesn't start with <code>{...} -&gt;</code> unless you specifically ask for it (for example by using <code>@</code>).</p>",
        "id": 472778130,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727300472
    },
    {
        "content": "<p>I just pulled <code>master</code> and can confirm that</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"c1\">-- This error is the same as the one above</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">,</span><span class=\"mi\">1</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- This demonstrates the issue you mention</span>\n</code></pre></div>\n<p>I will file.  And TIL, you can explicitly provide universe levels!</p>",
        "id": 472778177,
        "sender_full_name": "Tom",
        "timestamp": 1727300509
    },
    {
        "content": "<p><a href=\"http://Issue\">https://github.com/leanprover/lean4/issues/5475</a></p>",
        "id": 472779905,
        "sender_full_name": "Tom",
        "timestamp": 1727301495
    },
    {
        "content": "<p>Thanks. I edited the issue (<a href=\"https://github.com/leanprover/lean4/pull/5475\">lean4#5475</a>). The error is to do with the <code>_fvar.467</code> in the error message. It doesn't have to do with universe levels — I included the <code>.{1,1}</code> so you could see the error on the older version of Lean.</p>",
        "id": 472780515,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1727301805
    }
]