[
    {
        "content": "<p>I am new to Lean (just started today). </p>\n<p>The first thing I am struggling with is the <code>induction</code> tactic from the \"Addition world\" tutorials in the Natural Number Game. It asks me to use it but I don't understand what it is doing.</p>\n<p>Here is where its use is introduced:</p>\n<p><a href=\"https://adam.math.hhu.de/#/g/leanprover-community/nng4/world/Addition/level/1\">https://adam.math.hhu.de/#/g/leanprover-community/nng4/world/Addition/level/1</a></p>\n<p>If I use </p>\n<p><code>induction n with d hd</code></p>\n<p>It splits into two goals. The manual page on this even use the same example to explain <code>induction</code> but I still don't understand what happened when I applied it. </p>\n<p>Will you please explain?</p>",
        "id": 447625925,
        "sender_full_name": "Jay",
        "timestamp": 1719538079
    },
    {
        "content": "<p>Are you familiar with Algebraic Data Types (e.g. Rust, Haskell, etc)? If so, this syntax may be more familiar to you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_add₁</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This is ~the same:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">zero_add₂</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>It is like \"if-else\" but it has support from the type theory via a rule in the type theory known as the \"recursor\" or \"eliminator\", which basically postulates that if a type as defined as one of N things, then we can define a function on that type by defining it on each of those N things.</p>",
        "id": 447627480,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719538980
    },
    {
        "content": "<p>Note that <code>induction</code> in the Natural Number Game is overridden to use Lean 3 syntax which is different from Lean 4 syntax. I think this is confusing, but much ink has already been spilled on this topic (search \"nng induction'\").</p>",
        "id": 447627601,
        "sender_full_name": "llllvvuu",
        "timestamp": 1719539060
    },
    {
        "content": "<p>The idea behind induction is that every element of an inductive type is built up by applying constructors finitely many times, so if we can establish a property by reducing it to the same property on smaller pieces then we will have shown that every value has the property.</p>\n<p>As it applies to <code>Nat</code>, we have two constructors, <code>zero : Nat</code> and <code>succ : Nat -&gt; Nat</code>. So if zero has property <code>P</code>, and successors of things with property <code>P</code> also have property <code>P</code>, then everything built up from zero and successor (which is everything in the type) has property <code>P</code>.</p>\n<p>This is all then wrapped up in a convenient tactic called <code>induction</code>. When you write <code>induction n</code>, lean takes your goal to be the property <code>P n</code> here, and then applies the rule of proof by induction, meaning that we have to show that <code>P 0</code> holds, and that <code>P (succ n)</code> holds given that <code>P n</code> holds. These are the two subgoals that lean will give back to you.</p>",
        "id": 447628991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1719539932
    },
    {
        "content": "<p>Thanks. I am going to take these responses and go back to the tutorial and try to work through the idea for a while. I will come back when I have learned something new or got stuck.</p>",
        "id": 447631656,
        "sender_full_name": "Jay",
        "timestamp": 1719540986
    },
    {
        "content": "<p>Ok. That was a partial success. I will need to go through the intro to induction again. I made it through the tutorial and finished all the games. Unfortunately, I think I cheated. I merely reused induction in the same way I'd seen it used in previous examples so I knew what tactics and theorems to use to complete the game but I don't believe I really understood why it worked. I really just repeated a process without understanding its function.</p>\n<p>That's probably enough for me for one night. Thank you all for you help so far. I am likely to come back for more tomorrow.</p>",
        "id": 447635287,
        "sender_full_name": "Jay",
        "timestamp": 1719542540
    },
    {
        "content": "<p>Here's how I understand it (I'm new too so take it this with the appropriate grain of salt :P).</p>\n<p>Lean is based on the <em>Calculus of Inductive Constructions</em> which I think comes with the idea of induction sort of built in. Which is to say you need to be convinced that a proof by induction is a valid line of reasoning a priori.</p>\n<hr>\n<p>Here's a sort of loose-weave example. Say I want to convince somebody that I'll never be older than my brother.</p>\n<ul>\n<li>When I was born, my brother was older than me.</li>\n<li>If my brother is older than me for a given year, he will still be older than me the next year (This is because each year we both age the same amount).</li>\n<li>Therefore, for any year after my birth, my brother is older than me.</li>\n</ul>\n<p>Without any concrete information about how old we are today or how old we'll end up being is this a valid argument? It seems like it, right? </p>\n<p>Ok maybe the argument isn't sound in this case -  if my brother stops aging when he dies, or if we may need to account for time dilation due to space travel, then one of the premises is suspect (Which would mean you wouldn't find a proof for the inductive step). </p>\n<p>Though assuming the premises are true, then conclusion seems to follow.</p>\n<hr>\n<p>How does this work in lean? I'm actually not sure. I think it's just a rule in the foundational system. If you have an inductive proof that is run-able as a program, then I think the runtime semantics would be that you could feed it a specific age (say 13) and the proof would loop through my ages from 0 to 13, at each step is applies the proof of the inductive step to show that it's true for the next year, and then it can return a proof that when I'm 13, my brother is older than me. Because this can be done for any age, the type system sees this as a proof for every age.</p>",
        "id": 449954182,
        "sender_full_name": "Mark Fischer",
        "timestamp": 1720464646
    },
    {
        "content": "<p>I would also like to know if \"proof by induction\" is an additional axiom that has to added to the other logical axioms, or whether it follows from other axioms. I seem to recall that somewhere it said that proof by induction is it's own axiom, but I'm not sure.</p>",
        "id": 450268223,
        "sender_full_name": "Mr Proof",
        "timestamp": 1720554602
    },
    {
        "content": "<p>Proof by induction is a consequence of the recursors and their computation rules that are axiomatically generated for each inductive type.</p>",
        "id": 450284738,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1720558622
    }
]