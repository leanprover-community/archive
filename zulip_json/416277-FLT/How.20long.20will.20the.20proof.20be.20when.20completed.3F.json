[
    {
        "content": "<p>Sorry if this is an inappropriate place for this question. I got inspired to ask this after seeing a speedrun of NNG. Obviously, the \"final boss\" wasn't beaten during the speedrun. I started to wonder whether someone could theoretically beat the boss once the project is done. This would of course take a very long time, but after all there have been speedruns in categories of other games lasting over 24 hours. So, how many characters/lines long might the proof be when complete, order of magnitude -wise? Could the server / client even handle such a long proof?</p>",
        "id": 541868570,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1759041548
    },
    {
        "content": "<p>Are you asking how large the actual FLT proof will be when it is complete, or how large would it be if you explicitly tried to make it really short? Or how long it would be if you had to write it as a single theorem without any auxiliary definitions (if such a thing is actually possible), as if you were actually typing it into NNG4? And if mathlib spends 100000 lines building up the theory of some algebraic structure and the FLT project uses those theorems, do you count the 100000 lines towards the proof length?</p>",
        "id": 541874877,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759048325
    },
    {
        "content": "<p>Hmm, I didn't really consider those things when thinking about the question. Well, I guess I was thinking of making it as short as possible but without using mathlib. The heuristic for what I'm going for is to pretend someone actually tried to type it or minimized variation thereof into NNG4. I see now that this question might be harder to answer than I initially assumed, as proving something in NNG4 is very different to what Dr. Buzzard is doing</p>",
        "id": 541875262,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1759048702
    },
    {
        "content": "<p>I guess the first thing to consider is whether this is possible in the first place. If you were to just restrict yourself to simple statements like the tactics in NNG4 and not have <code>exact</code> statements that span hundreds of lines, then you would essentially be reasoning in a system that resembles Peano Arithmetic. FLT was proven in informal math, and I think basically everyone believes that it is provable in ZFC (and Lean is even slightly stronger than ZFC), but I don't think anyone knows whether or not FLT is provable in Peano Arithmetic, although many people have speculated that it may be.</p>\n<p>If it is provable, then you probably would need some way to make definitions. Definitions are never required, but they can compress proofs by reducing duplication. NNG4 doesn't have the <code>let</code> tactic so unless you want to use <code>let</code> inside a gigantic <code>exact</code> tactic this means that you might get exponential blowup in the size of proofs. If you took Wiles's proof of FLT and got rid of all the definitions, it might take more characters than the number of atoms in the known universe to write down the proof.</p>",
        "id": 541877290,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759050745
    },
    {
        "content": "<p>This is of course assuming that you are interested in the FLT proof that we currently know about. I don't think humanity will ever know what the theoretical shortest FLT proof is.</p>",
        "id": 541877355,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759050830
    },
    {
        "content": "<p>Note that you can bypass some of the restrictions of NNG4 by writing a very large <code>exact</code> statement. So hypothetically, you could compress all of the ongoing FLT formalization into a single <code>exact</code> statement (with the caveat that inductive types cannot be defined within a proof, so you'd need access to something like <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=WType#doc\">docs#WType</a>). This wouldn't actually shorten the proof, and it might make it much longer.</p>",
        "id": 541877697,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759051175
    },
    {
        "content": "<p>Oh, I forgot NNG doesn't have let. However, it does have ´have´, which can substitute for it in some circumstances, right? (I'm still a Lean novice). And yeah, I'm interested in the currently known FLT proof.</p>",
        "id": 541877710,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1759051197
    },
    {
        "content": "<p>So <code>have</code> can sometimes work as a substitute for <code>let</code>, but not always. The problem is that when you define something using <code>have</code>, Lean forgets its definition (see <a href=\"https://leanprover-community.github.io/extras/pitfalls.html#using-have-for-data\">https://leanprover-community.github.io/extras/pitfalls.html#using-have-for-data</a>).</p>",
        "id": 541877787,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759051268
    },
    {
        "content": "<p>I'm not sure how much of mathlib that the FLT project depends on, but given how tightly coupled mathlib is, I suspect that even a single theorem can transitively depend on a large percentage of mathlib. If you just want a rough ballpark estimate, mathlib is currently about 2 million lines of code, so the complete FLT proof, when minified by removing unnecessary theorems from mathlib, would probably depend on at least 1 million lines of Lean code from mathlib.</p>",
        "id": 541877973,
        "sender_full_name": "Niels Voss",
        "timestamp": 1759051442
    },
    {
        "content": "<p>I see, thanks. I was already suspecting it might be too long to type into NNG, but I didn't realize how limited NNG actually was and how that might make it even longer<br>\n.</p>",
        "id": 541878011,
        "sender_full_name": "Juho Pitkänen",
        "timestamp": 1759051465
    },
    {
        "content": "<p>The distribution of length may be strange, because I would expect that most of the expected length comes from scenarios in which high levels of automation are used to generate very un-golfed proof terms.</p>",
        "id": 541894224,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1759067771
    }
]