[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/348111-batteries/topic/ten.20unproved.20string.20theorems/near/433485865\">said</a>:</p>\n<blockquote>\n<p>If I'm lucky, I'll be supported this summer or next year by <a href=\"https://www.nipa.kr/eng/index\">NIPA</a>'s <a href=\"https://www.oss.kr/\">OSS Support Center (Open UP)</a> to teach Korean students and programmers how to prove these string theorems.</p>\n</blockquote>\n<p>The OSS Support Center has just requested me to submit a summary of the project I'll contribute to and a plan for my mentoring. They seem indifferent to formalizing mathematics, so I'll focus on explaining to them how Lean can be used in industry.</p>\n<p>I wonder what advantages Lean has in program verification over proof-oriented programming languages like F* and Dafny. I don't know much about these two languages, but they appear more geared towards effectful programming:</p>\n<ul>\n<li>Section 20.5 of <em>Proof-Oriented Programming in F</em>* (last modified on Jun 25, 2024): <a href=\"https://fstar-lang.org/tutorial/proof-oriented-programming-in-fstar.pdf\">https://fstar-lang.org/tutorial/proof-oriented-programming-in-fstar.pdf</a></li>\n<li>\"Verification of Imperative Programs\" (Dafny): <a href=\"https://dafny.org/teaching-material/Lectures/3-3-Verification-Imperative.html#/\">https://dafny.org/teaching-material/Lectures/3-3-Verification-Imperative.html#/</a></li>\n</ul>",
        "id": 451952979,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721197008
    },
    {
        "content": "<p>Without a doubt, Mathlib is one of Lean's huge advantages; it's used in <a href=\"https://github.com/leanprover/SampCert\">SampCert</a>. But what else?</p>",
        "id": 451958302,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721198394
    },
    {
        "content": "<ol>\n<li>Dafny has a larger trusted code base.</li>\n<li>Working with dafny is not always  a great experience because one must constantly massage the goals until the smt solver can tell you that you are fine. Since you don't get something like an infoview (there might be debugging tools I don't know), it is like having exactly one tactic.  You must constantly supply the right amount of hints until this tactic can close the goal.</li>\n<li>The more powerful the automation you use, the more mysterious and brittle the proof itself is. The proof can break because your goal stated the order of summands wrong or what not.</li>\n</ol>",
        "id": 451994921,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721206458
    },
    {
        "content": "<p>I googled \"dafny verification brittle\" and landed at a blogpost that explains this aspect: <a href=\"https://dafny.org/blog/2023/12/01/avoiding-verification-brittleness/\">https://dafny.org/blog/2023/12/01/avoiding-verification-brittleness/</a></p>",
        "id": 451995908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721206584
    },
    {
        "content": "<p>All that being said, dafny and F* have been used for a lot of verification papers in software. Lean also has a non trivial learning curve (although I think we get more info from the system when a goal is not closed)</p>",
        "id": 451997018,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721206721
    },
    {
        "content": "<p>When mentioning mathlib as an advantage, you should probably explain which parts of mathlib were advantageous to sampcert. Maybe it was just what Mario calls Mathlib-lite. Or maybe it used deep mathematics theorems.</p>",
        "id": 451998020,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721206847
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> would have a better answer</p>",
        "id": 451998649,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721206934
    },
    {
        "content": "<p>Another thing, since you mentioned effects, you can only put that sort of code into Dafny methods. These are not pure functions. But they are \"opaque\" in the system. There are some restrictions about putting methods inside another (iirc you just can't do that). They are purely visible as an interface with the <code>requires</code> and <code>ensures</code> clauses satisfied. I didn't work with dafny long enough to know how limiting this can be.</p>",
        "id": 452000660,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1721207220
    },
    {
        "content": "<p>I find it difficult to choose between Lean and Dafny for teaching purposes. When I want to teach how to design and write proofs, I have a clear preference for Lean because I can present the rules of natural deduction and put them in practice. On the other hand, Dafny is nice and fun to teach how to verify programs by annotating them with invariants and learning about Floyd logic. However, a problem with tools based on SMT automation like Dafny is that as long as what you are trying to prove is simple enough, it feels like magic, but eventually you realize that you do need to know how to write proofs, and you don't have the interactive system and the proof scripts to help understand what is going on. Perhaps you should use both! </p>\n<p>As for SampCert and its use of Mathlib, I don't know what qualifies as deep but here are three (plus 1 bonus) theorems I use. They may not be the deepest, but they're not high-school mathematics (at least not for me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> ). Overall, I felt like the most useful part of Mathlib for me was analysis.</p>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Fourier/PoissonSummation.html#Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay\">Poisson summation formula</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Convex/Integral.html#ConvexOn.map_integral_le\">Jensen's inequality</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.html#summable_jacobiTheta%E2%82%82_term_iff\">Some convergence result of the Jacobi Theta function</a> that, I think, saved me days of work proving what I want through simpler means</li>\n<li>Finally, I'll mention <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Analysis/Asymptotics/Asymptotics.html#Asymptotics.IsBigO.comp_tendsto\">a theorem that perhaps is not deep</a> but that I found thanks to <a href=\"https://www.moogle.ai/\">moogle.ai</a> and that I was relieved to find because I felt stuck</li>\n</ol>",
        "id": 452199641,
        "sender_full_name": "John Tristan",
        "timestamp": 1721253460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"221511\">John Tristan</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20advantages.20does.20lean.20have.20over.20f*.20and.20dafny.3F/near/452199641\">said</a>:</p>\n<blockquote>\n<p>As for SampCert and its use of Mathlib, I don't know what qualifies as deep but here are three (plus 1 bonus) theorems I use. They may not be the deepest, but they're not high-school mathematics (at least not for me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> ).</p>\n</blockquote>\n<p>I'm pretty sure that the examiners of the OSS Support Center will regard these theorems as deep mathematics!</p>",
        "id": 452247650,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721278980
    },
    {
        "content": "<p>This is certainly not \"mathlib lite\".</p>",
        "id": 452255530,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1721282726
    }
]