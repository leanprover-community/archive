[
    {
        "content": "<p>I'm very new to Lean, but I'm trying to give it a chance with creating a small library for bitmaps. I try to use theorem proving in the place of unit testing on places where that should be possible. </p>\n<p>I stuck on a small function, but I split the problem in pieces and found that this theorem does not verify for some reason:<br>\n<code>theorem th0 : USize.toNat ((1 : USize) * (1 : USize)) = USize.toNat 1 := by rfl</code></p>\n<p>How should I approach similar problems?</p>\n<p>The same with Nats is verifying:<br>\n<code>theorem th1 : 1 * 1 = 1 := rfl</code></p>",
        "id": 482489531,
        "sender_full_name": "Vassil Keremidchiev",
        "timestamp": 1731621218
    },
    {
        "content": "<p>The <code>UIntX</code> and <code>IntX</code> API isn't particularly fleshed out at this point for proving purposes unfortunately. You can still get there if you are willing to unfold <code>UInt</code> operations to their rathe well supported <code>BitVec</code> equivalent but you'll be building a lot of API yourself if you want to prove things.</p>",
        "id": 482499812,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731626197
    },
    {
        "content": "<p>I think the main issue is here is that the size of a <code>USize</code> is architecture dependent and depends on an opaque constant: <code>System.Platform.numBits</code>.  You cannot know its exact value, just that it is 32 or 64.  It's therefore even a bit painful to prove simple things like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- BitVec System.Platform.numBits == USize</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- reason about 64 and 32 bits</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits_eq</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>This is also where <code>rfl</code> is getting stuck, because it can't compute the constant <code>System.Platform.numBits</code>, which is needed to fully evaluate both sides of the equation.  Declaring the bitsize directly makes it computable then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In this case though, <code>simp</code> does have enough theorems to be able to prove your property, so maybe you can try that instead and see if it works for other tests as well. In this case it is probably making use of a fact that 1 * 1 is 1 for any bitsize (this is a theorem from Mathlib actually <code>mul_one</code>).  <code>simp</code> doesn't do pure computation, but instead performs rewrites of theorems in its database.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat_ofNat</span><span class=\"o\">]</span>\n<span class=\"c1\">-- other solution is to use BitVec 32 or 64 directly</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 482500772,
        "sender_full_name": "Yann Herklotz",
        "timestamp": 1731626693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"688543\">Yann Herklotz</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Problem.20with.20USize/near/482500772\">said</a>:</p>\n<blockquote>\n<p>I think the main issue is here is that the size of a <code>USize</code> is architecture dependent and depends on an opaque constant: <code>System.Platform.numBits</code>.  You cannot know its exact value, just that it is 32 or 64.  It's therefore even a bit painful to prove simple things like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- BitVec System.Platform.numBits == USize</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"c1\">-- reason about 64 and 32 bits</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">System</span><span class=\"bp\">.</span><span class=\"n\">Platform</span><span class=\"bp\">.</span><span class=\"n\">numBits_eq</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>This is also where <code>rfl</code> is getting stuck, because it can't compute the constant <code>System.Platform.numBits</code>, which is needed to fully evaluate both sides of the equation.  Declaring the bitsize directly makes it computable then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>In this case though, <code>simp</code> does have enough theorems to be able to prove your property, so maybe you can try that instead and see if it works for other tests as well. In this case it is probably making use of a fact that 1 * 1 is 1 for any bitsize (this is a theorem from Mathlib actually <code>mul_one</code>).  <code>simp</code> doesn't do pure computation, but instead performs rewrites of theorems in its database.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th0</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mul_one</span><span class=\"o\">,</span>\n<span class=\"w\">  </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">toNat_ofNat</span><span class=\"o\">]</span>\n<span class=\"c1\">-- other solution is to use BitVec 32 or 64 directly</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">th1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">@</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>First, thank you very much about the explanation and the examples! <br>\nIt's interesting to me, why this constant is not a constant in the type space also? It cannot change during runtime. It's related to the compilation and can be fixed.</p>",
        "id": 482697772,
        "sender_full_name": "Vassil Keremidchiev",
        "timestamp": 1731706361
    },
    {
        "content": "<p>You are proving something about your Lean program, Lean programs can generally run on both 32 and 64 bit platforms so you need to prove something about all platforms that your program can run on. If a proof is invalid depending on the platform you're on that is probably not good.</p>",
        "id": 482706777,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1731710924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Problem.20with.20USize/near/482706777\">said</a>:</p>\n<blockquote>\n<p>You are proving something about your Lean program, Lean programs can generally run on both 32 and 64 bit platforms so you need to prove something about all platforms that your program can run on. If a proof is invalid depending on the platform you're on that is probably not good.</p>\n</blockquote>\n<p>But it's not like running same script or same Python on different platforms. It's a recompilation of the program to have two separate executables for each platform. Each compilation could have different settings, so it is like you have two separate programs with a separate proof checks. Those separate compilations lead to very different instructions used.</p>",
        "id": 483432996,
        "sender_full_name": "Vassil Keremidchiev",
        "timestamp": 1732092887
    },
    {
        "content": "<p>Yes, still just compiling a Lean proof on a different computer should not make a difference as to whether it type checks or not.</p>",
        "id": 483434089,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1732093207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"780093\">Vassil Keremidchiev</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Problem.20with.20USize/near/483432996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Problem.20with.20USize/near/482706777\">said</a>:</p>\n<blockquote>\n<p>You are proving something about your Lean program, Lean programs can generally run on both 32 and 64 bit platforms so you need to prove something about all platforms that your program can run on. If a proof is invalid depending on the platform you're on that is probably not good.</p>\n</blockquote>\n<p>But it's not like running same script or same Python on different platforms. It's a recompilation of the program to have two separate executables for each platform. Each compilation could have different settings, so it is like you have two separate programs with a separate proof checks. Those separate compilations lead to very different instructions used.</p>\n</blockquote>\n<p>\"A program written in Lean\" and \"the artifact obtained by compiling a program written in Lean\" are two different things. The compiler is not part of the trusted code base, and there's no model of the compiler that you can use within Lean to reason about compilation. When you write proofs about USize, you're doing so before it's known what the compilation target or pointer size are, so it cannot be fixed.</p>\n<p>If you want to assume the program will be run in a 32 bit system, presumably you can write your proofs  with a hypothesis <code>System.Platform.numBits = 32</code>.</p>\n<p>Alternatively you can go the sel4 route and use the proof assistant to reason about a compiled program by making the assembly output by the compiler the domain instead of the source code.</p>",
        "id": 483520113,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1732118747
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Problem.20with.20USize/near/483520113\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"780093\">Vassil Keremidchiev</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Problem.20with.20USize/near/483432996\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Problem.20with.20USize/near/482706777\">said</a>:</p>\n<blockquote>\n<p>You are proving something about your Lean program, Lean programs can generally run on both 32 and 64 bit platforms so you need to prove something about all platforms that your program can run on. If a proof is invalid depending on the platform you're on that is probably not good.</p>\n</blockquote>\n<p>But it's not like running same script or same Python on different platforms. It's a recompilation of the program to have two separate executables for each platform. Each compilation could have different settings, so it is like you have two separate programs with a separate proof checks. Those separate compilations lead to very different instructions used.</p>\n</blockquote>\n<p>\"A program written in Lean\" and \"the artifact obtained by compiling a program written in Lean\" are two different things. The compiler is not part of the trusted code base, and there's no model of the compiler that you can use within Lean to reason about compilation. When you write proofs about USize, you're doing so before it's known what the compilation target or pointer size are, so it cannot be fixed.</p>\n<p>If you want to assume the program will be run in a 32 bit system, presumably you can write your proofs  with a hypothesis <code>System.Platform.numBits = 32</code>.</p>\n<p>Alternatively you can go the sel4 route and use the proof assistant to reason about a compiled program by making the assembly output by the compiler the domain instead of the source code.</p>\n</blockquote>\n<p>Thanks for the detailed explanation! It totally makes sense!</p>",
        "id": 484593628,
        "sender_full_name": "Vassil Keremidchiev",
        "timestamp": 1732654101
    }
]