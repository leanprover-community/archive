[
    {
        "content": "<p>Hi <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> Coming from SW verification in Isabelle/HOL, I wonder if there's support for elimination rules in Lean, whereby I mean rules which consume a hypothesis by destructing it in a particular way.</p>\n<p>As a concrete example, I'd like a tactic which repeatedly finds and splits _all_ disjunctions in the current list of hypothesis, without me having to name them explicitly. In Isabelle, for example, <code>elim disjE</code>would do that, where <code>disjE: ?P ∨ ?Q ⟹ (?P ⟹ ?R) ⟹ (?Q ⟹ ?R) ⟹ ?R</code>.</p>\n<p>How would this best be implemented in Lean? The combination of apply+assumption is somewhat close to a single-step elimination, but it does not remove the hypothesis to be destructed and is thus not repeatable.</p>",
        "id": 434022339,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713438632
    },
    {
        "content": "<p>You can use the <code>clear</code> tactic to remove hypothesis. In general I think you would have to write your own tactic that does what you intend, as I don't think we have a tactic specific for that. Did you check the metaprogramming book? <a href=\"https://github.com/leanprover-community/lean4-metaprogramming-book\">https://github.com/leanprover-community/lean4-metaprogramming-book</a></p>",
        "id": 434035603,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1713443502
    },
    {
        "content": "<p>I don't know how exactly <code>elim</code> works,  but for examples like the one you have given <code>tauto</code> handles them easily</p>",
        "id": 434049608,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713447590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> Can you elaborate? Note that it is not about proving the elimination rule itself, but applying it in the way described.</p>",
        "id": 434051819,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713448220
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"360938\">@Tomaz Gomes</span> Thank you! I will have a look at the <code>clear</code> tactic and also double-check the metaprogramming book, which I did have a look at but could have missed it.</p>",
        "id": 434051910,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713448257
    },
    {
        "content": "<p>Here are two examples. the second one is a bit contrived:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">tauto</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">∨</span> <span class=\"n\">r</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">tauto</span>\n</code></pre></div>",
        "id": 434052194,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713448344
    },
    {
        "content": "<p>If you go to the top right of the code panel, you should be able to open this in the lean playground and check for yourself.</p>",
        "id": 434052327,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713448385
    },
    {
        "content": "<p>About applying the elimination rule in the way described at the level of a single step, I would use the <code>cases</code> or even <code>rcases</code> tactic.</p>",
        "id": 434052480,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713448435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> Thank you, but proving those theorems is not the problem, it's about using them as elimination rules. As mentioned, one aspect is that one should have to name hypothesis explicitly, which <code>cases</code> would require you to do.</p>",
        "id": 434054124,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713448857
    },
    {
        "content": "<p>You mean something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"n\">Or.elim</span>\n</code></pre></div>",
        "id": 434057029,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713449514
    },
    {
        "content": "<p>I think he mean that he wants a general tactic that would take a proof of a theorem like this and use it to prove a more general case, i.e., about a disjunction with an arbitrary number of propositions</p>",
        "id": 434057742,
        "sender_full_name": "Tomaz Mascarenhas",
        "timestamp": 1713449654
    },
    {
        "content": "<p>I am confused. On the one hand one can <code>apply Or.elim</code> to get a single step of the elimination rule. On the other end of the spectrum <code>tauto</code> does all the eliminations automatically and iteratively. Maybe you are looking for something in the middle of the spectrum.</p>",
        "id": 434059027,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713450004
    },
    {
        "content": "<p>Maybe something that works solely with disjunctions for example</p>",
        "id": 434059132,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713450035
    },
    {
        "content": "<p>there is also pattern destructuring of the form illustrated below, <del>but this requires appropriately introducing the necessary names</del>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">hq</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩)</span> <span class=\"n\">hpr</span> <span class=\"n\">hqr</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">solve_by_elim</span>\n</code></pre></div>",
        "id": 434059596,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713450173
    },
    {
        "content": "<p>Actually naming is not necessary in this example. Destructuring namelessly suffices:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">solve_by_elim</span>\n</code></pre></div>",
        "id": 434060058,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713450316
    },
    {
        "content": "<p><code>tauto</code> does not do eliminations, it may only be helpful in proving some of the elimination rules themselves (if they are propositional in nature). Here's an example application hopefully clarifying what I'm looking for: Given the goal <code>P ∨ Q → T ∨ W → S → U</code>, I want to be able to do <code>elim disjE</code> and -- up to <code>intro</code>s -- get four new goals <code>P → T → S → U</code>, <code>Q → T → S → U</code>, <code>P → W → S → U</code>, <code>Q → W → S → U</code>. Another example would be: _Given_ (proving this is again not the issue) <code>nat_boundE: i &lt; Suc n → (i = n → R) → (i &lt; n → R) → R</code>, and given a goal with hypothesis <code>i &lt; Suc (Suc (Suc (Suc 0))))</code> somewhere, I want to be able to call <code>elim nat_boundE</code> and immediately see subgoals emerge for <code>i=0,1,2,3</code>.</p>",
        "id": 434063620,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713451311
    },
    {
        "content": "<p>I'll have a stab at following <span class=\"user-mention\" data-user-id=\"360938\">@Tomaz Gomes</span>'s suggestion of implementing this as a combination of the core functions underlying <code>apply</code>, <code>assumption</code> and <code>clear</code>.</p>",
        "id": 434063909,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713451390
    },
    {
        "content": "<p>It sounds a bit like you want a tactic that does “as long as there is an assumption <code>h</code> of inductive type <code>T</code>, run <code>cases h</code>”, where <code>T</code> could be disjunction, but possibly others as well.</p>",
        "id": 434064345,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713451530
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Yes, that would already be useful, though there are elimination rules that are not of this kind, e.g. the last example.</p>",
        "id": 434064513,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713451580
    },
    {
        "content": "<p>I haven’t seen this elimination rule style theorems in Lean a lot besides genuine pattern matchers and recursors.  The <code>cases</code> tactic supports <code>cases foo using bar</code> where <code>bar</code> is an arbitrary elimination theorem. Not sure how well it copes when the conclusion is <code>R</code> and not <code>R x y</code> (applied to some targets), though.</p>",
        "id": 434087579,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713451731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"710624\">Hanno Becker</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Elimination.20rules/near/434063620\">said</a>:</p>\n<blockquote>\n<p>Here's an example application hopefully clarifying what I'm looking for: Given the goal <code>P ∨ Q → T ∨ W → S → U</code>, I want to be able to do <code>elim disjE</code> and -- up to <code>intro</code>s -- get four new goals <code>P → T → S → U</code>, <code>Q → T → S → U</code>, <code>P → W → S → U</code>, <code>Q → W → S → U</code>. Another example would be: _Given_ (proving this is again not the issue) <code>nat_boundE: i &lt; Suc n → (i = n → R) → (i &lt; n → R) → R</code>, and given a goal with hypothesis <code>i &lt; Suc (Suc (Suc (Suc 0))))</code> somewhere, I want to be able to call <code>elim nat_boundE</code> and immediately see subgoals emerge for <code>i=0,1,2,3</code>.</p>\n</blockquote>\n<p>thanks. I think these examples help me understand what you are looking for. I don't think there is a tactic that does this. It requires repeatedly recursing over all hypothesis, applying <code>rcases</code> or <code>interval_cases</code> (for the <code>Nat</code>example) and bring them to a point where you can <code>solve_by_elim</code> on all goals</p>",
        "id": 434096478,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713452416
    },
    {
        "content": "<p>Mathlib has a tactic for this. Here's recursively doing cases on all disjunctions and conjunctions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">casesm</span><span class=\"bp\">*</span> <span class=\"n\">_</span> <span class=\"bp\">∨</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 434208161,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713461459
    },
    {
        "content": "<p>There's a variant where you can do it by type name rather than by patterns:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">Or</span> <span class=\"n\">And</span>\n</code></pre></div>",
        "id": 434208455,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713461583
    },
    {
        "content": "<p>Thank you very much <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span>, those are very helpful pointers. I will look at the tactics and how they are implemented, and experiment with a generic <code>elim</code>. Elimination rules are ubiquitous and provide a nice unified framework for destructing tactics like <code>interval_cases</code> or <code>casesm*</code>, so it may be useful to have them at our disposal in Lean as well.</p>",
        "id": 434275365,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713497652
    },
    {
        "content": "<p>Here's a first attempt. I'm completely new to Lean metaprogramming, so any comment is welcome.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- Almost a copy from stdlib, but remembering the fvarid</span>\n<span class=\"c1\">--</span>\n\n<span class=\"sd\">/-- Try to close goal by assumption. Upon succes, return fvar id of</span>\n<span class=\"sd\">  matching assumption. Otherwise, return none. --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumptionCore'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.assign</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Close goal `mvarId` using an assumption. Throw error message if failed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumption'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">FVarId</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">assumptionCore'</span> <span class=\"n\">mvarId</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"assumption' tactic failed\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarid</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">fvarid</span>\n\n<span class=\"c1\">--</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">erule</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">with_intro</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">saveState</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvids</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.apply</span> <span class=\"n\">e</span>\n    <span class=\"k\">match</span> <span class=\"n\">mvids</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"ill-formed elimination rule {e}\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">main</span> <span class=\"o\">::</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- Try to solve main goal by assumption, remember fvar of hypothesis</span>\n      <span class=\"k\">let</span> <span class=\"n\">fvid</span> <span class=\"bp\">←</span> <span class=\"n\">assumption'</span> <span class=\"n\">main</span>\n      <span class=\"c1\">-- Remove hypothesis from all other goals</span>\n      <span class=\"k\">let</span> <span class=\"n\">other'</span> <span class=\"bp\">←</span> <span class=\"n\">other.mapM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">mvid</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvid.isAssignedOrDelayedAssigned</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvid</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.clear</span> <span class=\"n\">fvid</span>\n        <span class=\"k\">if</span> <span class=\"n\">with_intro</span> <span class=\"k\">then</span>\n          <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvid</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.intros</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n      <span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"n\">other'</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">restoreState</span> <span class=\"n\">s</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"erule_tac failed\"</span>\n\n<span class=\"c1\">-- Run erule repeatedly</span>\n<span class=\"kd\">def</span> <span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"n\">Meta.repeat1'</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mvid</span><span class=\"o\">]</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"erule\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"elim\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">elim</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Some examples of elimination rules</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- Elimination rules abound, but here are some simple examples.</span>\n<span class=\"c1\">-- While those can be handled by existing tactics as well, the point</span>\n<span class=\"c1\">-- is to show that `elim` unifies various types of deconstruction</span>\n<span class=\"c1\">-- in a single tactic, parametrized by a suitable elimination rule.</span>\n\n<span class=\"c1\">-- 1/ Disjunction elimination</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">elim</span> <span class=\"n\">Or.elim</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 2/ Conjunction elimination</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">conjE</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">elim</span> <span class=\"n\">conjE</span> <span class=\"c1\">-- Separate hypothesis A, B, C, D</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 3/ Destructing existentials</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exE'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span>\n   <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"n\">intro</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n   <span class=\"n\">cases</span> <span class=\"n\">f</span>\n   <span class=\"n\">apply</span> <span class=\"n\">g</span>\n   <span class=\"n\">assumption</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">100</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">128</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">elim</span> <span class=\"n\">exE'</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 4/ Destructing compound definitions</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dummyStruct</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkDummy</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f0</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValidDummy</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"n\">x.f0</span> <span class=\"bp\">*</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span>\n   <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f0</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValidDummyE</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">):</span>\n   <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f0</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f1</span> <span class=\"bp\">→</span> <span class=\"n\">x.f0</span> <span class=\"bp\">*</span> <span class=\"n\">x.f1</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isValidDummy</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">v</span>\n  <span class=\"n\">erule</span> <span class=\"n\">conjE</span>\n  <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">vx</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vy</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">elim</span> <span class=\"n\">isValidDummyE</span> <span class=\"c1\">-- Breaks up both validity assumptions, but leaves goal intact</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 5/ Case-splitting on natural numbers</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succ</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succE</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t0</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n     <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">bound_nat_succ</span> <span class=\"n\">lt</span><span class=\"o\">)</span>\n     <span class=\"n\">apply</span> <span class=\"n\">t0</span>\n     <span class=\"n\">assumption</span>\n     <span class=\"n\">apply</span> <span class=\"n\">t1</span>\n     <span class=\"n\">assumption</span>\n\n<span class=\"c1\">-- Syntax directed version of bound_nat_succE</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succE'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t0</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">bound_nat_succE</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">assumption</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"mi\">0</span><span class=\"o\">))))</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">elim</span> <span class=\"n\">bound_nat_succE'</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals for i=0,1,2,3 -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 434290845,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713506650
    },
    {
        "content": "<p>You could try replacing the apply + assumption sequences using solve_by_elim</p>",
        "id": 434291061,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713506804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I'm not sure this works, as <code>solve_by_elim</code> either solves the current goal or fails?</p>",
        "id": 434302624,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713511813
    },
    {
        "content": "<p>By the way, there are a number of <code>elim</code> theorems already, like for instance <code>Or.elim</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">disjE</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">∨</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">Or.elim</span> <span class=\"n\">h</span> <span class=\"n\">hP</span> <span class=\"n\">hQ</span>\n</code></pre></div>",
        "id": 434302913,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713511926
    },
    {
        "content": "<p>(and that can be proved using the recursor that's defined for <code>Or</code> directly, with <code>Or.recOn h hP hQ</code>)</p>",
        "id": 434303008,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1713511980
    },
    {
        "content": "<p>Is this something the stdlib might benefit from? The prototype above is surely incomplete, but if there's interest in having a general elimination rule in Lean, I could try to make time to open a PR and things could be discussed further there.</p>",
        "id": 434310283,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713514157
    },
    {
        "content": "<p>About solve_by_elim: putting. a <code>&lt;;&gt; try solve_by_elim</code> might just close any number of trivial subgoals. </p>\n<p>About <code>Std</code>: I like the idea in principle.  At least for verification this is very useful.   In practice, the Lean FRO is substantially restructuring <code>Std</code> (I'll try to find the link to the announcement). So there is a non trivial chance that this PR might potentially languish for a while without attention.</p>",
        "id": 434312520,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713514980
    },
    {
        "content": "<p>The announcement <a href=\"#narrow/stream/348111-std4/topic/Movement.20from.20Std.20to.20Init/near/431696248\">message about Std changes</a></p>",
        "id": 434313321,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713515277
    },
    {
        "content": "<p>Thank you Shreyas, that's good to know</p>",
        "id": 434313750,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713515421
    },
    {
        "content": "<p>A point about your examples: Single step elimination of propositional operators is not going to be a good way to explain the tactic. The basic issue is illustrated by the confusion I had in my messages above. <code>cases</code> or <code>apply elim_rule</code> already does that.</p>",
        "id": 434313870,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713515471
    },
    {
        "content": "<p>Also, once the goals are in a nice shape, tactics like simp_all and solve_by_elim will perfectly work without hypothesis names. So that's not necessarily the key difference either.</p>\n<p>EDIT: The key differentiator here is the recursive traversal of all hypothesis  and destructuring them in every possible way. The examples need to illustrate this aspect</p>",
        "id": 434314086,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713515558
    },
    {
        "content": "<p>I'm still not sure about <code>solve_by_elim</code> -- this does seem to strive to solve goals entirely, while <code>elim ...</code> is just a proof step (usually an early one). Can you show how to solve one of the examples (not the elimination rules themselves) using <code>solve_by_elim</code>?</p>",
        "id": 434314390,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713515658
    },
    {
        "content": "<p>I often use something like <code>rcases x &lt;;&gt; try simp_all</code> or  <code>rcases x &lt;;&gt; try aesop</code> to get past a lot of steps. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Elimination.20rules/near/434314086\">said</a>:</p>\n<blockquote>\n<p>Also, once the goals are in a nice shape, tactics like simp_all and solve_by_elim will perfectly work without hypothesis names</p>\n</blockquote>\n<p>About <code>solve_by_elim</code>, I am not on my machine now, but my first try would be to replace the proof of example 6 by <code>elim bound_Nat_succE' &lt;;&gt; intros &lt;;&gt; try solve_by_elim</code></p>",
        "id": 434315037,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713515907
    },
    {
        "content": "<p>(The last example)</p>",
        "id": 434315085,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713515930
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Kim Morrison</span> <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Would a generic <code>elim</code> be something worth considering for either [the new] Std or Boost?</p>",
        "id": 434315320,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713516028
    },
    {
        "content": "<p>EDIT : Some examples weren't solved</p>",
        "id": 434322464,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713518653
    },
    {
        "content": "<p>The tactic combination is : <code>&lt;;&gt; intros &lt;;&gt; try (first | assumption | solve_by_elim)</code></p>",
        "id": 434322519,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713518682
    },
    {
        "content": "<p>I’m personally hesitant to comment on which tactics should be in core or std, simply because I have not done enough serious proving/verification to make a judgement call.  I generally see a risk that if we create tactics as scratches need to be itched we’ll end up with a huge zoo of inconsistent, overlapping, special-cases tactics that make it very hard to learn and master lean. That’s also why I am holding back my own “let’s do this or that kind of tactic” impulses.</p>\n<p>In this particular case I have a gut feeling that a generic <code>elim</code> may be motivated by a different approach to proof automation than is common in Lean. It feels natural to me (having had Isabelle experience), which is why I don’t trust my own opinion here. It makes me wonder what I am missing that such a tactic doesn’t already exist – did the existing heavy Lean users really never think of it, or do they approach the problem differently and thus there is a smaller need for this.</p>\n<p>So I’m inclined to recommend to develop possible new tactics outside first (as a library or in mathlib) to see how useful it in general and later worry about upstreaming.</p>",
        "id": 434326389,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713520062
    },
    {
        "content": "<p>Oh, and about <code>solve_by_elim</code>, I think someone recently mentioned that it is very badly named, and has very little to do with “elimination rules”.</p>",
        "id": 434326554,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713520110
    },
    {
        "content": "<p>I think it should be called by <code>solve_by_applies</code> ;)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Elimination.20rules/near/434326554\">said</a>:</p>\n<blockquote>\n<p>Oh, and about <code>solve_by_elim</code>, I think someone recently mentioned that it is very badly named, and has very little to do with “elimination rules”.</p>\n</blockquote>",
        "id": 434326644,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713520139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> Thank you for your thoughtful reply, I think we are on the same page. It would be good to understand if indeed there is a different approach to proof automation altogether in Lean, or whether there just hasn't been as much need for it due to the emphasis on mathematics proofs rather than software verification (which tends to have a much smaller ratio of ideas vs. boilerplate reasoning than mathematics).</p>",
        "id": 434329369,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713521031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"710624\">@Hanno Becker</span> : The elimination of hidden variable names seems to affect the ability of closing tactics to solve some of the goals. Is it essential for elim to clear the hypotheses? EDIT: Sorry that didn't turn out to be the case for the examples you have given</p>",
        "id": 434330170,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713521333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span></p>\n<blockquote>\n<p>Is it essential for elim to clear the hypotheses?</p>\n</blockquote>\n<p>Yes, otherwise it would spin forever</p>",
        "id": 434332339,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713522122
    },
    {
        "content": "<p>I think it would be better to present this as a problem rather than a specific solution to that problem, because it won't be clear whether a new tactic is needed without that. Regarding the examples, here's my best attempt at automated and idiomatic versions of them:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Tactic.IntervalCases</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span>\n\n<span class=\"c1\">-- 1/ Disjunction elimination</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">Or</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- more idiomatic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"bp\">|</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"bp\">|</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 2/ Conjunction elimination</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">conjE</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">And</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 hypotheses -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- more idiomatic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intro</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">⟩</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 hypotheses -/</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 3/ Destructing existentials</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">100</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">128</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">casesm</span><span class=\"bp\">*</span> <span class=\"bp\">∃</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- more idiomatic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">100</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">128</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">a</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy1</span><span class=\"o\">,</span> <span class=\"n\">hy2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">b</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 4/ Destructing compound definitions</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dummyStruct</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkDummy</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f0</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">isValidDummy</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"n\">x.f0</span> <span class=\"bp\">*</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span>\n   <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f0</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">vx</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vy</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">casesm</span><span class=\"bp\">*</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span> <span class=\"bp\">∧</span> <span class=\"n\">_</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- more idiomatic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">vx</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vy</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">hx1</span><span class=\"o\">,</span> <span class=\"n\">dx</span><span class=\"o\">,</span> <span class=\"n\">hx2</span><span class=\"o\">,</span> <span class=\"n\">hx3</span><span class=\"o\">,</span> <span class=\"n\">hx4</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">vx</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">hy1</span><span class=\"o\">,</span> <span class=\"n\">dy</span><span class=\"o\">,</span> <span class=\"n\">hy2</span><span class=\"o\">,</span> <span class=\"n\">hy3</span><span class=\"o\">,</span> <span class=\"n\">hy4</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">vy</span>\n  <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- 5/ Case-splitting on natural numbers</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succ</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n\n<span class=\"c1\">-- Syntax directed version of bound_nat_succ</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succ'</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">∨</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">repeat'</span> <span class=\"o\">(</span><span class=\"n\">rename</span> <span class=\"n\">_</span><span class=\"bp\">&lt;</span><span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">lt</span><span class=\"bp\">;</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">bound_nat_succ'</span> <span class=\"n\">lt</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">this</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">clear</span> <span class=\"n\">lt</span><span class=\"o\">)</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- more idiomatic</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">i</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals for i=0,1,2,3 -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 434337479,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713524178
    },
    {
        "content": "<p>Of the examples, the last one is most clearly requiring something new (especially if we generalize it to something other than splitting natural numbers because we already have a tactic for that). It is possible to automate this with existing tactics, but there are various unsavory aspects of it and I wouldn't expect it to be used in practice.</p>\n<p>The biggest issue IMO with this <code>elim</code> tactic is that it doesn't give you a way to name the hypotheses that come out, which makes it not chain very well with anything except for high-automation tactics.</p>\n<p>As a stylistic matter, it is much more common to see elimination rules not presented in continuation passing style as you are showing here but rather as an inductive type (or and exists in some combination), relying on the builtin case splitting tools for these.</p>\n<p>There was an idea for a <code>clear_after</code> style annotation to go on variable uses to say \"clear this after using it in the current expression\", which would allow for writing things like <code>obtain _ | lt := bound_nat_succ' (clear_after lt)</code>. But it's not really clear how to implement this I think, because the tactic consuming the expression (here <code>obtain</code>) has to opt in somehow to handle the clearing job and define what \"after the expression has been used\" means.</p>",
        "id": 434338573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713524632
    },
    {
        "content": "<p>Mario: I get the impression that <code>elim</code> only really stands apart from the  <code>cases</code> family of tactics when there are large numbers of case distinctions to be made. Is my impression correct?</p>",
        "id": 434340684,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713525458
    },
    {
        "content": "<p>In these examples, the “more idomatic” style doesn’t help if you want the tactic to handle an unknown, arbitrary number of cases/nesting depth etc, e.g. when writing a reusable tactic (either ad-hoc for, say  <code>induction &lt;;&gt; …</code>, or a “real” tactic (macro) composed of smaller tactics that you use in many different profs)</p>",
        "id": 434340790,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713525488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Thank you very much.</p>\n<blockquote>\n<p>The biggest issue IMO with this <code>elim</code> tactic is that it doesn't give you a way to name the hypotheses that come out, which makes it not chain very well with anything except for high-automation tactics.</p>\n</blockquote>\n<p>Yes, I think this would be by design: In high-automation tactics, names of hypothesis usually don't matter (Isabelle doesn't even have named hypothesis).</p>\n<p>Since <code>elim</code> repeats elimination and (in Isabelle at least) can be given a list of elimination rules to apply, it also would not be clear how to name the hypotheses in the first place.</p>\n<p>However, at least the single-step version <code>erule</code> would benefit from (a) optionally allowing to specify the names of the hypotheses that are introduced, (b) optionally allowing the destruction of a specific hypothesis.</p>\n<blockquote>\n<p>As a stylistic matter, it is much more common to see elimination rules not presented in continuation passing style as you are showing here but rather as an inductive type (or and exists in some combination), relying on the builtin case splitting tools for these.</p>\n</blockquote>\n<p>This starts to get cumbersome when the elimination is not destructing a single inductive data type. In my experience, the pattern of Example 4 (Destructing compound definitions) is quite common: You have some sort of well-formedness property on datatypes which needs unpacking, and that unpacking may take a few steps before hypothesis are in the shape you want. The <code>elim</code>-approach captures this neatly without having to write any new tactics. However, whether proving the elimination rule is better than defining a macro for (say) <code>casesm* isValidDummy _, ∃ _, _, _ ∧ _</code> is perhaps a matter of taste.</p>\n<p>One positive of varying theorems rather than tactics though is that you can extend <code>elim</code> to work on a <em>set</em> of theorems (which ideally is captured via some named theorem list / attribute, so they can be extended) to routinely apply a set of elimination rules to your hypothesis. If every elimination rule is its own tactic / macro, this is not as easy.</p>",
        "id": 434340798,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713525490
    },
    {
        "content": "<blockquote>\n<p>Yes, I think this would be by design: In high-automation tactics, names of hypothesis usually don't matter (Isabelle doesn't even have named hypothesis).</p>\n</blockquote>\n<p>Well, I think this relates to what Joachim said about this being a tool for proofs in a different style than that used by lean</p>",
        "id": 434341413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713525751
    },
    {
        "content": "<blockquote>\n<p>Well, I think this relates to what Joachim said about this being a tool for proofs in a different style than that used by lean</p>\n</blockquote>\n<p>Yes, agreed. But is that because Lean's focus has been mostly on math so far? As the scope widens to include [more] program verification, the proof style(s) will likely broaden as well to meet the different demands.</p>",
        "id": 434341683,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713525877
    },
    {
        "content": "<p>Your example 4 seems to contain an unnecessary elim lemma, which just restates the definition in this different style. When you rewrite it to and/exists you end up with exactly the same thing as the original definition, so there is no need to have it in the first place. But if it was doing something interesting, you could still write it using and and exists. For example <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Nat.le.dest#doc\">docs#Nat.le.dest</a> is roughly of this form</p>",
        "id": 434341742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713525909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"710624\">Hanno Becker</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Elimination.20rules/near/434341683\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Well, I think this relates to what Joachim said about this being a tool for proofs in a different style than that used by lean</p>\n</blockquote>\n<p>Yes, agreed. But is that because Lean's focus has been mostly on math so far? As the scope widens to include [more] program verification, the proof style(s) will likely broaden as well to meet the different demands.</p>\n</blockquote>\n<p>Maybe? I've done a fair number of program verification proofs and haven't really felt the need to forgo hypothesis names</p>",
        "id": 434341913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713525988
    },
    {
        "content": "<blockquote>\n<p>which just restates the definition in this different style</p>\n</blockquote>\n<p>Yes, but that's the point of elimination rules -- they are never difficult/interesting, but restate a definition or lemma in a style that's most suitable for automation.</p>",
        "id": 434342247,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713526136
    },
    {
        "content": "<p>what I mean is: there is a mechanical translation you can do to elimination rules in the style you have been giving which removes the parameter <code>R</code>, replaces multiple hypotheses with <code>\\/</code>, and multiple arguments with <code>\\exists</code> or <code>/\\</code>. This is the idiomatic style for writing elimination lemmas in lean, and if you treat such lemmas as elimination rules you will find many more of them in mathlib than if you require the lemmas to be in this backward style</p>",
        "id": 434342769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526334
    },
    {
        "content": "<p>when you apply that transformation to <code>isValidDummyE</code>, you get precisely the definition of <code>isValidDummy</code></p>",
        "id": 434342838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526364
    },
    {
        "content": "<p>Translating this into Isabelle-Sprech: In Lean, <code>drule</code> is more idiomatic than <code>erule</code> :-)<br>\n(If I remember correctly)</p>",
        "id": 434342927,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1713526396
    },
    {
        "content": "<p>(okay, the argument order is different but I assume that's not relevant?)</p>",
        "id": 434342930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526397
    },
    {
        "content": "<p>Yes, but then you still have to destruct the <code>\\exists</code> and <code>Or</code> afterwards -- the point of the elimination rule is to capture this as a single step.</p>",
        "id": 434343129,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713526450
    },
    {
        "content": "<p>that's what your <code>elim</code> would do</p>",
        "id": 434343160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526463
    },
    {
        "content": "<p>or <code>cases</code> / <code>obtain</code> / etc</p>",
        "id": 434343174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526471
    },
    {
        "content": "<p>if I want to apply <code>le.dest</code> as an elimination rule I use something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h.dest</span>\n</code></pre></div>",
        "id": 434343459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526572
    },
    {
        "content": "<p>rather than (the equivalent of) </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">refine</span> <span class=\"n\">h.dest</span> <span class=\"k\">fun</span> <span class=\"n\">k</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n</code></pre></div>",
        "id": 434343541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526615
    },
    {
        "content": "<p>which is what you would have to do if le.dest was written in CPS</p>",
        "id": 434343576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1713526631
    },
    {
        "content": "<p>Here's the version with <code>solve_by_elim</code> that works. I removed all the <code>elim</code> occurrences because in at least one case, the <code>elim</code> version didn't work, which I am guessing has something to do with cleared hypotheses</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>The Solve_by_elim version.</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Meta</span> <span class=\"n\">Elab.Tactic</span>\n<span class=\"kn\">open</span> <span class=\"n\">Mathlib</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- Almost a copy from stdlib, but remembering the fvarid</span>\n<span class=\"c1\">--</span>\n\n<span class=\"sd\">/-- Try to close goal by assumption. Upon succes, return fvar id of</span>\n<span class=\"sd\">  matching assumption. Otherwise, return none. --/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumptionCore'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">Option</span> <span class=\"n\">FVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mvarId.withContext</span> <span class=\"k\">do</span>\n    <span class=\"n\">mvarId.checkNotAssigned</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span>\n    <span class=\"k\">match</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">findLocalDeclWithType</span><span class=\"bp\">?</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvarId.getType</span><span class=\"o\">))</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">none</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarId</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mvarId.assign</span> <span class=\"o\">(</span><span class=\"n\">mkFVar</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">fvarId</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Close goal `mvarId` using an assumption. Throw error message if failed. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">assumption'</span> <span class=\"o\">(</span><span class=\"n\">mvarId</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"n\">FVarId</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">res</span> <span class=\"bp\">←</span> <span class=\"n\">assumptionCore'</span> <span class=\"n\">mvarId</span>\n  <span class=\"k\">match</span> <span class=\"n\">res</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwTacticEx</span> <span class=\"bp\">`</span><span class=\"n\">assumption</span> <span class=\"n\">mvarId</span> <span class=\"s2\">\"assumption' tactic failed\"</span>\n  <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">fvarid</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">fvarid</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">--</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">erule</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">with_intro</span> <span class=\"o\">:</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"n\">true</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"bp\">←</span> <span class=\"n\">saveState</span>\n  <span class=\"n\">try</span>\n    <span class=\"k\">let</span> <span class=\"n\">mvids</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.apply</span> <span class=\"n\">e</span>\n    <span class=\"k\">match</span> <span class=\"n\">mvids</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">throwError</span> <span class=\"s2\">\"ill-formed elimination rule {e}\"</span>\n    <span class=\"bp\">|</span> <span class=\"n\">main</span> <span class=\"o\">::</span> <span class=\"n\">other</span> <span class=\"bp\">=&gt;</span>\n      <span class=\"c1\">-- Try to solve main goal by assumption, remember fvar of hypothesis</span>\n      <span class=\"k\">let</span> <span class=\"n\">fvid</span> <span class=\"bp\">←</span> <span class=\"n\">assumption'</span> <span class=\"n\">main</span>\n      <span class=\"c1\">-- Remove hypothesis from all other goals</span>\n      <span class=\"k\">let</span> <span class=\"n\">other'</span> <span class=\"bp\">←</span> <span class=\"n\">other.mapM</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">mvid</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mvid.isAssignedOrDelayedAssigned</span><span class=\"o\">)</span> <span class=\"k\">then</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">let</span> <span class=\"n\">mvid</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.clear</span> <span class=\"n\">fvid</span>\n        <span class=\"k\">if</span> <span class=\"n\">with_intro</span> <span class=\"k\">then</span>\n          <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mvid</span><span class=\"o\">)</span> <span class=\"bp\">←</span> <span class=\"n\">mvid.intros</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n        <span class=\"k\">else</span>\n          <span class=\"n\">return</span> <span class=\"n\">mvid</span>\n      <span class=\"o\">)</span>\n      <span class=\"n\">return</span> <span class=\"n\">other'</span>\n  <span class=\"n\">catch</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">restoreState</span> <span class=\"n\">s</span>\n    <span class=\"n\">throwError</span> <span class=\"s2\">\"erule_tac failed\"</span>\n<span class=\"c1\">-- Run erule repeatedly</span>\n<span class=\"kd\">def</span> <span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Expr</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mvid</span> <span class=\"o\">:</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MetaM</span> <span class=\"o\">(</span><span class=\"n\">List</span> <span class=\"n\">MVarId</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n   <span class=\"n\">Meta.repeat1'</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mvid</span><span class=\"o\">]</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"erule\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">erule</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"elim\"</span> <span class=\"n\">e</span><span class=\"o\">:</span><span class=\"n\">term</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n   <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"bp\">←</span> <span class=\"n\">elabTermForApply</span> <span class=\"n\">e</span>\n   <span class=\"n\">Elab.Tactic.liftMetaTactic</span> <span class=\"o\">(</span><span class=\"n\">elim</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"c1\">-- Some examples of elimination rules</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- Elimination rules abound, but here are some simple examples.</span>\n<span class=\"c1\">-- While those can be handled by existing tactics as well, the point</span>\n<span class=\"c1\">-- is to show that `elim` unifies various types of deconstruction</span>\n<span class=\"c1\">-- in a single tactic, parametrized by a suitable elimination rule.</span>\n<span class=\"c1\">-- 1/ Disjunction elimination</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∨</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">∨</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">Or</span> <span class=\"c\">/-</span><span class=\"cm\"> Now we have 4 goals -/</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- 2/ Conjunction elimination</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">conjE</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"n\">R</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span> <span class=\"n\">P</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t'</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">∧</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">And</span><span class=\"c1\">-- Separate hypothesis A, B, C, D</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- 3/ Destructing existentials</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">exE'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}:</span>\n   <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n   <span class=\"n\">intros</span>\n   <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">Exists</span>\n   <span class=\"n\">solve_by_elim</span>\n   <span class=\"n\">done</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">100</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">100</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">128</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">Exists</span> <span class=\"n\">And</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- 4/ Destructing compound definitions</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">dummyStruct</span> <span class=\"o\">:=</span>\n  <span class=\"n\">mkDummy</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">f0</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f1</span><span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">isValidDummy</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n   <span class=\"o\">(</span><span class=\"n\">x.f0</span> <span class=\"bp\">*</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">∧</span>\n   <span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f0</span> <span class=\"bp\">∧</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">isValidDummyE</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">):</span>\n   <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">d</span><span class=\"o\">:</span><span class=\"n\">Nat</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">5</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f0</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">x.f1</span> <span class=\"bp\">→</span> <span class=\"n\">x.f0</span> <span class=\"bp\">*</span> <span class=\"n\">x.f1</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">42</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">isValidDummy</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">v</span>\n  <span class=\"n\">intros</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">And</span> <span class=\"n\">Exists</span>\n  <span class=\"n\">solve_by_elim</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">dummyStruct</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">vx</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vy</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">isValidDummy</span> <span class=\"n\">at</span> <span class=\"bp\">*</span>\n  <span class=\"n\">cases_type</span><span class=\"bp\">*</span> <span class=\"n\">And</span> <span class=\"n\">Exists</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span>\n  <span class=\"bp\">&lt;;&gt;</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- 5/ Case-splitting on natural numbers</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succ</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">omega</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succE</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t0</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">bound_nat_succ</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">solve_by_elim</span>\n    <span class=\"n\">done</span>\n<span class=\"c1\">-- Syntax directed version of bound_nat_succE</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">bound_nat_succE'</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t0</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">bound_nat_succE</span> <span class=\"n\">lt</span><span class=\"o\">)</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">solve_by_elim</span>\n  <span class=\"n\">done</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">lt</span><span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">4</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n  <span class=\"n\">interval_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;;&gt;</span>\n  <span class=\"gr\">sorry</span>\n</code></pre></div>\n</div></div>",
        "id": 434352282,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713529869
    },
    {
        "content": "<p>Thanks all for the feedback and the alternatives! Looks like existing tactics are good enough for the proofs people have been wanting to do so far. I can only report from my own experience that when proofs scale up to hundreds of hypotheses and thousands of proofs steps, automation is crucial, and <code>elim</code> can be a very useful framework for uniformly applying a variety of destruction operations in that context. It also allows to keep the number of custom tactics down, which seems to align with the sentiment expressed by <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> above that a large zoo of special-case tactics makes Lean more difficult to learn and master.</p>",
        "id": 434356843,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713531337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"710624\">Hanno Becker</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Elimination.20rules/near/434356843\">said</a>:</p>\n<blockquote>\n<p>Thanks all for the feedback and the alternatives! Looks like existing tactics are good enough for the proofs people have been wanting to do so far. I can only report from my own experience that when proofs scale up to hundreds of hypotheses and thousands of proofs steps, automation is crucial, and <code>elim</code> can be a very useful framework for uniformly applying a variety of destruction operations in that context. It also allows to keep the number of custom tactics down, which seems to align with the sentiment expressed by <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> above that a large zoo of special-case tactics makes Lean more difficult to learn and master.</p>\n</blockquote>\n<p>Agreed in principle. I just think that to lean users, the key to explain the importance of a tactic is to provide an example that demonstrates the need for the tactic beyond a doubt. That means coming up with an example that is tedious with the cases tactics we have, but a breeze for <code>elim</code>. The current examples are useful test cases, but to demonstrate the utility of <code>elim</code> over others, the example needs to be much more complex.</p>",
        "id": 434357346,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713531494
    },
    {
        "content": "<p>We had a similar difficulty understanding the utility of small scale reflection in Lean SSR.</p>",
        "id": 434357500,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713531547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> The \"issue\" is that an elimination rule is hardly ever complicated, so for any instance of <code>elim thm</code> it is most likely that one can counter \"But tactic sequence X,Y,Z, does the same and is good enough?\" The value lies in the uniformity of the approach, not any individual instance: The \"X,Y,Z\" will likely vary with the example (cf. <code>cases, obtain, casesm*, repeat', interval_cases, cases_type*</code> considered in alternatives above), but with <code>elim</code>, all that varies is the theorem you feed it, but not the tactic itself.</p>",
        "id": 434358951,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1713531998
    },
    {
        "content": "<p>I agree on the proof discipline aspect and fwiw I'd like to see elim in whatever version of std comes out. I am just pointing out that to convince the community, two things need to be communicated properly:</p>\n<ol>\n<li>In the form of examples, exactly when and how we ought to use elim to benefit from it over the existing array of cases tactics.</li>\n<li>How <code>elim</code> works in conjunction with or composes with other tactics, and the effect of clearing hypothesis on this.</li>\n</ol>",
        "id": 434383998,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713539871
    },
    {
        "content": "<p>I think the second aspect is not as simple as \"let's do what Isabelle does\" because many a proof will ultimately have to use other tactics in combination with <code>elim</code> and these are lean tactics</p>",
        "id": 434384261,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1713539961
    }
]