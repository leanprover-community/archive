[
    {
        "content": "<p>For example, what exactly does it mean to prove the correctness of the following Lean program, <a href=\"https://leanprover.github.io/functional_programming_in_lean/hello-world/running-a-program.html?search=#combining-io-actions\"><code>HelloName.lean</code></a>? How do I do that?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IO</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stdin</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO.getStdin</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">stdout</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">IO.getStdout</span>\n\n<span class=\"w\">  </span><span class=\"n\">stdout.putStrLn</span><span class=\"w\"> </span><span class=\"s2\">\"How would you like to be addressed?\"</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">stdin.getLine</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">input.dropRightWhile</span><span class=\"w\"> </span><span class=\"n\">Char.isWhitespace</span>\n\n<span class=\"w\">  </span><span class=\"n\">stdout.putStrLn</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"bp\">!</span><span class=\"s2\">\"Hello, {name}!\"</span>\n</code></pre></div>",
        "id": 451927269,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721189671
    },
    {
        "content": "<p>You provide a specification and then you need to verify that specification. without specification there is nothing to be done.</p>",
        "id": 451935030,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721192702
    },
    {
        "content": "<p>What would be a specification of the <code>HelloName.lean</code> program? What theorems should I prove? I haven't started learning about program verification, so it's been difficult for me to imagine what a specification of a program would look like.</p>",
        "id": 451935097,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721192739
    },
    {
        "content": "<p>\"Name contains no white spaces on the right\", \" name is only alpha numeric \" (you violate that), \"the program always asks for input before giving output\". Many specifications are possible.</p>",
        "id": 451939620,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1721194456
    },
    {
        "content": "<p>I see. I don't know how one can state in Lean that the program always asks for input before giving output, but I guess there's a way for it.</p>",
        "id": 451944605,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721195341
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417769\">Bulhwi Cha</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/451935097\">said</a>:</p>\n<blockquote>\n<p>What would be a specification of the <code>HelloName.lean</code> program? What theorems should I prove? I haven't started learning about program verification, so it's been difficult for me to imagine what a specification of a program would look like.</p>\n</blockquote>\n<p>I think this is not an exciting example if you're starting to explore verification; it mostly concerns IO and related side effects which are necessarily opaque in Lean and don't permit very robust specifications or feats of verification in userspace. The hitchhikers guide and software foundations  (second half of vol 1, and vol 2) have pretty reasonable introductions to verification of basic imperative programs.</p>",
        "id": 451960332,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1721199064
    },
    {
        "content": "<p>Maybe one could use a state monad transformer who's state can be used for tracing, then add state changes after the IO actions, and finally prove that the trace has the order in which stdin occurred before stdout ?<br>\nThe same could work for a runtime analysis. Every time you perform an elementary operation, you increase the counter in the state. Then, you prove the big-oh stuff for that counter.<br>\nI'm no expert though. Hope someone posts an example in this thread. I would love to see the API of  <code>Batteries.Control</code> for example  in action.</p>",
        "id": 451978447,
        "sender_full_name": "Yves Jäckle",
        "timestamp": 1721203121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/451960332\">said</a>:</p>\n<blockquote>\n<p>I think this is not an exciting example if you're starting to explore verification; it mostly concerns IO and related side effects which are necessarily opaque in Lean and don't permit very robust specifications or feats of verification in userspace.</p>\n</blockquote>\n<p>For these reasons, I think proof-oriented programming languages like F* and Dafny <em>currently</em> offer better support for verification of effectful programs.</p>",
        "id": 452244529,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721277184
    },
    {
        "content": "<p>I don't think those necessarily get you much further in this case; the boundaries of what behavior or properties you can claim are verified depends on whether or not you have a model of what the host machine does with IO. You can lift certain properties into Lean and reason about them, which is what Yves suggested, ultimately you have to hand the results off to the computer. </p>\n<p>It's possible to specify and reason about what the operating system does with the end result, I think that's what the Coq ecosystem's \"verified software toolchain\" is about, and I assume the sel4 proofs include stuff like this, but my understanding is that it's a question of having those libraries and tools that know about and describe the compiler, operating system, etc available, not whether the type theory or effect system has a certain feature.</p>",
        "id": 452263098,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1721285854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452263098\">said</a>:</p>\n<blockquote>\n<p>…, but my understanding is that it's a question of having those libraries and tools that know about and describe the compiler, operating system, etc available, not whether the type theory or effect system has a certain feature.</p>\n</blockquote>\n<p>I agree. It's a question of whether libraries and tools for certain work are <em>currently</em> available to a language's ecosystem.</p>",
        "id": 452273649,
        "sender_full_name": "Bulhwi Cha",
        "timestamp": 1721289110
    },
    {
        "content": "<p>I'd like to add that for specifications of the sort \"The program always asks for input before giving output\" you also likely need some sort of temporal logic, which - as far as I know - is rare outside of model checkers. Lean, Dafny and the like shine for <em>functional</em> specifications.</p>",
        "id": 452284864,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1721291608
    },
    {
        "content": "<p>I think the use case of an ERC20 smart contract, where the total supply must be always the sum of all balances is a good property to think about a program. That's is done in dafny like this <a href=\"https://github.com/Consensys/WrappedEther.dfy/blob/main/src/WrappedEtherModel.dfy\">https://github.com/Consensys/WrappedEther.dfy/blob/main/src/WrappedEtherModel.dfy</a></p>",
        "id": 452297361,
        "sender_full_name": "Hz",
        "timestamp": 1721295443
    },
    {
        "content": "<p>One thing you can do is to write your effectful program in the <a href=\"https://sans-io.readthedocs.io/how-to-sans-io.html\">sans-IO</a> style. This method involves implementing the protocol as pure functions representing a state machine with inputs/outputs. Then you create another layer that wires actual IO to the state machine.<br>\nWhile it remains hard to verify the wiring layer for reasons discussed here, you can get far by verifying the state machine, and it's no different from other Lean proofs since it's just pure functions.</p>",
        "id": 452297888,
        "sender_full_name": "pandaman",
        "timestamp": 1721295534
    },
    {
        "content": "<p>sans-IO is great, it'd be awesome if it were 87 times more popular in the (Python) ecosystem than it already is, but I have never seen something that was a non \"traditional-IO-protocoly\" thing (e.g. an HTTP server, a client for some REST API, PROXY protocol, bla bla...) be written specifically claiming to be a \"sans-IO program\". (I'm not sure what the point of my comment is, only that it's interesting that you brought up sans-IO in this context, and maybe it indeed would be nice to somehow have the sans-IO docs relate to the point you were making)</p>",
        "id": 452354168,
        "sender_full_name": "Julian Berman",
        "timestamp": 1721311649
    },
    {
        "content": "<p>Though I guess e.g. Gary Bernhardt's \"Functional Core, Imperative Shell\" (<a href=\"https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell\">https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell</a>) or just generally the adage to separate logic from state is already quite similar.</p>",
        "id": 452354462,
        "sender_full_name": "Julian Berman",
        "timestamp": 1721311710
    },
    {
        "content": "<p>Yeah, I would say these more or less refer to the same concept in a sense that purity helps understanding/testing/verification/etc. I brought up sans-IO here because this particular example sounds a bit like an interactive message protocol.</p>",
        "id": 452368967,
        "sender_full_name": "pandaman",
        "timestamp": 1721315173
    },
    {
        "content": "<p>I am fond of Eric Hehner's way of thinking (from <a href=\"https://www.cs.toronto.edu/~hehner/aPToP/\">aPToP</a> and the corresponding video course:</p>\n<ul>\n<li>a specification of behavior is just a big binary (boolean) expression relating an initial state of a system to a resulting state</li>\n<li>some specifications are implementable, some are not (ex: you can't specify what the input will be. you can only specify what the output will be given a certain input)</li>\n<li>of the implementable specifications, some are directly executable</li>\n<li>for those that aren't, you can implement them by refining the specification until the whole thing is directly executable</li>\n<li>a program is a specification of behavior that is directly executable </li>\n</ul>\n<p>In the case of Lean, the specification language includes a syntax for describing which things happen before which other things... So in Lean, your code is <em>already</em> a specification that the input happens before the output.</p>\n<p>You don't need to prove a specification that are directly executable. (What is there to prove? That the spec is the spec?) (You could talk about a proof that the lean compiler correctly generates the machine for the program you wrote, but then you're verifying lean, not your program.)</p>\n<p>OTOH, if you were using a more complicated algorithm with multiple threads or some other abstraction so that the order of execution was no longer directly specified in the code, then it might make sense to prove statements about the order of operations.</p>",
        "id": 452388691,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721320223
    },
    {
        "content": "<p>FWIW, I'm not an expert at this, but I've been working to formally specify what a \"prime number sieve\" is and verify that a particular algorithm implements that spec in lean for the past few weeks, and keeping a dev log <a href=\"#narrow/stream/113489-new-members/topic/How.20do.20I.20prove.20my.20prime.20sieve.20works.3F\">in this thread</a>.</p>",
        "id": 452389624,
        "sender_full_name": "Michal Wallace (tangentstorm)",
        "timestamp": 1721320524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"571277\">Ira Fesefeldt</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452284864\">said</a>:</p>\n<blockquote>\n<p>I'd like to add that for specifications of the sort \"The program always asks for input before giving output\" you also likely need some sort of temporal logic, which - as far as I know - is rare outside of model checkers. Lean, Dafny and the like shine for <em>functional</em> specifications.</p>\n</blockquote>\n<p>I don't think you need to reach for temporal logic. You can either appeal to the evaluation order of the language (for <code>putStrLn (f getInput)</code> under eager evaluation , <code>f getInput</code> will be evaluated before <code>putStrLn</code>), or you can assign the result of <code>getInput</code> to a variable <code>Option String</code> that starts as <code>None</code> and state that the output operation only succeeds if the variable has been assigned/is not <code>None</code>.</p>",
        "id": 452688671,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1721434765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452688671\">said</a>:</p>\n<blockquote>\n<p>I don't think you need to reach for temporal logic. You can either appeal to the evaluation order of the language (for <code>putStrLn (f getInput)</code> under eager evaluation , <code>f getInput</code> will be evaluated before <code>putStrLn</code>), or you can assign the result of <code>getInput</code> to a variable <code>Option String</code> that starts as <code>None</code> and state that the output operation only succeeds if the variable has been assigned/is not <code>None</code>.</p>\n</blockquote>\n<p>Maybe this is a philosophical question, but I do think you only proved a specification if there is a theorem that states the specification clearly and is correct. And I don't see how any of these solutions is able to specify the property in a theorem? It looks to me like software engineering patterns that guarantee you the specification, but doesn't give you the possibility to actually prove the correctness of the specification? But I may also misunderstand you.</p>",
        "id": 452723005,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1721454670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"571277\">Ira Fesefeldt</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452723005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452688671\">said</a>:</p>\n<blockquote>\n<p>I don't think you need to reach for temporal logic. You can either appeal to the evaluation order of the language (for <code>putStrLn (f getInput)</code> under eager evaluation , <code>f getInput</code> will be evaluated before <code>putStrLn</code>), or you can assign the result of <code>getInput</code> to a variable <code>Option String</code> that starts as <code>None</code> and state that the output operation only succeeds if the variable has been assigned/is not <code>None</code>.</p>\n</blockquote>\n<p>Maybe this is a philosophical question, but I do think you only proved a specification if there is a theorem that states the specification clearly and is correct. And I don't see how any of these solutions is able to specify the property in a theorem? It looks to me like software engineering patterns that guarantee you the specification, but doesn't give you the possibility to actually prove the correctness of the specification? But I may also misunderstand you.</p>\n</blockquote>\n<p>If temporal logic is on the table and we're assuming there's a defined semantics available, I don't think it's controversial  to reason that because a program P which references a variable x can make progress iff x is defined when it's referenced, termination of a program <code>x := readInput; putStrLn x</code> is a valid proof that <code>readInput</code> was executed before <code>putStrLn</code>. I agree that whether the addition of temporal logic would add a more helpful notion of \"before\" is a matter of opinion.</p>",
        "id": 452810050,
        "sender_full_name": "Chris Bailey",
        "timestamp": 1721466166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"571277\">Ira Fesefeldt</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452723005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452688671\">said</a>:</p>\n<blockquote>\n<p>I don't think you need to reach for temporal logic. You can either appeal to the evaluation order of the language (for <code>putStrLn (f getInput)</code> under eager evaluation , <code>f getInput</code> will be evaluated before <code>putStrLn</code>), or you can assign the result of <code>getInput</code> to a variable <code>Option String</code> that starts as <code>None</code> and state that the output operation only succeeds if the variable has been assigned/is not <code>None</code>.</p>\n</blockquote>\n<p>Maybe this is a philosophical question, but I do think you only proved a specification if there is a theorem that states the specification clearly and is correct. And I don't see how any of these solutions is able to specify the property in a theorem? It looks to me like software engineering patterns that guarantee you the specification, but doesn't give you the possibility to actually prove the correctness of the specification? But I may also misunderstand you.</p>\n</blockquote>\n<p>Can someone say “my specification is that my recursive function must halt” and Lean confirms that? Would this be part of program verification, even though no theorem is stated? Or does this not count?</p>",
        "id": 455233066,
        "sender_full_name": "Tyler Josephson ⚛️",
        "timestamp": 1722378726
    },
    {
        "content": "<p>Termination is special as it is hard coded into lean - the missing <code>partial</code> keyword is the specification that the function terminates. And at least I would count that as a valid specification. And that's definitely program verification.</p>",
        "id": 455280121,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1722400236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424214\">Tyler Josephson ⚛️</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/455233066\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"571277\">Ira Fesefeldt</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452723005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228466\">Chris Bailey</span> <a href=\"#narrow/stream/236449-Program-verification/topic/what.20does.20it.20mean.20to.20prove.20the.20correctness.20of.20a.20program.3F/near/452688671\">said</a>:</p>\n<blockquote>\n<p>I don't think you need to reach for temporal logic. You can either appeal to the evaluation order of the language (for <code>putStrLn (f getInput)</code> under eager evaluation , <code>f getInput</code> will be evaluated before <code>putStrLn</code>), or you can assign the result of <code>getInput</code> to a variable <code>Option String</code> that starts as <code>None</code> and state that the output operation only succeeds if the variable has been assigned/is not <code>None</code>.</p>\n</blockquote>\n<p>Maybe this is a philosophical question, but I do think you only proved a specification if there is a theorem that states the specification clearly and is correct. And I don't see how any of these solutions is able to specify the property in a theorem? It looks to me like software engineering patterns that guarantee you the specification, but doesn't give you the possibility to actually prove the correctness of the specification? But I may also misunderstand you.</p>\n</blockquote>\n<p>Can someone say “my specification is that my recursive function must halt” and Lean confirms that? Would this be part of program verification, even though no theorem is stated? Or does this not count?</p>\n</blockquote>\n<p>Most program verification that is done irl right now relies on completely unverified tools to basically say \"yes it's fine\" or \"no, here is a counter example\" (sometimes without the counter example part). Not having a theorem in Lean stated but having the thing otherwise verified by Lean is a perfectly fine notion of verification^^</p>",
        "id": 455296592,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1722408337
    }
]