[
    {
        "content": "<p>Hey, I am attempting to implement a simple programming language in lean, and I'd like to write it's parser in lean too.</p>\n<p>Is there some examples on how to use the Parsec library somewhere ?</p>\n<p>Also, on a related note, do you think I should use Lean's builtin parser ? I don't really know how to transform a <code>String</code> into a <code>Syntax</code> though...</p>",
        "id": 407480508,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702389211
    },
    {
        "content": "<p>There is the syntax chapter and macro chapter of the #mpil book.</p>",
        "id": 407486614,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1702390746
    },
    {
        "content": "<p><a href=\"https://github.com/JLimperg/internal-language/blob/main/InternalLanguage.lean\">Here</a> is an embedding of the simply-typed lambda calculus into Lean as a DSL. If you want a more traditional, stand-alone compiler, check out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a>; this runs the parser for a syntax category on a string.</p>",
        "id": 407487861,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1702391069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Using.20Parsec/near/407487861\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/JLimperg/internal-language/blob/main/InternalLanguage.lean\">Here</a> is an embedding of the simply-typed lambda calculus into Lean as a DSL. If you want a more traditional, stand-alone compiler, check out <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Lean.Parser.runParserCategory#doc\">docs#Lean.Parser.runParserCategory</a>; this runs the parser for a syntax category on a string.</p>\n</blockquote>\n<p>So I have two questions:</p>\n<ol>\n<li>In your definitions for elaborators, you use <code>TermElabM</code>, which it seems can be used to perform more lew-level stuff than \"classical\" elaborators as in #mpil ?</li>\n<li><code>runParserCategory</code> takes an <code>Environment</code> as first argument, how would one provide that ?</li>\n</ol>",
        "id": 407489514,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702391487
    },
    {
        "content": "<p>In case it is relevant, Lean also has <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Data/Parsec.lean\">an implementation of the <code>Parsec</code> library</a> which can be used to turn <code>String</code>s into Lean terms. This is used, for example, in <a href=\"https://github.com/leanprover/lean4/blob/master/src/Lean/Data/Json/Parser.lean\">Lean's Json parser</a>.</p>",
        "id": 407490626,
        "sender_full_name": "Anand Rao Tadipatri",
        "timestamp": 1702391775
    },
    {
        "content": "<p>Oh and I just found out the <code>megaparsec</code> library which seems great too !</p>",
        "id": 407491352,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702391987
    },
    {
        "content": "<p>The type <code>TermElab</code> in MPIL, chapter \"Elaboration\", is an abbreviation for <code>Syntax -&gt; Option Expr -&gt; TermElabM Expr</code>. So this is fairly similar to what I do. The other elaborators in MPIL are command elaborators, which use <code>CommandElabM</code> and have slightly different capabilities.</p>",
        "id": 407491458,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1702392008
    },
    {
        "content": "<p>For the <code>Environment</code>, you can pass the empty environment <code>{}</code>.</p>",
        "id": 407491514,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1702392025
    },
    {
        "content": "<p>But to be clear, I'm not advocating for using Lean's parser; if you just want to write a traditional compiler with Lean as the implementation language, Megaparsec is probably easier.</p>",
        "id": 407492067,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1702392172
    },
    {
        "content": "<p>Yeah that's what I am starting to think</p>",
        "id": 407492133,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702392192
    },
    {
        "content": "<p>Furthermore, it might be cleaner</p>",
        "id": 407492185,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702392205
    },
    {
        "content": "<p>And I just realized that <code>megaparsec</code> has a tutorial, which answer my question then.<br>\nThank you for your answers !</p>",
        "id": 407497600,
        "sender_full_name": "Thomas Vigouroux",
        "timestamp": 1702393466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"658705\">Thomas Vigouroux</span> has marked this topic as resolved.</p>",
        "id": 407497619,
        "sender_full_name": "Notification Bot",
        "timestamp": 1702393470
    },
    {
        "content": "<p>there's also <a href=\"https://github.com/tydeu/lean4-partax\">partax</a> by <span class=\"user-mention\" data-user-id=\"315577\">@Mac Malone</span> that lets you mix the DSL approach that <span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> mentions with a traditional stand-alone compiler by generating a (standalone) parser from these Lean syntax extension</p>",
        "id": 408149202,
        "sender_full_name": "Andr√©s Goens",
        "timestamp": 1702633173
    }
]