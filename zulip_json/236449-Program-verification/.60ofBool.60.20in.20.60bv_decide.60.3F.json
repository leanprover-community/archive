[
    {
        "content": "<p>I'm greatly enjoying the new <code>bv_decide</code> tactic so far, but I had some difficulty getting it to understand conversion from <code>Bool</code> to <code>BitVec</code>. Here's a silly but frustrating example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Elab</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">BVDecide</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">BitVec</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">splitAnd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xLeft</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">extractLsb</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">yLeft</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">extractLsb</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">xRight</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">extractLsb</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">yRight</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">extractLsb</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">ofBool</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">xLeft</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">yLeft</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xRight</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">yRight</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">splitAnd_eq_and</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">splitAnd</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ofBool</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">splitAnd</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">bv_decide</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span>\n<span class=\"cm\">  The prover found a potentially spurious counterexample:</span>\n<span class=\"cm\">  - It abstracted the following unsupported expressions as opaque variables: [ofBool (x == y),</span>\n<span class=\"cm\">   ofBool (extractLsb' 4 4 x == extractLsb' 4 4 y &amp;&amp; extractLsb' 0 4 x == extractLsb' 0 4 y)]</span>\n<span class=\"cm\">  Consider the following assignment:</span>\n<span class=\"cm\">  ofBool (extractLsb' 4 4 x == extractLsb' 4 4 y &amp;&amp; extractLsb' 0 4 x == extractLsb' 0 4 y) = 0x1#1</span>\n<span class=\"cm\">  ofBool (x == y) = 0x0#1</span>\n\n<span class=\"cm\">  -/</span>\n</code></pre></div>\n<p>How can I fix this? For the particular example above, it's fine to add a <code>congr</code> after <code>simp</code>, but I'm looking for a more general solution when <code>Bool</code> may be converted to <code>BitVec</code> and then used in a more complex manner.</p>",
        "id": 474978137,
        "sender_full_name": "Quang Dao",
        "timestamp": 1728131923
    },
    {
        "content": "<p>This mutual recursion between bool and BitVec is not yet supported</p>",
        "id": 474983399,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728136543
    },
    {
        "content": "<p>So you are pretty much expected to get your goal into a firm where its boolean connectives like and or etc and then inside whatever BitVec</p>",
        "id": 474983463,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728136576
    },
    {
        "content": "<p>So if you just remove ofBool and put bool in the proper places it's going to work</p>",
        "id": 474983516,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728136613
    },
    {
        "content": "<p>Thanks! How complex would it be to implement this mutual recursion?</p>",
        "id": 474983529,
        "sender_full_name": "Quang Dao",
        "timestamp": 1728136636
    },
    {
        "content": "<p>It is quite clear which code needs to be moved into the same mutual block etc. in order for this to work out. Whether it is easy to do this while maintaining the proofs well or not I do not know yet</p>",
        "id": 474988222,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728140292
    },
    {
        "content": "<p>Since <code>ofBool</code> is essentially an \"if then else\" statement, could we support it by transforming the SAT formula accordingly?</p>",
        "id": 474988608,
        "sender_full_name": "Quang Dao",
        "timestamp": 1728140597
    },
    {
        "content": "<p>In other words, instead of putting current definitions into <code>mutual</code> block, we could define conditional expressions as a new inductive type and write conversion rules for it. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">CondExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Gate</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BoolExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BVExpr</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">BVExpr</span><span class=\"w\"> </span><span class=\"n\">α</span>\n</code></pre></div>",
        "id": 474988895,
        "sender_full_name": "Quang Dao",
        "timestamp": 1728140810
    },
    {
        "content": "<p><code>BoolExpr</code> has to potentially contain <code>BVExpr</code> though</p>",
        "id": 474989018,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1728140893
    }
]