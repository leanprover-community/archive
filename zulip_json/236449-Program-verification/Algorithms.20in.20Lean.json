[
    {
        "content": "<p>This question is from somebody who is looking to work on the formalization of distributed algorithms:</p>\n<p>What algorithms have been formalized (and proved to be accurate) in Lean? If only a handful, why is that? </p>\n<p>I suppose this is the right stream for this question, pls let me know if not. <br>\nAny examples of algorithms that have been formalized would be appreciated, thank you!</p>",
        "id": 470775256,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1726530268
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 470780046,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726532199
    },
    {
        "content": "<p>What kind of algorithms are we talking about here?</p>",
        "id": 470780124,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726532225
    },
    {
        "content": "<p>Can you give some examples?</p>",
        "id": 470780140,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726532229
    },
    {
        "content": "<p>because depending on the answer, there are several different siloed fields with different notions of algorithms and models of distributed computing.</p>",
        "id": 470780492,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726532363
    },
    {
        "content": "<p>Further there are different notions of formalising distributed algorithms/protocols. From raw formalisms to systematic verification + synthesis approaches using separation logics.</p>",
        "id": 470784271,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726533176
    },
    {
        "content": "<p>If you mean synchronous distributed graph algorithms, the reason is basically that until very recently, almost no one from the community actively worked in this area (unless you count me). Another issue is the literature in this area plays fast and loose with definitions, so what looks like one model is actually several related models.</p>",
        "id": 470792867,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726535732
    },
    {
        "content": "<p>If you are referring to asynchronous systems with algorithms like raft and paxos, the community that does verify them is active in other theorem provers.</p>",
        "id": 470792989,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726535773
    },
    {
        "content": "<p>There are also shared memory models, and I believe there are some people from the PL community using Coq, and process calculi people use model checker like tools.</p>",
        "id": 470793133,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726535853
    },
    {
        "content": "<p>some example works from the PL side : <a href=\"https://ilyasergey.net/assets/pdf/papers/dpc-jfp.pdf\">https://ilyasergey.net/assets/pdf/papers/dpc-jfp.pdf</a></p>",
        "id": 470793413,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726535975
    },
    {
        "content": "<p><a href=\"https://ilyasergey.net/assets/pdf/papers/scilla-oopsla19.pdf\">https://ilyasergey.net/assets/pdf/papers/scilla-oopsla19.pdf</a><br>\n<a href=\"https://www.cs.purdue.edu/homes/roopsha/papers/QuickSilver.OOPSLA21.pdf\">https://www.cs.purdue.edu/homes/roopsha/papers/QuickSilver.OOPSLA21.pdf</a></p>",
        "id": 470793633,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726536059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470780124\">said</a>:</p>\n<blockquote>\n<p>What kind of algorithms are we talking about here?</p>\n</blockquote>\n<p>Thank you for your response!</p>\n<p>A few examples include Asynchronous Byzantine agreement protocols and DAG-based consensus protocols (and the theory leading up to them).</p>",
        "id": 470810352,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1726541229
    },
    {
        "content": "<p>In particular, interest is in verification of liveness and probabilistic guarantees of randomised asynchronous distributed algorithms.</p>",
        "id": 470821469,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1726543969
    },
    {
        "content": "<p>Then there are formalisations in Coq like the following: <a href=\"https://arxiv.org/abs/1907.05523\">https://arxiv.org/abs/1907.05523</a></p>",
        "id": 470906933,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726561295
    },
    {
        "content": "<p>people encode distributed systems in ITPs in three primary ways:</p>\n<ul>\n<li>global transition system (this was done in <a href=\"https://arxiv.org/abs/1907.05523\">https://arxiv.org/abs/1907.05523</a> and many others like Verdi Raft)</li>\n<li>Lamport's happens-before relation (done for example in <a href=\"https://github.com/vrahli/Velisarios\">https://github.com/vrahli/Velisarios</a>)</li>\n<li>distributed separation logic (for example <a href=\"https://github.com/logsem/aneris\">https://github.com/logsem/aneris</a>)</li>\n</ul>",
        "id": 470907397,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726561444
    },
    {
        "content": "<p>This still leaves room for a lot of other sorts of distributed systems  which haven't been formalised or verified yet in ITPs</p>",
        "id": 470911484,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726562747
    },
    {
        "content": "<p>specifically systems which aren't asynchronous</p>",
        "id": 470912781,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726563097
    },
    {
        "content": "<p>Is there an advantage of formalising distributed algorithms in Lean instead of Coq?</p>",
        "id": 470937181,
        "sender_full_name": "Sasha Rubin",
        "timestamp": 1726568238
    },
    {
        "content": "<p>I don't check all papers in the field, but I didn't see any high-profile Lean-based paper on distributed systems verification. The main advantage is usually proposed to be access to Mathlib (but MathComp for Coq gives mostly similar math)</p>",
        "id": 470939738,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726568991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470911484\">said</a>:</p>\n<blockquote>\n<p>This still leaves room for a lot of other sorts of distributed systems  which haven't been formalised or verified yet in ITPs</p>\n</blockquote>\n<p>You can in principle do any specific distributed algorithm using any of the three approaches (happens-before, etc.), but the encoding specifics and proof reuse will be very different. And availability of maintained libraries varies, of course.</p>",
        "id": 470948556,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726571577
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"756459\">Sasha Rubin</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470937181\">said</a>:</p>\n<blockquote>\n<p>Is there an advantage of formalising distributed algorithms in Lean instead of Coq?</p>\n</blockquote>\n<p>I am formalising distributed graph algorithms with some colleagues, and I see a few advantages in Lean over Coq:</p>\n<ol>\n<li>I can teach lean math to mathy people in this area who will run in fear if the word \"constructive\" is used. Even though mathcomp is classical, Coq has an overall reputation of letting you pick your axioms, which means people need to know some foundations.</li>\n</ol>",
        "id": 470961495,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726575262
    },
    {
        "content": "<ol start=\"2\">\n<li>UX UX and UX. Unparalleled editor support, easy use of gitpod etc. This ranks above any technical considerations, because one can learn to work around technical limitations for most popular ITPs. Good UX is a huge time and effort saver</li>\n</ol>",
        "id": 470961513,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726575270
    },
    {
        "content": "<ol start=\"3\">\n<li>Mathlib. It is growing rather fast, so I am not worried about not having math that I might need.</li>\n</ol>",
        "id": 470961529,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726575276
    },
    {
        "content": "<ol start=\"4\">\n<li>Lean's metaprogramming is a bit more unified. There is one book that I can run a seminar on, and bring everyone upto speed.</li>\n</ol>",
        "id": 470961908,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726575380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198375\">Karl Palmskog</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470939738\">said</a>:</p>\n<blockquote>\n<p>I don't check all papers in the field, but I didn't see any high-profile Lean-based paper on distributed systems verification. The main advantage is usually proposed to be access to Mathlib (but MathComp for Coq gives mostly similar math)</p>\n</blockquote>\n<p>I have it on good authority that this situation might change in the next couple of years. Looking forward to it. It will be a nice comparison.</p>",
        "id": 470965673,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726576476
    },
    {
        "content": "<p>constructivism is a non-issue to most Coq users, but the Coq community has traditionally argued for careful \"axiom management\", since certain combinations of axioms can lead to trouble. When we did distributed system implementation verification in HOL4+CakeML, the main difference from Coq was not having to juggle decidable equality <em>explicitly</em> (but instead it shows up during the CakeML synthesis phase)</p>",
        "id": 470967255,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726576876
    },
    {
        "content": "<p>core MathComp packages are axiom-free, while certain non-core packages like MathComp Analysis use a variety of axioms related to classical logic</p>",
        "id": 470969103,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726577390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198375\">Karl Palmskog</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470967255\">said</a>:</p>\n<blockquote>\n<p>the Coq community has traditionally argued for careful \"axiom management\", since certain combinations of axioms can lead to trouble.</p>\n</blockquote>\n<p>In mathy communities like the algorithms community, most people probably took that one logic course in undergrad. We are not experts in proving soundness and completeness theorems for various axiom choices. So this is risky business for us. Lean (as in the whole tactic infrastructure of lean + mathlib) picks them for us and tactics use them freely.</p>",
        "id": 470969549,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726577507
    },
    {
        "content": "<p>Another thing is, a lot of the algorithms theory community's work is producing combinatorial lemmas and procedures. The computational bit is not as important for us as it is for systems folks.</p>",
        "id": 470970835,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726577812
    },
    {
        "content": "<p>you can encode \"axioms\" in many different ways, e.g., as your assumptions about how the network behaves. In computer science oriented reviews (think CPP conference), these assumptions could well be a focus of PC discussions. I think formal (program) verification is quite different from math/algorithms in this way, e.g., the reason for adding some assumption or axiom or framework is more likely to be scrutinized</p>",
        "id": 470977552,
        "sender_full_name": "Karl Palmskog",
        "timestamp": 1726579296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198375\">Karl Palmskog</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Algorithms.20in.20Lean/near/470977552\">said</a>:</p>\n<blockquote>\n<p>I think formal (program) verification is quite different from math/algorithms in this way, e.g., the reason for adding some assumption or axiom or framework is more likely to be scrutinized</p>\n</blockquote>\n<p>This makes sense. In math, one can construct reasonable mathematical models and work on them. These models don't necessarily have to conform to a ground truth in the same way that assumptions about the behaviour of programs have to (the ground truth being that they are run or simulated on a computer).</p>",
        "id": 470984386,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726580563
    },
    {
        "content": "<p>So in a formalisation project of math or algorithms, the only relevant question is whether the model corresponds in some reasonable way to what is already on paper.</p>",
        "id": 470984711,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1726580639
    },
    {
        "content": "<p>There are quite a few formalizations of consensus in Coq already. E.g.<br>\n<a href=\"https://eprint.iacr.org/2020/917\">https://eprint.iacr.org/2020/917</a><br>\n<a href=\"https://verse-lab.github.io/papers/bythos-ccs24.pdf\">https://verse-lab.github.io/papers/bythos-ccs24.pdf</a></p>\n<p>Aside, the concise SSR style is available in Lean too, one \"just\" needs to rebuild the math-comp libraries...<br>\n<a href=\"https://arxiv.org/pdf/2403.12733\">https://arxiv.org/pdf/2403.12733</a></p>",
        "id": 476716207,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1728894435
    },
    {
        "content": "<p>I think we can mix and match SSR and normal lean tactics</p>",
        "id": 476728930,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728897725
    },
    {
        "content": "<p>So mathlib + leanSSR should work as is</p>",
        "id": 476729756,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1728897952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250372\">@Ashvni Narayanan</span> I am presently working on a formalization of the Morpheus consensus algorithm, but it's deterministic and semisynchronous, not asynchronous and probabilistic. but it would be interesting to model the system degradation under liveness violations or a message adversary.</p>",
        "id": 502923081,
        "sender_full_name": "Ember Arlynx",
        "timestamp": 1740966654
    },
    {
        "content": "<p>It's going OK. Next week I am working towards a refinement proof for the fastpath optimizations.</p>",
        "id": 502923569,
        "sender_full_name": "Ember Arlynx",
        "timestamp": 1740966998
    }
]