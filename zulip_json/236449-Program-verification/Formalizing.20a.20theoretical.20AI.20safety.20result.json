[
    {
        "content": "<p><a href=\"https://github.com/google-deepmind/debate\">https://github.com/google-deepmind/debate</a> formalizes a theoretical result related to AI safety in Lean 4 (the paper is <a href=\"https://arxiv.org/abs/2311.14125\">https://arxiv.org/abs/2311.14125</a>).  It is a fairly simple theorem, but was a fun exercise to formalize (and was useful in learning the differences between Lean 3 and Lean 4).  And now we have the basic setting down in case we want to formalize follow-up results (this paper is just a baby step).</p>\n<p><a href=\"/user_uploads/3121/FWlOFxhBOU3Yk11lAXNmus8T/Screenshot-2023-11-27-at-10.58.57am.png\">Screenshot-2023-11-27-at-10.58.57am.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/FWlOFxhBOU3Yk11lAXNmus8T/Screenshot-2023-11-27-at-10.58.57am.png\" title=\"Screenshot-2023-11-27-at-10.58.57am.png\"><img src=\"/user_uploads/3121/FWlOFxhBOU3Yk11lAXNmus8T/Screenshot-2023-11-27-at-10.58.57am.png\"></a></div>",
        "id": 404387500,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701082937
    },
    {
        "content": "<p>In particular, we have a simple monad for expressing stochastic computations relative to multiple oracles:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A stochastic computation that can make oracle queries.</span>\n<span class=\"sd\">    Importantly, the computation does not know the oracle, so we can model query complexity.</span>\n<span class=\"sd\">    The `Comp` constructors are not very user friendly due to kernel restrictions on inductive,</span>\n<span class=\"sd\">    but we replace them with clean ones below. -/</span>\n<span class=\"kd\">inductive</span> <span class=\"n\">Comp</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Set</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">1</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Return a result with no computation -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">pure'</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span>\n  <span class=\"sd\">/-- Sample a value with some probability distribution, then continue -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">sample'</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Prob</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span>\n  <span class=\"sd\">/-- Query an oracle `o ∈ s`, and branch on the result -/</span>\n  <span class=\"bp\">|</span> <span class=\"n\">query'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">o</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Vector</span> <span class=\"n\">Bool</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">s</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>The current result uses only one oracle in spirit, but still uses the multiple-oracle functionality to express per-player query complexity.  Future results along this research path (if we succeed in getting there) will likely use multiple oracles in more fundamental ways, in particular to express machine heuristics than humans don't have access to.</p>",
        "id": 404388074,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701083141
    },
    {
        "content": "<p>Thank you to <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> for his careful review and various helpful suggestions!  (But all inelegant proofs are my fault. :))</p>",
        "id": 404388304,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701083219
    },
    {
        "content": "<p>One more note: rather than using <code>PMF</code> I made a custom <code>Prob</code> monad for finitely supported probability distributions: <a href=\"https://github.com/google-deepmind/debate/blob/main/Prob/Defs.lean#L31\">https://github.com/google-deepmind/debate/blob/main/Prob/Defs.lean#L31</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Prob α is a finitely supported probability distribution over results α -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">Prob</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"sd\">/-- Finitely supported probabilities -/</span>\n  <span class=\"n\">prob</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℝ</span>\n  <span class=\"sd\">/-- prob is nonnegative -/</span>\n  <span class=\"n\">prob_nonneg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span> <span class=\"mi\">0</span> <span class=\"bp\">≤</span> <span class=\"n\">prob</span> <span class=\"n\">x</span>\n  <span class=\"sd\">/-- The total probability is 1 -/</span>\n  <span class=\"n\">total</span> <span class=\"o\">:</span> <span class=\"n\">prob.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>This was in part a learning exercise, but I think it's also useful to avoid integrability side conditions that appear with <code>PMF</code>.  You can avoid integrability if summing over <code>ENNReal</code>, but finite support means expectations over the reals are also fine (<a href=\"https://github.com/google-deepmind/debate/blob/main/Prob/Defs.lean#L43\">https://github.com/google-deepmind/debate/blob/main/Prob/Defs.lean#L43</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Integral w.r.t. a distribution -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">pp_dot</span><span class=\"kd\">]</span> <span class=\"kd\">def</span> <span class=\"n\">Prob.exp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Prob</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n  <span class=\"n\">f.prob.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">p</span> <span class=\"bp\">↦</span> <span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I'm not perfectly confident this is the right design decision, but integrability was annoying enough in the <code>Prob</code> / <code>PMF</code> comparison file that I have some evidence: <a href=\"https://github.com/google-deepmind/debate/blob/main/Prob/Pmf.lean\">https://github.com/google-deepmind/debate/blob/main/Prob/Pmf.lean</a></p>",
        "id": 404389515,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701083681
    },
    {
        "content": "<p>Ah, also: monad syntax is lovely as always.  Here's the main debate protocol that the repo formalizes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- One step of the debate protocol -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">step</span> <span class=\"o\">(</span><span class=\"n\">alice</span> <span class=\"o\">:</span> <span class=\"n\">Alice</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bob</span> <span class=\"o\">:</span> <span class=\"n\">Bob</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vera</span> <span class=\"o\">:</span> <span class=\"n\">Vera</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Bool</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"n\">Comp</span> <span class=\"n\">AllIds</span> <span class=\"o\">(</span><span class=\"n\">State</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">alice</span> <span class=\"n\">_</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">allow_all</span>\n  <span class=\"k\">if</span> <span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">bob</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">allow_all</span> <span class=\"k\">then</span> <span class=\"k\">do</span>  <span class=\"c1\">-- Bob accepts Alice's probability, so take the step</span>\n    <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"bp\">←</span> <span class=\"n\">bernoulli</span> <span class=\"n\">p</span>  <span class=\"c1\">-- This is Figure 4, steps 2b,2c,2d, as a fixed part of the protocol</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"o\">(</span><span class=\"n\">y.cons</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"k\">else</span>  <span class=\"c1\">-- Bob rejects, so we call the verifier and end the computation</span>\n    <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"o\">(</span><span class=\"n\">vera</span> <span class=\"n\">_</span> <span class=\"n\">y</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">allow_all</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- n steps of the debate protocol -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">steps</span> <span class=\"o\">(</span><span class=\"n\">alice</span> <span class=\"o\">:</span> <span class=\"n\">Alice</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bob</span> <span class=\"o\">:</span> <span class=\"n\">Bob</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vera</span> <span class=\"o\">:</span> <span class=\"n\">Vera</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">Comp</span> <span class=\"n\">AllIds</span> <span class=\"o\">(</span><span class=\"n\">State</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">pure</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">Vector.nil</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"k\">match</span> <span class=\"bp\">←</span><span class=\"n\">steps</span> <span class=\"n\">alice</span> <span class=\"n\">bob</span> <span class=\"n\">vera</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">step</span> <span class=\"n\">alice</span> <span class=\"n\">bob</span> <span class=\"n\">vera</span> <span class=\"n\">y</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">r</span>\n\n<span class=\"sd\">/-- The full debate protocol that stitches these together -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">debate</span> <span class=\"o\">(</span><span class=\"n\">alice</span> <span class=\"o\">:</span> <span class=\"n\">Alice</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bob</span> <span class=\"o\">:</span> <span class=\"n\">Bob</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">vera</span> <span class=\"o\">:</span> <span class=\"n\">Vera</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Comp</span> <span class=\"n\">AllIds</span> <span class=\"n\">Bool</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">match</span> <span class=\"bp\">←</span><span class=\"n\">steps</span> <span class=\"n\">alice</span> <span class=\"n\">bob</span> <span class=\"n\">vera</span> <span class=\"o\">(</span><span class=\"n\">t</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">ok</span> <span class=\"n\">y</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">y.head</span>\n  <span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">error</span> <span class=\"n\">r</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">return</span> <span class=\"n\">r</span>\n</code></pre></div>",
        "id": 404389645,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701083740
    },
    {
        "content": "<p>This is wonderful news.</p>",
        "id": 404398895,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1701087056
    },
    {
        "content": "<p>About  the design choices: Have you found it more convenient to avoid the more abstract mathlib definitions at other places too?</p>",
        "id": 404398995,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1701087095
    },
    {
        "content": "<p>Nothing that occurs to me offhand.  Mathlib is usually pretty good at providing simple variants (e.g., <code>Finset</code>).</p>",
        "id": 404403295,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701088721
    },
    {
        "content": "<p><code>Prob</code> might make sense as an addition to Mathlib (<code>Finprob</code> or <code>FinPMF</code> or something).</p>",
        "id": 404411494,
        "sender_full_name": "Geoffrey Irving",
        "timestamp": 1701091545
    }
]