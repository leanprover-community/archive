[
    {
        "content": "<p>This is my first time coding in Lean. My proof compiles and checks out but I'd love to hear feedback as to whether anything I did was invalid, nonstandard, libraries I should have used, etc.. Happy to take any / all critiques on the math as well. Full repository with accompanying written paper at: <a href=\"https://github.com/eabadir/PprobablyEqualsNP\">https://github.com/eabadir/PprobablyEqualsNP</a> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">Log</span><span class=\"bp\">.</span><span class=\"n\">Basic</span><span class=\"w\"> </span><span class=\"c1\">-- For log base 2</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span><span class=\"w\"> </span><span class=\"c1\">-- For List.sum</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Set</span><span class=\"bp\">.</span><span class=\"n\">Defs</span><span class=\"w\"> </span><span class=\"c1\">-- For Set type used by P and NP</span>\n<span class=\"c1\">-- Using placeholder axioms for complexity theory results not readily available</span>\n<span class=\"c1\">-- or easy to formalize at this level (like poly-time reduction transitivity).</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">PnPProofDetailedV2</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Section 1: Foundational Definitions (Complexity, SAT, Entropy)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- Basic Types and Complexity Classes</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"c1\">-- Give Word a default value</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"c1\">-- A language is a property of words</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- Abstract notion of a Turing Machine or equivalent</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">compute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Machine computation</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">timeComplexity</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- Time cost</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- Input size measure</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">successWord</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Special word indicating acceptance</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">combineInput</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">cert</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Combining input and certificate for NP</span>\n\n<span class=\"c1\">-- Polynomial Time Definitions</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PolyTime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RunsInPolyTime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">PolyTime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">timeComplexity</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Complexity Class P</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">RunsInPolyTime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">         </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">compute</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">successWord</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Complexity Class NP</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Set</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">PolyTime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">RunsInPolyTime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">         </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cert</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"n\">cert</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">                        </span><span class=\"n\">compute</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">combineInput</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">cert</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">successWord</span><span class=\"w\"> </span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- Polynomial Time Reducibility</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PolyTimeReducible</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">RunsInPolyTime</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">compute</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">))</span>\n\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" &lt;=p \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PolyTimeReducible</span><span class=\"w\"> </span><span class=\"c1\">-- Notation for reduction</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">polyTimeReducible_trans</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"n\">L3</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L3</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- NP-Completeness Definition</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">  </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">L'</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L</span>\n\n<span class=\"c1\">-- Circuits and SAT (Boolean Satisfiability Problem)</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">encodeCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">decodeCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Circuit</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">evalCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w_c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">ass</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decodeCircuit</span><span class=\"w\"> </span><span class=\"n\">w_c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">evalCircuit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">ass</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">CookLevin_inNP</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">CookLevin_hard</span><span class=\"w\">   </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">CookLevin</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">CookLevin_inNP</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">hL</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">CookLevin_hard</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">hL</span>\n\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropy</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Section 2: Modeling Physics and Its Properties</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemDesc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">IsPhysicalSystem</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemDesc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">decodeDesc</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemDesc</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemProperty</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemDesc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_phys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPhysicalSystem</span><span class=\"w\"> </span><span class=\"n\">desc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemDesc</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_phys</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsPhysicalSystem</span><span class=\"w\"> </span><span class=\"n\">desc</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"n\">decodeDesc</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"bp\">∧</span>\n<span class=\"w\">      </span><span class=\"n\">PhysicalSystemProperty</span><span class=\"w\"> </span><span class=\"n\">desc</span><span class=\"w\"> </span><span class=\"n\">h_phys</span>\n\n<span class=\"sd\">/-- Rota's Entropy Theorem (RET): Physics entropy reduces to scaled Shannon Entropy. Full derivation of RET is available in the paper, or, available online Rota's unpublished textbook at:</span>\n<span class=\"sd\">https://archive.org/details/GianCarlo_Rota_and_Kenneth_Baclawski__An_Introduction_to_Probability_and_Random_Processes/page/n367/mode/2up</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">RET_Reduction_PhysicsEntropy_to_ShannonEntropy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span>\n\n<span class=\"sd\">/-- Shannon Coding Theorem: Coding Shannon Entropy is in P O(N log N). -/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyInPbyShannonCoding</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">reduction_in_P</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span>\n\n<span class=\"sd\">/-- Physics problem is in P via reduction to Shannon Entropy (which is in P). -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">PhysicsProblemIsInP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">reduction_in_P</span><span class=\"w\"> </span><span class=\"n\">RET_Reduction_PhysicsEntropy_to_ShannonEntropy</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyInPbyShannonCoding</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Section 3: Deriving Physics NP-Completeness</span>\n<span class=\"cm\">Establishing Reductions and Membership</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- Auxiliary problems and reductions</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ProgramProblem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">CircuitProblem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblemToProgram</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">ProgramProblem</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ProgramToCircuitProblem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ProgramProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">CircuitProblem</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">CircuitProblemToSAT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">CircuitProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span>\n\n<span class=\"sd\">/-- Physics reduces to SAT (via Shannon -&gt; Program -&gt; Circuit -&gt; SAT chain). -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Physics_to_SAT_Reduction</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">RET_Reduction_PhysicsEntropy_to_ShannonEntropy</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblemToProgram</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">r3</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ProgramToCircuitProblem</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">r4</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CircuitProblemToSAT</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">polyTimeReducible_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">polyTimeReducible_trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">polyTimeReducible_trans</span><span class=\"w\"> </span><span class=\"n\">r1</span><span class=\"w\"> </span><span class=\"n\">r2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">r4</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">reducible_in_NP</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span>\n\n<span class=\"sd\">/-- Physics ∈ NP (Membership Part of NP-Completeness).</span>\n<span class=\"sd\">    Derived via the reduction `Physics &lt;=p SAT` and `SAT ∈ NP`. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblemInNP</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">reducible_in_NP</span><span class=\"w\"> </span><span class=\"n\">Physics_to_SAT_Reduction</span><span class=\"w\"> </span><span class=\"n\">CookLevin</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"sd\">/-- Axiom: A physical system can realize/encode SAT computations.</span>\n<span class=\"sd\">    (e.g., Electrons behaving on a substrate designed as a logic circuit).</span>\n<span class=\"sd\">    This provides the reduction *from* SAT *to* the physical system. -/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Electrons_On_Circuits_Is_Physical_SAT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span>\n\n\n<span class=\"sd\">/-- Physics problem is NP-complete. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">PhysicsIsNPComplete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- Membership: Proven above via reduction TO SAT.</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblemInNP</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- NP-Hardness: Show any L ∈ NP reduces to PhysicalSystemEntropyProblem.</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">hL</span><span class=\"w\"> </span><span class=\"c1\">-- Assume L is an arbitrary language in NP (hL : L ∈ NP).</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Goal: Show L &lt;=p PhysicalSystemEntropyProblem</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Step 1: Every L ∈ NP reduces to SAT (by Cook-Levin NP-Hardness).</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_L_reduces_to_SAT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CookLevin</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"n\">hL</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Step 2: SAT reduces to the PhysicalSystemEntropyProblem (by the new axiom).</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_SAT_reduces_to_Physics</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">Electrons_On_Circuits_Is_Physical_SAT</span><span class=\"w\"> </span><span class=\"c1\">-- Use the new axiom here</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Step 3: Chain the reductions using transitivity.</span>\n<span class=\"w\">    </span><span class=\"c1\">-- L &lt;=p SAT_problem  and  SAT_problem &lt;=p PhysicalSystemEntropyProblem  implies  L &lt;=p PhysicalSystemEntropyProblem</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">polyTimeReducible_trans</span><span class=\"w\"> </span><span class=\"n\">h_L_reduces_to_SAT</span><span class=\"w\"> </span><span class=\"n\">h_SAT_reduces_to_Physics</span>\n\n<span class=\"c1\">-- Bidirectional reductions between SAT and Physics</span>\n<span class=\"c1\">-- This is a corollary of the NP-Completeness of both problems.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SAT_is_NPC_and_Physics_is_NPC</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">CookLevin</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">PhysicsIsNPComplete</span><span class=\"w\"> </span><span class=\"c1\">-- Use the lemma just proved</span>\n\n<span class=\"c1\">-- Define notation for bidirectional polynomial-time reducibility</span>\n<span class=\"kn\">infix</span><span class=\"o\">:</span><span class=\"mi\">50</span><span class=\"w\"> </span><span class=\"s2\">\" &lt;-&gt;p \"</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- lemma: If two languages are NP-complete, they are poly-time equivalent. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">NPComplete_problems_are_polyTime_equivalent</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"bp\">&lt;-&gt;</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h_L1_npc</span><span class=\"w\"> </span><span class=\"n\">h_L2_npc</span>\n<span class=\"w\">  </span><span class=\"n\">constructor</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_L2_npc</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">L1</span><span class=\"w\"> </span><span class=\"n\">h_L1_npc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"c1\">-- L1 ∈ NP reduces to L2 (hard)</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_L1_npc</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"w\"> </span><span class=\"n\">L2</span><span class=\"w\"> </span><span class=\"n\">h_L2_npc</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"c1\">-- L2 ∈ NP reduces to L1 (hard)</span>\n\n<span class=\"sd\">/-- Corollary: SAT and Physics are bidirectionally reducible because both are NP-Complete. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SAT_Physics_bidirectional_reduction</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">&lt;-&gt;</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_sat_npc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">CookLevin</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_phys_npc</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PhysicsIsNPComplete</span><span class=\"w\"> </span><span class=\"c1\">-- Now relies on a sound proof</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">NPComplete_problems_are_polyTime_equivalent</span><span class=\"w\"> </span><span class=\"n\">h_sat_npc</span><span class=\"w\"> </span><span class=\"n\">h_phys_npc</span>\n\n<span class=\"c1\">-- We can extract the specific reductions if needed</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">SAT_to_Physics_derived</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SAT_Physics_bidirectional_reduction</span><span class=\"bp\">.</span><span class=\"m\">1</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Physics_to_SAT_derived</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">SAT_Physics_bidirectional_reduction</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Section 4: Deriving NP-Completeness and the Contradiction (Steps j, k, l)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">P_and_NPComplete_implies_P_eq_NP</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">NP</span>\n\n<span class=\"c1\">-- Main Theorem: Assuming P ≠ NP leads to a contradiction.</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">P_eq_NP_from_Physics</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h_p_ne_np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"c1\">-- 1. The physics problem is in P (Derived from Rota + Shannon Coding efficiency)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hPhys_in_P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PhysicsProblemIsInP</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- 2. The physics problem is NP-Complete (Proven above using both reduction directions)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hPhys_is_NPComplete</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">NPComplete</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">PhysicsIsNPComplete</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- 3. Apply the standard complexity result: If a problem is in P and NP-Complete, then P = NP.</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_p_eq_np</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">NP</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"n\">P_and_NPComplete_implies_P_eq_NP</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"n\">hPhys_in_P</span><span class=\"w\"> </span><span class=\"n\">hPhys_is_NPComplete</span>\n\n<span class=\"w\">  </span><span class=\"c1\">-- 4. This conclusion (P = NP) contradicts the initial assumption (P ≠ NP).</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_p_ne_np</span><span class=\"w\"> </span><span class=\"n\">h_p_eq_np</span>\n\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">PnPProofDetailedV2</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Copyright (c) 2025 Essam Abadir, Distributed under the DeSciX Community License.-/</span>\n</code></pre></div>",
        "id": 514504229,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745646784
    },
    {
        "content": "<p>I'm not an expert on computability theory and didn't look at it very carefully, but it does strike as notable that you've added <em>a lot</em> of axioms. Not sure what the community is you want to target/get feedback from, but I would imagine the mathematical and theoretical computer science communities at large will not consider your proof reasonable if you've added a bunch of axioms, I'd recommend not adding any axioms. It looks like a lot of things you have there should be definitions, or variables, etc instead.</p>",
        "id": 514521396,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1745660408
    },
    {
        "content": "<p>Thank you. Are there conventions for using past proven results such as<br>\nShannon’s Coding Theorem? Are those normally definitions instead of axioms?</p>",
        "id": 514533158,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745669519
    },
    {
        "content": "<p>Usually, we want to have no axioms in our code (except for the few builtin ones)</p>",
        "id": 514533310,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745669595
    },
    {
        "content": "<p>More generally, whether you assume a value of some type, there's a question whether the type is inhabited. So when you prove something like <code>H → P = NP</code>, one may wonder if H is inhabited (or true).</p>\n<p>An axiom is essentially a global assumption, so writing <code>axiom h: H</code> is like appending <code>H</code> to assumptions of all theorems that use that axiom.</p>\n<p>Also, if there are some useful definitions in the Mathlib, it would be wise to use them, so other people would not have to wonder if your definitions of P and NP match the conventional ones.</p>",
        "id": 514536365,
        "sender_full_name": "suhr",
        "timestamp": 1745671870
    },
    {
        "content": "<p>This proof boils down to the following three claims:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Axiom: A physical system can realize/encode SAT computations.</span>\n<span class=\"sd\">    (e.g., Electrons behaving on a substrate designed as a logic circuit).</span>\n<span class=\"sd\">    This provides the reduction *from* SAT *to* the physical system. -/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Electrons_On_Circuits_Is_Physical_SAT</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span>\n\n<span class=\"sd\">/-- Rota's Entropy Theorem (RET): Physics entropy reduces to scaled Shannon Entropy. Full derivation of RET is available in the paper, or, available online Rota's unpublished textbook at:</span>\n<span class=\"sd\">https://archive.org/details/GianCarlo_Rota_and_Kenneth_Baclawski__An_Introduction_to_Probability_and_Random_Processes/page/n367/mode/2up</span>\n<span class=\"sd\">-/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">RET_Reduction_PhysicsEntropy_to_ShannonEntropy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhysicalSystemEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span>\n\n<span class=\"sd\">/-- Shannon Coding Theorem: Coding Shannon Entropy is in P O(N log N). -/</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyInPbyShannonCoding</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ShannonEntropyProblem</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">P</span>\n</code></pre></div>\n<p>Certainly, it follows from these three assumptions that P = NP. I don't know what are the shannon entropy problem and the physical system entropy problem, but the result here suggests that you should really dig into these because at least one of these assumptions is probably faulty.</p>",
        "id": 514570382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745696829
    },
    {
        "content": "<p>Thank you. This is all very helpful.</p>\n<p>I’ve put some effort into refactoring and moving all fundamental results and definitions from complexity and information theory into a separate definitions file. I’ll look around but if anyone knows of modules that contain generally accepted code for things like the Cook-Levin theorem please let me know.</p>\n<p>As Mario says, it then boils to one of those three axioms. Shannon’s Coding Theorem, that any system characterized by Shannon Entropy is codeable with series yes/no questions on the order of n log n,  is a foundational proof in information theory. Rota’s Entropy Theorem was taught it for decades at MIT by Prof. Gian-Carlo Rota, a giant in the field of Probability Theory, as the foundational result proved in his class - that physics entropies (Bose-Einstein, Fermi-Dirac, Maxwell-Boltzmann) are mathematically scaled forms of Shannon Entropy ... and it is indeed a very key result. Sadly, despite being taught to generations of MIT mathematics students, Rota's Entropy Theorem seems never to have been formally published ... here is a link to it in his unpublished manuscript posted by one of his students <a href=\"https://archive.org/details/GianCarlo_Rota_and_Kenneth_Baclawski__An_Introduction_to_Probability_and_Random_Processes/page/n367/mode/2up\">https://archive.org/details/GianCarlo_Rota_and_Kenneth_Baclawski__An_Introduction_to_Probability_and_Random_Processes/page/n367/mode/2up</a>.</p>\n<p>I’m working on putting the whole derivation of Rota's Entropy Theorem into Lean but it is seriously pushing the level of my Lean skills.  I've checked it in to the repository if anyone is interested / expert <a href=\"https://github.com/eabadir/PprobablyEqualsNP\">https://github.com/eabadir/PprobablyEqualsNP</a>. Currently hitting an issue 0.0 not being acceptable as 0. I’ll post a code question on it separately.</p>\n<p>I don't think I can get down to zero axioms though. The last axiom, that electrons traversing a computer circuit is the physical circuit satisfiability SAT problem, seems to be a tautology worthy of an axiom.</p>",
        "id": 514574465,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745699960
    },
    {
        "content": "<p>Note, people will not really fully accept this proof until it has zero axioms. But I think it's fine to be exploring these concepts in lean using <code>axiom</code>. I just suggest you refrain from announcing that you've proved P = NP until you actually have no assumptions and lean is not reporting errors, and even then it's going to draw an extreme level of skepticism and it is more tactful to say you are working on a proof of shannon's coding theorem and/or Rota's entropy theorem rather than leading with P=NP.</p>",
        "id": 514683176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745786924
    },
    {
        "content": "<blockquote>\n<p>I don't think I can get down to zero axioms though. The last axiom, that electrons traversing a computer circuit is the physical circuit satisfiability SAT problem, seems to be a tautology worthy of an axiom.</p>\n</blockquote>\n<p>If you think this is unformalizable, then this is actually the most important part to start with. If I understand your conundrum correctly, \"electrons traversing a computer circuit\" can probably just be replaced by \"the circuit satisfiability SAT problem\" for the purposes of the proof. This axiom on its own has no proving power; the reason it features in the proof is because you have a reduction of it to the shannon entropy problem, and perhaps you can just skip the unformalizable middle man and prove <code>SAT_problem &lt;=p ShannonEntropyProblem</code> directly. (Or fail to do so, but learn a lot in the process.)</p>",
        "id": 514683620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745787275
    },
    {
        "content": "<p>Thanks, this has been quite helpful and great suggestions which I’ll<br>\nincorporate.</p>\n<p>I must say though, being new to Lean, it is very counter to my intuition to<br>\nnot have axioms so I’d love to get a better understanding.</p>\n<p>Axioms as normally discussed are the very foundation of formal systems and<br>\nany formal argument. To my knowledge you can’t have one without the other,<br>\nevery proof has them either out in the open or hidden away.</p>\n<p>Does Lean syntactically use the word axiom in a different way or is there<br>\nsomething  I am misunderstanding understanding about the language?</p>",
        "id": 514813552,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745846703
    },
    {
        "content": "<p>These axioms make no sense:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"c1\">-- Give Word a default value</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"c1\">-- A language is a property of words</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"c1\">-- Abstract notion of a Turing Machine or equivalent</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">compute</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Machine computation</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">timeComplexity</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- Time cost</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"c1\">-- Input size measure</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">successWord</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Special word indicating acceptance</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">combineInput</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"n\">cert</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"w\"> </span><span class=\"c1\">-- Combining input and certificate for NP</span>\n</code></pre></div>",
        "id": 514844528,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854309
    },
    {
        "content": "<p>and then there is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Polynomial Time Definitions</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">PolyTime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"bp\">^</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">c</span>\n</code></pre></div>\n<p>You are really just defining asymptotics for polynomial functions here</p>",
        "id": 514844837,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854385
    },
    {
        "content": "<p>Then you define the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">RunsInPolyTime</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Machine</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">PolyTime</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">timeComplexity</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">wordLength</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which is meaningless since you haven't actually provided definitions for <code>timeComplexity</code> and <code>wordLength</code></p>",
        "id": 514845165,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854463
    },
    {
        "content": "<p>I could go on: But you have stubbed out everything important as an axiom</p>",
        "id": 514845356,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854515
    },
    {
        "content": "<p>including important definitions</p>",
        "id": 514845411,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854529
    },
    {
        "content": "<p><del>I'd just like to interject for a moment. What you’re referring to as ZFC, is in fact, FOL/ZFC, or as I’ve recently taken to calling it, first order logic plus set axioms. ZFC is not a foundation of mathematics unto itself, but rather a set of axioms of a fully functioning first order theory made useful by the logical connectives, quantifiers and vital set of inference rules composing a full formal system as defined by sequent calculus.</del></p>\n<p>A formal system is a set of inference rules that guide how one judgements (conclusions) are derived from other judgements (premises). Some systems, like ZFC or ETCS, are based on inference rules of first-order logic (for example, natural deduction). But these rules do not say anything about things like sets, so you need a whole set of axioms in order to say something.</p>\n<p>In contrast, dependent type theories like one used by Lean are not based on first-order logic. They are <em>theories of constructions.</em> A proof is merely a special case of a mathematical construction. Because of that, dependent type theories can be usable without <em>any</em> axioms at all: all you need is already made possible by inference rules. Though, Lean still adds some extra axioms to make life easier. </p>\n<p>Whether you use Lean or anything else, you should not add arbitrary axioms without justification, because they can make your theory inconsistent. So if you use ZFC you only use axioms of ZFC, if you use Lean, you only use axioms from the standard library.</p>",
        "id": 514845461,
        "sender_full_name": "suhr",
        "timestamp": 1745854542
    },
    {
        "content": "<p>A definition is meaningless without semantic content (the body of the definition at least)</p>",
        "id": 514846012,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854685
    },
    {
        "content": "<p>I mean what stops you from claiming that this implies <code>PSPACE != NPSPACE</code> by renaming some of your axioms (This is false btw, which is my point; you can write false statements like this) </p>\n<p>Edit note : As Henrik pointed out below the previous version had an egregious error of comparing L and NL instead</p>",
        "id": 514846140,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745854717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514846140\">said</a>:</p>\n<blockquote>\n<p>(This is false btw, which is my point; you can write false statements like this)</p>\n</blockquote>\n<p>It's not false, just unknown. What is known is that there exists a quadratic reduction of any problem in NL to L (Savitch's theorem) but that does not make them disjoint or equal.</p>",
        "id": 514861239,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745859136
    },
    {
        "content": "<p>I appreciate everyone's thoughtful feedback, and I’d like to clarify a central philosophical and practical point raised in this discussion.</p>\n<p>As a new Lean user, this discussion seem to suggest two extremes: either Lean contains a complete set of axioms capable of proving anything that's provable, or every proof must regress to an exhaustive first-principles derivation—akin to Russell and Whitehead’s infamous 360-page proof that 1+1=2.</p>\n<p>The first scenario—having a complete and sufficient set of axioms—is explicitly ruled out by Gödel’s Incompleteness Theorems, which demonstrate that no consistent, sufficiently rich formal system can prove all truths expressible within it. Thus, expecting Lean, or indeed any formal system, to contain such completeness would seem paradoxical. Furthermore, Russell’s paradox illustrates the risk inherent in naive axiomatics, underscoring why Lean’s  axiomatic approach should be valid.</p>\n<p>The second scenario—requiring every proof to painstakingly start from foundational logic—defeats the purpose of formalization entirely. Lean’s utility arises precisely from building on well-established theorems and results, enabling practical and concise proofs rather than exhaustive regressions.</p>\n<p>My hope in looking at Lean, and formal verification tools in general, was that it would sit thoughtfully between these extremes. That they would rely on a core set of axioms and inference rules, augmented by carefully vetted libraries of established mathematical results. When these standard results (e.g., Cook-Levin, Shannon Coding, and others foundational to computational complexity and information theory) are already proven and accepted, we ideally reference or formalize these results explicitly rather than introducing them as arbitrary axioms. </p>\n<p>For precisely these reasons, I have asked multiple times for guidance on generally accepted libraries or packages that provide foundational definitions and results in complexity theory. Attempting to define everything from first principles or redoing well-established proofs such as Shannon's Coding Theorem would only introduce unnecessary error, obfuscation, and complexity into the proof.</p>\n<p>Regarding the nature of Lean as a dependent type system, I do not see how it  exempts Lean from formal logic. Indeed, dependent type theory itself is a formal logic system—a constructive logic system with additional structure. Lean's type-theoretic foundation is not outside formal logic; rather, it is a well-defined, rigorous subset of it, designed to facilitate both foundational clarity and practical proof management.</p>\n<p>Your critique about my liberal use of axioms is fair and well-taken. My intent, especially as someone new to Lean, was to first outline clearly the theoretical landscape of the proof. Now, guided by your feedback, I'm actively working to convert those axioms which are \"new\" and further definable (such as Rota's Entropy Theorem) into explicit, verifiable theorems and definitions within Lean’s framework, ideally leveraging established libraries and community-accepted definitions.</p>\n<p>I just don't see how the complete absence of axioms is practically achievable (as even Lean’s minimal kernel has axiomatic underpinnings), but definitely do understand the goal is always to minimize assumptions by leveraging formally proven, established results. I would hope this strikes the necessary balance between foundational rigor and practical usability, respecting both Gödel’s constraints and Russell’s cautionary lessons.</p>\n<p>Again, I VERY MUCH appreciate everyone's input. I look forward to refining the approach. I'm personally most interested at the moment in porting Rota's Entropy Theorem into Lean as his formal mathematical derivation hadn't been previously published and, I think it is a result which has staggering implications. Prof Rota was a giant in his field and it is amazing to me that his most major contribution seems to have been entirely missed, a historical error I hope to contribute to correcting  with your further continued guidance and the collaborative insights of this community.</p>",
        "id": 514871855,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745862547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514871855\">said</a>:</p>\n<blockquote>\n<p>The second scenario—requiring every proof to painstakingly start from foundational logic—defeats the purpose of formalization entirely. Lean’s utility arises precisely from building on well-established theorems and results, enabling practical and concise proofs rather than exhaustive regressions.</p>\n</blockquote>\n<p>I don't understand - what's the point of formalization to you?</p>",
        "id": 514873782,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745863215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514813552\">said</a>:</p>\n<blockquote>\n<p>I must say though, being new to Lean, it is very counter to my intuition to<br>\nnot have axioms so I’d love to get a better understanding.</p>\n<p>Axioms as normally discussed are the very foundation of formal systems and<br>\nany formal argument. To my knowledge you can’t have one without the other,<br>\nevery proof has them either out in the open or hidden away.</p>\n<p>Does Lean syntactically use the word axiom in a different way or is there<br>\nsomething  I am misunderstanding understanding about the language?</p>\n</blockquote>\n<p>Lean does use axioms, but all the \"acceptable\" axioms are for the most part already predefined and available in the library. (There is an additional subtlety that in dependent type theory there is quite a lot which a logician might call an axiom which is instead smuggled in through other schema like inductive types and so does not actually make use of the <code>axiom</code> keyword.)</p>\n<p>I believe that your use of axioms to stub out parts of the development you have not investigated and/or wish to take for granted is defensible, but for this use it is clearer to use definitions by <code>sorry</code> instead to make it clear that the definition is not intended to be an opaque self-evident postulate, but rather an \"unfinished\" part of the proof (even if \"unfinished\" here means \"I have no intention to actually fill this in, but it is in the literature and maybe someone else can fill it in later'). That is, instead of <code>axiom Word : Type</code>, you should use <code>def Word : Type := sorry</code>.</p>",
        "id": 514873997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745863281
    },
    {
        "content": "<p>We have already painstakingly built up a library from foundational logic, that's what mathlib is, and it already contains many well-established results. If you see something missing, you are welcome to add it yourself.</p>",
        "id": 514874234,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745863338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514871855\">said</a>:</p>\n<blockquote>\n<p>The first scenario—having a complete and sufficient set of axioms—is explicitly ruled out by Gödel’s Incompleteness Theorems, which demonstrate that no consistent, sufficiently rich formal system can prove all truths expressible within it. Thus, expecting Lean, or indeed any formal system, to contain such completeness would seem paradoxical. Furthermore, Russell’s paradox illustrates the risk inherent in naive axiomatics, underscoring why Lean’s  axiomatic approach should be valid.</p>\n</blockquote>\n<p>This is not a practical concern. Most theorems of interest are provable outright and do not involve independent statements. These statements do exist, and indeed Lean has some very easy to state independent statements like <code>Nat = Int</code>, but in general they tend to be either non-mathematical questions or very esoteric. If you were to reduce P=NP to an independent statement this would of course also be big news though. There are plenty of ways of dealing with proper axiomatic extensions and independent statements, but I suggest you cross that bridge when you come to it.</p>",
        "id": 514875297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745863675
    },
    {
        "content": "<blockquote>\n<p>Attempting to define everything from first principles or redoing well-established proofs such as Shannon's Coding Theorem would only introduce unnecessary error, obfuscation, and complexity into the proof.</p>\n</blockquote>\n<p>On the contrary, redoing a well-established proof will eliminate the unnecessary error caused by potential mis-statement of the theorem. It will certainly add complexity to the proof though. But without these major components, this is but a proof sketch; that's not a bad thing, but we have to recognize it for what it is, and a proof sketch is not a proof (yet) - instead it points the way to the parts that require additional investigation, namely the sorries (or axioms in this case) that remain.</p>",
        "id": 514875954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745863886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514871855\">said</a>:</p>\n<blockquote>\n<p>Your critique about my liberal use of axioms is fair and well-taken. My intent, especially as someone new to Lean, was to first outline clearly the theoretical landscape of the proof. Now, guided by your feedback, I'm actively working to convert those axioms which are \"new\" and further definable (such as Rota's Entropy Theorem) into explicit, verifiable theorems and definitions within Lean’s framework, ideally leveraging established libraries and community-accepted definitions.</p>\n</blockquote>\n<p>This is the right idea. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<blockquote>\n<p>I just don't see how the complete absence of axioms is practically achievable (as even Lean’s minimal kernel has axiomatic underpinnings), but definitely do understand the goal is always to minimize assumptions by leveraging formally proven, established results.</p>\n</blockquote>\n<p>Just to be clear, it's not that you can't use axioms, it's that you shouldn't define axioms which are not already in the library. That is, <em>you</em> shouldn't be using the <code>axiom</code> keyword in your project, but it's fine to depend on the prelude library which has a small handful of <code>axiom</code>s in it.</p>",
        "id": 514876470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745864058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514861239\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514846140\">said</a>:</p>\n<blockquote>\n<p>(This is false btw, which is my point; you can write false statements like this)</p>\n</blockquote>\n<p>It's not false, just unknown. What is known is that there exists a quadratic reduction of any problem in NL to L (Savitch's theorem) but that does not make them disjoint or equal.</p>\n</blockquote>\n<p>Sorry, some combination of brain misfire and sleep deprivation. I think PSPACE = NPSPACe would have been the accurate version.</p>",
        "id": 514884184,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745866712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514884184\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"395550\">Henrik Böving</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514861239\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514846140\">said</a>:</p>\n<blockquote>\n<p>(This is false btw, which is my point; you can write false statements like this)</p>\n</blockquote>\n<p>It's not false, just unknown. What is known is that there exists a quadratic reduction of any problem in NL to L (Savitch's theorem) but that does not make them disjoint or equal.</p>\n</blockquote>\n<p>Sorry, some combination of brain misfire and sleep deprivation. I think PSPACE = NPSPACe would have been the accurate version.</p>\n</blockquote>\n<p>Yes that does follow from Savitch</p>",
        "id": 514885964,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1745867297
    },
    {
        "content": "<p><strong>Essam Abadir</strong></p>\n<p>First, many thanks—especially to <strong>Mario</strong>—for the steady combination of technical pointers and gentle nudges about community norms.  I come to Lean with a logician’s habit of thinking in terms of axiom systems; the language feels a bit like the trilingual upbringing I grew up with (Arabic ∣ English ∣ French): I can use all three, but still have to stop and ask which tongue I just spoke.  This thread was my way of asking native-Lean speakers <em>how</em> they think in Lean, not merely <em>how</em> to coerce Lean into compiling.</p>\n<hr>\n<h3><strong>What I think I have learned (sanity-check me!)</strong></h3>\n<ul>\n<li>\n<p><strong>Axioms live in their own file(s).</strong></p>\n<p>I have split everything that is still an axiom into a separate ComplexityDefs.lean, as the GitHub repo now shows.</p>\n</li>\n<li>\n<p><strong>Be explicit, not “smuggled”.</strong></p>\n<p>Instead of</p>\n</li>\n</ul>\n<p><code>axiom Word : Type</code></p>\n<ul>\n<li>the recommended pattern is</li>\n</ul>\n<p><code>def Word : Type := sorry</code></p>\n<ul>\n<li>That is clearer about intent (“this needs filling in”) and avoids the whiff of hidden postulates.  I confess I would <em>like</em> such lines to sit next to the proof that needs them so reviewers see the dependency chain immediately, but I also appreciate the proof-file clarity Mario’s convention gives.</li>\n</ul>\n<p>Let me know if I am mis-reading any of that.</p>\n<hr>\n<h3><strong>The elephant with the big letters</strong></h3>\n<h3><strong>P vs NP</strong></h3>\n<p>Yes, I put the headline theorem right at the top.  That violates the usual etiquette of “under-promise, over-deliver”, and I did it on purpose.  I wanted maximal scrutiny: if the foundation is sand, better the tower collapses in public.  Please do not read that as naïveté.  The arrows and lemmas will stand or fall with the definitions beneath them, and that is exactly how it should be.</p>\n<hr>\n<h3><strong>On the absence of complexity-theory libraries (@Aaron Liu)</strong></h3>\n<p>I have pored over mathlib and the various half-started community projects.  As far as I can see there is still <strong>no</strong> canonical suite of definitions for Machine, timeComplexity, RunsInPolyTime, Cook-Levin, etc.  That is why I keep asking.</p>\n<p>Suggesting that a single newcomer “just add the entirety of complexity theory to mathlib” feels a bit like suggesting we re-typeset <em>Principia Mathematica</em> so that the lemma “1 + 1 = 2” is fully formal.  If a result as foundational as <strong>Shannon’s Coding Theorem</strong> is still missing, I prefer to mark it <em>explicitly</em> as an axiom rather than slide the assumption in under a definition.</p>\n<hr>\n<h3><strong>On the</strong></h3>\n<h3><strong>L ≟ NL</strong></h3>\n<h3><strong>sidebar (@Henrik, @Shreyas)</strong></h3>\n<p>The log-space discussion is interesting, but it isn’t central to the coding questions nor to the proof sketch itself.  Pointing out that I have not supplied a full formal definition of timeComplexity is a fair observation, yet it circles back to the same practical dilemma: Lean has no ready-made complexity-theory toolkit.  Until that gap is bridged, Mario’s “define-with-sorry, isolate axioms” recipe seems the most honest compromise.</p>\n<hr>\n<p>Again, thank you all.  Please keep the feedback coming—whether on Lean idioms, on the way I am partitioning axioms vs. definitions, or on any mathematical mis-steps you catch.</p>",
        "id": 514914665,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745879461
    },
    {
        "content": "<p>Define with sorry is not a reasonable compromise for the problem you describe. It’s a reasonable starting point provided you have a feasible plan to fill out the sorries. And those sorries still need to be filled out. The whole challenge here is to define these notions of complexity in a theorem prover whose functions are extensionally equal (to be clear there are a few different solutions) . And then to do it in a way that accommodates multiple computational models and nuances. Secondly, and I am sorry that I have to say this, you almost certainly do not have a proof of P != NP. For more details see Scott Aaronson’s blogpost on what a proof of P vs NP should clarify.</p>",
        "id": 514915619,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745879979
    },
    {
        "content": "<p>For one thing you need to explain what makes 3SAT so much harder than 2 SAT which has a polynomial time algorithm.</p>",
        "id": 514915873,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745880107
    },
    {
        "content": "<p>Oh wait. You claim <code>P = NP</code>. Then I’d like to see this poly time 3SAT algorithm.</p>",
        "id": 514916269,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745880313
    },
    {
        "content": "<p>Mathlib seem to have some notion of complexity: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime</a></p>\n<p>No NP class in mathlib yet though.</p>",
        "id": 514916774,
        "sender_full_name": "suhr",
        "timestamp": 1745880587
    },
    {
        "content": "<p>Your statements about reductions simply don’t have the right quantifiers. When you reduce problems you have to explain how each input instance is solved via the reduction. Also what on earth is <code>Electrons_On_Circuits_Is_Physical_SAT</code></p>",
        "id": 514916922,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745880669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514916774\">said</a>:</p>\n<blockquote>\n<p>Mathlib seem to have some notion of complexity: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime</a></p>\n<p>No NP class in mathlib yet though.</p>\n</blockquote>\n<p>This is not super hard to define. The certificate definition should be doable as long as we can express the input encoding to a TM as the concatenation of two input encodings of bounded  size</p>",
        "id": 514917763,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745881170
    },
    {
        "content": "<p>But let’s take this discussion to a separate thread</p>",
        "id": 514917801,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745881190
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"394485\">@suhr</span> that is helpful.</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I also found this by searching on your name :) : <a href=\"https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Sat/FromLRAT.lean?utm_source=chatgpt.com\">https://github.com/leanprover-community/mathlib4/blob/master/Mathlib/Tactic/Sat/FromLRAT.lean?utm_source=chatgpt.com</a></p>\n<p>In my definitions file I currently have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- Boolean Circuits and SAT</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Inhabited</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"gr\">sorry</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">encodeCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">decodeCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Circuit</span>\n<span class=\"kn\">axiom</span><span class=\"w\"> </span><span class=\"n\">evalCircuit</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SAT_problem</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Lang</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">w_c</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Circuit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Word</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"n\">decodeCircuit</span><span class=\"w\"> </span><span class=\"n\">w_c</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">evalCircuit</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">assignment</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span>\n</code></pre></div>\n<p>Using your library could I treat encodeCircuit c as Lean code that <em>produces</em> a CNFFormula; then my SAT_problem can be the predicate ¬ satisfiable φ?</p>",
        "id": 514918269,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745881412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514917763\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514916774\">said</a>:</p>\n<blockquote>\n<p>Mathlib seem to have some notion of complexity: <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Computability/TMComputable.html#Turing.TM2ComputableInTime</a></p>\n<p>No NP class in mathlib yet though.</p>\n</blockquote>\n<p>This is not super hard to define. The certificate definition should be doable as long as we can express the input encoding to a TM as the concatenation of two input encodings of bounded  size</p>\n</blockquote>\n<p>Appreciate that <span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> I'll start a separate thread now on cleaning up the ComplexityDefs.lean file I'm working on.</p>",
        "id": 514919176,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745881920
    },
    {
        "content": "<p>My suggestion to start a new thread was to @suhr but you are welcome to do that if you would like to contribute. But I also recommend trying it out in a separate project before making a mathlib PR</p>",
        "id": 514919368,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745882025
    },
    {
        "content": "<p>And getting some feedback</p>",
        "id": 514919375,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1745882031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466334\">@Shreyas Srinivas</span> In words how would you describe the physical problem that SAT represents in the real world? In Lean, how would you describe it?</p>\n<p>I don't think Lean can be used for a constructive proof of P=NP since the constructive algorithm would need to run on a machine that is Turing Complete and, to my knowledge, Lean is not.</p>\n<p>The alternative, which Lean is capable of, is a proof of existence ... and I believe Scott Aaronson says he is a fan of those.</p>",
        "id": 514922290,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745883669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514922290\">said</a>:</p>\n<blockquote>\n<p>I don't think Lean can be used for a constructive proof of P=NP since the constructive algorithm would need to run on a machine that is Turing Complete and, to my knowledge, Lean is not.</p>\n</blockquote>\n<p>What reason do you have for believing this?</p>",
        "id": 514922459,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745883773
    },
    {
        "content": "<p>Many reductions can be done on a machine that is not turing complete, why do you think P=NP is any different?</p>",
        "id": 514923006,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745884026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514922459\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514922290\">said</a>:</p>\n<blockquote>\n<p>I don't think Lean can be used for a constructive proof of P=NP since the constructive algorithm would need to run on a machine that is Turing Complete and, to my knowledge, Lean is not.</p>\n</blockquote>\n<p>What reason do you have for believing this?</p>\n</blockquote>\n<p>My understanding is that Lean programs always terminate and therefore can not . Again, I'm new to the whole environment so please correct me if I'm wrong. Either way, for my particular background (fractal video compression, physics game engines) I'd use a 3GL.</p>",
        "id": 514923173,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745884133
    },
    {
        "content": "<p>Why does the constructive algorithm have to run on a turing-complete machine? Why can't it run on a non-turing-complete machine?</p>",
        "id": 514923552,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745884379
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514923552\">said</a>:</p>\n<blockquote>\n<p>Why does the constructive algorithm have to run on a turing-complete machine?</p>\n</blockquote>\n<p>The approach of my proof is dependent on Rota's Entropy Theorem (RET) - I fully acknowledge it rises and falls on RET, and, that I'll probably have to port RET to Lean or some equivalent even though the math is 50 years old at this point. </p>\n<p>RET  shows strict equivalence between physics entropies (Bose-Einstein, Fermi-Dirac, etc.) and Shannon Entropy which strictly implies that physics is computable in polynomial time. The constructive proof would therefore have to run in an environment where anything theoretically computable in computer science (Turing Complete) is computable. I'm sure that regardless what I say in this thread the constructive algorithm will be perceived as some sort of movie. On the other hand, the reason I'm attracted to Lean (or logic more broadly) is that there is a certain  certain satisfaction which comes with the proof of existence and Lean allows concrete discussable in this context.</p>\n<p>Said differently, a constructive proof would have to be able to compute anything in physics, i.e. your machine must be able compute anything that realizable (or at least compute a physics problem that was thought uncomputable, like Bose-Einstein statistics).  This is the basis of Aaronson's Boson Sampling being the problem from which all quantum computing benchmarks derive ... \"can you compute what light does using computational automata.\" </p>\n<p>I do have a constructive algorithm which does this, it's off topic for this forum but if you want to check out the constructive proof then see then see this link (<a href=\"https://storage.googleapis.com/daita-assets/sites/egpt/index.html\">https://storage.googleapis.com/daita-assets/sites/egpt/index.html</a>). I have no idea how this could be implemented in Lean and, I <em>think</em> that theorically it is impossible to implement in lean since the automata have to actually run their stochastic processes at large scale. The solution is in the recursive/fractal pattern that the Partition Theory which Rota taught can handle. The constructive algorithm is able to compute wave interference patterns, the double slit (see the interference report showing the expected interference), and Blackbody radiation simulations producing the expected distributions. </p>\n<p>As previously discussed in this thread, assuming it is acceptable to take Shannon's Coding Theorem as an axiom (or that the derivation gets added to Lean by me or someone else),  my proof will rise and fall on whether Rota's Entropy Theorem holds (assuming that you are willing to accept that SAT is a real  world circuit satisfiability problem and not some abstract puzzle). </p>\n<p>While related to, but not quite the same as the \"can you compute what light does\" question, the same combinatoric math enables a fully discrete and digitally computable derivation of Plancks's Law under the assumption of quantum gravity (note, I don't consider the Planck derivation a constructive proof relevant to P=NP but it is a constructive proof of computable physics in the computer science sense of computation: <a href=\"https://www.researchgate.net/publication/387306298_Without_Attraction_You've_Got_Nothing_-_Quantum_Gravity_Derivation_Under_Chaos_Probability_Theories\">https://www.researchgate.net/publication/387306298_Without_Attraction_You've_Got_Nothing_-_Quantum_Gravity_Derivation_Under_Chaos_Probability_Theories</a>).  <br>\n(Edited for clarity).</p>",
        "id": 514924656,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745885034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514914665\">said</a>:</p>\n<blockquote>\n<p>I have pored over mathlib and the various half-started community projects.  As far as I can see there is still <strong>no</strong> canonical suite of definitions for Machine, timeComplexity, RunsInPolyTime, Cook-Levin, etc.  That is why I keep asking.</p>\n<p>Suggesting that a single newcomer “just add the entirety of complexity theory to mathlib” feels a bit like suggesting we re-typeset <em>Principia Mathematica</em> so that the lemma “1 + 1 = 2” is fully formal.  If a result as foundational as <strong>Shannon’s Coding Theorem</strong> is still missing, I prefer to mark it <em>explicitly</em> as an axiom rather than slide the assumption in under a definition.</p>\n</blockquote>\n<p>The fact is that this project will not be complete until complexity theory is in mathlib, whether that happens because you do it or because others do in the meantime. It's unfortunate, but that's just the way it is when your theorem relies on unformalized prerequisites. You can of course proceed with the project without formalizing complexity theory first, but your claims will be conditional in that case.</p>\n<p>There are two main theorems you seem to be relying on here, Shannon's Coding Theorem and Rota's Entropy Theorem. These two are clearly what you should focus most on to make progress. The next step here would be to get a statement, as precise as you can, on which to test peoples' intuitions, because I and many others have strong intuitions that say that P = NP is not provable, so it is probably not necessary to actually go as far as a formal proof to find the \"minimal unintuitive lemma\" buried in your derivation.</p>",
        "id": 514997961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745916230
    },
    {
        "content": "<p>A good start would be to determine which of SCT or RET is more likely to be false (or mis-stated / misinterpreted). From your description, I'm inclined to say RET is the suspicious one: Physics is not able to magically solve NP complete problems on its own without a lengthy annealing process in practice, so I suspect something is being idealized incorrectly here.</p>",
        "id": 514998382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745916351
    },
    {
        "content": "<p>I think the discussion of constructive proofs is mostly a red herring. You can treat Lean as a classical proof system and ignore computability in the metalogic entirely; for a theorem of this form you really want explicit complexity theory and Lean is just as capable of talking about and proving theorems about complexity theory as ZFC. Also keep in mind that P = NP is a statement in complexity theory, not computability theory. It's entirely trivial from a computability perspective, because everything in sight is computable. Lean can solve NP complete problems computably using the brute force algorithm. Similarly, Physics is likely computable but that doesn't mean it is polynomial time.</p>",
        "id": 514998961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745916500
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 515005694,
        "sender_full_name": "Yan Yablonovskiy",
        "timestamp": 1745918406
    },
    {
        "content": "<p>On what page is Rotas entropy theorem stated in the book. At the linked page (367) there is no theorem</p>",
        "id": 515008512,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1745919202
    },
    {
        "content": "<p>I only skimmed through the book a bit and found nothing that reminds me of computing or any reduction</p>",
        "id": 515008994,
        "sender_full_name": "Johannes Tantow",
        "timestamp": 1745919347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902373\">Essam Abadir</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/514914665\">said</a>:</p>\n<blockquote>\n<h3><strong>P vs NP</strong></h3>\n<p>Yes, I put the headline theorem right at the top.  That violates the usual etiquette of “under-promise, over-deliver”, and I did it on purpose.  I wanted maximal scrutiny: if the foundation is sand, better the tower collapses in public.</p>\n</blockquote>\n<p>By the way, when I said \"it will draw extreme skepticism\" earlier that was euphemistic for \"people will think you are a crank\". More skepticism is not always a good thing; if you crank it up too much, rather than getting maximal scrutiny you will get everyone ignoring your work, being dismissive, and/or not assuming you are acting in good faith, which is really not a recipe for productive interaction. I find this a slightly unfortunate aspect of mathematical research work; mathematicians working on a big theorem are known to keep the headline tightly under wraps until they've triple checked everything in order to be able to weather the inevitable storm of skepticism.</p>",
        "id": 515012088,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745919784
    },
    {
        "content": "<p>As a <em>software developer,</em> I have a somewhat different perspective. I care about two things:</p>\n<ul>\n<li>Whether a person is honest</li>\n<li>Whether a person is willing to work and learn</li>\n</ul>\n<p>In the case of this thread, I can believe that OP is honest but I don't see willingness to work: formalizing the <em>statement</em> of the P vs NP problem is within the reach, but OP is unwilling to do it, mentioning Principia Mathematica as an excuse.</p>\n<p>I do have a bit of faith in people, so I patiently wait if any work actually will be done.</p>",
        "id": 515016328,
        "sender_full_name": "suhr",
        "timestamp": 1745920801
    },
    {
        "content": "<p>I don't see it so much as unwillingness as a (correct) assessment that it's a lot of work and rather tangential to the purpose of this particular formalization. Clearly they did not sign up to go on a year long yak shaving expedition here, and it's unfortunate that they or someone else needs to in this case.</p>",
        "id": 515021101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745922203
    },
    {
        "content": "<p>Is a proper formalization of the statement of a theorem really tangential to the purpose of formalization of a supposed proof of the theorem?</p>",
        "id": 515052308,
        "sender_full_name": "suhr",
        "timestamp": 1745930551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"394485\">suhr</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/515016328\">said</a>:</p>\n<blockquote>\n<p>As a <em>software developer,</em> I have a somewhat different perspective. I care about two things:</p>\n<ul>\n<li>Whether a person is honest</li>\n<li>Whether a person is willing to work and learn</li>\n</ul>\n<p>In the case of this thread, I can believe that OP is honest but I don't see willingness to work: formalizing the <em>statement</em> of the P vs NP problem is within the reach, but OP is unwilling to do it, mentioning Principia Mathematica as an excuse.</p>\n<p>I do have a bit of faith in people, so I patiently wait if any work actually will be done.</p>\n</blockquote>\n<p>I'll take you at your word and ask that you help since some of this beyond my skills in Lean. For example:</p>\n<hr>\n<p>As part of formalizing the Rota Entropy Theorem proof sketch I've hit a persistent roadblock in a specific lemma (<code>f_non_decreasing</code>). The core issue seems to stem from proving the positivity (<code>&gt; 0.0</code>) of a <code>Real</code> expression involving <code>Nat</code> coercion, specifically <code>1 / (↑k + 1)</code>, within the context of filtering a list.</p>\n<p><strong>Goal:</strong></p>\n<p>The high-level goal within the failing lemma is to show <code>filter P (uniformDist (k+1) ++ [0.0]) = uniformDist (k+1)</code>, where <code>P</code> is the predicate <code>fun x : Real =&gt; decide (x &gt; 0.0)</code>. This requires proving intermediate steps, including <code>filter P (uniformDist (k+1)) = uniformDist (k+1)</code>. This latter step boils down to proving that for any <code>x</code> in <code>uniformDist (k+1)</code>, <code>P x</code> holds. Since <code>x = 1 / (↑k + 1)</code>, the specific goal becomes proving <code>1 / (↑k + 1) &gt; 0.0</code>.</p>\n<p><strong>The Problem:</strong></p>\n<p>While proving <code>1 / (↑k + 1) &gt; 0.0</code> seems straightforward (positive numerator, positive denominator), applying standard tactics and lemmas consistently fails, often with confusing typeclass errors or unification failures.</p>\n<p><strong>Attempts Made:</strong></p>\n<ol>\n<li><strong>Initial Predicate:</strong> Started with the predicate <code>(· &gt; 0)</code>, relying on Lean's implicit <code>decide</code>, and using tactics like <code>positivity</code>. Ran into issues.</li>\n<li><strong>Explicit Predicate/Zero:</strong> Switched to <code>fun x : Real =&gt; decide (x &gt; 0.0)</code> and using the literal <code>0.0</code> when adding zero to the list (<code>p' := p ++ [0.0]</code>) to avoid type inference issues between <code>Nat</code>/<code>Int</code>/<code>Real</code> zeros.</li>\n<li>\n<p><strong>Proving Denominator Positivity (<code>↑k + 1 &gt; 0.0</code>):</strong></p>\n<p>*   <code>norm_cast</code> followed by <code>Nat.succ_pos k</code>: Failed (type mismatch).<br>\n  *   <code>apply Nat.cast_pos.mpr</code>: Failed because <code>↑k + 1</code> doesn't syntactically match <code>↑n</code>.<br>\n  *   Rewriting <code>↑k + 1</code> to <code>↑(k+1)</code> using <code>rw [← Nat.cast_add_one k]</code> then <code>apply Nat.cast_pos.mpr</code>: Seemed correct but subsequent steps sometimes failed.<br>\n  *   Using <code>linarith [Nat.zero_le k]</code>: This <em>seems</em> to work reliably for proving <code>↑k + 1 &gt; 0.0</code>.</p>\n</li>\n<li>\n<p><strong>Proving Numerator Positivity (<code>1 &gt; 0.0</code>):</strong></p>\n<p>*   <code>exact zero_lt_one</code>: Sometimes failed with type mismatches (expecting <code>&gt; 0</code> vs <code>&gt; 0.0</code>).<br>\n  *   <code>norm_num</code>: Works reliably.</p>\n</li>\n<li>\n<p><strong>Combining Positivity (<code>div_pos</code>, <code>one_div_pos</code>, <code>inv_pos</code>):</strong> After successfully proving <code>h_num_pos : 1 &gt; 0.0</code> (e.g., with <code>norm_num</code>) and <code>h_den_pos : ↑k + 1 &gt; 0.0</code> (e.g., with <code>linarith</code>), the final step applying a division positivity rule fails:</p>\n<p>*   <code>exact div_pos h_num_pos h_den_pos</code>: Often fails with <code>typeclass instance problem is stuck... PosMulReflectLT ...</code> or similar.<br>\n  *   <code>apply one_div_pos</code> then <code>exact h_den_pos</code>: Sometimes fails with similar typeclass errors or unification issues.<br>\n  *   <code>apply inv_pos</code> on <code>(↑k + 1)⁻¹</code>: Similar issues.</p>\n</li>\n</ol>\n<p>It feels like there's a subtle type inference or typeclass resolution issue preventing the final step, even when the prerequisites seem correctly proved.</p>\n<p><strong>Minimal Working Example (MWE):</strong></p>\n<p>This lemma isolates the failing step:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.Real.Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib.Data.List.Defs</span><span class=\"w\"> </span><span class=\"c1\">-- For List.replicate</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"c1\">-- Simplified uniformDist for MWE</span>\n<span class=\"kd\">noncomputable</span><span class=\"w\"> </span><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- The failing lemma attempt</span>\n<span class=\"kd\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self_MWE</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">filter_eq_self.mpr</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: ∀ x ∈ uniformDist n, decide (x &gt; 0.0) = true</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat.not_lt_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_replicate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"n\">obtain</span><span class=\"w\"> </span><span class=\"o\">⟨</span><span class=\"n\">_hnz</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"o\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_true_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: 1 / (↑k + 1) &gt; 0.0</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Prove prerequisites seemingly successfully</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_num_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_den_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">      </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat.zero_le</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- linarith seems robust here</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- This final step often fails with typeclass errors</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">div_pos</span><span class=\"w\"> </span><span class=\"n\">h_num_pos</span><span class=\"w\"> </span><span class=\"n\">h_den_pos</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Using apply one_div_pos / exact h_den_pos also tends to fail similarly.</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">Error Message frequently seen at the `exact div_pos` or `apply one_div_pos` step:</span>\n<span class=\"cm\">\"typeclass instance problem is stuck, it is often due to metavariables</span>\n<span class=\"cm\">  PosMulReflectLT ?m.XXXX\"</span>\n<span class=\"cm\">(or similar typeclasses related to ordered fields/division rings)</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n<p><strong>Question:</strong></p>\n<p>What is the most robust and correct way to prove <code>1 / (↑k + 1) &gt; 0.0</code> in this context, avoiding the typeclass/unification failures we're seeing with <code>div_pos</code> and related lemmas? Is there a different tactic or lemma sequence we should be using?</p>\n<p>Thanks for any insights!</p>\n<hr>",
        "id": 515079583,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745936920
    },
    {
        "content": "<p><code>positivity</code> seems to work here though?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"c1\">-- Simplified uniformDist for MWE</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">))</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self_MWE</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">filter_eq_self</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_replicate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"n\">hnz</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_true_iff</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_num_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">norm_num</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_den_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">linarith</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_le</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 515080334,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1745937087
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for asking a question which is clearly on topic</p>",
        "id": 515080951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745937234
    },
    {
        "content": "<p>general recommendation, don't use <code>0.0</code> if you want <code>0</code>. The latter has more lemmas about it and the former should be simped to the same thing</p>",
        "id": 515081812,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745937411
    },
    {
        "content": "<p>(I don't think they are syntactically equal)</p>",
        "id": 515081898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745937431
    },
    {
        "content": "<p>Yeah, <code>0.0</code> is a <code>Float</code> which is used for programming rather than for math. While there's a coercion of floats into reals, there's not many lemmas about the result of such coercion.</p>\n<p>For math you should use <code>0</code> instead of <code>0.0</code>.</p>",
        "id": 515082450,
        "sender_full_name": "suhr",
        "timestamp": 1745937574
    },
    {
        "content": "<p>Not exactly, <code>0.0</code> uses an <code>OfScientific</code> instance for the type just like <code>0</code> uses <code>OfNat</code> for the type. There is a default instance which uses <code>Float</code>, but this only affects uses where the type cannot be inferred</p>",
        "id": 515083137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745937729
    },
    {
        "content": "<p>Yeah, Mathlib implements this in a somewhat roundabout way. You have <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Ring/Unbundled/Rat.html#NNRatCast.toOfScientific\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/Order/Ring/Unbundled/Rat.html#NNRatCast.toOfScientific</a>, which implements <code>OfScientific</code> for everything that has a canonical homomorphism from rationals.</p>",
        "id": 515087010,
        "sender_full_name": "suhr",
        "timestamp": 1745938522
    },
    {
        "content": "<p>Thx that got things a bit further assuming I implemented your advice correctly. I'm very much getting out my depths at this point in terms of understanding what is happening under the hood and the Lean idioms are new to me. In hopes of giving you well structured questions I'm enlisting an LLM to help me write questions up from here:</p>\n<p>At the step involving <code>List.filter</code> and are running into trouble with a <code>convert_to</code> step, even after simplifying the setup based on previous advice (thanks @[Forum User Who Provided Positivity Solution]!).</p>\n<p><strong>Context:</strong></p>\n<p>We are inside a larger proof (<code>f_non_decreasing</code>) and need to prove the following intermediate fact:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Goal: Prove that filtering (p ++ [0]) is the same as p</span>\n<span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_filter_eq_p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p'.filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Where:</p>\n<ul>\n<li><code>p := uniformDist (k+1)</code> (a list of positive <code>Real</code> numbers <code>1 / (↑k + 1)</code>)</li>\n<li><code>p' := p ++ [0]</code> (using generic <code>0</code>, type inferred as <code>Real</code>)</li>\n<li>We have helper lemmas:<br>\n    *   <code>filter_decide_gt_zero_singleton_zero : filter (fun x : Real =&gt; decide (x &gt; 0)) [0] = []</code><br>\n    *   <code>filter_decide_gt_zero_uniformDist_eq_self : filter (fun x : Real =&gt; decide (x &gt; 0)) (uniformDist n) = uniformDist n</code> (proven using <code>positivity</code>)</li>\n</ul>\n<p><strong>The Attempted Proof using <code>convert_to</code>:</strong></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_filter_eq_p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p'.filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) (p ++ [0]) = p</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_append</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p ++ filter (...) [0] = p</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Use convert_to for robustness against predicate unification issues</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- Subgoal 1: prove filter (...) [0] = []</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_singleton_zero</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Main goal after convert: filter (...) p ++ [] = p</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">append_nil</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p = p</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: p = p</span>\n<span class=\"w\">  </span><span class=\"c1\">-- rfl -- closes goal</span>\n</code></pre></div>\n<p><strong>The Problem:</strong></p>\n<p>Despite the helper lemmas seeming correct (especially <code>filter_decide_gt_zero_uniformDist_eq_self</code> which now uses <code>positivity</code> successfully), the <code>convert_to</code> step (or sometimes the subsequent <code>rw [filter_decide_gt_zero_uniformDist_eq_self nk_pos]</code>) fails. The typical error is either a type mismatch error involving the predicate (<code>decide (x &gt; 0)</code>) or a failure to unify the goal.</p>\n<p>It feels like <code>convert_to</code> isn't simplifying the predicate correctly, or the context within <code>f_non_decreasing</code> is causing issues that weren't present in the isolated MWE for the helper lemma.</p>\n<p><strong>Question:</strong></p>\n<p>Is <code>convert_to</code> the right approach here? Is there a more robust way to prove <code>h_filter_eq_p</code> given the helper lemmas? Could there be an issue with how the predicate <code>(fun x : Real =&gt; decide (x &gt; 0))</code> is being handled by <code>filter_append</code> vs. <code>convert_to</code> vs. the helper lemmas?</p>\n<p><strong>Full Code Context:</strong> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">Log</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">PartitionTheoryDefs</span><span class=\"w\"> </span><span class=\"c1\">-- Assuming this file is available</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">! RotaEntropyProof.lean -/</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">RotaEntropyProof</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">PartitionTheoryDefs</span>\n\n<span class=\"c1\">-- === Definition of f(n) ===</span>\n\n<span class=\"sd\">/-- The function f(n) = H applied to the uniform distribution on n elements. -/</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EntropyFunction</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_def_alt</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EntropyFunction</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">if_pos</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_one_is_zero</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EntropyFunction</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hProps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEntropyProperties</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_unif_1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f_def_alt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_unif_1</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hProps</span><span class=\"bp\">.</span><span class=\"n\">prop0</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">zero_lt_one</span>\n\n\n<span class=\"c1\">-- === Helper Lemmas (Using generic 0) ===</span>\n\n<span class=\"c1\">-- Define uniformDist here if not in PartitionTheoryDefs or separate file</span>\n<span class=\"c1\">-- noncomputable def uniformDist (n : Nat) : List Real :=</span>\n<span class=\"c1\">--   match n with</span>\n<span class=\"c1\">--   | 0 =&gt; []</span>\n<span class=\"c1\">--   | k+1 =&gt; replicate (k+1) (1 / (k+1 : Real))</span>\n\n<span class=\"sd\">/-- Helper: filter (fun x : Real =&gt; decide (x &gt; 0)) on [0] is []. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_singleton_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_false_iff_not</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"sd\">/-- Helper: filter (fun x : Real =&gt; decide (x &gt; 0)) on uniformDist n is identity for n &gt; 0. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">filter_eq_self</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_replicate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"n\">hnz</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_true_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: 1 / (↑k + 1) &gt; 0</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span><span class=\"w\"> </span><span class=\"c1\">-- Should solve the goal directly</span>\n\n<span class=\"c1\">-- === Main Proof for f_non_decreasing ===</span>\n\n<span class=\"sd\">/-- Lemma: f is non-decreasing. Follows from Properties 2 and 5. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_non_decreasing</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EntropyFunction</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hProps</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HasEntropyProperties</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hn_succ_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f_def_alt</span><span class=\"w\"> </span><span class=\"n\">hn_succ_pos</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">dif_neg</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">f_one_is_zero</span><span class=\"w\"> </span><span class=\"n\">hProps</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">f_def_alt</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp_dist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsProbDist</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">uniformDist_IsProbDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span>\n\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp_len_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nk_pos</span><span class=\"o\">]</span>\n\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Use generic 0</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'_dist</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">IsProbDist</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">constructor</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"n\">hpi_mem</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_append</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hpi_mem</span>\n<span class=\"w\">        </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hpi_mem</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hp_dist</span><span class=\"bp\">.</span><span class=\"m\">1</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span><span class=\"n\">hp</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_singleton</span><span class=\"bp\">.</span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c1\">-- 0 ≥ 0</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">sum_append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">sum_singleton</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hp_dist</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">norm_num</span><span class=\"w\"> </span><span class=\"c1\">-- 1 + 0 = 1</span>\n\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'_len_val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'_len_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp'_len_val</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">positivity</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Apply Prop 5</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_p'_le_unif</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">      </span><span class=\"n\">hProps</span><span class=\"bp\">.</span><span class=\"n\">prop5</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"n\">hp'_dist</span><span class=\"w\"> </span><span class=\"n\">hp'_len_pos</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp'_len_val</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_p'_le_unif</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Apply Prop 2 - Ensure predicate matches EXACTLY</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_p'_eq_filter</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hProps</span><span class=\"bp\">.</span><span class=\"n\">prop2</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"n\">hp'_dist</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Show filter p' (&gt;0) = p using helper lemmas</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_filter_eq_p</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) (p ++ [0]) = p</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_append</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p ++ filter (...) [0] = p</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Use convert_to for robustness</span>\n<span class=\"w\">      </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">      </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_singleton_zero</span><span class=\"w\"> </span><span class=\"c1\">-- Prove filter (...) [0] = []</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">append_nil</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p = p</span>\n<span class=\"w\">      </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: p = p</span>\n\n<span class=\"w\">    </span><span class=\"c1\">-- Combine</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h_p'_eq_Hp</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_p'_eq_filter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">h_filter_eq_p</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h_p'_eq_Hp</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h_p'_le_unif</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">h_p'_le_unif</span>\n\n<span class=\"c1\">-- ....</span>\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">RotaEntropyProof</span>\n</code></pre></div>",
        "id": 515098398,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745940944
    },
    {
        "content": "<blockquote>\n<p>In hopes of giving you well structured questions I'm enlisting an LLM to help me write questions up from here</p>\n</blockquote>\n<p>I don't think this is necessary. The actual context you need to provide along with questions (e.g. code blocks) should be written by you alone, and the grammar around that does not need to be polished (and LLMs tend to generate unnecessarily long posts with low signal to noise ratio). Unless you have serious difficulties writing in english I would suggest just asking questions au naturel</p>",
        "id": 515099175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745941154
    },
    {
        "content": "<p>in particular, when something is wrong, it can be difficult to tell the difference between your mistake and the LLM's mistake</p>",
        "id": 515099508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745941243
    },
    {
        "content": "<p>There is an instance of this in your post:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">PartitionTheoryDefs</span><span class=\"w\"> </span><span class=\"c1\">-- Assuming this file is available</span>\n</code></pre></div>\n<p>This makes the code example not an MWE. Is this line written by you or hallucinated?</p>",
        "id": 515100355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745941451
    },
    {
        "content": "<p>To add to this: recently, there have been a number of low-effort questions asked --- where somebody would (seemingly) copy-paste LLM output without understanding or thinking about it. This makes a number of people rather cautious with LLM-written posts and reconsider responding. If you write in your own words, you avoid this trap.</p>",
        "id": 515100676,
        "sender_full_name": "Michael Rothgang",
        "timestamp": 1745941545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"619540\">Johannes Tantow</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/515008512\">said</a>:</p>\n<blockquote>\n<p>On what page is Rotas entropy theorem stated in the book. At the linked page (367) there is no theorem</p>\n</blockquote>\n<p>Rota's Entropy Theorem doesn't actually have a name in the book - I gave it that moniker in lieu of the following: Most of Chapter 7 constitutes a proof culminating on p. 382 that any function displaying the 5 properties Rota describes is an entropy function which is mathematically equivalent to scaled Shannon Entropy. The preceding chapters 1-6 show that all the \"interesting distributions\" of nature have those properties. p. 383 gives the computability consequence since in Information Theory, Shannon's Coding Theorem gives the computability of any function displaying Shannon Entropy - as explained by Rota, Shannon's Coding Theorem demands that there is a yes/no series of questions (which can be encoded in boolean gates) that give an O(n log n) encoding, but, as also explained by Rota, finding that encoding can be \"highly non-trivial.\"</p>",
        "id": 515101848,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745941851
    },
    {
        "content": "<p>Here's a better MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Real</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Analysis</span><span class=\"bp\">.</span><span class=\"n\">SpecialFunctions</span><span class=\"bp\">.</span><span class=\"n\">Log</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">Rat</span><span class=\"bp\">.</span><span class=\"n\">Defs</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Data</span><span class=\"bp\">.</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">Basic</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">List</span>\n\n<span class=\"c1\">-- Simplified uniformDist for MWE</span>\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">replicate</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">simp</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- Helper: filter (fun x : Real =&gt; decide (x &gt; 0)) on [0] is []. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_singleton_zero</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">gt_iff_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_false_iff_not</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lt_irrefl</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">)]</span>\n\n<span class=\"sd\">/-- Helper: filter (fun x : Real =&gt; decide (x &gt; 0)) on uniformDist n is identity for n &gt; 0. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">filter_eq_self</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">uniformDist</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">not_lt_zero</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mem_replicate</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨_</span><span class=\"n\">hnz</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">hx_eq</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hx_mem</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hx_eq</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">decide_eq_true_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: 1 / (↑k + 1) &gt; 0</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span><span class=\"w\"> </span><span class=\"c1\">-- Should solve the goal directly</span>\n\n<span class=\"c1\">-- === Main Proof for f_non_decreasing ===</span>\n\n<span class=\"sd\">/-- Lemma: f is non-decreasing. Follows from Properties 2 and 5. -/</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">f_non_decreasing</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">succ_pos</span><span class=\"w\"> </span><span class=\"n\">k</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp_len_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Use generic 0</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'_len_val</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">hp'_len_pos</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">hp'_len_val</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">positivity</span>\n\n<span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) (p ++ [0]) = p</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_append</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p ++ filter (...) [0] = p</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Use convert_to for robustness</span>\n<span class=\"w\">  </span><span class=\"n\">convert_to</span><span class=\"w\"> </span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">filter_decide_gt_zero_singleton_zero</span><span class=\"w\"> </span><span class=\"c1\">-- Prove filter (...) [0] = []</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">append_nil</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: filter (...) p = p</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">filter_decide_gt_zero_uniformDist_eq_self</span><span class=\"w\"> </span><span class=\"n\">nk_pos</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- Goal: p = p</span>\n</code></pre></div>",
        "id": 515102483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942013
    },
    {
        "content": "<p>and here's a proof of the main goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">p'</span><span class=\"bp\">.</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">decide</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">trivial</span>\n\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">filter_append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">uniformDist</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 515103073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942182
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/515100355\">said</a>:</p>\n<blockquote>\n<p>There is an instance of this in your post:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">PprobablyEqualsNP</span><span class=\"bp\">.</span><span class=\"n\">PartitionTheoryDefs</span><span class=\"w\"> </span><span class=\"c1\">-- Assuming this file is available</span>\n</code></pre></div>\n<p>This makes the code example not an MWE. Is this line written by you or hallucinated?</p>\n</blockquote>\n<p>I added that line since I didn't post the file.</p>\n<p>I understand, was aiming for transparency. Hopefully at this point in the thread it's not taken as a low effort post.</p>",
        "id": 515103280,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745942244
    },
    {
        "content": "<p>Note that I removed an <code>open Classical</code>, which is likely causing problems because it is changing the decision procedure used in the filter</p>",
        "id": 515103309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942251
    },
    {
        "content": "<p>You should remove references to your project when constructing a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a></p>",
        "id": 515103480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942292
    },
    {
        "content": "<p>either by inlining everything, or by sorrying everything that is not directly relevant to the question. In the MWE I posted, you will notice that I removed everything to do with <code>EntropyFunction</code> since it's not relevant, and so all the dependencies on the other file went away</p>",
        "id": 515103701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/515103309\">said</a>:</p>\n<blockquote>\n<p>Note that I removed an <code>open Classical</code>, which is likely causing problems because it is changing the decision procedure used in the filter</p>\n</blockquote>\n<p>THANK YOU! I'll pipe this back in and try to digest the Lean idioms a bit more. You've saved me a few weeks at least on my Yak shaving adventure.</p>",
        "id": 515104521,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745942538
    },
    {
        "content": "<p>fun fact, I noticed this because mathlib has a linter which warns whenever you <code>open Classical</code></p>",
        "id": 515104805,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942618
    },
    {
        "content": "<p>because you aren't the only one to be bitten by this</p>",
        "id": 515104868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745942639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Request.20for.20Feedback.3A.20Lean.204.20Proof.20related.20to.20P.3DNP/near/515104805\">said</a>:</p>\n<blockquote>\n<p>fun fact, I noticed this because mathlib has a linter which warns whenever you <code>open Classical</code></p>\n</blockquote>\n<p>I would have been trying to find that forever.</p>",
        "id": 515106749,
        "sender_full_name": "Essam Abadir",
        "timestamp": 1745943154
    }
]