[
    {
        "content": "<p>Hi everyone,</p>\n<p>I'm the author of <a href=\"https://github.com/pandaman64/lean-regex\">lean-regex</a>, a library that brings regular expression searches to Lean <strong>and</strong> verifies their correctness. Recently, I've been thinking about how to formalize and verify the correctness of regex searches with capture groups and thought this problem might interest the community as well. While I don't have specific questions yet, I would appreciate any thoughts, suggestions, or references on this topic.</p>",
        "id": 456280249,
        "sender_full_name": "pandaman",
        "timestamp": 1722754150
    },
    {
        "content": "<p>Capture groups introduce new kinds of complexities to the semantics of regular expressions, which are not typically covered in textbook. In particular:</p>\n<ol>\n<li>The regex semantics need to track these positions as an \"output\" of the predicate.</li>\n<li>Capture groups require tracking positions in the original string, which is not very compositional but a global property.</li>\n</ol>\n<p>To address this, I developed <a href=\"https://github.com/pandaman64/lean-regex/blob/13049ae3b7edf70a874daa177739e140ccc9963f/RegexCorrectness/Semantics/Expr/Captures.lean\">an Expr.captures semantics</a>. I was able to prove a correspondence between this new semantics and the existing semantics without capture groups, which I verified for correctness before. So I believe this is a good starting point for further verification using this semantics.</p>",
        "id": 456280269,
        "sender_full_name": "pandaman",
        "timestamp": 1722754174
    },
    {
        "content": "<p>The regex implementation utilizes NFA (Non-deterministic Finite Automaton) under the hood. So, the next step is to formalize the semantics of capture groups in terms of transitions within the compiled NFA. For example, a regex <code>(e)ₙ</code> (which means <code>n</code>'th capture group wrapping <code>e</code>) is compiled to NFA as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">save</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">save</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span>\n</code></pre></div>\n<p><code>.save</code> is a state that saves the current position in the string, with two <code>.save</code> states recording the start and end positions. The challenge is that the NFA semantics need to handle mutations made by the <code>.save</code> states. I'm wondering whether Separation Logic could help manage this.</p>",
        "id": 456280346,
        "sender_full_name": "pandaman",
        "timestamp": 1722754233
    },
    {
        "content": "<p>Moreover, <a href=\"https://github.com/pandaman64/lean-regex/blob/13049ae3b7edf70a874daa177739e140ccc9963f/Regex/Data/Expr.lean\">my regex definition</a> allows assigning the same <code>n</code> to different parts of the regex, and when verifying the correctness of the NFA semantics, I would need to constrain the regexes to those that don't have such conflicts. What I'm thinking of is using Separation Logic like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"c1\">-- `owns e` means the set of capture groups owned by `e` (without overlaps)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">SepProp</span>\n<span class=\"c1\">-- example</span>\n<span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">concat</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"w\"> </span><span class=\"n\">e₂</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"n\">e₁</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"n\">e₂</span>\n<span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">group</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">n</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">owns</span><span class=\"w\"> </span><span class=\"n\">e</span>\n</code></pre></div>\n<p>I haven't used Separation Logic before, so I'm unsure if this approach is feasible or how to integrate it with Lean. I definitely need to learn more about it and would greatly appreciate your feedback.</p>",
        "id": 456280538,
        "sender_full_name": "pandaman",
        "timestamp": 1722754408
    },
    {
        "content": "<p>First of all, very cool project!</p>\n<p>Secondly, maybe some questions about the Separation Logic part, because I do not quite understand it yet and they may help with the discussion:</p>\n<ul>\n<li>Why does <code>owns</code> have this type? I would have expected something like <code>Expr → Set Nat → Prop</code> --- where you could also call <code>Set Nat → Prop</code> just <code>CaptureProp</code> or something like this. <code>Set Nat</code> is then your object to separate --- i.e. the list of positions the expressions captured and disjoint union on sets is the disjoint operator used for the partial commutatitive monoid. But I am unsure what the <code>Nat</code> is supposed to do?</li>\n<li>I am not sure that Separation Logic is particular useful for <em>mutation</em>, but it is useful for <em>framing</em> --- that is beeing able to ignore certain parts of your object under only mild side-conditions. I am happy for anyone correcting me with this one.</li>\n<li>Separation Logic is usually facilitated in some high-level Prop-transformer semantics. Thus it usually requires you to establish these high-level semantics in the first place. Is that something that is actually worth the effort? For program verification this is useful, as we require new proofs for each program --- thus high-level proofs simplify the process. Do you think something similar also holds for your capture groups? Or how do you actually planned to facilitate Separation Logic?</li>\n</ul>",
        "id": 456472891,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1722845297
    },
    {
        "content": "<p>Hi. Thank you for sharing your thoughts and questions!</p>\n<blockquote>\n<ul>\n<li>Why does <code>owns</code> have this type? I would have expected something like <code>Expr → Set Nat → Prop</code> --- where you could also call <code>Set Nat → Prop</code> just <code>CaptureProp</code> or something like this. <code>Set Nat</code> is then your object to separate --- i.e. the list of positions the expressions captured and disjoint union on sets is the disjoint operator used for the partial commutatitive monoid. But I am unsure what the <code>Nat</code> is supposed to do?</li>\n</ul>\n</blockquote>\n<p><code>Nat</code> corresponds to the indices of capture groups, so if we have a regex like <code>(ab)c(def)</code>, <code>(ab)</code> owns <code>{1}</code> and <code>(def)</code> owns <code>{2}</code> (<code>0</code> is owned by the entire regex). And yeah, I'm not sure how exactly this stuff will be represented using SL. Thank you for the suggestion!</p>\n<blockquote>\n<ul>\n<li>I am not sure that Separation Logic is particular useful for <em>mutation</em>, but it is useful for <em>framing</em> --- that is beeing able to ignore certain parts of your object under only mild side-conditions. I am happy for anyone correcting me with this one.</li>\n</ul>\n</blockquote>\n<p>I think you are right and I could have explained a bit better why I want framing. My regex search implementation will keep track of positions inside the haystack for each capture groups the search has encountered. So for example, when reasoning about the search for regex <code>(e)</code>, the search for the inner regex <code>e</code> shouldn't affect the positions tracked by the outer capture group, which I think framing would shine.</p>\n<blockquote>\n<ul>\n<li>Separation Logic is usually facilitated in some high-level Prop-transformer semantics. Thus it usually requires you to establish these high-level semantics in the first place. Is that something that is actually worth the effort? For program verification this is useful, as we require new proofs for each program --- thus high-level proofs simplify the process. Do you think something similar also holds for your capture groups? Or how do you actually planned to facilitate Separation Logic?</li>\n</ul>\n</blockquote>\n<p>My ultimate goal is to prove <a href=\"https://github.com/pandaman64/lean-regex/blob/19af0d0a8e57375725032ed2eb3a4f25fc290cc8/Regex/VM/Basic.lean#L123\">my regex search function</a> is correct. It should return <code>.some</code> if and only if there is a match in the string and the returned capture groups should store the corresponding positions. I'll need to develop a theory about capture groups that will be used during the program verification, and that's why I started looking into Separation Logic.</p>",
        "id": 456507978,
        "sender_full_name": "pandaman",
        "timestamp": 1722854370
    },
    {
        "content": "<p>Possibly related: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3632934\">semantics and efficient implementation of regexes with lookaround operators</a>.</p>",
        "id": 456536525,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1722862283
    },
    {
        "content": "<p>That sounds indeed more reasonable and also exciting!<br>\nIf you are not aware, Lean offers an ITP for Separation Logic here: <a href=\"https://github.com/leanprover-community/iris-lean\">https://github.com/leanprover-community/iris-lean</a><br>\nDespite its name, it currently features mostly MoSEL functionalities and not Iris, but can be nice to have when proving theorems in a Separation Logic on (a subset of) the given BI structure there.</p>",
        "id": 456582304,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1722867719
    },
    {
        "content": "<p>I often want to use regex's in Lean, so thanks for this. I just had a request on a practical point - can you tag a version with each stable lean toolchain?</p>",
        "id": 456782147,
        "sender_full_name": "Siddhartha Gadgil",
        "timestamp": 1722927368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266304\">@Siddhartha Gadgil</span> Hi. I added v4.10.0 tag and will add tags for later versions. Thank you the suggestion.</p>",
        "id": 459641866,
        "sender_full_name": "pandaman",
        "timestamp": 1723269396
    },
    {
        "content": "<p>I have been thinking about how to formalize the NFA matching. In my previous verification attempt, the behavior is formalized in terms of graphs. For example, I defined a predicate that represents <a href=\"https://github.com/pandaman64/lean-regex/blob/19af0d0a8e57375725032ed2eb3a4f25fc290cc8/RegexCorrectness/NFA/Transition/Path/Basic.lean#L79\">a path in the NFA</a>. However, extending these graph concepts with capture groups seem too complicated to carry.</p>\n<p>My NFA complilation is heavily based on <a href=\"https://swtch.com/~rsc/regexp/\">Russ Cox's famous regex articles</a>, and each state of an NFA can be regarded as <a href=\"https://github.com/pandaman64/lean-regex/blob/19af0d0a8e57375725032ed2eb3a4f25fc290cc8/Regex/NFA/Basic.lean#L5\">an instruction of a virtual machine</a>. So I realized that we can define an operational semantics for the virtual machine as an imperative language with side effects to arrays (corresponding to capture groups) instead of using the vocabulary from graph theory. Moreover, reasoning about the NFAs as programs can be carried using Separation Logic as the axiomatic semantics, which feels a good fit to me.</p>",
        "id": 459644619,
        "sender_full_name": "pandaman",
        "timestamp": 1723270871
    },
    {
        "content": "<p>I guess my next step is to read <a href=\"https://softwarefoundations.cis.upenn.edu/slf-current/index.html\">\"Separation Logic Foundations\"</a> and consider if we can port it to Lean (with iris-lean or whatever)</p>",
        "id": 459645421,
        "sender_full_name": "pandaman",
        "timestamp": 1723271229
    },
    {
        "content": "<p>When defining the operational semantics, keep in mind that they should satisfy a certain framing condition. For example, in heap-manipulating programs, (non-symbolic) deterministic allocation doesn't satisfy the framing condition. That's why you always see a non-deterministic (or a symbolic) allocation when using separation logic.</p>",
        "id": 459646441,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1723271674
    },
    {
        "content": "<p>Interesting. I don't think the operational semantics is going to have dynamic allocations. Rather, it will operate on an array with fixed size (each cell corresponding to start/end positions of capture groups)</p>",
        "id": 459646692,
        "sender_full_name": "pandaman",
        "timestamp": 1723271978
    },
    {
        "content": "<p>Maybe it's more like assigining to variables <code>s1, e1, s2, e2, ...</code>.</p>",
        "id": 459646784,
        "sender_full_name": "pandaman",
        "timestamp": 1723272025
    },
    {
        "content": "<p>I don't know how this will translate. It is something I stumbled upon during the last years while defining operational semantics myself and considering eliminating non-determinism for different reasons. After failing I got more sensitive to this problem.</p>",
        "id": 459647022,
        "sender_full_name": "Ira Fesefeldt",
        "timestamp": 1723272315
    },
    {
        "content": "<p>That's a very cool project!! Potentially interesting: <a href=\"https://dl.acm.org/doi/abs/10.1145/3591287\">https://dl.acm.org/doi/abs/10.1145/3591287</a></p>",
        "id": 459834517,
        "sender_full_name": "Luisa Cicolini",
        "timestamp": 1723357506
    }
]