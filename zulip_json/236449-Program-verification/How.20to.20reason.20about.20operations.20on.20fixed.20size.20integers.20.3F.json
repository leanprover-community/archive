[
    {
        "content": "<p>Apologies if this is stupid, but I haven't managed to find the proper lemmas to reason about fixed size integers.</p>\n<p>As an exercise to teach myself more about Lean, I'm trying to prove the correctness of the (refined) Barrett reduction algorithm that is used in recent post quantum cryptography implementations.</p>\n<p>I have proved the correctness for an implementation on <code>Int</code> given some bounds on the input, and now I want to prove the correctness for an implementation on <code>Int16</code> which satisfies the range constraint by definition, but I don't see how to prove its correctness.</p>\n<p>Any advice on how to proceed?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mod_approx</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℚ</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">N</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">/</span><span class=\"n\">N</span><span class=\"o\">))</span>\n\n<span class=\"kn\">notation</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"s2\">\"mod±\"</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">mod_approx</span><span class=\"w\"> </span><span class=\"n\">round</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mlkem_barrett_reduce</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">3329</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(((</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">20159</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"o\">))</span><span class=\"bp\">/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">26</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- proof elided for space</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">mlkem_barrett_reduce_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Hx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"n\">mlkem_barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">mod</span><span class=\"bp\">±</span><span class=\"w\"> </span><span class=\"mi\">3329</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"c\">/-</span>\n<span class=\"cm\">https://github.com/pq-crystals/kyber/blob/main/ref/reduce.c</span>\n<span class=\"cm\">int16_t barrett_reduce(int16_t a) {</span>\n<span class=\"cm\">  int16_t t;</span>\n<span class=\"cm\">  const int16_t v = ((1&lt;&lt;26) + KYBER_Q/2)/KYBER_Q;</span>\n\n<span class=\"cm\">  t  = ((int32_t)v*a + (1&lt;&lt;25)) &gt;&gt; 26;</span>\n<span class=\"cm\">  t *= KYBER_Q;</span>\n<span class=\"cm\">  return a - t;</span>\n<span class=\"cm\">}</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mlkem_barrett_reduce_impl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int32</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toInt32</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">20159</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&lt;&lt;&lt;</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"mi\">26</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3329</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">toInt16</span>\n<span class=\"w\">  </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">mlkem_barrett_reduce_impl_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"n\">mlkem_barrett_reduce_impl</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"bp\">.</span><span class=\"n\">ofInt</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">Int16</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">mod</span><span class=\"bp\">±</span><span class=\"w\"> </span><span class=\"mi\">3329</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mlkem_barrett_reduce_correct</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Int16</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)]</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 496817281,
        "sender_full_name": "Alix Trieu",
        "timestamp": 1738254168
    },
    {
        "content": "<p>I think <code>omega</code> should handle some of these, but especially the ones you have in the end are ideal for <code>bv_decide</code></p>",
        "id": 496827660,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1738257083
    },
    {
        "content": "<p>(see <a href=\"https://lean-lang.org/blog/2024-10-3-lean-4120/\">https://lean-lang.org/blog/2024-10-3-lean-4120/</a>)</p>",
        "id": 496827749,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1738257120
    },
    {
        "content": "<p>(you'll have to phrase this in terms of <code>BitVec</code>s, but <code>Int32</code> and <code>Int16</code> should be the same)</p>",
        "id": 496827875,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1738257156
    },
    {
        "content": "<p>There is going to be native support for IntX and UIntX in bv_decide by the end of this quarter, the current nightlies already know how to reason about UIntX with bv_decide. Though one operation that's going to mess this up is the <code>mod_approx</code> function as <code>bv_decide</code> has no way to reason about it</p>",
        "id": 496828029,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1738257207
    },
    {
        "content": "<p>Thanks for the answers, I have tried using <code>bv_decide</code>, but I haven't managed to understand how to transform goals in a way <code>bv_decide</code> can do something. For instance, how should I phrase the following statement so that it works ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int16</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">Hmax</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">isLt</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">Hmax</span>\n<span class=\"w\">  </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">lt_or_le</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">Hlt</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_neg_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">Hlt</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">Hlo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"mi\">32768</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_eq_toNat_bmod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">bmod</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">emod_eq_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">abs_of_neg</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">Hle</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_pos_iff</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">Hle</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">Hlo</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">32768</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt_eq_toNat_bmod</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">bmod</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">emod_eq_of_lt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">omega</span><span class=\"o\">)]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">abs_of_nonneg</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 496980456,
        "sender_full_name": "Alix Trieu",
        "timestamp": 1738320976
    },
    {
        "content": "<p>I think one thing that complicates this is that this isn't a comparison between two BitVecs, but an Int and Int and I didn't manage it to force it to be a direct comparison between BitVecs, but I did manage this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">^</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">abs_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int16</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>\n<p>I'm not sure what the right solution from the BitVec API here is, maybe there should be a good way to reason about comparisons with numbers that aren't BitVecs, maybe I'm just not aware of it.</p>",
        "id": 497021751,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1738334402
    },
    {
        "content": "<p>To answer the question of how to phrase it, here is a trivial example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">255</span><span class=\"bp\">#</span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">bv_decide</span>\n</code></pre></div>\n<p>There is the sharp edge that <code>&lt; 256</code> silently truncates to <code>&lt; 0#8</code>. Dealing with signed ints is a bit more complicated, since BitVec thinks signedness is really just a special rule for how to convert a BitVec represented as an unsigned int to a signed int, which you can see in the if statement after the <code>rw</code> here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">BitVec</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">128</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">toInt</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">omega</span>\n</code></pre></div>",
        "id": 497024255,
        "sender_full_name": "Vlad Tsyrklevich",
        "timestamp": 1738335130
    }
]