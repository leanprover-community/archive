[
    {
        "content": "<p>Has anyone done much work on <em>automated</em> conversion of code that one would like to prove something about, from a conventional programming language (today I happen to care about C, but it could easily be Python tomorrow, or Fortran, or ...), to Lean?  Or any other proof-assistant language for that matter?</p>\n<p>Part of why I have been having so much trouble with my 'proving equivalence of two versions of a function' project turns out to have been that I did the initial conversion from C to Lean wrong, and in general that seems like it's always going to be a place where it's really easy for errors to slip in.</p>",
        "id": 518138664,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747249003
    },
    {
        "content": "<p>If you want to prove something about C code, rewriting it to rust often recommended.<br>\n<span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> ' Aenaes converts rust to lean.<br>\nOne could also use <a href=\"https://hax.cryspen.com/publications/\">https://hax.cryspen.com/publications/</a> (for F* and Rocq, Lean is often requested and would be feasible).</p>",
        "id": 518140189,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1747249528
    },
    {
        "content": "<p>Thanks for the mention <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> : <a href=\"https://github.com/AeneasVerif/aeneas\">Aeneas</a> indeed allows to compile (a subset of) safe Rust programs to pure models in Lean, and comes with a Lean library to reason about those. It's still very much work in progress as there are many missing features but there is enough to reason about non trivial programs (we have verified standard data structures such as a hashmap and an AVL tree, and are currently verifying cryptographic code).</p>",
        "id": 518239832,
        "sender_full_name": "Son Ho",
        "timestamp": 1747298187
    },
    {
        "content": "<p>id be interested in hearing more about the cryptographic code. what kinds of things specifically?</p>",
        "id": 518332556,
        "sender_full_name": "Tanner Duve",
        "timestamp": 1747321974
    },
    {
        "content": "<p>We provide the libcrux library, which includes many efficient verified cryptographic implementations:<br>\n<a href=\"https://github.com/cryspen/libcrux\">https://github.com/cryspen/libcrux</a><br>\nLibcrux was introduced here: <a href=\"https://github.com/hacspec/hacspec/blob/master/rwc2023-abstract.pdf\">https://github.com/hacspec/hacspec/blob/master/rwc2023-abstract.pdf</a></p>",
        "id": 518333840,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1747322274
    },
    {
        "content": "<p>On Aeneas' side we are currently verifying an implementation of ML-KEM for the SymCrypt library (the cryptographic library of Windows): <a href=\"https://csrc.nist.gov/pubs/fips/203/ipd\">https://csrc.nist.gov/pubs/fips/203/ipd</a><br>\nThis is a post-quantum key encapsulation mechanism, and totals around 2k lines of Rust code. The code (and the proofs) is not public yet, but will be at some point.</p>",
        "id": 518334361,
        "sender_full_name": "Son Ho",
        "timestamp": 1747322394
    },
    {
        "content": "<p>Aeneas does look like the general kind of thing I want.  However, converting code from C to Rust manually can be error-prone as well, and in my case I couldn't leave the C version behind after doing correctness proofs on the Rust version.</p>",
        "id": 518336111,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747322774
    },
    {
        "content": "<p>On our side we also have the problem of porting C to Rust, verifying the Rust code, and preserving an equivalent version of the C code: we are progressively moving the SymCrypt library (written in C) to Rust, but we still need to provide C implementations for legacy reasons (some users of SymCrypt can't compile Rust code for instance).<br>\nThe ML-KEM implementation was originally implemented in C and manually ported to Rust (we mostly used macros, but there <em>were</em> mistakes in the port, for instance because we used the plain Rust addition in places where we should have used <code>wrapping_add</code> - those mistakes were caught either through testing or verification). Since then, we've had some success by using the <a href=\"https://github.com/AeneasVerif/scylla\">Scylla</a> tool to port C code to Rust code. This tool is very experimental and mostly targets cryptographic code, but we've had quite promising preliminary results. When it comes to providing C code to our clients, we actually compile the Rust code back to C with <a href=\"https://github.com/AeneasVerif/eurydice\">Eurydice</a>. Eurydice is designed to produce clean, readable C code.</p>\n<p>So, (yes, that's a lot of tools), the workflow is basically:</p>\n<ul>\n<li>port C to Rust either manually or with Scylla. This is one shot: once the port is done we can discard the original C code, and we only maintain the Rust code.</li>\n<li>verify the Rust code with Aeneas</li>\n<li>generate an equivalent C version of the Rust code with the Eurydice compiler (we regenerate the C code every time the Rust code is modified, and commit the changes)</li>\n</ul>",
        "id": 518337790,
        "sender_full_name": "Son Ho",
        "timestamp": 1747323171
    },
    {
        "content": "<p>(about Scylla, here is a preprint: <a href=\"https://arxiv.org/pdf/2412.15042\">https://arxiv.org/pdf/2412.15042</a>)</p>",
        "id": 518338378,
        "sender_full_name": "Son Ho",
        "timestamp": 1747323304
    }
]