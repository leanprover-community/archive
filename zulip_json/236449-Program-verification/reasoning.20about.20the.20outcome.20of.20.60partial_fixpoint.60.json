[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> <span class=\"user-mention\" data-user-id=\"436568\">@Josh Clune</span> <span class=\"user-mention\" data-user-id=\"927230\">@Michael Naehrig</span> and I are looking at <code>partial_fixpoint</code>... does <code>partial_fixpoint</code> expose an induction principle that would allow reasoning about the terminating case without necessarily proving properties about the divergent case? we can provide a minimal example if that helps... <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> pinging you as the author of partial_fixpoint</p>",
        "id": 527730149,
        "sender_full_name": "Jonathan Protzenko",
        "timestamp": 1751991282
    },
    {
        "content": "<p>I don't think there's anything builtin but you can pretty easily make your own inductive predicate to prove things with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">partial_fixpoint</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom_two_mul_natCast</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"bp\">.</span><span class=\"n\">case1</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"bp\">.</span><span class=\"n\">case2</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">omega</span>\n<span class=\"w\">    </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simpa</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">mul_add</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">using</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">le_myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case1</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">case2</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">h'</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">myFn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">if_neg</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">le_of_lt</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">le_myFn</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">dom_two_mul_natCast</span>\n</code></pre></div>",
        "id": 527748610,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1751997878
    },
    {
        "content": "<p>If you use a monad you also get a partial correctness theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">partial_fixpoint</span>\n\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">partial_correctness</span>\n</code></pre></div>",
        "id": 527749803,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751998351
    },
    {
        "content": "<p>After staring at the type of <code>myFn.partial_correctness</code> for a while, this looks like it might be what you want.</p>",
        "id": 527750891,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1751998742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"816344\">Aaron Liu</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/527750891\">said</a>:</p>\n<blockquote>\n<p>After staring at the type of <code>myFn.partial_correctness</code> for a while, this looks like it might be what you want.</p>\n</blockquote>\n<p>Yes, this looks exactly like what we need, thanks!<br>\nHere is a minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> `flip` models a random tape -/</span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">flipCoin</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">flipCoin</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">partial_fixpoint</span>\n\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">flipCoin_thm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">flipCoin</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">flipCoin.partial_correctness</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">intros</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"n\">hi</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">  </span><span class=\"n\">split</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">hi</span>\n</code></pre></div>",
        "id": 527763077,
        "sender_full_name": "Son Ho",
        "timestamp": 1752004328
    },
    {
        "content": "<p>I think the hive mind answered the questions already, but I don’t want to appear as if I'm not taking care of my users:</p>\n<p>For <em>every</em> <code>partial_fixpoint</code> definition you get a fixpoint induction principle (<code>.fixpoint_induct</code>). This is likely only useful and of interest if you have defined your own <code>CCPO</code> (e.g. when <a href=\"https://github.com/leanprover/lean4/blob/master/tests/lean/run/partial_fixpoint_probability.lean\">defining probability distributions recursively</a>)</p>\n<p>For those <code>partial_fixpoint</code> definitions that produce an <code>Option</code> you get a <code>partial_correctness</code> theorem (derived from the <code>fixpoint_induct</code> theorem). It allows you to prove statements of the form “if the function, given arguments <code>x</code>, <code>y</code>… returns successfully with result <code>r</code> , then some predicate holds for <code>x</code>,<code>y</code>,<code>z</code>.</p>\n<p>(This could be generalized to other result types possibly, let me know if you run into this.)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">partial_fixpoint</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: myFn.fixpoint_induct (motive : (Int → Int → Option Int) → Prop) (adm : Lean.Order.admissible motive)</span>\n<span class=\"sd\">  (h :</span>\n<span class=\"sd\">    ∀ (myFn : Int → Int → Option Int), motive myFn → motive fun a b =&gt; if a = 0 then some b else myFn (a - 2) (b + 1)) :</span>\n<span class=\"sd\">  motive myFn</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">fixpoint_induct</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">info: myFn.partial_correctness (motive : Int → Int → Int → Prop)</span>\n<span class=\"sd\">  (h :</span>\n<span class=\"sd\">    ∀ (myFn : Int → Int → Option Int),</span>\n<span class=\"sd\">      (∀ (a b r : Int), myFn a b = some r → motive a b r) →</span>\n<span class=\"sd\">        ∀ (a b r : Int), (if a = 0 then some b else myFn (a - 2) (b + 1)) = some r → motive a b r)</span>\n<span class=\"sd\">  (a b r✝ : Int) : myFn a b = some r✝ → motive a b r✝</span>\n<span class=\"sd\">-/</span>\n<span class=\"bp\">#</span><span class=\"n\">guard_msgs</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"bp\">#</span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">myFn</span><span class=\"bp\">.</span><span class=\"n\">partial_correctness</span>\n</code></pre></div>",
        "id": 528040376,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1752140689
    },
    {
        "content": "<p>And I know it’s not what people are used to yet, but the reference manual even talks about it:<br>\n<a href=\"https://lean-lang.org/doc/reference/latest/Definitions/Recursive-Definitions/#partial-correctness-theorem\">https://lean-lang.org/doc/reference/latest/Definitions/Recursive-Definitions/#partial-correctness-theorem</a></p>",
        "id": 528040424,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1752140701
    },
    {
        "content": "<p>This looks very cool. Where does this partial_correctness theorem come from? Is that something that the partial_fixpoint implementation hardcodes for option or can I have a custom partial_correctness theorem for my custom monad?</p>",
        "id": 528054592,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1752145230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/528040376\">said</a>:</p>\n<blockquote>\n<p>(This could be generalized to other result types possibly, let me know if you run into this.)</p>\n</blockquote>\n<p>I would love to be able to do this. For instance I have a type :</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">div</span>\n</code></pre></div>\n<p>where <code>div</code> is the default value used for the divergent case. I would like to be able to derive a partial correctness theorem for the <code>ok</code> and <code>fail</code> cases.</p>",
        "id": 528072385,
        "sender_full_name": "Son Ho",
        "timestamp": 1752151054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/528054592\">schrieb</a>:</p>\n<blockquote>\n<p>This looks very cool. Where does this partial_correctness theorem come from? Is that something that the partial_fixpoint implementation hardcodes for option or can I have a custom partial_correctness theorem for my custom monad?</p>\n</blockquote>\n<p>It's currently hardcoded</p>",
        "id": 528127342,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1752167469
    },
    {
        "content": "<p>Looking at <a href=\"https://github.com/leanprover/lean4/blob/338456e765807b088f44b1205a7743a215e331a1/src/Lean/Elab/PreDefinition/PartialFixpoint/Induction.lean#L304\">https://github.com/leanprover/lean4/blob/338456e765807b088f44b1205a7743a215e331a1/src/Lean/Elab/PreDefinition/PartialFixpoint/Induction.lean#L304</a> you can try to define your <code>Result a := Option (a + Unit)</code> and make the CCPO instance defeq to the one from option. Maybe that's sufficient already? (Although maybe the code above needs to replace isAppOfArity with defeq checks for that to work).</p>",
        "id": 528128170,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1752167829
    },
    {
        "content": "<p>It actually doesn't work because the order instance of <code>Result</code> is not equivalent to the order instance of <code>Option (a + Unit)</code> (if a computation evaluates to <code>fail</code>, we need to abort). But I note that the <code>partial_correctness</code> theorems are actually derived from the quite general <code>fixpoint_induct</code> theorems, which are all we need: it is enough to instantiate <code>fixpoint_induct</code> with the proper motive, and proving that this motive is admissible is straightforward with the following theorem (inspired by <code>Option.admissible_eq_some</code>) :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">Result.admissible_neq_div</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">Lean.Order.admissible</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Lean.Order.admissible_flatOrder</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"n\">contextual</span>\n</code></pre></div>\n<p>In particular, I managed to wrote the following version of <code>flipCoin</code> which uses the <code>Result</code> type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span>\n<span class=\"n\">partial_fixpoint</span>\n</code></pre></div>\n<p>and prove the corresponding partial correctness theorem:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"bp\">.</span><span class=\"n\">partial_correctness</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">        </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">),</span>\n<span class=\"w\">          </span><span class=\"o\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">flipCoin'</span><span class=\"w\"> </span><span class=\"n\">flip</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">motive</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">r</span>\n</code></pre></div>\n<p>I'm going to define an attribute to automatically generate this kind of theorems for partial functions defined with the <code>Result</code> type, and it will be enough for my use case.</p>",
        "id": 528171110,
        "sender_full_name": "Son Ho",
        "timestamp": 1752188580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/528171110\">said</a>:</p>\n<blockquote>\n<p>(if a computation evaluates to <code>fail</code>, we need to abort)</p>\n</blockquote>\n<p>Does this impact the order instance?</p>",
        "id": 528171312,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752188684
    },
    {
        "content": "<p>which order are you thinking of?</p>",
        "id": 528171346,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1752188697
    },
    {
        "content": "<p>Sorry, I was confused: it has an impact on the <code>MonoBind</code> instance that is required by the <code>partial_fixpoint</code>.</p>",
        "id": 528171626,
        "sender_full_name": "Son Ho",
        "timestamp": 1752188841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/528171110\">schrieb</a>:</p>\n<blockquote>\n<p>But I note that the <code>partial_correctness</code> theorems are actually derived from the quite general <code>fixpoint_induct</code> theorem</p>\n</blockquote>\n<p>Yes, it’s only a thin convenience wrapper around it, so at least for advanced users (that’s you) it should be possible to use the <code>fixpoint_induct</code> directly. Good to know that that’s actually the case!</p>\n<p>I’d wait wait generalizing this feature in Lean proper until we have more use cases and understand better which kind of Monads and which kind of partial correctness theorems people expect.</p>",
        "id": 528304378,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1752228173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/236449-Program-verification/topic/reasoning.20about.20the.20outcome.20of.20.60partial_fixpoint.60/near/528304378\">said</a>:</p>\n<blockquote>\n<p>I’d wait wait generalizing this feature in Lean proper until we have more use cases and understand better which kind of Monads and which kind of partial correctness theorems people expect.</p>\n</blockquote>\n<p>I think having the <code>fixpoint_induct</code> theorem is already super nice. :)</p>",
        "id": 528653188,
        "sender_full_name": "Son Ho",
        "timestamp": 1752496956
    }
]