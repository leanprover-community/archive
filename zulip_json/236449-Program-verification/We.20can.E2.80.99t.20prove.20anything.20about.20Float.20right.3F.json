[
    {
        "content": "<p>I recently told someone that we canâ€™t prove (or disprove) something as simple as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">float_lt_transitive</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Float</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>in Lean because <code>Float</code> is opaque.  I want to (1) confirm this is correct and (2) check that there are no plans to change this soon.</p>",
        "id": 529870482,
        "sender_full_name": "Jason Rute",
        "timestamp": 1753097312
    },
    {
        "content": "<ol>\n<li>Yes, this is correct.</li>\n<li>See my message at <a class=\"message-link\" href=\"/#narrow/channel/217875-Is-there-code-for-X.3F/topic/Proving.20nan.20.21.3D.20nan/near/499394462\">#Is there code for X? &gt; Proving nan != nan @ ðŸ’¬</a></li>\n</ol>",
        "id": 529871877,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1753097806
    },
    {
        "content": "<p>As a side note: It is my unconsidered opinion that one could proceed by building polymorphic code that depends on common type classes between <code>Real</code> and <code>Float</code>, e.g. <code>Add</code>,<code>Mul</code>, etc and <code>OfScientific</code>, and prove things about the <code>Real</code> instance. But of course, that says nothing about the floating point errors of the <code>Float</code> version.</p>\n<p>Anything more, I think, would require porting a large portion of <a href=\"https://flocq.gitlabpages.inria.fr/\">https://flocq.gitlabpages.inria.fr/</a></p>",
        "id": 541472565,
        "sender_full_name": "Cody Roux",
        "timestamp": 1758810405
    },
    {
        "content": "<p>One could consider exposing Rocq as an external prover (in the sense of lean-smt), and prove the properties using Flocq...</p>",
        "id": 541614914,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758876148
    },
    {
        "content": "<p>Fyi some discussion here: <a class=\"stream-topic\" data-stream-id=\"219941\" href=\"/#narrow/channel/219941-Machine-Learning-for-Theorem-Proving/topic/Artificial.20Algorithms/with/540967667\">#Machine Learning for Theorem Proving &gt; Artificial Algorithms</a> <br>\nA very early stage port of (the easy part of) Flocq is here (<span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span> made further developments ):<br>\n<a href=\"https://github.com/mkaratarakis/HopfieldNet/blob/master/HopfieldNet/floats/Flocqv2.lean\">https://github.com/mkaratarakis/HopfieldNet/blob/master/HopfieldNet/floats/Flocqv2.lean</a></p>",
        "id": 541616962,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1758876846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"779253\">@Matteo Cipollina</span> That's pretty cool! Could you summarize your experience doing the transpilation. What tools/prompts did you use, what worked and what is still hard?</p>",
        "id": 541650999,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758888114
    },
    {
        "content": "<p>If we could only translate the statements from Rocq to Lean, that would already be great progress.</p>",
        "id": 541651194,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1758888164
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/We.20can.E2.80.99t.20prove.20anything.20about.20Float.20right.3F/near/541650999\">ha scritto</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"779253\">Matteo Cipollina</span> That's pretty cool! Could you summarize your experience doing the transpilation. What tools/prompts did you use, what worked and what is still hard?</p>\n</blockquote>\n<p>Thank you :) Indeed  I'd dare claim that it is already possible to semi-automate the porting of Flocq to Lean (a thankless job otherwise), and potentially, with supervision, the porting of Rocq code to Lean.  What I did - after getting familiar with Flocq - and think about various alternative designs, was to create curated API distillate of relevant API in Flocq (and from Flocq's paper and relevant literature, while studying them) and relevant Mathlib API a good port should build on and that I did not want to reduplicate, have these as .md files and then use them as context wherever I needed help to check for myself or for CoPilot to help in the proofs and, most importantly, to provide context to AI helping me regularly, brutally review the code against criteria like accuracy vs Flocq math,  'optimal level of generality', integration with mathlib, insight against Flocq original. With a good blueprint, this orchestration, some care in choosing words, simple short prompts, and some judgment/taste, a lot can be done quite quickly.  Always zero or one-shot. What is hard is to keep up with the theory to decide the correct assumptions for the definitions and theorems statements at each new step, in the subsequent parts.  One reason I've stopped is that I wanted study more and also try to think of a reimplementation rather than porting (to allow a compatible license to mathlib). But actually, I just had no time to continue it in the last months, but I will try to develop it more with <span class=\"user-mention\" data-user-id=\"454183\">@Michail Karatarakis</span> and <span class=\"user-mention\" data-user-id=\"776090\">@GasStationManager</span>, trying to share some more lessons for these general-purpose low-gratification porting :)</p>",
        "id": 541702395,
        "sender_full_name": "Matteo Cipollina",
        "timestamp": 1758902554
    },
    {
        "content": "<p>I'd say this kind of stuff seems like an ethical use of LLMs...</p>",
        "id": 561287016,
        "sender_full_name": "Cody Roux",
        "timestamp": 1764627808
    }
]