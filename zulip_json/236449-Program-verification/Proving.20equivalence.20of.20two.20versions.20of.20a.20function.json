[
    {
        "content": "<p>I have been beating my head against this proof for two weeks now and so I am going to stop asking questions about tiny pieces of it and just drop the whole thing on you and beg for help.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"c1\">-- Conversion factor from seconds to nanoseconds (10⁹)</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span>\n\n<span class=\"c1\">-- The nanoseconds field of a `struct timespec` is guaranteed to be</span>\n<span class=\"c1\">-- in the range 0 ≤ tv_nsec &lt; ONE_S_IN_NS.</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">Nsec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span>\n\n<span class=\"c1\">-- Lean analogue of `struct timespec`.  A Timespec represents an</span>\n<span class=\"c1\">-- interval of time since some unspecified epoch instant.  We seek to</span>\n<span class=\"c1\">-- prove an equivalence between two methods of computing whether the</span>\n<span class=\"c1\">-- *difference* between two Timespec quantities is greater than some</span>\n<span class=\"c1\">-- interval, so we don't care what the epoch actually is.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- In C, the seconds field is a `time_t`, which is normally either a</span>\n<span class=\"c1\">-- 32- or 64-bit signed machine integer.  For our purposes—measuring</span>\n<span class=\"c1\">-- time intervals typically no more than a few tens of seconds—we can</span>\n<span class=\"c1\">-- ignore the possibility of machine integer overflow and model the</span>\n<span class=\"c1\">-- seconds field using Int, i.e. a mathematical integer with unbounded</span>\n<span class=\"c1\">-- range.</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sec</span><span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nsec</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"c1\">-- This function defines the conversion from a Timespec quantity to</span>\n<span class=\"c1\">-- the total number of nanoseconds that have elapsed since that</span>\n<span class=\"c1\">-- Timespec's (unspecified) epoch.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tv</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">tv</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">tv</span><span class=\"bp\">.</span><span class=\"n\">nsec</span>\n\n<span class=\"c1\">-- Version one of the calculation we're interested in.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_mul</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">before</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_ns</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nsec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">min_ns</span>\n\n<span class=\"c1\">-- Version two of the calculation we're interested in.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_cases</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">before</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_ns</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nsec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">min_ns</span><span class=\"w\"> </span><span class=\"bp\">||</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">delta_ns</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">ofNat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"bp\">;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- There is no `|| delta_ns &lt; 0` on this expression because in this</span>\n<span class=\"w\">    </span><span class=\"c1\">-- case delta_ns cannot be negative.</span>\n<span class=\"w\">    </span><span class=\"n\">delta_ns</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">min_ns</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">true</span>\n\n<span class=\"c1\">-- The statement to be proved:</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">timespec_differences_equivalent</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_cases</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_difference_at_least_cases</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_to_ns</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I believe that <code>timespec_difference_at_least_mul</code> and  <code>timespec_difference_at_least_cases</code> are indeed equivalent.  If a counterexample exists, it indicates a bug in <code>timespec_difference_at_least_cases</code>; my larger goal is to have a version of <code>`timespec_difference_at_least_cases</code> (in a conventional programming language) that has no such bugs.</p>\n<p>As you may guess from some of my other posts, I have been able to prove subcases of the equivalence but not in a way that lets me integrate them into a complete proof.  For example, this lemma is valid:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">equivalence_when_equal_seconds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">or</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h₁</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> an &lt; bn ↔ an &lt; bn -/</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">tauto</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">h₂</span><span class=\"w\"> </span><span class=\"c\">/-</span><span class=\"cm\"> m ≤ an - bn ↔ bn + m ≤ an -/</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">mp</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add_le_of_le_sub_left</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">mpr</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">le_sub_left_of_add_le</span>\n</code></pre></div>\n<p>and its statement is <em>approximately</em> what the equivalence above reduces to when <code>after.sec = before.sec</code>, but it doesn't unify because (I think) there are a bunch of type conversions in the way.  And that's where I keep getting stuck.  <code>rewrite</code> and <code>simp</code> <em>sometimes</em> see through type conversions and sometimes don't and I am starting to believe that I have begun in the wrong place somehow.</p>\n<p>Note that the use of <code>Fin</code> expresses something important about the original problem domain that I am reluctant to give up.  For instance, the logic of the <code>after.sec = before.sec + 1</code> case is valid <em>only</em> because <code>Timespec.nsec</code> is always less than <code>ONE_S_IN_NS</code>.  However, possibly there is a more fluent way to specify that than with <code>Fin</code>.</p>",
        "id": 517263346,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746887634
    },
    {
        "content": "<p>You might find it easier here to first write an \"ideal\" implementation of <code>Sub TimeSpec</code> and <code>LE TimeSpec</code>, and write some characterization lemmas about those operations first</p>",
        "id": 517265581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746889424
    },
    {
        "content": "<p>Then you can prove that both implementations match the ideal one, and that they therefore match each other by transitivity</p>",
        "id": 517265647,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746889460
    },
    {
        "content": "<p>That's kinda what <code>timespec_difference_at_least_mul</code> already is, though?  Maybe I don't understand what you have in mind</p>",
        "id": 517265878,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1746889674
    },
    {
        "content": "<p>I managed to reduce it to two statements I don't find very obviously true</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">timespec_differences_equivalent</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_cases</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_difference_at_least_cases</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_to_ns</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">equivalence_when_equal_seconds</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split_ifs</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_lt_add_iff_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_fin_lt</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">or_comm</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">or_congr_left'</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hnsec</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_le_add_iff_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">norm_cast</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">le_iff_val_le_val</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"bp\">.</span><span class=\"n\">val_add</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- this isn't obvious to me</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"c1\">-- this isn't obvious to me</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 517273938,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1746895588
    },
    {
        "content": "<p>Just looking at it briefly, but I'm a bit concerned about this: <code>after.nsec ≥ before.nsec + min_ns</code></p>\n<p>Remember that Fin addition wraps by default, so if min_ns is like 800000000 and after.nsec is 600000000 and before.nsec is 500000000 then this will be true even if you might like it to be false</p>",
        "id": 517956760,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747189971
    },
    {
        "content": "<p>I swear I read documentation that said that Fin addition would enlarge the bound as necessary.  Maybe that was Lean 3? Anyway, wrapping addition is very much <em>not</em> what I wanted.</p>",
        "id": 518134931,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747247747
    },
    {
        "content": "<p>Maybe you could consider not using Fin addition and instead using Nat addition? You already said you wanted to keep Fin in the structure, but you can define another function <code>Timespec.nsecNat</code> or something without having to change the structure</p>",
        "id": 518135696,
        "sender_full_name": "Niels Voss",
        "timestamp": 1747247990
    },
    {
        "content": "<p>Yeah. I've managed to get a lot further with this by minimizing my use of <code>Fin</code>.  Instead I use <code>Nat</code> for nanosecond quantities and carry around the bounds as separate hypotheses.  This makes a lot more of the standard toolbox usable and gets rid of all the double conversions.  I also discovered a useful trick for complicated algebraic manipulation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">variables</span><span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mess</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simplified</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rearrangement</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>works for anything linarith can prove!  This should be mentioned in beginner documentation somewhere ;-)</p>\n<p>Now I'm stuck on something different: the last (hopefully) two steps of the proof boil down to being able to prove <code>a &lt; N → a &lt; (complex expression)</code> where the complex expression is, to the human eye, obviously greater than or equal to N, but I don't know how to express that in Lean except for the very simplest cases (where something like <code>Nat.lt_add_right</code>is exactly applicable).  Here's the whole thing again with a lot of comments and <code>sorry</code> placeholders for the remaining steps.</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span>\n\n<span class=\"c1\">-- Conversion factor from seconds to nanoseconds (10⁹)</span>\n<span class=\"kn\">abbrev</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span>\n\n<span class=\"c1\">-- Lean analogue of `struct timespec`.  A Timespec represents an</span>\n<span class=\"c1\">-- interval of time since some unspecified epoch instant.  We seek to</span>\n<span class=\"c1\">-- prove an equivalence between two methods of computing whether the</span>\n<span class=\"c1\">-- *difference* between two Timespec quantities is greater than some</span>\n<span class=\"c1\">-- interval, so we don't care what the epoch actually is.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- In C, the seconds field is a `time_t`, which is normally either a</span>\n<span class=\"c1\">-- 32- or 64-bit signed machine integer.  For our purposes—measuring</span>\n<span class=\"c1\">-- time intervals typically no more than a few tens of seconds—we can</span>\n<span class=\"c1\">-- ignore the possibility of machine integer overflow and model the</span>\n<span class=\"c1\">-- seconds field using Int, i.e. a mathematical integer with unbounded</span>\n<span class=\"c1\">-- range.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- In C, the nanoseconds field is a `long` (yes, signed, for no good</span>\n<span class=\"c1\">-- reason) and is constrained to the range [0, ONE_S_IN_NS) by</span>\n<span class=\"c1\">-- convention alone.  Fin has properties we don't want</span>\n<span class=\"c1\">-- (e.g. arithmetic on Fin is defined to be modulo its limit) and is</span>\n<span class=\"c1\">-- also just awkward to work with.  Instead, our version of Timespec</span>\n<span class=\"c1\">-- uses Nat for the nanoseconds field and, rather like Fin, bundles a</span>\n<span class=\"c1\">-- proof that it's in the appropriate range.</span>\n<span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">sec</span><span class=\"w\">        </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span>\n<span class=\"w\">  </span><span class=\"n\">nsec</span><span class=\"w\">       </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"n\">nsec_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"n\">deriving</span><span class=\"w\"> </span><span class=\"n\">Repr</span>\n\n<span class=\"c1\">-- This function defines the conversion from a Timespec quantity to</span>\n<span class=\"c1\">-- the total number of nanoseconds that have elapsed since that</span>\n<span class=\"c1\">-- Timespec's (unspecified) epoch.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tv</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">tv</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">tv</span><span class=\"bp\">.</span><span class=\"n\">nsec</span>\n\n<span class=\"c1\">-- This is the simple version of</span>\n<span class=\"c1\">-- timespec_difference_at_least.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- The calculation it performs is valid for any `min_ns: Nat`, but we limit</span>\n<span class=\"c1\">-- it to `min_ns: Fin ONE_S_IN_NS` so that an `=` equivalence between this</span>\n<span class=\"c1\">-- function and timespec_difference_at_least_cases, below, is type correct.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_mul</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">before</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_ns</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">timespec_to_ns</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"o\">)</span><span class=\"bp\">;</span>\n<span class=\"w\">  </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">delta</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">min_ns</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n\n<span class=\"c1\">-- This is the cleverer version of timespec_difference_at_least that avoids</span>\n<span class=\"c1\">-- needing to do any multiplication.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- Unlike timespec_difference_at_least_mul, it *does* rely on `min_ns`</span>\n<span class=\"c1\">-- being in the specified finite range.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_cases</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">before</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Timespec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">min_ns</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">min_ns</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">sec</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">ONE_S_IN_NS</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"bp\">.</span><span class=\"n\">nsec</span><span class=\"w\"> </span><span class=\"bp\">≥</span><span class=\"w\"> </span><span class=\"n\">min_ns</span><span class=\"bp\">.</span><span class=\"n\">val</span>\n<span class=\"w\">  </span><span class=\"k\">else</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Either after.sec &lt; before.sec, or after.sec &gt; before_sec + 1.</span>\n<span class=\"w\">    </span><span class=\"c1\">-- In the former case, (timespec_to_ns after) &lt; (timespec_to_ns before)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- no matter what the nsec values are.  In the latter case,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (timespec_to_ns after) - (timespec_to_ns before) must be at</span>\n<span class=\"w\">    </span><span class=\"c1\">-- least one whole second and therefore greater than any possible</span>\n<span class=\"w\">    </span><span class=\"c1\">-- value of min_ns.</span>\n<span class=\"w\">    </span><span class=\"n\">true</span>\n\n<span class=\"c1\">-- There are four cases to consider for the proof, depending on the</span>\n<span class=\"c1\">-- relationship between after.sec and before.nsec:</span>\n<span class=\"c1\">--   after.sec &lt; before.sec</span>\n<span class=\"c1\">--   after.sec = before.sec</span>\n<span class=\"c1\">--   after.sec = before.sec + 1</span>\n<span class=\"c1\">--   after.sec &gt; before.sec + 1</span>\n<span class=\"c1\">-- These are exhaustive, by trichotomy of the ordering relation on ℕ.</span>\n<span class=\"c1\">--</span>\n<span class=\"c1\">-- We prove each case individually.</span>\n\n<span class=\"c1\">-- The after.sec = before.sec case, which is the easiest.</span>\n<span class=\"c1\">-- We don't need any of the bounds on an, bn, or m.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_eq_bs</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bn</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">an</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">or_congr_right'</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">zify</span>\n<span class=\"w\">  </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">le_sub_iff_add_le'</span>\n\n<span class=\"c1\">-- Simplification lemma used by the remaining cases:</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">x_ne_x_plus_stuff</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n\n<span class=\"c1\">-- The after.sec &lt; before.sec case, which is the second easiest since</span>\n<span class=\"c1\">-- both functions always return true.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_lt_bs</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">δs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">δs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">δs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">δs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right-hand side of the equivalence is always true</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x_ne_x_plus_stuff</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now we have the disjunction</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ as * 1000000000 + ↑an &lt; (as + 1 + ↑δs) * 1000000000 + ↑bn</span>\n<span class=\"w\">    </span><span class=\"c1\">--   ∨ ↑m ≤ as * 1000000000 + ↑an - ((as + 1 + ↑δs) * 1000000000 + ↑bn)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the left side of which is always true</span>\n<span class=\"w\">    </span><span class=\"n\">left</span>\n<span class=\"w\">    </span><span class=\"c1\">-- cancel duplicate terms on both sides of the remaining inequality</span>\n<span class=\"w\">    </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_mul</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">add_lt_add_iff_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">norm_cast</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now we have an &lt; 1*1000000000 + (δs * 1000000000 + bn),</span>\n<span class=\"w\">    </span><span class=\"c1\">-- with all variables Nat,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and we know an &lt; 1000000000</span>\n<span class=\"w\">    </span><span class=\"n\">revert</span><span class=\"w\"> </span><span class=\"n\">an_bound</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">lt_add_right</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">δs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- The after.sec &gt; before.sec + 1 case, which is very similar to the</span>\n<span class=\"c1\">-- after.sec &lt; before.sec case.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_gt_bs_plus_one</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right-hand side of the equivalence is always true</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now we have the disjunction</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ (bs + 1 + (↑q + 1)) * 1000000000 + ↑an &lt; bs * 1000000000 + ↑bn</span>\n<span class=\"w\">    </span><span class=\"c1\">--   ∨ ↑m ≤ (bs + 1 + (↑q + 1)) * 1000000000 + ↑an</span>\n<span class=\"w\">    </span><span class=\"c1\">--           - (bs * 1000000000 + ↑bn)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right side of which is always true, but proving it requires</span>\n<span class=\"w\">    </span><span class=\"c1\">-- all three bounds and a bunch of algebraic rearrangement</span>\n<span class=\"w\">    </span><span class=\"n\">right</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">         </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rearrangement</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ ↑m ≤ 2000000000 + ↑q * 1000000000 + ↑an - ↑bn</span>\n<span class=\"w\">    </span><span class=\"c1\">-- an &lt; 1000000000 and bn &lt; 1000000000</span>\n<span class=\"w\">    </span><span class=\"c1\">-- so the smallest the RHS can be is when q=0, an=0, bn=999999999</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and that's still 1000000001, and m also &lt; 1000000000 so it must</span>\n<span class=\"w\">    </span><span class=\"c1\">-- be smaller, but I don't know how to put that into Lean-ese</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- The most interesting case is when after.sec = before.sec + 1.</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_eq_bs_plus_one</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- eliminate obviously false clauses on both sides of the ↔</span>\n<span class=\"w\">    </span><span class=\"c1\">-- simp can see one for itself but needs some help for the other</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_mul</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">false_by_bounds</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">false_by_bounds</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- rearrange the remaining left side of the iff</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ ↑m ≤ 1000000000 + ↑an - ↑bn ↔ m ≤ 1000000000 + an - bn</span>\n<span class=\"w\">    </span><span class=\"c1\">-- bn &lt; 1000000000, so the subtraction on the RHS cannot underflow,</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and both sides _should_ be equivalent, but again I don't know</span>\n<span class=\"w\">    </span><span class=\"c1\">-- how to put that into Lean-ese</span>\n<span class=\"w\">   </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">timespec_differences_equivalent</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">timespec_difference_at_least_cases</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">funext</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Bool</span><span class=\"bp\">.</span><span class=\"n\">eq_iff_iff</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">m</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">as</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">an_bound</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">bs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">  </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">timespec_difference_at_least_mul</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_difference_at_least_cases</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">timespec_to_ns</span><span class=\"o\">,</span>\n<span class=\"w\">        </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split_ifs</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">as_rel_bs</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"c1\">-- have as_rel_bs: as = bs</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">as_rel_bs</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">case_as_eq_bs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span>\n<span class=\"w\">  </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"c1\">-- have as_rel_bs: ¬(as = bs)</span>\n<span class=\"w\">    </span><span class=\"n\">rcases</span><span class=\"w\"> </span><span class=\"n\">lt_trichotomy</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">as_lt_bs</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">as_gt_bs</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"c1\">-- have as_lt_bs: as &lt; bs</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">δs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">exists_add_of_le</span><span class=\"w\"> </span><span class=\"n\">as_lt_bs</span>\n<span class=\"w\">      </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">case_as_lt_bs</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">δs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">an_bound</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"n\">tauto</span><span class=\"w\"> </span><span class=\"c1\">-- as = bs already disposed of above</span>\n<span class=\"w\">    </span><span class=\"bp\">.</span><span class=\"w\"> </span><span class=\"c1\">-- have as_gt_bs: bs &lt; as</span>\n<span class=\"w\">      </span><span class=\"c1\">-- this case must be split further into as = bs + 1 and as &gt; bs + 1</span>\n<span class=\"w\">      </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">δs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">exists_add_of_le</span><span class=\"w\"> </span><span class=\"n\">as_gt_bs</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">x_ne_x_plus_stuff</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">δs</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">case_as_eq_bs_plus_one</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span>\n<span class=\"w\">      </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">succ</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">case_as_gt_bs_plus_one</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span>\n</code></pre></div>",
        "id": 518136665,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747248330
    },
    {
        "content": "<blockquote>\n<p>being able to prove <code>a &lt; N → a &lt; (complex expression)</code></p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n</code></pre></div>",
        "id": 518143525,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747250710
    },
    {
        "content": "<p>Going to try it on your examples.</p>",
        "id": 518143540,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747250717
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_gt_bs_plus_one</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right-hand side of the equivalence is always true</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- now we have the disjunction</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ (bs + 1 + (↑q + 1)) * 1000000000 + ↑an &lt; bs * 1000000000 + ↑bn</span>\n<span class=\"w\">    </span><span class=\"c1\">--   ∨ ↑m ≤ (bs + 1 + (↑q + 1)) * 1000000000 + ↑an</span>\n<span class=\"w\">    </span><span class=\"c1\">--           - (bs * 1000000000 + ↑bn)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right side of which is always true, but proving it requires</span>\n<span class=\"w\">    </span><span class=\"c1\">-- all three bounds and a bunch of algebraic rearrangement</span>\n<span class=\"w\">    </span><span class=\"n\">right</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">((((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"w\">         </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">j</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">k</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">j</span>\n<span class=\"w\">      </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rearrangement</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"n\">Int</span><span class=\"bp\">.</span><span class=\"n\">reduceAdd</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"c1\">-- ⊢ ↑m ≤ 2000000000 + ↑q * 1000000000 + ↑an - ↑bn</span>\n<span class=\"w\">    </span><span class=\"c1\">-- an &lt; 1000000000 and bn &lt; 1000000000</span>\n<span class=\"w\">    </span><span class=\"c1\">-- so the smallest the RHS can be is when q=0, an=0, bn=999999999</span>\n<span class=\"w\">    </span><span class=\"c1\">-- and that's still 1000000001, and m also &lt; 1000000000 so it must</span>\n<span class=\"w\">    </span><span class=\"c1\">-- be smaller, but I don't know how to put that into Lean-ese</span>\n<span class=\"w\">    </span><span class=\"n\">zify</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">m_bound</span>\n<span class=\"w\">    </span><span class=\"n\">zify</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_sub_iff_add_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_le_add_iff_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_add_iff_nonneg_right</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 518144809,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251149
    },
    {
        "content": "<p>Didn't even use <code>an_bound</code>.</p>",
        "id": 518144819,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251154
    },
    {
        "content": "<p>Oh, <em>this</em> is what <code>refine</code> is for?  I couldn't figure it out from the documentation.  (The tactics documentation could use a lot more examples.)</p>\n<p>I'm not surprised it turns out not all of the bounds are necessary; these lemmas were spat out by <code>extract_goal</code> from the places where they're used, and the plan was to minimize their arguments once proven, but of course one can't do that until one is <em>done</em> proving them.</p>",
        "id": 518145447,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747251388
    },
    {
        "content": "<p>You don't even need to be explicit about the rearrangement</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_gt_bs_plus_one</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right-hand side of the equivalence is always true</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">right</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">    </span><span class=\"n\">zify</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sub_iff_add_le</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"bp\">_</span><span class=\"mi\">000</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_le_add_iff_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_add_iff_nonneg_right</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 518145824,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251542
    },
    {
        "content": "<p>I used <code>ring_nf</code> to do the cancellations</p>",
        "id": 518145844,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251549
    },
    {
        "content": "<p>Had to undo the 1B + 1B step to get into a nice form</p>",
        "id": 518145894,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251570
    },
    {
        "content": "<p>OK, even less juggling. I used <code>bn &lt; 1B</code> and made a <code>1B + bn &lt;= 2B</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- the right-hand side of the equivalence is always true</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Nat</span><span class=\"bp\">.</span><span class=\"n\">add_one_ne_zero</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">right</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">    </span><span class=\"n\">zify</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"n\">m_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sub_iff_add_le</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">refine</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">add_le_add_left</span><span class=\"w\"> </span><span class=\"n\">bn_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">?_</span>\n<span class=\"w\">    </span><span class=\"n\">norm_num</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_add_iff_nonneg_right</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">positivity</span>\n</code></pre></div>",
        "id": 518146349,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251769
    },
    {
        "content": "<p>Where the heck is <code>ring_nf</code> documented?<br>\nI suspect I could have been using it a lot earlier if I'd known about it</p>",
        "id": 518146593,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747251866
    },
    {
        "content": "<p>When you use <code>ring</code> as a non-finishing tactic, it'll complain</p>",
        "id": 518146633,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251887
    },
    {
        "content": "<p>and say, \"use ring_nf to normalize expressions\"</p>",
        "id": 518146660,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747251900
    },
    {
        "content": "<p>Same question about <code>ring</code> then!</p>",
        "id": 518146707,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747251918
    },
    {
        "content": "<p>And <code>norm_num</code> for that matter<br>\nI'm finding the documentation well-nigh useless and I don't know if I'm looking in the wrong place or what</p>",
        "id": 518146871,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747251988
    },
    {
        "content": "<p>Here's a list of all the tactics in mathlib:<br>\n<a href=\"https://seasawher.github.io/mathlib4-help/tactics/\">tactics</a></p>",
        "id": 518146955,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747252028
    },
    {
        "content": "<p>Like take <a href=\"https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF\">https://leanprover-community.github.io/mathlib4_docs/Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF</a><br>\nwhich is what comes up if I put \"ring_nf\" into the search box<br>\nI do not know what most of these words mean</p>",
        "id": 518146983,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747252040
    },
    {
        "content": "<p>or, from the page <span class=\"user-mention\" data-user-id=\"816344\">@Aaron Liu</span> linked,</p>\n<blockquote>\n<p><code>tac &lt;;&gt; tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal, concatenating all goals produced by <code>tac'</code>.</p>\n</blockquote>\n<p>I think I see what that <em>does</em> but I have no idea when I would want to use it</p>",
        "id": 518147155,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747252116
    },
    {
        "content": "<p>Sometimes you do a <code>cases a &lt;;&gt; cases b &lt;;&gt; cases c &lt;;&gt; simp</code></p>",
        "id": 518147411,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747252215
    },
    {
        "content": "<p>... <code>cases</code> doesn't compute for me in this context</p>",
        "id": 518147562,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747252305
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib4/blob/c61b9b01b5cb518d61dfd95afe1253bd92a147ad/Mathlib/Order/WithBot.lean#L372-L373\">Take a look</a></p>",
        "id": 518147717,
        "sender_full_name": "Aaron Liu",
        "timestamp": 1747252379
    },
    {
        "content": "<p>I'm sorry, this is just continuing to go further down the rabbit hole of things being defined in terms of other things that I don't understand either.  I'm really not much of a mathematician.</p>",
        "id": 518147942,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747252473
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">case_as_eq_bs_plus_one</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"mi\">0</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"bp\">↔</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"n\">bn</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"c1\">-- eliminate obviously false clauses on both sides of the ↔</span>\n<span class=\"w\">    </span><span class=\"c1\">-- simp can see one for itself but needs some help for the other</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">le_tsub_iff_left</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">bn_bound</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">))]</span>\n<span class=\"w\">    </span><span class=\"n\">zify</span>\n<span class=\"w\">    </span><span class=\"n\">ring_nf</span>\n<span class=\"w\">    </span><span class=\"c1\">-- crucial here are add_sub and le_sub_iff_add_le'</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_sub</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_sub_iff_add_le'</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">not_true_eq_false</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">false_or</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">or_iff_right_iff_imp</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add_rotate</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_assoc</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">add_lt_add_iff_left</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">H</span>\n<span class=\"w\">    </span><span class=\"n\">linarith</span>\n</code></pre></div>",
        "id": 518148002,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252501
    },
    {
        "content": "<p>First I saw that the iff had things that look like <code>m ≤ 1000000000 + an - bn</code> on both sides of the iff (after a ring_nf). I moved <code>bn</code> over the left using the <code>tsub</code> lemma, with a side proof that I can, because we know that 1B + an &gt; bn (not hitting nat subtraction truncation, basically).</p>",
        "id": 518148177,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252579
    },
    {
        "content": "<p>Then a simp to help with this goal</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">↔</span>\n<span class=\"w\">  </span><span class=\"bp\">¬</span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span>\n</code></pre></div>",
        "id": 518148236,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252611
    },
    {
        "content": "<p>note how <code>↑m ≤ 1000000000 + (↑an - ↑bn)</code> and <code>↑bn + ↑m ≤ 1000000000 + ↑an</code> are basically the same</p>",
        "id": 518148310,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> Thank you, this is hugely helpful</p>",
        "id": 518148325,
        "sender_full_name": "Zack Weinberg",
        "timestamp": 1747252652
    },
    {
        "content": "<p>Then you get a <code>1000000000 + bs * 1000000000 + ↑an &lt; bs * 1000000000 + ↑bn</code> which needs some help cancellation, and <code>add_rotate</code> (I guessed the name, none of <code>add_comm</code>, <code>add_left_comm</code>, <code>add_right_comm</code> were relevant) gets you there.</p>",
        "id": 518148428,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252693
    },
    {
        "content": "<p>Where <code>add_lt_add_iff_left</code> is one I knew by name -- the name is precisely the \"move\" I want to make.</p>",
        "id": 518148474,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252711
    },
    {
        "content": "<p>we then get a</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℤ</span>\n<span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℕ</span>\n<span class=\"n\">bn_bound</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">ONE_S_IN_NS</span>\n<span class=\"n\">H</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">bn</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">1000000000</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">an</span>\n</code></pre></div>\n<p>and that's something that <code>linarith</code> can easily handle.</p>",
        "id": 518148560,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1747252748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"902878\">Zack Weinberg</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Proving.20equivalence.20of.20two.20versions.20of.20a.20function/near/518136665\">said</a>:</p>\n<blockquote>\n<p>I also discovered a useful trick for complicated algebraic manipulation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">    </span><span class=\"bp\">...</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">rearrangement</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">variables</span><span class=\"bp\">...</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">mess</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">simplified</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">linarith</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">rearrangement</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>works for anything linarith can prove! This should be mentioned in beginner documentation somewhere ;-)</p>\n</blockquote>\n<p>You can even do things like <code>rw [show mess = simplified by linarith]</code></p>\n<p><span class=\"user-mention silent\" data-user-id=\"902878\">Zack Weinberg</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Proving.20equivalence.20of.20two.20versions.20of.20a.20function/near/518146707\">said</a>:</p>\n<blockquote>\n<p>Same question about <code>ring</code> then!</p>\n</blockquote>\n<p>The course notes for Imperial's formalizing mathematics course contain documentation of some of the basic tactics which is far more extensive than the documentation available in the official docs. See <a href=\"https://b-mehta.github.io/formalising-mathematics-notes/Part_2/Part_2.html\">here</a>. Maybe this is helpful? We cover both <code>refine</code> and <code>ring</code> (and in the ring docs we also mention this <code>rw [show ...]</code> trick). See also the glossary <a href=\"https://b-mehta.github.io/formalising-mathematics-notes/Part_1/Part_1.html\">here</a> for explanation of some of the terms used.</p>",
        "id": 518165662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1747259838
    }
]