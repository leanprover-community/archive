[
    {
        "content": "<p>When using Aeneas with the Lean back end, it seems to use Hax. But Hax can also be used independently to produce Lean code for verification purposes?</p>",
        "id": 532723133,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1754312484
    },
    {
        "content": "<p>Aeneas uses the Hax frontend, that queries rustc to extract the <code>THIR</code> or <code>MIR</code> representations. Then, both Aeneas and Hax produce code for different backends. The main difference comes from the fact that Hax targets the Thir representation, while Aeneas targets Mir (and they don't do the same code transformations)</p>\n<p>While Aeneas has put a focus on Lean for a long time, Hax was more designed towards F* and Rocq/Coq (among others). Recently, we've been developing a Lean backend for Hax, that happens to borrow some definitions from Aeneas.</p>",
        "id": 532725306,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754313225
    },
    {
        "content": "<p>(Keeping in mind that the Hax backend for Lean is 1 month old, while the Lean backend of Aeneas has been developed for several years)</p>",
        "id": 532725610,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754313338
    },
    {
        "content": "<p>Thanks, that already clarifies a lot. </p>\n<p>Is it possible to say briefly if there is likely to be a different way that identical rust will be represented in lean?</p>",
        "id": 532725855,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1754313416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"746143\">Clément Blaudeau</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/532725610\">said</a>:</p>\n<blockquote>\n<p>(Keeping in mind that the Hax backend for Lean is 1 month old, while the Lean backend of Aeneas has been developed for several years)</p>\n</blockquote>\n<p>Indeed!</p>",
        "id": 532726033,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1754313473
    },
    {
        "content": "<p>There are/will be two sets of differences : </p>\n<ol>\n<li>The Lean representation of Rust primitives/intrinsics in Aeaneas and Hax might be different (although some effort is likely going to be put in trying to merge/reuse some definitions and interfaces). For instance, Aeneas has a custom integer type for <code>i32</code>, while Hax uses Lean's <code>Int32</code>. Depending on what you're using the extracted code for, that might or might not make a difference. Hax uses the recent additions to Lean.Std.Do for specifications, while Aeneas has a custom <code>wp</code> notion (with some impressive engineering in tactics) that predates it </li>\n<li>The phases that transform the Rust code are different in the engine of Hax and Aeneas. Loops, mutability, borrowing, etc. are not treated in the same way, and this difference would show in the extracted code</li>\n</ol>",
        "id": 532730767,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754315028
    },
    {
        "content": "<p>In addition to this. Hax has already been used for many more applications than Aeneas; see <a href=\"https://hax.cryspen.com/publications/\">https://hax.cryspen.com/publications/</a><br>\nIncluding our recent multi-prover verification of a PQ TLS implementation, accepted at CCS: <a href=\"https://eprint.iacr.org/2025/980\">https://eprint.iacr.org/2025/980</a><br>\nWe have also used it for smart contract verification. A paper is under submission.</p>\n<p>Historically, Hax has been designed to verify security critical (cryptographic) rust software in Rust, whereas Aeneas aimed for a wider fragment of the rust language.<br>\nInterestingly, <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> is currently working on verifying cryptographic implementations, whereas Hax is extending the fragment of the rust language it is supporting.</p>",
        "id": 533067503,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1754474462
    },
    {
        "content": "<p>Yes, hax and Aeneas have quite different translation mechanisms. Aeneas actually used to be completely independent of hax, but we decided to port the code which directly interacts with rustc into the hax frontend, with the hope of sharing code and engineering effort. In practice we have mostly been extending the hax frontend so that it can support MIR, but we hope sharing this code has benefits in the future.<br>\nWe have put a strong focus into designing a translation mechanism which is expressive and principled. As a result, Aeneas can support some complex patterns like functions returning mutable borrows in all generality, while as far as I know hax had to hardcode support for some such patterns, to support iterators for instance (I'm curious about the work on extending the fragment supported by hax <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> ). Part of the translation performed by Aeneas has also been formalized and proven correct (to be more precise, we have a proof that the symbolic execution performed by Aeneas, which is at the core of the translation, implements a borrow-checker, and we plan to extend this proof to have a correctness theorem about the generated code).<br>\nWe are currently applying Aeneas to the verification of the open source cryptographic library of Microsoft, which is notably used in Windows and Azure Linux: we're porting the code from C to Rust, and verifying it in Aeneas. Microsoft published a blog post about this effort: <a href=\"https://www.microsoft.com/en-us/research/blog/rewriting-symcrypt-in-rust-to-modernize-microsofts-cryptographic-library/\">https://www.microsoft.com/en-us/research/blog/rewriting-symcrypt-in-rust-to-modernize-microsofts-cryptographic-library/</a><br>\nCryptographic code is only our first target, and we're in the process of extending the translation to support a larger class of programs. In particular, we're currently working on connecting the pure translation to a separation logic framework to make it possible to reason about unsafe and concurrent code.</p>",
        "id": 533073073,
        "sender_full_name": "Son Ho",
        "timestamp": 1754476591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/532723133\">said</a>:</p>\n<blockquote>\n<p>it seems to use Hax.</p>\n</blockquote>\n<p>What made you think it uses hax by the way?</p>",
        "id": 533073952,
        "sender_full_name": "Son Ho",
        "timestamp": 1754476930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/533073952\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/532723133\">said</a>:</p>\n<blockquote>\n<p>it seems to use Hax.</p>\n</blockquote>\n<p>What made you think it uses hax by the way?</p>\n</blockquote>\n<p>At some point there was an error message produced that mentioned Hax. I think it was when I hadn't properly installed some of the requirements and I think it was when running Charon but I don't remember precisely.</p>",
        "id": 534975524,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1755530963
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> and <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> for the details related to Hax versus Aeneas. That really helps a lot getting an understanding of the two options.</p>",
        "id": 534975974,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1755531087
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"613177\">@Oliver Butterley</span> out of curiosity, what are you trying to prove about what rust code?</p>",
        "id": 535069799,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1755588584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/535069799\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> out of curiosity, what are you trying to prove about what rust code?</p>\n</blockquote>\n<p>I was searching for a way to verify Rust code which works well both for low level bit operations and can also express rather sophisticated mathematical properties. Of course all of that together is a big ask! </p>\n<p>I was experimenting with a <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/src/lib.rs\">function from <code>curve25519-dalek</code></a> and it's not too hard to <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/verify/Verify/Proofs/reduce.lean\">prove the relevant properties in Lean</a> after extracting with Aeneas its <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/verify/Verify/Src/RustLeanPlayground.lean\">Lean form</a>. </p>\n<p>In general I was rather impressed how it could be done and the Lean proof wasn't harder that proving the same in Verus even though I didn't get any advantage from <code>grind</code> on this occasion.  I used heavily Aeneas' <code>progress as</code> rather than stuff from Lean's <code>Std.do</code>. I suspect there will be improved ways to do some of this as the Lean libraries expand and Aeneas is pinned to a more recent version of Lean.</p>\n<p>Next I'll try Hax -&gt; Lean with the same function to see how it goes.</p>",
        "id": 535998025,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1756118544
    },
    {
        "content": "<p>Given the same Rust code, how similar will the Lean version of the code be?</p>",
        "id": 535998358,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1756118674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"613177\">@Oliver Butterley</span> I'm looking forward to the comparison.<br>\nIn general, for efficient verified curve operations, I would likely take the fiat-cryptography route, which uses a verified compiler:<br>\n<a href=\"https://github.com/mit-plv/fiat-crypto/tree/master/fiat-rust\">https://github.com/mit-plv/fiat-crypto/tree/master/fiat-rust</a></p>\n<p>I should be possible to connect this compiler with Lean. We're looking at some options of how to do that, but that might take some time...</p>\n<p>In general, I would expect Hax code (eventually) to be simpler, is the current semantics Hax is functional. Aeneas supports a bigger subset of rust, which needs a bi-functional semantics: <a href=\"https://aeneasverif.github.io/publications/\">https://aeneasverif.github.io/publications/</a></p>\n<p>However, it is possible for Aeneas to use stactic analysis and use the functional semantics if appropriate for a specific rust program. I am not sure this is currently done. <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> ?</p>",
        "id": 536006393,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1756121820
    },
    {
        "content": "<p>Thanks for the info!</p>",
        "id": 536017619,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1756125887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/535998025\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/535069799\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> out of curiosity, what are you trying to prove about what rust code?</p>\n</blockquote>\n<p>I was searching for a way to verify Rust code which works well both for low level bit operations and can also express rather sophisticated mathematical properties. Of course all of that together is a big ask! </p>\n<p>I was experimenting with a <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/src/lib.rs\">function from <code>curve25519-dalek</code></a> and it's not too hard to <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/verify/Verify/Proofs/reduce.lean\">prove the relevant properties in Lean</a> after extracting with Aeneas its <a href=\"https://github.com/oliver-butterley/rust-lean-playground/blob/master/verify/Verify/Src/RustLeanPlayground.lean\">Lean form</a>. </p>\n<p>In general I was rather impressed how it could be done and the Lean proof wasn't harder that proving the same in Verus even though I didn't get any advantage from <code>grind</code> on this occasion.  I used heavily Aeneas' <code>progress as</code> rather than stuff from Lean's <code>Std.do</code>. I suspect there will be improved ways to do some of this as the Lean libraries expand and Aeneas is pinned to a more recent version of Lean.</p>\n<p>Next I'll try Hax -&gt; Lean with the same function to see how it goes.</p>\n</blockquote>\n<p>I'm happy to hear that you were successful doing this experiment! About <code>progress</code>: we've been following the development of Lean's <code>Std.do</code> very closely and we're definitely interested in using it in the future, but on the other hand maintaining our own version of <code>progress</code> gives us some freedom in doing experiments. For instance, you may have noticed that <code>progress*</code> repeatedly applies <code>progress</code> while <code>progress*?</code> generates the corresponding proof script, which is quite convenient to quickly get into the core of the proof. We are also working on more interesting extensions.<br>\nAbout <code>grind</code>: we intend to use it in the very near future, but we need to annotate our standard library with grind attributes first (it is not difficult, just a bit boring).<br>\nAlso note that we have developed a collection of tactics to make the proof interaction easier. For instance:</p>\n<ul>\n<li><code>scalar_tac</code> is a more powerful version of <code>omega</code></li>\n<li><code>simp_{lists,scalar,lists_scalar}</code> is an optimized version of <code>simp</code> which uses <code>scalar_tac</code> as a discharger together with specific simp sets to simplify goals containing lists and integers. They're very useful to reason about programs containing arrays (to simplify things like <code>get (set a i) j</code>) or performing non-linear arithmetic operations (to simplify things like <code>a % b = a</code>), and both of those are all over the place in cryptographic code.</li>\n<li><code>bvify n</code>, <code>natify</code>, <code>zmodify</code> do the same as <code>zify</code> but target <code>BitVec</code>, <code>Nat</code> and <code>ZMod</code>, etc.</li>\n</ul>\n<p>About the complexity of the translation: yes indeed, Aeneas uses backward functions only when needed (that is when translating functions which return mutable borrows). This is not based on static analysis: it is simply based on the signature of the functions we translate. So I believe Hax and Aeneas' output should mostly coincide on the subset they have in common. It is possible that Hax output is more respectful of the original control-flow, though, as it consumes the THIR rather than the MIR.</p>",
        "id": 536173315,
        "sender_full_name": "Son Ho",
        "timestamp": 1756192446
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span> </p>\n<p>I missed the possibility of <code>progress*?</code>, it's good to know! I found <code>progress</code> did the job well for everything I saw so I have no complaints. </p>\n<p>I was very happy to discover <code>bvify n</code>, it's great. </p>\n<p>I should experiment more with <code>scalar_tac</code> and the enhanced versions of simp. I didn't yet since I could solve my goals without and didn't easily find documentation about them. Another time I'll did deeper. </p>\n<p>One day soon there will be a \"Verifying Rust in Lean\" book, along the lines of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">Theorem Proving in Lean</a> and <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a> then we will all get and easy way into this activity.</p>\n<p>By the way, the availability of the lean examples (although buried a little deep in the Aeneas repo) was great for getting start. More examples are always good!</p>",
        "id": 536176362,
        "sender_full_name": "Oliver Butterley",
        "timestamp": 1756193747
    },
    {
        "content": "<p>We're adding lean examples (and documentation) to the hax tutorial right now, they should be available in the coming days/weeks!</p>",
        "id": 536182084,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1756195941
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"371938\">@Son Ho</span>. I'm hoping Hax can reuse some of the clever tactics you've already provided for Aeneas.</p>",
        "id": 536183813,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1756196589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"613177\">Oliver Butterley</span> <a href=\"#narrow/channel/236449-Program-verification/topic/What.20is.20the.20connection.20between.20Aeneas.20and.20Hax.3F/near/536176362\">said</a>:</p>\n<blockquote>\n<p>Thanks, <span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> </p>\n<p>I missed the possibility of <code>progress*?</code>, it's good to know! I found <code>progress</code> did the job well for everything I saw so I have no complaints. </p>\n<p>I was very happy to discover <code>bvify n</code>, it's great. </p>\n<p>I should experiment more with <code>scalar_tac</code> and the enhanced versions of simp. I didn't yet since I could solve my goals without and didn't easily find documentation about them. Another time I'll did deeper. </p>\n<p>One day soon there will be a \"Verifying Rust in Lean\" book, along the lines of <a href=\"https://leanprover.github.io/theorem_proving_in_lean4/\">Theorem Proving in Lean</a> and <a href=\"https://leanprover-community.github.io/mathematics_in_lean/\">Mathematics in Lean</a> then we will all get and easy way into this activity.</p>\n<p>By the way, the availability of the lean examples (although buried a little deep in the Aeneas repo) was great for getting start. More examples are always good!</p>\n</blockquote>\n<p>Yes, I need to document all this better and rewrite the tutorial but I've been overwhelmed with other things. ^^'<br>\nAbout <code>bvify n</code>: I also wrote a wrapper <code>bv_tac n</code> which calls <code>bvify</code> then <code>bv_decide</code>. </p>\n<p>That's a good remark: we need to add more examples in the repo. I'm hoping to take some time in the near future to minimize some examples about verified code we're working on right now to exemplify the use of all those tactics on cryptographic code.</p>",
        "id": 536203835,
        "sender_full_name": "Son Ho",
        "timestamp": 1756203301
    }
]