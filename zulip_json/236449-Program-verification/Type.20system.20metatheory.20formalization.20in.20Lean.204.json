[
    {
        "content": "<p>Hi!</p>\n<p>I'm new to Lean and formal verification in general. Recently, I started studying publications about type systems and noticed that some authors, e.g., [1],[2],[3], provided proofs of various properties of metatheory of their type systems, e.g., soundness and completeness of the algorithmic system w.r.t. the declarative system, and the decidability of the type inference algorithm in that system.</p>\n<p>I thought it was cool that it was possible to mechanize results about type systems. Hence, I decided to search for resources that could teach me how to prove properties about metatheory of programming languages, e.g., to be able to prove things about the type system in [1] or [4] myself.</p>\n<p>Most authors used hand-written proofs, Agda, or Coq. I learned that [3] used Lean 4 for proofs, and the proofs took 16KLOC (<a href=\"https://proofassistants.stackexchange.com/a/2506\">https://proofassistants.stackexchange.com/a/2506</a>). This amount of code would be quite overwhelming to study.</p>\n<p>Then, I found <a href=\"https://github.com/rami3l/PLFaLean\">https://github.com/rami3l/PLFaLean</a>. It provided a chapter about bidirectional type checking, but there seemed to be no info about extrinsic typing, unification and mutable cells in metavariables, techniques used in [4] and GHC.</p>\n<p>So, my questions:</p>\n<ol>\n<li>What kind of metatheory is Lean convenient to use for?</li>\n<li>Which (digestible) works use Lean 4 for proofs about metatheory?</li>\n<li>How do you prove correctness and completeness of bidirectional typing algorithms like in [1] or [4]? Which proof assistant would you choose for this task and why?</li>\n</ol>\n<p>References<br>\n[1] J. Dunfield and N. R. Krishnaswami, “Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism,” Aug. 22, 2020, <em>arXiv</em>: arXiv:1306.6032. doi: <a href=\"https://doi.org/10.48550/arXiv.1306.6032\">10.48550/arXiv.1306.6032</a>.<br>\n[2] S. Jiang, C. Cui, and B. C. D. S. Oliveira, “Bidirectional Higher-Rank Polymorphism with Intersection and Union Types,” <em>Proc. ACM Program. Lang.</em>, vol. 9, no. POPL, pp. 2118–2148, Jan. 2025, doi: <a href=\"https://doi.org/10.1145/3704907\">10.1145/3704907</a>.<br>\n[3] J. E. Ghalayini and N. Krishnaswami, “Explicit Refinement Types,” <em>Proc. ACM Program. Lang.</em>, vol. 7, no. ICFP, p. 195:187-195:214, Aug. 2023, doi: <a href=\"https://doi.org/10.1145/3607837\">10.1145/3607837</a>.<br>\n[4] S. P. Jones, D. Vytiniotis, S. Weirich, and M. Shields, “Practical type inference for arbitrary-rank types,” <em>J. Funct. Prog.</em>, vol. 17, no. 1, pp. 1–82, Jan. 2007, doi: <a href=\"https://doi.org/10.1017/S0956796806006034\">10.1017/S0956796806006034</a>.</p>",
        "id": 518023878,
        "sender_full_name": "Danila Danko",
        "timestamp": 1747217274
    },
    {
        "content": "<p>A canonical introduction is <a href=\"https://softwarefoundations.cis.upenn.edu/\">https://softwarefoundations.cis.upenn.edu/</a> (in Rocq).<br>\nThere's a Lean port (<a href=\"https://alashworth.github.io/sf-lean/index.html\">https://alashworth.github.io/sf-lean/index.html</a>), but I don't know what the status is.<br>\nThis one is also recommended: <a href=\"https://lean-forward.github.io/hitchhikers-guide/2023/\">https://lean-forward.github.io/hitchhikers-guide/2023/</a></p>",
        "id": 518055649,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1747226660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> thanks! On the PLF <a href=\"https://softwarefoundations.cis.upenn.edu/plf-current/Postscript.html\">Postscript</a> page, I found a link to <a href=\"http://iron.ouroborus.net/\">http://iron.ouroborus.net/</a> and there a link to <a href=\"https://github.com/discus-lang/iron/\">https://github.com/discus-lang/iron/</a>. </p>\n<blockquote>\n<p>Iron Lambda is a collection of <a href=\"http://coq.inria.fr/\">​Coq</a> formalisations for functional languages of increasing complexity.</p>\n</blockquote>\n<p>Looks digestible, although it's in Rocq.</p>",
        "id": 518089058,
        "sender_full_name": "Danila Danko",
        "timestamp": 1747234541
    },
    {
        "content": "<p>A student of mine recently formalised a standard Martin-Löf type theory in Lean. (Code is not public yet.) Using Lean (as opposed to Rocq or Agda) was fine except for the issue discussed <a href=\"#narrow/channel/270676-lean4/topic/Induction.20over.20mutually.20inductive.20predicates/with/402060061\">here</a>: rule induction over mutually inductive predicates is unsupported. Depending on your theory, this issue might be really annoying, or it might not matter at all.</p>",
        "id": 518912218,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1747566272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256311\">@Jannis Limperg</span> did your student use an intrinsically typed representation? </p>\n<p>I'm curious because <a href=\"https://homepages.inf.ed.ac.uk/wadler/papers/plfa/scp.pdf\">PLFA</a> argued for intrinsic typing (Section 5) and there was a discussion regarding the preferred approach: <a href=\"#narrow/channel/236449-Program-verification/topic/Intrinsic.20or.20Extrinsic.20Typing.20for.20PL.20Metatheory.3F/with/472052866\">https://leanprover.zulipchat.com/#narrow/channel/236449-Program-verification/topic/Intrinsic.20or.20Extrinsic.20Typing.20for.20PL.20Metatheory.3F/with/472052866</a></p>",
        "id": 518936069,
        "sender_full_name": "Danila Danko",
        "timestamp": 1747585631
    },
    {
        "content": "<p>No. He (<span class=\"user-mention\" data-user-id=\"812279\">@Johannes Reichle</span>) used intrinsically scoped syntax, i.e. terms are annotated with the number of free variables in them, but not intrinsically typed syntax. Since this is a full dependent type theory, I'm not sure whether intrinsic typing would be practical (possible?) without induction-recursion.</p>\n<p>Personally, I'm also a big hater of intrinsic typing. I feel like it adds a ton of complexity as soon as you have any sort of dependency structure. For simple theories, it is pretty, though.</p>",
        "id": 518936651,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1747586128
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"911144\">@Danila Danko</span> You mean also want to have a look at the POPLmark and POPLmark Reloaded benchmarks: <a href=\"https://poplmark-reloaded.github.io/\">https://poplmark-reloaded.github.io/</a><br>\nHint: Lean4 is still missing ;-)</p>",
        "id": 518948996,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1747595942
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> thanks! </p>\n<ul>\n<li>Both benchmarks have accompanying PDFs that provide context about tasks.</li>\n<li>Some of the solutions, especially for the non-Reloaded POPLMark problems, have extensive explanations.</li>\n<li>The Coq proofs in the POPLmark Reloaded version are relatively small and readable.</li>\n<li>Implementing a Lean 4 version is a good challenge :) I couldn't find implementations on GitHub.</li>\n</ul>",
        "id": 518956293,
        "sender_full_name": "Danila Danko",
        "timestamp": 1747600670
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"911144\">@Danila Danko</span> I recently made this blog post \"Beginner Resources for Formalizing Lambda Calculi\" that has a couple of projects you've not already mentioned: <a href=\"https://chrishenson.net/posts/2025-05-10-formalized_lambda_calculus.html\">https://chrishenson.net/posts/2025-05-10-formalized_lambda_calculus.html</a></p>\n<p>It includes a link to my own repo in Lean 4 that currently just has a proof of beta confluence for simple types with pairs.</p>",
        "id": 518958303,
        "sender_full_name": "Chris Henson",
        "timestamp": 1747602174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"687698\">@Chris Henson</span> thanks! The resources on formalization aren't that scarce!</p>",
        "id": 518959160,
        "sender_full_name": "Danila Danko",
        "timestamp": 1747602857
    }
]