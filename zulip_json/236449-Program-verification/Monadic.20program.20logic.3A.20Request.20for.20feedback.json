[
    {
        "content": "<p>Fellow Lean users,</p>\n<p>As announced in the <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493913623\">Lean FRO meeting at Lean Together 2025</a>, I'm working on behalf of the Lean FRO on a Floyd/Hoare-style program logic framework to verify \"arbitrary\" monadic code written in Lean. <br>\nThis thread is meant to collect requirements from you! </p>\n<h3>Scope: \"Is this work relevant to my use case?\"</h3>\n<p>TLDR; this work could be relevant to you if you want to verify code written using Lean's <code>do</code>-notation.</p>\n<p>Let me clarify what \"program logic for monadic code\" means by giving a sketch of the definition of Hoare Triple I have in mind: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>(Find <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=JYWwDg9gTgLgBAWQIYwBYBtgCM4ChfAB2AJgK4DGMwAbgKZwAqUShAzgMoxLkDWcAXIwCeYegEY4Ad1S0otXHDgAfOGFJyBjZm07ceC5XFZcY9QQApAw8CaGI2gEo4gJMItLDl17PXOj/sUraAA9yWjB4C0BW4Bs7RxcmN11POO13PXwAAQBtOTJybHRaAF1cYloAMzgABTkAYQgSGxTEvji7L1tRAxUAOjUNAF4APjgASWIuuG7jFHprVjghuAAlWiRSqAY4a3Nq2jqG1nsJ7qCQsLgAfSMF4d394iMM7Npc/KKS8rgAMSRgdHv5oJ4j49O07Mc+vRFgBVQjAGDHaamLbXRY/P4Ax7+SanULwKLzRbmKIuO71B7zaoQMCOADr31+/3J81Y+AAtGzvKx0DM4Eg4DAUmVoCBZEZfAKIHy4CBSOgqGysEgoHICg9IMZyOT4cB6rgsjkKG9iqUKpUIMZ7nBzIBG4Giokc5kBXOajqg9ocHoE/QMtq8ZIOcCgdIZGOZj1w1NohBdEqIuCCSHABTgAG9AIPAcCilgAvpoAw8nSZZtakfRM+ZcecopD7HWqlBqQtrdYXJnSY2ad6g2V0PhWLRKLqY+bLeSAKKBJNgAqsqMx4GpXj4ajK4BILApv2ZqIRQCBBFnAEEEKMsB8sx6BMVwAGJDSFrTA7Kx+P1BaRPaOYFa7ZXgnij6WxZbMev5nPiB5Fryp6qOoDh1o46a4ByfLwPU9CQEQ8AjHy6CsFKqBrLGejdHIayyAANHAWCkPA8IAOQsqAM5ijAUpMQUoqELR8BICyxZIZyWCDkgpADgKMgxpI9DkCwArqDG/JgHIWokDq9RwJhUqKRaMAqcQamSfCqAQDRcBasmwAyaYDyCkgdBQKwSC4d0AlwOwSb0MK7qSFA8JiuYSm0KwpAgBu6BCPYLmJsmZhVDp36Abyma1g2Tb9Nafptv6nYhrC8KOC+PZ9tFzH5vF5JwD+Vb4jBciOFSYDNuYmWpV29LEtl1K5XCMAFelUC9gmU4xWVY4ND+ZYoqB/41rB9YNU1LWtq1IYdR2XVwPSeW9d2A3FcNpWCJ+CXTdWiXItBtb1Z2i12i40HrW11oklsB6Pd1+W7YNJUpkd5XjedswgdVWaA69tVwddaUZXdwFeA9K2bc98NvYjW09X1RVDdOv1xWNDxVX+1YgZN57WiD+5g5dc3wa1t3w8e92ow1q0RIzcNM51T3EqjCMs0j22Y3t2MjX9+OVeTRP4iTQFk6d4FUweV31oATcD0/d7MIyrrOa5rzM5UjPMo1zH07YVwuubeLwUPQ5iPqIgLpW+nrNcQUqQhlgAJhIg9RrCsZFQAA8mUJGrMQjgADxwGIADMcCAORE1rewgvvEP76zB6HayOOlABEqDALn9ZHbUFWQciAByKBg5wvmEAA5hD805fg0YPMdE4HbO+BENMhD3gW3S9zAKeEIRgiptMnhAk0vh5i4o+ETspcHL4RzYr0sE3NaRBlLIIxsFw/exYvDxjOvhhTLLqLDAU8BXIV6TD6fRgANw74Qe9QAfff3oIL/mHTrITY2wCxGHgscCmN84BP0Pi/VkuBCD1HMmoLgm56DDxYAPFexAh6HwADIoCoH/NMU8+AzwSHPLwdQYqmEITAYhtswFkJWhCLeRJzC733ofLBsUaHMToUQyy9B+aCH4XfWg9DGHWjAZvDQLML49FJtAu+lxuywOMFI4Rb8P5fx/kfEh4jaCCIYdoqw2U9gVUpDlRROIpag0JMMDRMAtH3gQUg/uEBwA0TChgnhx8GyWJIHg4wuxoDrFIRKChIJeB5hLrQcJ/lmESlEelLh39/EhEQcgrxqDfEaUySInBISXHjkiaCaJS4eBxLgPgspy8gkUhSQbQq6T9G8PwKaUMTISCsG6CpYw1pGolw2oIdEPTiB8QqT6RQoVdKoHFKCSQRk2EDGGOYWxV8oLQPSOMgE/T6iDPmGASB9iCTb3MGUUgMYLhREWB7MAlFdmMn2QM+AxyjgfAqHs5k3RnaaB+b0xZ090qAsmQcw+Wh3xfO6fssoTkxJjJeeGFhhUwV9LeQyXC8hsmeO8WglMmCAnopKWEqAESJ6oqIrEixiT3TmHRcCngmyPaLDaYUxEQEriOLgKoh+6VnFkoiawd+7Lf7yA3iDbl28+XqOHkKsUIqCl6I5a5AAgqoHSekDJwCCIFVgrAiCN1YlwdAZloDKRgIQIKrIukd2CSapyQzNCw2SaCbWo0vwVTtCwtWL5fSPNhb8+F2LPnkB5Aan2Y9iBMGAKVcwIAvStAdIlaecATIwEqMqJM1LmVSBkHIAwgo41bkCJoRNNpHSVHzDgpliNzAAEVPUJRYaI1qkZRAxlPrG+NxbmKfKQSYYc/ACiEVzoAYMpc5VDgLnQAIZQzrgIEEdYcF2TrgE2udU6hgGG7b5Zify90pjLdWht2Sh31GXWOtd1a50LqXaOh4U7x2AGXCKd1AF0qCnRu2dW7BgGHHZUedZaAP/VwY6s1VyYzvsWA22d+Bw28XmIQyQVz0C7pLbbRNl5RBghTZBNNGas3METYuV0BhMgvxAIUOAmRkOoco9Rijqce0pkTWQ6j0hZASoFIe2gFwBm0AAI5pmrZUOiNbGl1oanmVMTaG3ibFl6gGrbOx5nMGWwQFaL6KHMKgYZ07AAmRFUBT6UsBCCMExR0qBhOCHk3AIzTbCpmYs+AbT1oFmCD7Ue4z666IFQMIoLz9Bj3rqLbxi4QRbKUAuKIBywBjDRngKmatIywAybExJq0KnqQycc3jJTBMpOqYC9aDTMpKpWfzF4ILi6fMNv84oQLvHasBS3tWwAyUTGccKeprGGYtb1TDaXLzbvVFZy9afkghK3uaYlVhz3QJBIHsPwErNXWsaEuS+EAjglvTp6zxvrWAiAPEG3AFWw3FMtuaeN1MSwRsNDVtltLpXy0VetBUKbXhE3axK7psrNWQv1fc7IRs7pbPdAAEz2eWJD7sznDWud+6gD7cBAAARFRSia2KhYEdA2hbVFHBLAa41tbZbBiDHSmUeqyx8BAA\">here the exact definition</a> I'm currently working with, but the above is close enough to give you an idea.)<br>\nThe intention is that any user may provide a definition of <code>M</code> and <code>triple</code> (plus structural rules) and then verify programs in <code>M</code> building on an extensive program logic with good automation and UX.</p>\n<p>In addition to scalable extrinsic proofs, the vision is to allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework.</p>\n<p>Note that although <code>M α</code> is \"semantics of a program in Lean\", you should be able to use this framework for any language with a denotational semantics into a monad.</p>\n<p>This should include any strongly normalizing object language such as System F, but exclude untyped lambda calculus, System F with recursive types or mutable references (finding monadic semantic domains for the latter is an <a href=\"https://arxiv.org/abs/2210.02169\">active research problem</a>).</p>\n<h3>Request for feedback</h3>\n<p>I am interested in gathering any kind of feedback (please keep focus on semantics rather than syntax that is likely to change <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>), or people I should reach out to that are <em>not yet</em> in the following list:</p>\n<p>Jeremy Avigad, Mario Carneiro, Wojciech Nawrocki, John Tristan, Jonathan Protzenko</p>\n<p>However, I'm specifically interested in feedback to the following items which I encourage you refer to in your answer:</p>\n<ol>\n<li>What is your use case? Can you point me to reasonably self-contained example code?</li>\n<li>We need to figure out what \"arbitrary\" monadic code means. For example, my prototype would currently support any kind of transformer stack that can be represented as <code>StateT</code>/<code>ExceptT</code> (plus <code>ReaderT</code>/<code>WriterT</code> and equivalents through <code>StateT</code>) over <code>Id</code>/<code>IO</code>.  (Behavior of runtime <code>IO</code> functions will be axiomatised.) <strong>Is this sufficient for your use case?</strong> I'm asking because this plan does not currently include a Separation Logic to reason about <code>IO.Ref</code> or <code>ST.Ref</code>, and I'm yet unsure how much of a breaking change it would be to add this capability after the fact.</li>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>.    Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n<li>My focus so far is on unary program logic. I have heard at least one voice who want to work in a relational program logic (relating multiple program runs with different preconditions) for cryptographic proofs à la <a href=\"https://github.com/SSProve/ssprove\">SSProve</a>. <strong>Does your use case require a relational program logic?</strong></li>\n<li>Any Related Work I should look at?  I am aware of F*, Dafny, Verus, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Classes/SatisfiesM.html#SatisfiesM\">the <code>SatisfiesM</code> experiment from Batteries</a>, the Rocq frameworks above and the literature on Dijkstra monads.</li>\n</ol>\n<p>Thanks!</p>",
        "id": 499713950,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739532684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">said</a>:</p>\n<blockquote>\n<ol>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>. Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n</ol>\n</blockquote>\n<p>I assume you are aware of <a href=\"https://github.com/leanprover-community/iris-lean\">https://github.com/leanprover-community/iris-lean</a> ? It is starting to gain momentum with some of the people working on Iris, so while it's currently not really ready for use it may be in a better state once your work is getting closer to completion. Ideally these two frameworks will be able to work together seamlessly, and we should coordinate as needed to make sure this is the case</p>",
        "id": 499733706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739537836
    },
    {
        "content": "<p>I would love to support that effort in some form. I could imagine the following definition for <code>triple</code> in terms of <a href=\"https://github.com/leanprover-community/iris-lean/blob/f1274361f9aee39717db8c7c0a611deddaf6ba9a/src/Iris/Instances/Classical/Instance.lean#L15\"><code>HeapProp</code></a> (could probably be generalised to any <code>BI</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HeapProp</span><span class=\"w\"> </span><span class=\"n\">VAL</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HeapProp</span><span class=\"w\"> </span><span class=\"n\">VAL</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">□</span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">-⋆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OBSERVE</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is the interpretation suggested on p141 in <a href=\"https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf\">the Iris lecture notes</a>.<br>\nBut what is <code>M</code>? What is <code>OBSERVE</code>? What is <code>VAL</code>?</p>\n<p>Provided that a user can answer these questions for their domain, I have no doubts that they will be able to use the framework I have prototyped.</p>\n<p>I am however doubtful whether this will be useful to verify code using <code>IO.Ref</code>s.<br>\nFor example, even if we take <code>M := IO</code> and postulate <code>OBSERVE</code> as well as the structural rules of the logic, it is still quite difficult to find a <code>VAL</code> that lives in <code>Type 0</code>. <br>\nI have played around with using <code>VAL := Σ α, α</code> (because we want to allocate <code>IO.Ref</code>s for any kind of <code>α : Type</code>), but that lives in <code>Type 1</code>. A potential shortcoming of my prototype is that this universe bump requires several <code>ULift</code>s in pure instantiations where we do not even need separation logic. Frankly, this is unacceptable.</p>\n<p>I tried the alternative of indexing all computations over a heap context <code>Γ : Nat -&gt; Type</code> but stopped when I realized that I would need to sacrifice the functional dependency <code>m -&gt; stack</code> in doing so, because <code>Γ</code> occurs in the instantiation of <code>stack</code>. That turned out to be a no-go as well, because it greatly regresses type inference for all other instances.</p>\n<p>Long story short: I would be more than happy to anticipate support for future Separation Logics, however that support must not come at  a loss of convenience for other instances of the framework.</p>",
        "id": 499767219,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739546231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">said</a>:</p>\n<blockquote>\n<p>Fellow Lean users,</p>\n<p>As announced in the <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493913623\">Lean FRO meeting at Lean Together 2025</a>, I'm working on behalf of the Lean FRO on a Floyd/Hoare-style program logic framework to verify \"arbitrary\" monadic code written in Lean. <br>\nThis thread is meant to collect requirements from you! </p>\n<h3>Scope: \"Is this work relevant to my use case?\"</h3>\n<p>TLDR; this work could be relevant to you if you want to verify code written using Lean's <code>do</code>-notation.</p>\n<p>Let me clarify what \"program logic for monadic code\" means by giving a sketch of the definition of Hoare Triple I have in mind: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>(Find <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=JYWwDg9gTgLgBAWQIYwBYBtgCM4ChfAB2AJgK4DGMwAbgKZwAqUShAzgMoxLkDWcAXIwCeYegEY4Ad1S0otXHDgAfOGFJyBjZm07ceC5XFZcY9QQApAw8CaGI2gEo4gJMItLDl17PXOj/sUraAA9yWjB4C0BW4Bs7RxcmN11POO13PXwAAQBtOTJybHRaAF1cYloAMzgABTkAYQgSGxTEvji7L1tRAxUAOjUNAF4APjgASWIuuG7jFHprVjghuAAlWiRSqAY4a3Nq2jqG1nsJ7qCQsLgAfSMF4d394iMM7Npc/KKS8rgAMSRgdHv5oJ4j49O07Mc+vRFgBVQjAGDHaamLbXRY/P4Ax7+SanULwKLzRbmKIuO71B7zaoQMCOADr31+/3J81Y+AAtGzvKx0DM4Eg4DAUmVoCBZEZfAKIHy4CBSOgqGysEgoHICg9IMZyOT4cB6rgsjkKG9iqUKpUIMZ7nBzIBG4Giokc5kBXOajqg9ocHoE/QMtq8ZIOcCgdIZGOZj1w1NohBdEqIuCCSHABTgAG9AIPAcCilgAvpoAw8nSZZtakfRM+ZcecopD7HWqlBqQtrdYXJnSY2ad6g2V0PhWLRKLqY+bLeSAKKBJNgAqsqMx4GpXj4ajK4BILApv2ZqIRQCBBFnAEEEKMsB8sx6BMVwAGJDSFrTA7Kx+P1BaRPaOYFa7ZXgnij6WxZbMev5nPiB5Fryp6qOoDh1o46a4ByfLwPU9CQEQ8AjHy6CsFKqBrLGejdHIayyAANHAWCkPA8IAOQsqAM5ijAUpMQUoqELR8BICyxZIZyWCDkgpADgKMgxpI9DkCwArqDG/JgHIWokDq9RwJhUqKRaMAqcQamSfCqAQDRcBasmwAyaYDyCkgdBQKwSC4d0AlwOwSb0MK7qSFA8JiuYSm0KwpAgBu6BCPYLmJsmZhVDp36Abyma1g2Tb9Nafptv6nYhrC8KOC+PZ9tFzH5vF5JwD+Vb4jBciOFSYDNuYmWpV29LEtl1K5XCMAFelUC9gmU4xWVY4ND+ZYoqB/41rB9YNU1LWtq1IYdR2XVwPSeW9d2A3FcNpWCJ+CXTdWiXItBtb1Z2i12i40HrW11oklsB6Pd1+W7YNJUpkd5XjedswgdVWaA69tVwddaUZXdwFeA9K2bc98NvYjW09X1RVDdOv1xWNDxVX+1YgZN57WiD+5g5dc3wa1t3w8e92ow1q0RIzcNM51T3EqjCMs0j22Y3t2MjX9+OVeTRP4iTQFk6d4FUweV31oATcD0/d7MIyrrOa5rzM5UjPMo1zH07YVwuubeLwUPQ5iPqIgLpW+nrNcQUqQhlgAJhIg9RrCsZFQAA8mUJGrMQjgADxwGIADMcCAORE1rewgvvEP76zB6HayOOlABEqDALn9ZHbUFWQciAByKBg5wvmEAA5hD805fg0YPMdE4HbO+BENMhD3gW3S9zAKeEIRgiptMnhAk0vh5i4o+ETspcHL4RzYr0sE3NaRBlLIIxsFw/exYvDxjOvhhTLLqLDAU8BXIV6TD6fRgANw74Qe9QAfff3oIL/mHTrITY2wCxGHgscCmN84BP0Pi/VkuBCD1HMmoLgm56DDxYAPFexAh6HwADIoCoH/NMU8+AzwSHPLwdQYqmEITAYhtswFkJWhCLeRJzC733ofLBsUaHMToUQyy9B+aCH4XfWg9DGHWjAZvDQLML49FJtAu+lxuywOMFI4Rb8P5fx/kfEh4jaCCIYdoqw2U9gVUpDlRROIpag0JMMDRMAtH3gQUg/uEBwA0TChgnhx8GyWJIHg4wuxoDrFIRKChIJeB5hLrQcJ/lmESlEelLh39/EhEQcgrxqDfEaUySInBISXHjkiaCaJS4eBxLgPgspy8gkUhSQbQq6T9G8PwKaUMTISCsG6CpYw1pGolw2oIdEPTiB8QqT6RQoVdKoHFKCSQRk2EDGGOYWxV8oLQPSOMgE/T6iDPmGASB9iCTb3MGUUgMYLhREWB7MAlFdmMn2QM+AxyjgfAqHs5k3RnaaB+b0xZ090qAsmQcw+Wh3xfO6fssoTkxJjJeeGFhhUwV9LeQyXC8hsmeO8WglMmCAnopKWEqAESJ6oqIrEixiT3TmHRcCngmyPaLDaYUxEQEriOLgKoh+6VnFkoiawd+7Lf7yA3iDbl28+XqOHkKsUIqCl6I5a5AAgqoHSekDJwCCIFVgrAiCN1YlwdAZloDKRgIQIKrIukd2CSapyQzNCw2SaCbWo0vwVTtCwtWL5fSPNhb8+F2LPnkB5Aan2Y9iBMGAKVcwIAvStAdIlaecATIwEqMqJM1LmVSBkHIAwgo41bkCJoRNNpHSVHzDgpliNzAAEVPUJRYaI1qkZRAxlPrG+NxbmKfKQSYYc/ACiEVzoAYMpc5VDgLnQAIZQzrgIEEdYcF2TrgE2udU6hgGG7b5Zify90pjLdWht2Sh31GXWOtd1a50LqXaOh4U7x2AGXCKd1AF0qCnRu2dW7BgGHHZUedZaAP/VwY6s1VyYzvsWA22d+Bw28XmIQyQVz0C7pLbbRNl5RBghTZBNNGas3METYuV0BhMgvxAIUOAmRkOoco9Rijqce0pkTWQ6j0hZASoFIe2gFwBm0AAI5pmrZUOiNbGl1oanmVMTaG3ibFl6gGrbOx5nMGWwQFaL6KHMKgYZ07AAmRFUBT6UsBCCMExR0qBhOCHk3AIzTbCpmYs+AbT1oFmCD7Ue4z666IFQMIoLz9Bj3rqLbxi4QRbKUAuKIBywBjDRngKmatIywAybExJq0KnqQycc3jJTBMpOqYC9aDTMpKpWfzF4ILi6fMNv84oQLvHasBS3tWwAyUTGccKeprGGYtb1TDaXLzbvVFZy9afkghK3uaYlVhz3QJBIHsPwErNXWsaEuS+EAjglvTp6zxvrWAiAPEG3AFWw3FMtuaeN1MSwRsNDVtltLpXy0VetBUKbXhE3axK7psrNWQv1fc7IRs7pbPdAAEz2eWJD7sznDWud+6gD7cBAAARFRSia2KhYEdA2hbVFHBLAa41tbZbBiDHSmUeqyx8BAA\">here the exact definition</a> I'm currently working with, but the above is close enough to give you an idea.)<br>\nThe intention is that any user may provide a definition of <code>M</code> and <code>triple</code> (plus structural rules) and then verify programs in <code>M</code> building on an extensive program logic with good automation and UX.</p>\n<p>In addition to scalable extrinsic proofs, the vision is to allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework.</p>\n<p>Note that although <code>M α</code> is \"semantics of a program in Lean\", you should be able to use this framework for any language with a denotational semantics into a monad.</p>\n<p>This should include any strongly normalizing object language such as System F, but exclude untyped lambda calculus, System F with recursive types or mutable references (finding monadic semantic domains for the latter is an <a href=\"https://arxiv.org/abs/2210.02169\">active research problem</a>).</p>\n<h3>Request for feedback</h3>\n<p>I am interested in gathering any kind of feedback (please keep focus on semantics rather than syntax that is likely to change <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>), or people I should reach out to that are <em>not yet</em> in the following list:</p>\n<p>Jeremy Avigad, Mario Carneiro, Wojciech Nawrocki, John Tristan, Jonathan Protzenko</p>\n<p>However, I'm specifically interested in feedback to the following items which I encourage you refer to in your answer:</p>\n<ol>\n<li>What is your use case?</li>\n<li>We need to figure out what \"arbitrary\" monadic code means. For example, my prototype would currently support any kind of transformer stack that can be represented as <code>StateT</code>/<code>ExceptT</code> (plus <code>ReaderT</code>/<code>WriterT</code> and equivalents through <code>StateT</code>) over <code>Id</code>/<code>IO</code>.  (Behavior of runtime <code>IO</code> functions will be axiomatised.) <strong>Is this sufficient for your use case?</strong> I'm asking because this plan does not currently include a Separation Logic to reason about <code>IO.Ref</code> or <code>ST.Ref</code>, and I'm yet unsure how much of a breaking change it would be to add this capability after the fact.</li>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>.    Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n<li>My focus so far is on unary program logic. I have heard at least one voice who want to work in a relational program logic (relating multiple program runs with different preconditions) for cryptographic proofs à la <a href=\"https://github.com/SSProve/ssprove\">SSProve</a>. <strong>Does your use case require a relational program logic?</strong></li>\n<li>Any Related Work I should look at?  I am aware of F*, Dafny, Verus, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Classes/SatisfiesM.html#SatisfiesM\">the <code>SatisfiesM</code> experiment from Batteries</a>, the Rocq frameworks above and the literature on Dijkstra monads.</li>\n</ol>\n<p>Thanks!</p>\n</blockquote>\n<p>I only know Iris and have a passing experience with Satisfies and Dafny. The thing that annoyed me in Satisfies is how difficult it is to extract the guarantees from inside the satisfies monad and relate it to a specific input variable in a proof for a function outside the monadic context. I also have a question, which is that we currently use the Id monad for proofs. Is it a good idea to add support for a monad with a heap structure for use with separation logics?</p>",
        "id": 499770803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1739547219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> Are you aware of the Dijkstra monad approach. I know there are other groups trying to implement it in Lean.<br>\n<a href=\"https://arxiv.org/abs/1903.01237\">https://arxiv.org/abs/1903.01237</a></p>\n<p>We've used it successfully for probabilistic relational Hoare logic in Coq: E.g. <a href=\"https://github.com/SSProve/ssprove\">https://github.com/SSProve/ssprove</a></p>",
        "id": 499774064,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739548131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499770803\">said</a>:</p>\n<blockquote>\n<p>I only know Iris and have a passing experience with Satisfies and Dafny. The thing that annoyed me in Satisfies is how difficult it is to extract the guarantees from inside the satisfies monad and relate it to a specific input variable in a proof for a function outside the monadic context.</p>\n</blockquote>\n<p>What is appealing about definitions such as <code>SatisfiesM</code>is their applicability across different monads. Unfortunately we were unable to prove basic properties such as conjunction (<code>SatisfiesM x p -&gt; SatisfiesM x q -&gt; SatisfiesM x (p \\and q)</code>) with it. Then we tinkered with (the weaker)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>\n<p>but had trouble defining infinite conjunction (i.e., the logic's <code>forall</code>) in terms of it. That was when I gave up on this approach and had a look at encodings of <code>triple</code> based on effect observations/Dijkstra monads (see my next post).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499770803\">said</a>:</p>\n<blockquote>\n<p>I also have a question, which is that we currently use the Id monad for proofs. Is it a good idea to add support for a monad with a heap structure for use with separation logics?</p>\n</blockquote>\n<p>I'm not completely sure I understand the question. If all programs that you want to prove correct can be expressed in <code>Id</code> (or any number of <code>StateT</code> on top of that), I don't think you need separation logic. You need separation logic only if your programs have dynamic memory allocation, because you need a way to say, e.g., \"the <code>ST.Ref</code> <code>a</code> returned by <code>ST.mkRef</code> is distinct from any <code>ST.Ref</code> <code>b</code> returned by <code>ST.mkRef</code> in the future\" and to then preserve any property of <code>a</code> after <code>b</code> has been allocated. Without dynamic memory allocation, you can express this property statically in the type system as a stack of <code>StateT</code>s; the frame rule is an appropriate <code>liftM</code>.</p>",
        "id": 499787164,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739552241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499774064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> Are you aware of the Dijkstra monad approach. I know there are other groups trying to implement it in Lean.<br>\n<a href=\"https://arxiv.org/abs/1903.01237\">https://arxiv.org/abs/1903.01237</a></p>\n<p>We've used it successfully for probabilistic relational Hoare logic in Coq: E.g. <a href=\"https://github.com/SSProve/ssprove\">https://github.com/SSProve/ssprove</a></p>\n</blockquote>\n<p>Yes, I am. In fact, until this week I had based my prototype framework around effect <code>Observation</code>s defined by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">MonadOrdered</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">pure_pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">bind_bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>You could define <code>def triple x P Q := P ≤ x.observe Q</code> in terms of this type class, and that would work well for most instances (except separation logic, where you want persistent separating implication as alluded to in my previous post instead of entailment).</p>\n<p>Again, what is important for the planned framework is that it is maximally convenient for the \"<code>StateT</code>/<code>ExceptT</code> on top of <code>Id</code>\" use case. <code>Observation</code>/Dijkstra monads allow for a polymorphic monad stack, which is nice.<br>\nHowever, when I tried to actually prove stuff about monad-polymorphic functions such as <code>forIn</code> or <code>foldlM</code>, I noticed that it is incredibly difficult to do so. Here is an example for <code>forIn</code>, allowing the user to supply a loop invariant. (I have successfully applied this lemma in my experiments, so it is useful.) Mind my difficulty expressing pre and post conditions such as <code>hpre</code> and <code>hstep</code>in this framework:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">forIn_list</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">obs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">tl</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\">  </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"n\">MonadOrdered</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Intuition: inv encapsulates the effects of looping over a prefix of xs (and gets passed the suffix)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- The induction hypothesis is:</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">hind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"c1\">-- This is because the predicate transformer is stronger (≤) than the invariant,</span>\n<span class=\"w\">      </span><span class=\"c1\">-- and the longer the suffix passed to `prog`, the more we rely on predicate transformer.</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Conversely, the shorter the suffix, the more we rely on the invariant summarizing the effects of looping over a prefix.</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">      </span><span class=\"k\">calc</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pure_bind</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- only [List.forIn_nil, obs.pure_pure, bind_pure]</span>\n<span class=\"w\">        </span><span class=\"c1\">-- For the after case (xs=[]), we have a lower bound because `forIn [] b` reduces to `pure b`</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"c1\">-- For the initial case (full xs), we have an upper bound via hpre</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hind</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Now prove hind : prog xs ≤ prog [] by induction</span>\n<span class=\"w\">    </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"c1\">-- not needed any longer and would need to be generalized</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil_append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonadOrdered</span><span class=\"bp\">.</span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bind_map_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonadOrdered</span><span class=\"bp\">.</span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bind_map_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Note</p>\n<ul>\n<li><code>pure init ≤ inv xs</code> expresses that <code>init</code> satisfies the precondition <code>inv xs</code>. Although I came up with this after long and hard thinking, I have no real intutition for what <code>inv xs</code> means. Its domain <code>w β</code> is <em>huge</em>, potentially encompassing all kinds of predicate transformers. </li>\n<li>In <code>hstep</code>, I want to express that the result of the loop iteration <code>f hd b</code> satisfies <code>inv [] b'</code> when it is <code>.done b'</code>, and <code>inv xs b'</code> when it is <code>.yield b'</code>. This is incredibly difficult to state and requires a disjunction. The disjunction means <code>hstep</code> is going to be hard to automate for the user of the lemma.</li>\n<li>While I could have required <code>∀{α}, CompleteLattice (w α)</code> instead and formulated <code>hstep</code> as <code>(inv (hd :: tl) &gt;&gt;= fun b =&gt; obs.observe (f hd b)) ≤ (.yield &lt;$&gt; inv tl ⊔ .done &lt;$&gt; inv [])</code> instead, this would not helped much with the automation problem.</li>\n</ul>\n<p>So I found myself wondering whether we could find a way to expose the means to formulate proper pre and postconditions. In doing so I came up with the framework I propose and realized that we do not need <code>Observation</code> at all. Here's the equivalent lemma in the framework I propose:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Triple</span><span class=\"bp\">.</span><span class=\"n\">forIn_list</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadTriple</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonadTriple</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCond</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">⦃</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">⦄</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">⦄)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_pure</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_bind</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">herror</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">        </span><span class=\"n\">split</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_pure</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n</code></pre></div>\n<p>It is <em>so much simpler</em>. Maybe I'm doing something wrong or missing a trick in my encoding of effect observations. If that is indeed the case, I would like to see how to improve on <code>Observation.forIn_list</code>.</p>",
        "id": 499787873,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739552425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> I haven't tried thinking about the details of your proposed approach, but it looks well thought-out. The issues we ran into in the past were really quite basic:</p>\n<ol>\n<li><code>do</code> notation does not provide a way to state and prove loop invariants. It seems that adding this is a foundational component of your strategy.</li>\n<li>With <code>SatisfiesM</code> specifically, we can prove <code>p arg a</code> where <code>arg</code> is the input, and <code>a : α</code> is the value produced by <code>M α</code>, but there is no way to reason about other cases, e.g. failure in <code>Except</code>: we may only show that if the result is <code>.ok v</code> then <code>p arg v</code>, but not that if the result is <code>.err e</code> then <code>q arg e</code>. Perhaps building <code>except</code> into your <code>TransStack</code> accounts for this?</li>\n</ol>\n<blockquote>\n<p>allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework</p>\n</blockquote>\n<p>I am also curious about this statement. My current model of verified programming in DTT is that certain intrinsically-verified programs cannot be expressed extrinsically. Here is the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">tizio</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- imagined syntax</span>\n<span class=\"w\">    </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>In this program, the executable code includes an array-bound proof term derived from proofs about earlier parts of the program. I don't immediately see how this could be expressed extrinisically (i.e., write the code first and the prove it correct as a separate theorem), and I suspect that it cannot.</p>",
        "id": 499934353,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1739641553
    },
    {
        "content": "<p>Hypothetically speaking it should be possibel to generate a function <code>tizio_aux</code> that contains the old body of <code>tizio</code> but also a proof argument that is abstracted over   the necessary hypotheses and plugs these hypothesis in at the appropriate array spots, then redefine <code>tizio</code> in terms of <code>tizio_aux &lt;your_external_proof_term&gt;</code> right? I'm not saying that this is convenient but at least a technical possibility and potentially automatable.</p>",
        "id": 499938836,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739643377
    },
    {
        "content": "<p>Me and <span class=\"user-mention\" data-user-id=\"246591\">@Quang Dao</span>  would have a definite use case for this in verifying cryptographic code (see <a href=\"https://github.com/dtumad/VCV-io\">here</a>). Having a standardized program logic would be very useful to simplify proofs that currently require ad-hoc reasoning.</p>\n<p>Specifically to your questions, in our use case we've been writing algorithms using a relatively simple monad stack, the main definition being a type to represent computations with oracles, which we use for uniform selection, random oracles, security game oracles, etc. More explicitly our main stack is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Map from indexing set to domain/range type of that oracle</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"c1\">-- Functor to represent queries with a given output type</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Most definitions are written in terms of this monad</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OptionT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Operational semantics are essentially just the universal properties of <code>OptionT</code>/<code>FreeMonad</code>, letting us lift a mapping from <code>OracleQuery</code> to a new monad <code>m</code> to one from <code>OracleComp</code> to <code>m</code>. The monads you listed seem to cover all our use cases of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simulateQ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Alternative</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OptionT</span><span class=\"bp\">.</span><span class=\"n\">mapM'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMonad</span><span class=\"bp\">.</span><span class=\"n\">mapM'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Example responding to repeated queries with a cache using StateT</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cachingOracle</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">DecidableEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">QueryCache</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">QueryCache</span><span class=\"bp\">.</span><span class=\"n\">queryFresh</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>Denotational semantics are just the case of mapping this into the <code>PMF</code> monad (actually <code>OptionT PMF</code> to represent a spmf):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalDist</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">FiniteRange</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OptionT</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">simulateQ</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">OptionT</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFintype</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">oa</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">probOutput</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">evalDist</span><span class=\"w\"> </span><span class=\"n\">oa</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I do think a relational program logic would be nice for our case, although the unary case would also be helpful.</p>",
        "id": 499942814,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1739646858
    },
    {
        "content": "<p>Hi, this sounds quite interesting. I am currently not working with Lean, but I am quite interested in using it for Iris-based verification in the future.<br>\n We recently presented a modular method for building program logics at POPL: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3704847\">https://dl.acm.org/doi/pdf/10.1145/3704847</a><br>\nOur approach is based on the free monad (or more concretely its implementation in Rocq in the form of interaction trees) and it allows one to modularly combine different effects in a program and reuse proofs. In particular, I think this approach provides a higher degree of modularity and reuse than an Dijkstra-monad-based approach.<br>\nOur target was to modularly build program logics for Iris and I would expect that one wants to use a similar approach if Iris gets ported to Lean. But I have not thought about general monadic programs, so maybe the tradeoffs are a bit different there.<br>\nMaybe some ideas from that paper could also be useful for what you have in mind. Let me know if you have any questions about this paper. I would be happy to talk more about this.</p>",
        "id": 500104446,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1739778261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499934353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> I haven't tried thinking about the details of your proposed approach, but it looks well thought-out. The issues we ran into in the past were really quite basic:</p>\n<ol>\n<li><code>do</code> notation does not provide a way to state and prove loop invariants. It seems that adding this is a foundational component of your strategy.</li>\n</ol>\n</blockquote>\n<p>Thanks! Indeed. Stating and proving loop invariants is just \"the specification lemma\" for <code>forIn</code> that I called <code>Triple.forIn_list</code> above.</p>\n<blockquote>\n<ol start=\"2\">\n<li>With <code>SatisfiesM</code> specifically, we can prove <code>p arg a</code> where <code>arg</code> is the input, and <code>a : α</code> is the value produced by <code>M α</code>, but there is no way to reason about other cases, e.g. failure in <code>Except</code>: we may only show that if the result is <code>.ok v</code> then <code>p arg v</code>, but not that if the result is <code>.err e</code> then <code>q arg e</code>. Perhaps building <code>except</code> into your <code>TransStack</code> accounts for this?</li>\n</ol>\n</blockquote>\n<p>Yes; the <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=JYWwDg9gTgLgBAWQIYwBYBtgCM4ChfAB2AJgK4DGMwAbgKZwAqUShAzgMoxLkDWcAXIwCeYegEY4Ad1S0otXHDgAfOGFJyBjZm07ceC5XFZcY9QQApAw8CaGI2gEo4gJMItLDl17PXOj/sUraAA9yWjB4C0BW4Bs7RxcmN11POO13PXwAAQBtOTJybHRaAF1cYloAMzgABTkAYQgSGxTEvji7L1tRAxUAOjUNAF4APjgASWIuuG7jFHprVjghuAAlWiRSqAY4a3Nq2jqG1nsJ7qCQsLgAfSMF4d394iMM7Npc/KKS8rgAMSRgdHv5oJ4j49O07Mc+vRFgBVQjAGDHaamLbXRY/P4Ax7+SanULwKLzRbmKIuO71B7zaoQMCOADr31+/3J81Y+AAtGzvKx0DM4Eg4DAUmVoCBZEZfAKIHy4CBSOgqGysEgoHICg9IMZyOT4cB6rgsjkKG9iqUKpUIMZ7nBzIBG4Giokc5kBXOajqg9ocHoE/QMtq8ZIOcCgdIZGOZj1w1NohBdEqIuCCSHABTgAG9AIPAcCilgAvpoAw8nSZZtakfRM+ZcecopD7HWqlBqQtrdYXJnSY2ad6g2V0PhWLRKLqY+bLeSAKKBJNgAqsqMx4GpXj4ajK4BILApv2ZqIRQCBBFnAEEEKMsB8sx6BMVwAGJDSFrTA7Kx+P1BaRPaOYFa7ZXgnij6WxZbMev5nPiB5Fryp6qOoDh1o46a4ByfLwPU9CQEQ8AjHy6CsFKqBrLGejdHIayyAANHAWCkPA8IAOQsqAM5ijAUpMQUoqELR8BICyxZIZyWCDkgpADgKMgxpI9DkCwArqDG/JgHIWokDq9RwJhUqKRaMAqcQamSfCqAQDRcBasmwAyaYDyCkgdBQKwSC4d0AlwOwSb0MK7qSFA8JiuYSm0KwpAgBu6BCPYLmJsmZhVDp36Abyma1g2Tb9Nafptv6nYhrC8KOC+PZ9tFzH5vF5JwD+Vb4jBciOFSYDNuYmWpV29LEtl1K5XCMAFelUC9gmU4xWVY4ND+ZYoqB/41rB9YNU1LWtq1IYdR2XVwPSeW9d2A3FcNpWCJ+CXTdWiXItBtb1Z2i12i40HrW11oklsB6Pd1+W7YNJUpkd5XjedswgdVWaA69tVwddaUZXdwFeA9K2bc98NvYjW09X1RVDdOv1xWNDxVX+1YgZN57WiD+5g5dc3wa1t3w8e92ow1q0RIzcNM51T3EqjCMs0j22Y3t2MjX9+OVeTRP4iTQFk6d4FUweV31oATcD0/d7MIyrrOa5rzM5UjPMo1zH07YVwuubeLwUPQ5iPqIgLpW+nrNcQUqQhlgAJhIg9RrCsZFQAA8mUJGrMQjgADxwGIADMcCAORE1rewgvvEP76zB6HayOOlABEqDALn9ZHbUFWQciAByKBg5wvmEAA5hD805fg0YPMdE4HbO+BENMhD3gW3S9zAKeEIRgiptMnhAk0vh5i4o+ETspcHL4RzYr0sE3NaRBlLIIxsFw/exYvDxjOvhhTLLqLDAU8BXIV6TD6fRgANw74Qe9QAfff3oIL/mHTrITY2wCxGHgscCmN84BP0Pi/VkuBCD1HMmoLgm56DDxYAPFexAh6HwADIoCoH/NMU8+AzwSHPLwdQYqmEITAYhtswFkJWhCLeRJzC733ofLBsUaHMToUQyy9B+aCH4XfWg9DGHWjAZvDQLML49FJtAu+lxuywOMFI4Rb8P5fx/kfEh4jaCCIYdoqw2U9gVUpDlRROIpag0JMMDRMAtH3gQUg/uEBwA0TChgnhx8GyWJIHg4wuxoDrFIRKChIJeB5hLrQcJ/lmESlEelLh39/EhEQcgrxqDfEaUySInBISXHjkiaCaJS4eBxLgPgspy8gkUhSQbQq6T9G8PwKaUMTISCsG6CpYw1pGolw2oIdEPTiB8QqT6RQoVdKoHFKCSQRk2EDGGOYWxV8oLQPSOMgE/T6iDPmGASB9iCTb3MGUUgMYLhREWB7MAlFdmMn2QM+AxyjgfAqHs5k3RnaaB+b0xZ090qAsmQcw+Wh3xfO6fssoTkxJjJeeGFhhUwV9LeQyXC8hsmeO8WglMmCAnopKWEqAESJ6oqIrEixiT3TmHRcCngmyPaLDaYUxEQEriOLgKoh+6VnFkoiawd+7Lf7yA3iDbl28+XqOHkKsUIqCl6I5a5AAgqoHSekDJwCCIFVgrAiCN1YlwdAZloDKRgIQIKrIukd2CSapyQzNCw2SaCbWo0vwVTtCwtWL5fSPNhb8+F2LPnkB5Aan2Y9iBMGAKVcwIAvStAdIlaecATIwEqMqJM1LmVSBkHIAwgo41bkCJoRNNpHSVHzDgpliNzAAEVPUJRYaI1qkZRAxlPrG+NxbmKfKQSYYc/ACiEVzoAYMpc5VDgLnQAIZQzrgIEEdYcF2TrgE2udU6hgGG7b5Zify90pjLdWht2Sh31GXWOtd1a50LqXaOh4U7x2AGXCKd1AF0qCnRu2dW7BgGHHZUedZaAP/VwY6s1VyYzvsWA22d+Bw28XmIQyQVz0C7pLbbRNl5RBghTZBNNGas3METYuV0BhMgvxAIUOAmRkOoco9Rijqce0pkTWQ6j0hZASoFIe2gFwBm0AAI5pmrZUOiNbGl1oanmVMTaG3ibFl6gGrbOx5nMGWwQFaL6KHMKgYZ07AAmRFUBT6UsBCCMExR0qBhOCHk3AIzTbCpmYs+AbT1oFmCD7Ue4z666IFQMIoLz9Bj3rqLbxi4QRbKUAuKIBywBjDRngKmatIywAybExJq0KnqQycc3jJTBMpOqYC9aDTMpKpWfzF4ILi6fMNv84oQLvHasBS3tWwAyUTGccKeprGGYtb1TDaXLzbvVFZy9afkghK3uaYlVhz3QJBIHsPwErNXWsaEuS+EAjglvTp6zxvrWAiAPEG3AFWw3FMtuaeN1MSwRsNDVtltLpXy0VetBUKbXhE3axK7psrNWQv1fc7IRs7pbPdAAEz2eWJD7sznDWud+6gD7cBAAARFRSia2KhYEdA2hbVFHBLAa41tbZbBiDHSmUeqyx8BAA\"><code>PostCond</code> type</a> contains a failure \"continuation\" for every <code>ExceptT</code> in the stack. That said, this is not the only viable design. I think that if the one-specification-monad-to-rule-them-all <code>SatisfiesM</code> would have worked out, we could encode the same information syntactically rather than semantically via the semantics of <code>tryCatch</code>.<br>\nSo something like <code>SatisfiesM (tryCatch (.ok &lt;$&gt; e) (.error \\o pure)) (fun | .ok a =&gt; p a | .error e =&gt; q e)</code> would work (<code>tryCatch</code> is used to \"interpret\" <code>ExceptT</code> here).  </p>\n<blockquote>\n<blockquote>\n<p>allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework</p>\n</blockquote>\n<p>I am also curious about this statement. My current model of verified programming in DTT is that certain intrinsically-verified programs cannot be expressed extrinsically. Here is the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">tizio</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- imagined syntax</span>\n<span class=\"w\">    </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>In this program, the executable code includes an array-bound proof term derived from proofs about earlier parts of the program. I don't immediately see how this could be expressed extrinisically (i.e., write the code first and the prove it correct as a separate theorem), and I suspect that it cannot.</p>\n</blockquote>\n<p>By \"intrinsic\" above I was referring to taking a function that would type-check all on its own, and then augmenting its definition with <code>requires</code>, <code>ensures</code>, <code>assert</code> and <code>invariant</code> syntax to specify a contract intrinsically. I would hope that the ensuing verification conditions (predicate entailments) would be discharged by e.g. <code>grind</code> for maximal convenience.<br>\nThis would be equivalent to implementing a post-processing step that extracts <code>requires</code>, <code>ensures</code>, <code>assert</code>s etc. and turns them into an extrinsic specification that can be proven entirely by a fixed set of tactics.</p>\n<p>In your example, the function wouldn't type-check without the array-bounds proof, so that would not fall within the \"intrinsic specification\" use case.<br>\nOn a related note, <code>while True</code> and <code>partial def</code> is unlikely to be supported. Perhaps the definitions provided by the <code>partial_fixpoint</code> work can be utilized, but that is yet hard to anticipate.</p>",
        "id": 500126921,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739784296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319772\">Devon Tuma</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499942814\">said</a>:</p>\n<blockquote>\n<p>Me and <span class=\"user-mention silent\" data-user-id=\"246591\">Quang Dao</span>  would have a definite use case for this in verifying cryptographic code (see <a href=\"https://github.com/dtumad/VCV-io\">here</a>). Having a standardized program logic would be very useful to simplify proofs that currently require ad-hoc reasoning.</p>\n<p>Specifically to your questions, in our use case we've been writing algorithms using a relatively simple monad stack, the main definition being a type to represent computations with oracles, which we use for uniform selection, random oracles, security game oracles, etc.</p>\n</blockquote>\n<p>Indeed, that should work nicely. Can you give an example of a relational property you would like to see specified? That is, how would <code>triple</code> need to be generalized for your relational use case? Would something like this help? (NB: <code>$states → Prop</code> is like a set of <code>tupleOf $states</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reltriple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Example for a pre and postcondition modelling non-interference on <code>StateT {secret : Bool, public : Nat} Id</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">secret</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">secret</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">public</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">public</span>\n</code></pre></div>\n<p>(The interpretation of these predicates in <code>reltriple</code> must be monotonic.)</p>\n<p>The problem with the relational case is that the design space is so large.</p>\n<ul>\n<li>I think the definition <code>reltriple</code> above characterises many 2-properties (of the same program), but some relational properties want to relate <em>two different programs</em> with each other, and the above does not allow for that.</li>\n<li>There is also the question of whether one wants to relate a code path that throws a particular exception <code>ε</code> with a successful execution returning an <code>α</code>. This affects the encoding of <code>PostCond</code>.</li>\n</ul>\n<p>I think we might want to hold back on this feature until we have more information on what kind of relational properties people want to express.</p>",
        "id": 500132682,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739785679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500104446\">said</a>:</p>\n<blockquote>\n<p>Hi, this sounds quite interesting. I am currently not working with Lean, but I am quite interested in using it for Iris-based verification in the future.<br>\n We recently presented a modular method for building program logics at POPL: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3704847\">https://dl.acm.org/doi/pdf/10.1145/3704847</a><br>\nOur approach is based on the free monad (or more concretely its implementation in Rocq in the form of interaction trees) and it allows one to modularly combine different effects in a program and reuse proofs. In particular, I think this approach provides a higher degree of modularity and reuse than an Dijkstra-monad-based approach.</p>\n</blockquote>\n<p>Great work! That looks like a neat approach if you want to reason about your own bespoke object language.<br>\nThough a small nit: Judging from the non-structural recursion in the application case in Fig. 9 I think I would have referred to the approach as \"coinductive big-step\" rather than \"denotational\".<br>\nOn the other hand, this makes me realize that my use \"denotational\" in the OP could perhaps be weakened to \"coinductive big-step\". That said, the program logic will only be useful to reason about calls to the <em>interpreter</em>, and not so much for reasoning about expressions in the object language; that would require bespoke specification lemmas and perhaps an entire tactic stack on top. At this point, I'm unsure whether the program logic is so useful at all for this use case...</p>\n<p>Just this weekend I had a look at the <a href=\"https://lthms.github.io/FreeSpec/coq/FreeSpec.Core.Impure.html#impure\">FreeSpec library</a> which is based on free monads, but they don't really apply it to a language with an interesting semantics...</p>\n<p>Regarding Iris: the goal of the planned framework is to provide a program logic for reasoning about programs written <em>in Lean as shallowly-embedded object language</em>. It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean. <br>\nThe program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>",
        "id": 500148363,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739789360
    },
    {
        "content": "<p>Thanks for your thoughts on this!</p>\n<blockquote>\n<p>Though a small nit: Judging from the non-structural recursion in the application case in Fig. 9 I think I would have referred to the approach as \"coinductive big-step\" rather than \"denotational\".</p>\n</blockquote>\n<p>I guess it depends on the view point and we also had some discussion about whether to use \"denotational\" or some other term when writing the paper. We landed on \"denotational\" since I would argue that one can view InteractionTrees as a semantic domain that we denote our expressions into, but one can argue about it. (In fact, I would see the non-structural recursion you mention as an argument for calling the approach denotational since we denote recursion into a recursion combinator of the semantic domain instead of doing the fixpoint ourselves, but I guess this is a matter of perspective.)</p>\n<blockquote>\n<p>That said, the program logic will only be useful to reason about calls to the <em>interpreter</em>, and not so much for reasoning about expressions in the object language; that would require bespoke specification lemmas and perhaps an entire tactic stack on top.</p>\n</blockquote>\n<p>I should clarify: The Program Logics a la Carte paper has two parts that can be separated: First, it provides a program logics for effectful programs (in the form of interaction trees) that provides nice modular reasoning principles. Second, it shows how use can use this program logic to build programs logics for object-level languages for it. For your purposes, only the first part is really relevant and I think you can ignore all parts about the object level languages. (This might be interesting to look at in the future, but probably not in the initial step.)</p>\n<blockquote>\n<p>Just this weekend I had a look at the <a href=\"https://lthms.github.io/FreeSpec/coq/FreeSpec.Core.Impure.html#impure\">FreeSpec library</a> which is based on free monads, but they don't really apply it to a language with an interesting semantics...</p>\n</blockquote>\n<p>At least from my perspective, <a href=\"https://github.com/DeepSpec/InteractionTrees/tree/master\">interaction trees</a> have superseeded the FreeSpec library as the canonical implementation of free monads in Rocq, so I would look at them instead. There have been quite a few interesting semantics formalized using interaction trees at this point (see e.g. the paper).</p>\n<blockquote>\n<p>The program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n</blockquote>\n<p>Just to make sure that we are one the same page: The Program Logics a la Carte paper proposes to replace this program logic part of Iris that is geared towards operational semantics of deeply-embedded languages with the denotational approach to interaction trees. I think the denotational way has significant advantages (in particular wrt. modularity) and if Iris gets ported to Lean, it might make sense to port the denotation approach to build a program logic instead of the old operational semantics based one.</p>\n<blockquote>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>\n</blockquote>\n<p>This is actually something something that surprised me when working on that paper, but the approach we use there and which is not too different from what you are proposing, scales to a surprisingly large number of effects. In the paper, we support the following effects among others: state, non-determinism, undefined behavior, aborting, concurrency, I/O with trace properties, non-termination. However, some of these effects rely on the expressiveness of Iris (e.g. non-termination relies on step-indexing), but maybe it is possible to achieve a similar large set of effects for your approach. </p>\n<blockquote>\n<p>It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean.</p>\n</blockquote>\n<p>This makes a lot of sense and I fully agree with this goal. To be clear, I don't want to argue that it makes sense to directly use the approach from the paper, instead I just want to share my perspective as someone who has worked on similar problems in the past and hope that this is useful for finding a solution that works well for Lean.</p>",
        "id": 500156586,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1739791361
    },
    {
        "content": "<p>Thanks again for your reply! I will definitely have a closer look at the first part of your paper then.<br>\nIt is pretty likely that interaction trees are out of scope as an out-of-the-box instance of <code>MonadTriple</code> because there currently is no formalisation of interaction trees in Lean's standard library. However, I would hope that your paper will guide me to a framework which could be instantiated for a user-written interaction tree library.</p>",
        "id": 500162133,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739792808
    },
    {
        "content": "<p>Hi, this would be really useful for the <a href=\"https://github.com/AeneasVerif/aeneas\">Aeneas project</a> that I'm working on (in collaboration with Jonathan Protzenko and others) where we do extrinsic proofs about pure models generated from Rust code and which live in an error monad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"c1\">-- for partial_fixpoint</span>\n</code></pre></div>\n<p>We had to put a fair amount of work into writing a <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/backends/lean/Aeneas/Progress/Progress.lean\"><code>progress</code></a> tactic to do proofs in a Hoare-logic style and which is a bit equivalent to CFML's <code>xapp</code>, though in our case we are not concerned about framing separation logic specifications but rather about automatically discharging preconditions.</p>\n<p>For now, because we only work with one monad and do not specify failing or divergent executions (we prove total correctness theorems) we write our theorems in a very specific shape (<code>progress</code> is mostly syntax driven - I would like something more general of course). For instance, this is the theorem to reason about addition about U32 machine integers and that <code>progress</code> knows how to manipulate (it automatically looks it up whenever seeing a call to <code>+</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">progress</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- saves the theorem in the relevant database</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">U32.add_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U32</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hmax</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">U32.max</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">-- precondition</span>\n<span class=\"w\">  </span><span class=\"c1\">-- there is generally a list of preconditions, and which live in different theories (i.e., require different solvers)</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"c1\">-- there are usually several existentially quantified variables</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- post-condition</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"bp\">....</span>\n</code></pre></div>\n<p>This is a specific class of proofs, but quite informative of what we need in practice, I believe, and I have a few examples of proofs that you can have a look at. For instance, there is the <a href=\"https://github.com/AeneasVerif/aeneas/blob/29d05d86d410d469a6979409777e869a390efbfc/tests/lean/Tutorial/Solutions.lean#L414\">tutorial</a> which showcases proofs about list-manipulating functions and a (minimal) big num library. We also have proofs about an <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/tests/lean/Avl/Properties.lean\">AVL tree</a> and a <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/tests/lean/Hashmap/Properties.lean\">hashmap</a> (the latter one is quite old and needs deep cleaning). I'm currently working on the verification of a Rust implementation of the ML-KEM post-quantum cryptographic primitive (not public yet).</p>\n<p>I believe there are quite a few things that need improvement and that would benefit from a more systematic approach.</p>\n<ol>\n<li>\n<p>For now, we only work with an error monad but in the future we will have to work with code which lives in more expressive monads to reason about some form of aliasing, I/O, or concurrency. An extremely useful feature would be a way of seamlessly switching between monads, for instance by having a way of lifting theorems (from, say, an error monad to a state error monad). Also, I mentioned that we currently only prove total correctness theorems, but users of the framework may also want to prove partial correctness theorems. It would be nice to have a way of easily switching between partial correctness and total correctness proofs, in particular by factoring theorems out. For instance, it should be possible to write a correctness theorem about <code>+</code> which specifies both the <code>ok</code> and <code>fail</code> cases, and use it in both partial and total correctness proofs, in the latter case by using the specification of <code>fail</code> as a precondition that has to be disproved.</p>\n</li>\n<li>\n<p>It is currently not extremely convenient to reason about sub-expressions; the problem of loops has been mentioned above, but I also need a way of easily reasoning about expressions like this (today <code>progress</code> is good at reasoning about <em>function calls</em>):</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>(those are maybe more of technical details at this stage, but I think it's important to mention them to inform about the proof experience) so far, most of the work has been put into writing the <code>progress</code> tactic so that the proofs are smooth, in particular when it comes to discharging pre-conditions. This tactic uses several simple, yet extremely useful tactics (<code>simp</code>, a tactic which looks a bit like <code>assumption</code> but which uses more clever heuristics to instantiate meta-variables, and a solver based on <code>omega</code>) - I can share a document about this if you are interested. Those tactics are currently hardcoded, but in the future we want them to be customizable: one non-obvious problem here is how to quickly figure out which solver should be applied on which precondition (we can't just try them one after the other as they tend to be expensive). It can also happen that we want to switch between different flavours of \"spec\" theorems depending on the program we verify. For instance I mentioned the problem of partial vs total correctness above. Another example is that in most situations today we want to use the <code>+</code> theorem I showed above which specifies addition in terms of <code>Int</code>, but when reasoning about a function performing bitwise operations we want to systematically lookup theorems which specify arithmetic operations in terms of bitvector operations, etc.</li>\n</ol>",
        "id": 500163298,
        "sender_full_name": "Son Ho",
        "timestamp": 1739793135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500163298\">said</a>:</p>\n<blockquote>\n<p>do not specify failing or divergent executions (we prove total correctness theorems) we</p>\n</blockquote>\n<p>You man “partial correctness”, right?</p>",
        "id": 500180060,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500180060\">said</a>:</p>\n<blockquote>\n<p>You man “partial correctness”, right?</p>\n</blockquote>\n<p>I was slightly imprecise. I believe a partial correctness theorem would go like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>In our case we prove panic freedom which means our theorems are total correctness theorems I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">/\\</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>But because here <code>fail</code> actually models a <code>panic</code> in Rust, and as it is possible to recover from panic in some situations, we may want to prove theorems of the following shape:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- something like this probably?</span>\n</code></pre></div>",
        "id": 500183173,
        "sender_full_name": "Son Ho",
        "timestamp": 1739798032
    },
    {
        "content": "<p>Ah, yes, that looks like total correctess to me. I misread the prose then.</p>",
        "id": 500200854,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739802067
    },
    {
        "content": "<p>Thanks, Son Ho, your pointer to Aeneas' <code>progress</code> tactic and its examples will be incredibly valuable. I think I'm already starting to encounter similar challenges in the examples I'm looking at (without a tactic such as <code>progress</code>). The <code>Result</code> type seems entirely reasonable to instantiate <code>triple</code> for.</p>\n<blockquote>\n<p>more expressive monads to reason about some form of aliasing, I/O, or concurrency</p>\n</blockquote>\n<p>As alluded to in <a class=\"message-link\" href=\"/#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499767219\">#Program verification &gt; Monadic program logic: Request for feedback @ 💬</a>, I have played around with an encoding of separation logic, but realized that you would need to somehow restrict the kinds of computations that end up in the heap to a closed universe, so that its entries can have <code>Type 0</code> rather than <code>Type 1</code> for the general <code>Σ α, α</code>. For this reason, I do not yet have plans to include a monad transformer adding a separation logic-based heap out of the box, but since the syntax of predicates is the same as for <code>StateT</code>, we could nurture such a transformer in a separate library first. I do not yet know how to model concurrency in this framework appropriately.</p>\n<blockquote>\n<p>This tactic uses several simple, yet extremely useful tactics [...]. I can share a document about this if you are interested.</p>\n</blockquote>\n<p>I would be very interested in that. It is something that I have been wondering as well, but put on my backlog because it is impossible to solve without seeing concrete instances, which I hopefully will see soon.</p>",
        "id": 500214056,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739805018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500214056\">said</a>:</p>\n<blockquote>\n<p>I would be very interested in that.</p>\n</blockquote>\n<p>I wrote this down in my <a href=\"https://www.sonho.fr/papers/thesis-manuscript.pdf\">PhD dissertation</a>, chapter 14.3.3 \"Hoare-Logic Style Proofs and the progress Tactic\". I will be very happy to provide additional feedback if you have questions.</p>",
        "id": 500217205,
        "sender_full_name": "Son Ho",
        "timestamp": 1739805724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500214056\">said</a>:</p>\n<blockquote>\n<p>but since the syntax of predicates is the same as for <code>StateT</code>, we could nurture such a transformer in a separate library first</p>\n</blockquote>\n<p>Yes, at this stage I'm also not sure what's the best way to proceed and what I will <em>actually</em> need either. But I intend to study the problem of verifying stateful code (i.e., code which I can't model only with an error monad) later this year: this should provide interesting insights about how to combine these kinds of reasonings.</p>",
        "id": 500220718,
        "sender_full_name": "Son Ho",
        "timestamp": 1739806507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500148363\">said</a>:</p>\n<blockquote>\n<p>Regarding Iris: the goal of the planned framework is to provide a program logic for reasoning about programs written <em>in Lean as shallowly-embedded object language</em>. It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean. <br>\nThe program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>\n</blockquote>\n<p>My inclination regarding this is that you should take care to separate the <em>syntax</em> of do notation programs with invariants from the <em>interpretation</em> of those programs and specifications wrt lean shallow embedding. I agree that lean shallow embedded programs should be the main focus, but it should be possible to leverage some parts of the frontend to do similar things even if the specification language is something fancy. </p>\n<p>This is more or less what I mean by \"working together with iris-lean\": it should be possible for iris-lean to present an interface that feels native to the greatest extent possible. I don't want to tie your hands too much here, but please don't do like <code>do</code> did and make a completely non-extensible system (and leave it unmaintained for a long time). I'm sure you weren't really thinking of doing so anyway, but I want to stress that extensibility and pluggability of the architecture is very much a use case that matters to me.</p>",
        "id": 500289419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739834884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> I just found this thread. I am literally right now trying to verify some code that uses do notation and running into the issue that I don't have for loop pre- and post-conditions! (In particular, it makes working with mutable arrays where I want to prove facts about their size at the end of the loop quite tricky.)</p>",
        "id": 507043386,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742493809
    },
    {
        "content": "<p>In general I am very interested in this work.</p>",
        "id": 507043689,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742493893
    },
    {
        "content": "<p>You could give my prototype a try; here's an example for proving a loop-based fibonacci function correct: <a href=\"https://github.com/sgraf812/mpl/blob/682c1f7ef8dfee8f1b565338c5a8f3c80d6442f1/Tests/Toy.lean#L284\">https://github.com/sgraf812/mpl/blob/682c1f7ef8dfee8f1b565338c5a8f3c80d6442f1/Tests/Toy.lean#L284</a>.<br>\nDislaimer: Not \"ready for production\" yet.</p>\n<p>What kind of code are we talking about? What kind of mutable arrays in particular? Is it the local kind of mutability, i.e. just <code>let mut arr : Array Blah := ...</code>?</p>",
        "id": 507045922,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1742494670
    },
    {
        "content": "<p>Yes, it's nothing particularly fancy. Though it uses vectors rather than arrays which makes the types more of a headache.</p>",
        "id": 507538742,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742714357
    },
    {
        "content": "<p>I think the dust on the semantic foundations and the general UX vision for manual proofs has settled.<br>\nIt's time to elicit a bit of guinea pig feedback! You can depend on <code>mpl</code> by adding the following <code>requires</code> to your lakefile.toml:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[[</span><span class=\"n\">require</span><span class=\"o\">]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"mpl\"</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"https://github.com/sgraf812/mpl\"</span>\n<span class=\"n\">rev</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"pre-release\"</span>\n</code></pre></div>\n<p>Alternatively, you can just clone the repository and play with the files in <code>Test/</code>, such as <code>Test/Toy.lean</code>.</p>\n<p><strong>Bear in mind that this not an official release! This library is not ready for production use. Please do not emphatically share this request. The automation is still hacky and underdeveloped and subject to change.</strong> </p>\n<p>I would be very happy for you to <code>import MPL</code>, give it a go and let me know about the general proof mode UX (examples in <code>Test/Toy.lean</code>). I am specifically interested in your opinion on</p>\n<ol>\n<li>The semantic foundations. Hoare triples are encoded based on a notion of predicate transformers that is parameterized by a <code>PostShape</code> parameter. Batteries are included for the typical transformer primitives (<code>StateT</code>, <code>ExceptT</code>, <code>Id</code>, a better-behaved <code>Idd</code>, <code>IO</code>). Would you say this is enough for your use case? </li>\n<li>The Iris-like proof mode for manipulating stateful hypotheses in a pointfree way, one that does not require repeated introduction of state variables. (Check out <code>Test/ProofMode.lean</code> for a comprehensive set of small examples.)</li>\n<li>The prototypical syntax in the README.md that extends <code>def</code>-elaboration with support for intrinsic verification features (<code>requires</code>, <code>ensures</code>, <code>invariant</code>). It bears repeating: You will find the proof automation lacking once you type in more complicated examples; this is mostly about the general look and feel for now. You have to <code>import MPL.Experimental</code> to opt into that feature. </li>\n</ol>\n<p>Next up on my agenda is writing an actual verification condition generator that replaces the <code>simp</code>-based <code>mwp</code> tactic and grow that in parallel with small to medium-sized verification projects. We were thinking about a congruence closure algorithm; any other ideas?</p>",
        "id": 514391777,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1745591052
    },
    {
        "content": "<p><a href=\"https://github.com/sgraf812/mpl\">https://github.com/sgraf812/mpl</a></p>",
        "id": 514683754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745787372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> this looks nice. I have yet to get a full overview. Are you planning a write-up?<br>\nThe automatic proofs of equivalence between imperative and functional code are nice.<br>\nWe added them in the Rocq backend for Hax some time ago (for the state monad):<br>\n<a href=\"https://eprint.iacr.org/2023/185\">https://eprint.iacr.org/2023/185</a></p>",
        "id": 515557624,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1746124111
    },
    {
        "content": "<p>It looks like your Idd would be replaced by <a href=\"https://github.com/leanprover/lean4/pull/7352\">lean4#7352</a></p>",
        "id": 515639580,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1746162544
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/515557624\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> this looks nice. I have yet to get a full overview. Are you planning a write-up?<br>\nThe automatic proofs of equivalence between imperative and functional code are nice.<br>\nWe added them in the Rocq backend for Hax some time ago (for the state monad):<br>\n<a href=\"https://eprint.iacr.org/2023/185\">https://eprint.iacr.org/2023/185</a></p>\n</blockquote>\n<p>Thanks! Unfortunately, a write-up is not on my agenda yet; building automation currently has my full attention.<br>\nYour work on relating Hac with Jasmin programs looks interesting, thanks for sharing. One open semantic question of <code>mpl</code> is whether translating <code>StateM σ α</code> into assertions (i.e., preconditions) of the form <code>σ -&gt; Prop</code> is really future-proof with a hypothestical future in which <code>mpl</code> builds on separation logic, for example to verify code using <code>ST.Ref</code>. Then it seems that having <code>σ -&gt; HProp</code> (where <code>HProp ~= Heap -&gt; Prop</code>) seems like a redundant encoding if <code>StateM σ m</code> can be encoded like <code>let mut</code> in your pure functional Hac translation, that is, allocating a \"static\"/\"global\" heap location for each <code>StateT σ</code> wrapper in the monad stack. This is also what AutoCorrode does (see for example <a href=\"https://awslabs.github.io/AutoCorrode/Unsorted/AutoCorrode/Micro_Rust_Examples.Showcase.html\"><code>swap_ref_contract</code></a>). However, this all hinges on whether future <code>mpl</code> will build on separation logic, which would sacrifice a lot of simplicity of the current approach.<br>\nI wonder: You write that you have a model of the global heap. Does this model include some notion of separating conjunction in the logic? How do you cope with aliasing? Presumably you rely on <code>let mut</code> aliasing being syntactically apparent? Edit: Ah, 5.4 has some discussion about disjointness. Sounds quite involved...</p>",
        "id": 515649825,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1746168094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/515639580\">said</a>:</p>\n<blockquote>\n<p>It looks like your Idd would be replaced by <a href=\"https://github.com/leanprover/lean4/pull/7352\">lean4#7352</a></p>\n</blockquote>\n<p>Indeed! Fixing <a href=\"https://github.com/leanprover/lean4/pull/7352\">lean4#7352</a> would make <code>Idd</code> unnecessary. It's somewhere on my backlog to take over your patch unless you merge it first :)</p>",
        "id": 515650132,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1746168264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> The equivalence proof between imperative and functional code, is before the connection with jasmin, although it extends to it. We haven't considered the connection to separation logic yet (only superficially), as we are mainly concerned with cryptographic code, where this seems less relevant.</p>",
        "id": 516024564,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1746362362
    },
    {
        "content": "<p>re. question 5 in your initial post, you might want to look at <a href=\"https://dl.acm.org/doi/10.1145/3729311\">PulseCore</a>. I haven't been following either project very closely so I'm not sure how similar they are at technical level, but it's an iris-like logic for shallowly-embedded monadic programs (in F*) which seems at least adjacent to your work.</p>",
        "id": 524980537,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1750397761
    },
    {
        "content": "<p>Indeed, their use of indirection theory (which I had not been aware of) to define step-indexed heaps and predicates is very interesting. Much less conceptual overhead compared to Iris' COFE setup, it appears. Would be a great fit for verifying programs in a monad that has an inherent or synthetsized notion of time/step-indexing. In my Lean experiments so far, I haven't seen any. However, if one were to define separation logic for <code>ST</code> on top of MPL, indirection theory sounds like a good fit.</p>",
        "id": 525297766,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1750673515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> : I want to try out mpl, but before that I would like to ask: does it support the notion of ghost states like iris. If so, is there a specific example I should look at in the repo?</p>",
        "id": 526285611,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751220578
    },
    {
        "content": "<p>Here I just mean variables that are not accessible in the code, only in the verification conditions.</p>",
        "id": 526285662,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1751220640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/stream/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/526285611\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> : I want to try out mpl, but before that I would like to ask: does it support the notion of ghost states like iris. If so, is there a specific example I should look at in the repo?</p>\n</blockquote>\n<p>I archived <code>mpl</code> on Friday after I merged my work into Core. The easiest way is to pick a nightly after 06-27 and <code>import Std.Tactic.Do</code>, then state the specs you want and use <code>mvcgen</code> to prove them. This is not an official release yet, but I'm very happy for feedback from early adopters. In the next Q, I'll be working on Markus' <a href=\"https://github.com/TwoFX/human-eval-lean/tree/master\">human-eval-lean</a> project for dog fooding and examples.</p>",
        "id": 526335934,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1751268696
    },
    {
        "content": "<p>Re: ghost state. The framework supports ghost variables, that is, schematic variables of the specification <code>{{P}} prog {{Q}}</code> that occur only in <code>P</code> or <code>Q</code>, but not in the program <code>prog</code>. <a href=\"https://github.com/leanprover/lean4/blob/9bbd2e64aac28fc4586c32ee0403d90d425d14c3/src/Std/Do/WP/Basic.lean#L47\">This spec</a> </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">mkFreshNat_spec</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">WPMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">sh</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"bp\">⌜#</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">mkFreshNat</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n</code></pre></div>\n<p>can be considered an example of this. It simply gives names <code>n</code> and <code>o</code> to parts of the pre-state. I think this is in line with \"variables that are not accessible in the code, only in the verification conditions\".</p>\n<p>This is of course a far cry from what systems such as Iris or Why3 consider ghost state. Such advanced notions of ghost state should be modeled by a custom <a href=\"https://github.com/leanprover/lean4/blob/9bbd2e64aac28fc4586c32ee0403d90d425d14c3/src/Std/Do/WP/Basic.lean#L47\"><code>WP</code></a> instance that reflects the notion of ghost state that is specific to your particular monad into a heap-like structure that is part of the <code>σ</code> in <code>PredShape.arg σ</code>. </p>\n<p>So for example when your program monad has a notion of time/step-indexing, then you can define your heap model in terms of this stratification and a notion of ghost state as well. I have not attempted anything like it yet, because the main intended use case of the logic is simple <code>StateT</code>/<code>ExceptT</code> wrappers without much dynamic memory allocation and certainly no notion of a runtime-relevant \"program counter\" which is often present in a deep rather than shallow embedding of a program semantics. </p>\n<p>So TLDR; if you want Iris-like \"ghost state\" then first we need to clarify what monad your programs run in in order to define what \"ghost state\" means. Then we can perhaps find a way to generalize many different kinds of monad-specific \"ghost state\" notions in a reusable library.</p>",
        "id": 526339533,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1751270004
    },
    {
        "content": "<p>How could I type this dafny program into lean with the new syntax?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">method</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">&lt;</span><span class=\"n\">int</span><span class=\"bp\">&gt;</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">&lt;</span><span class=\"n\">int</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">returns</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">res</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"bp\">&lt;</span><span class=\"n\">int</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span>\n<span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Length</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">Length</span>\n<span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"bp\">.</span><span class=\"n\">Length</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Length</span>\n<span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"bp\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">Length</span><span class=\"w\"> </span><span class=\"bp\">==&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">==</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"o\">{}</span>\n</code></pre></div>",
        "id": 526689391,
        "sender_full_name": "Alok Singh",
        "timestamp": 1751407468
    },
    {
        "content": "<p>Hmm. The idiomatic way to implement <code>add</code> is via <code>zipWith</code> and that wouldn't be monadic. You wouldn't use Hoare logic to prove it correct.</p>\n<p>The slightly less idiomatic way would be define <code>add</code> in <code>Id</code> and use a for loop:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"bp\">.</span><span class=\"n\">emptyWithCapacity</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">min</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">get_elem_tactic</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n<span class=\"w\">    </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"bp\">.</span><span class=\"n\">push</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">res</span>\n\n<span class=\"kd\">@[</span><span class=\"n\">grind</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">range_elim</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range'</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">++</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"n\">n</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range'</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">head</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">range'</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">    </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"m\">2</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">omega</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">add_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">⦃</span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n<span class=\"w\">    </span><span class=\"n\">add</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">add</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"bp\">.</span><span class=\"n\">pref</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ha</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">all_goals</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">grind</span>\n</code></pre></div>\n<p>The bounds checks are annoying; I would try to refactor <code>add</code> to use <code>Vector</code> if possible.</p>\n<p>As you can see by the use of <code>simp_all</code>, I haven't yet learned enough about <code>grind</code> to come up with the proper annotations in the logic. By the end of the Q it should just be <code>all_goals grind</code>.</p>",
        "id": 526761522,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1751449602
    },
    {
        "content": "<p>Shameless self-promotion: I have written a blog post about my initial experiences with the monadic verification framework: <a href=\"https://markushimmel.de/blog/my-first-verified-imperative-program/\">https://markushimmel.de/blog/my-first-verified-imperative-program/</a> Feedback is welcome.</p>",
        "id": 527342464,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1751802883
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> The paper link in footnote 1 of your blog post is broken.</p>",
        "id": 527363710,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1751826139
    },
    {
        "content": "<p>Maybe due to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/channel/113488-general/topic/Discussion.3A.20New.20lean-lang.2Eorg/with/527362820\">#general &gt; Discussion: New lean-lang.org</a>? :D</p>",
        "id": 527364782,
        "sender_full_name": "Joscha Mennicken",
        "timestamp": 1751827374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527363710\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> The paper link in footnote 1 of your blog post is broken.</p>\n</blockquote>\n<p>Fixed, thanks.</p>",
        "id": 527364870,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1751827452
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> I have some questions about your blog post:</p>\n<ol>\n<li>After the <code>mvcgen</code>, I see 6 goals in InfoView.  What exactly does the subsequence <code>case</code>tactic do to them?</li>\n<li>After the <code>case</code>, I see 5 goals which look very different from the previous 6 goals.  Where do they come from?</li>\n<li>Would it be possible for the assertions in Hoare triples to be interspersed with the code?  If the loop body itself has a relatively complex control flow, wouldn't the <code>mvcgen</code> produce many more VCs which would be hard to keep track of?</li>\n</ol>",
        "id": 527540865,
        "sender_full_name": "Ching-Tsun Chou",
        "timestamp": 1751914537
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527540865\">said</a>:</p>\n<blockquote>\n<p>After the <code>mvcgen</code>, I see 6 goals in InfoView. What exactly does the subsequence <code>case</code>tactic do to them?</p>\n</blockquote>\n<p><code>case</code> focuses on the goal with the given name (which is the first goal in this case).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527540865\">said</a>:</p>\n<blockquote>\n<p>After the <code>case</code>, I see 5 goals which look very different from the previous 6 goals. Where do they come from?</p>\n</blockquote>\n<p>They are the remaining goals after closing the first goal. They look different than before the <code>case</code> tactic because they mention the loop invariant, which appears as <code>?inv</code> before the <code>case</code> block and is replaced by the provided loop invariant after the <code>case</code> block.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110637\">Ching-Tsun Chou</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527540865\">said</a>:</p>\n<blockquote>\n<p>Would it be possible for the assertions in Hoare triples to be interspersed with the code?</p>\n</blockquote>\n<p>There were some experiments with this as seen <a href=\"https://github.com/sgraf812/mpl/blob/1dbf6bc75ff5398f59b77ae320f1f0a0781b721e/Test/Demo.lean#L18\">here</a>, but you'll have to ask <span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> what the status is.</p>",
        "id": 527546016,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1751916114
    },
    {
        "content": "<p><a href=\"https://github.com/Beneficial-AI-Foundation/NumpySpec/tree/main/NumpySpec\">https://github.com/Beneficial-AI-Foundation/NumpySpec/tree/main/NumpySpec</a> has a bunch of autogenerated examples with the new syntax. They’re all sorried rn</p>",
        "id": 527579171,
        "sender_full_name": "Alok Singh",
        "timestamp": 1751929464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260921\">Markus Himmel</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527546016\">said</a>:</p>\n<blockquote>\n<p>Ching-Tsun Chou <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527540865\">said</a>:</p>\n<blockquote>\n<p>Would it be possible for the assertions in Hoare triples to be interspersed with the code?</p>\n</blockquote>\n<p>There were some experiments with this as seen <a href=\"https://github.com/sgraf812/mpl/blob/1dbf6bc75ff5398f59b77ae320f1f0a0781b721e/Test/Demo.lean#L18\">here</a>, but you'll have to ask Sebastian Graf what the status is.</p>\n</blockquote>\n<p>The PoC over there was promising, but we'll revamp <code>do</code> elaboration in Q4 and will add the syntax for invariants etc. as part of that in Q4, so you'll have to wait a bit more.</p>",
        "id": 527613041,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1751956475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"337670\">Alok Singh</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/527579171\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/Beneficial-AI-Foundation/NumpySpec/tree/main/NumpySpec\">https://github.com/Beneficial-AI-Foundation/NumpySpec/tree/main/NumpySpec</a> has a bunch of autogenerated examples with the new syntax. They’re all sorried rn</p>\n</blockquote>\n<p>Files like <a href=\"https://github.com/Beneficial-AI-Foundation/NumpySpec/blob/main/NumpySpec/Numpy_Absolute.lean\">https://github.com/Beneficial-AI-Foundation/NumpySpec/blob/main/NumpySpec/Numpy_Absolute.lean</a> give the error (which doesn't show up in infoview but does on <code>lake build</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: NumpySpec/Numpy_Absolute.lean:26:5: type mismatch\n  ∀ (i : Fin n), result[i] = x[i].abs\nhas type\n  Prop\nbut is expected to have type\n  Assertion PostShape.pure\n</code></pre></div>\n<p>Other files have the same issue, but the code seems innocuous. Same error even if I replace the absolute function with an actual impl.</p>",
        "id": 527774371,
        "sender_full_name": "Alok Singh",
        "timestamp": 1752009822
    },
    {
        "content": "<p>Note that <code>Assertion PostShape.pure</code> is defeq to <code>Prop</code>, which makes this error all the more puzzling.</p>\n<p>My guess is that it is the same underlying issue as <a href=\"https://github.com/leanprover-community/mathlib4/pull/8766\">#8766</a> and it would be fixed by <a href=\"https://github.com/leanprover-community/mathlib4/pull/9256\">#9256</a>. Unfortunately, I had to shelve the patch yesterday after realizing that it breaks type class inference in Mathlib. It's unlikely that we'll see this fix landed.</p>\n<p>Try and wrap your <code>Prop</code> in <code>⌜⌝</code>, <code>⌜∀ (i : Fin n), result[i] = x[i].abs⌝</code>. That should work reliably. You will also be required to do that in the next release due to universer polymorphism changes (then we'll have <code>Assertion PostShape.pure =?= ULift Prop</code>)</p>",
        "id": 527813301,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1752041141
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> , thanks for the nice work on monadic reasoning! I am currently playing with your framework (especially using State monad), and have some questions (note: I am a beginner in Lean, although knowledgeable in other proof assistants).</p>\n<p>I have 4 low-level questions, <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAZRgEwHQBUCGBjGxuoAiEAUKJLIihjngcaggJ4B2MmAHmeNPEsiRIQwAUxZU0xQZ2AQQcQpnYAuOOiai4ABhIy5agBYikSkavWadujrPlgoI5AEY4ACmTLF7AJRuAzjDK6EYmMCLeqgAKUMLWtnD2jgBMbh5emL6uAUEh7GERcNGxcfoBpgD6wCwAbphQwJhs/oHBxnnhUTFg0gBGPQ7VcACycMoAvFSm6IZtpnAAkgIkyCIAZnCrAK4sTqoj6aMTftBQTMtrG9sprhyeShmjw3AAqizA8ONwx1Cn0jb6iWclXAABtgCI/OVAUlVKtoJgQSC4BwvjAADQJBzOZGouCAJMJMckcQFBAABADaflE2AAuiV5FsduUqSJsMoSHA4IBgylRFSqtXqjXggBDKDmXHZigC0krgAEVNhC8BBxLsFn44DAjA44Jg4NgIBAkSwIHlZOI4VBChAAgBhZVoMB1PAIjUGJQLOAgYB+PyOAD8Yp5/CIEFQkWtMDtLAdToaSNcjOJ8DGAD5eWFKjU6g0mgE4IByIkJ2JRed8os50rlCoCZrgMLgAHUDExXSINoaQRAAO5VADmcGQEAhLAA5PAu9AANZ+twIzUQTa9gxwd5wCdQSfq5XipLM6neKUyoPUBjh2321CO2BxtyJlGp9MiTMCnPwQuAlwcMtkynUul6Bkrj3Vl2U5HkygzflsyFAsixSFFyx3ZFAwkEMwwjKMY2vF0E22OByjgB8IKfKDBTYb9znWMJsieV5V0+QcxRBER4BRQAEwnFJwxUZeDBE1ERoBEeRqJgYC2TFMDH2faCmkQzkRIk7lUNPDCLyvZ140TAiiPaaSyJgb9OU5T4ejOIyjKgLs4HJES6XMzkQGqbBezERTOQAdrgSt5UVWsAGZQPsisZXmNcYJgCAVzYGJkE2bA234x84G3RLmNWeBGmQOB6iXeAIHWAADQAiokAbIICrRNyjMrULsEwEA202MA13eZdErhRFuz7DFvVbbVdRAQSV2QWwlHwMKmADILgrcE0tVdRoBzWKo+09Ftu3EdhcHwA8pp1MAwBBFsEGiRxUDEdhgBBSF9RYSEqhgGJKs5e7Ht2vxyCeryZR8mttwAFkCoLK347UeprREdXEAqqSxAqotbOBewgBEKt2ysek2eAwZEIT1U1d0Ct7epozhnqejqnoDQAL2YrLTJXGB1USX0WHi0ZXE+t1qjbT4P2BA7wUhaFPqJqoBDRmUADEceQcnsEnOBVXJrKRB+aBPQhPxMBc5rNTgAqvWiiACs+ysuyMcRQrdLLjSGkRdXN91Qq7TB1UHLqPQe8FxamysHJe0gJchrKkfgRLVZiKBTZleTIs2X19cNh7jYxA77YTqpsBBTYVn18heFQrAtvoY3o51EF50XVqjE9CBYuYld1Xz2BHDL1xQocBFgCpxwdXS1X5vgA2A7hlgZfVBa6l7TZ6rYDEMbDmuI/VnqvT8ZjMGGlhe28IA\">put as comments in the code present in this playground</a>, summarized here:</p>\n<ul>\n<li>Question 1: Is there a cool notation for PostCond.partial that I missed?</li>\n<li>Question 2: sometimes the notation <code>∧</code> does not work on SPred, I have not been able to understand why (see code)</li>\n<li>Question 3: is there a nice way to interact with the lemma <code>SPred.entails_cons_intro</code>?</li>\n<li>Question 4: how to deal with <code>spred(…)</code> in the goal? (<code>grind</code> doesn't know how to deal with it)</li>\n<li>Feedback 1: misleading error when using <code>mintro</code> without further argument</li>\n</ul>\n<p>Other questions and feedback:</p>\n<ul>\n<li>Feedback 2: the code works on the playground with \"latest mathlib\" and lean v4.22.0-rc3 on my computer, but have ugly type errors in the hoare triples with lean nightly on the playground?</li>\n<li>Question 5: is this the implementation of a well-known concept I can read in a research paper, or is it an invention of your own? (I know about the Hoare triples / weakest preconditions, but not about this implementation of SVal / SPred / Assertion / PostCond etc)</li>\n<li>Question 6: I have been grepping the lean4 repo to look for the <code>mvcgen</code> implementation but haven't been able to find it, where is it located?</li>\n</ul>\n<p>Thanks!</p>",
        "id": 529709883,
        "sender_full_name": "Théophile",
        "timestamp": 1753041642
    },
    {
        "content": "<p>Thanks for giving <code>Std.Do</code> a try!</p>\n<blockquote>\n<p>Question 1: Is there a cool notation for PostCond.partial that I missed?</p>\n</blockquote>\n<p>None yet. Maybe you have something in mind? I think a use case would help; I feel like <code>PostCond.partial</code> is far less common than <code>PostCond.total</code>, and when you use the former you often want to specify a more refined failure condition, but I might be wrong.</p>\n<blockquote>\n<p>Question 2: sometimes the notation <code>∧</code> does not work on SPred, I have not been able to understand why (see code)</p>\n</blockquote>\n<p>You need to wrap it with the <code>spred</code> quoter. The syntax for <code>PostCond.total</code> does this automatically for you:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Do</span><span class=\"bp\">.</span><span class=\"n\">PostCond</span><span class=\"bp\">.</span><span class=\"n\">partial</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">spred</span><span class=\"o\">(</span><span class=\"n\">state_invariant</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">pred1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n</code></pre></div>\n<blockquote>\n<p>Question 3: is there a nice way to interact with the lemma <code>SPred.entails_cons_intro</code>?</p>\n</blockquote>\n<p>You can use <code>mintro ∀s</code> to do that! Sorry about the lack of documentation/reference manual content at the moment.</p>\n<blockquote>\n<p>Question 4: how to deal with <code>spred(…)</code> in the goal? (<code>grind</code> doesn't know how to deal with it)</p>\n</blockquote>\n<p><code>spred(...)</code> is just a macro. It means that the usual prop notation such as <code>∧</code> actually desugars to its <code>SPred</code> variant such as <code>SPred.and</code>.<br>\nNote that using <code>simp</code> will \"destroy\" the SPred proof mode and should only be used as an endgame tactic. </p>\n<hr>\n<p>I can see that even with those changes there is no good way to conclude your proof, which is unfortunate.<br>\nI think that is cause by relying too much on <code>SPred [TheState]</code> being defeq to <code>TheState -&gt; Prop</code>.<br>\nYou willl find that the latest nightly unfortunately breaks this assumption completely, because now <code>SPred [TheState]</code> is defeq to <code>TheState -&gt; ULift Prop</code>.<br>\n<a href=\"https://live.lean-lang.org/#project=lean-nightly&amp;codez=JYWwDg9gTgLgBAZRgEwHQBUCGBjGxuoAiEAUKJLIihjngcaggJ4B2MmAHmeNPEsiRIQwAUxZU0xQZ2AQQcQpnYAuOOiai4ABhIy5agBYikSkavWadujrPlgoI5AEY4ACmTLF7AJRxVCAAUHZDgAbXQjExgRAF1rWzh7RwAmNw8vTF9/IMcwiON2aLj4/QBnQpEAfWAWADdMKGBMNj9EHJDwyIrizAAjXodauABZPwBeKlN0QwLTOABJARJkEQAzOFWAVxYnVVGM8bhS6CgmZbWN7dTXDk8lTNbRgFUWYHhlCeOoU+kbfSTnNVwAAbYAiUqVAHJVSraCYYHAuAcAA0iWCLg4cEARUSAbII0SkkYIAAKhUqibBxPTyLY7SpkkTYZQkOBwQDBlOVTNU6g0mmxACGUzMuO0FAFoRXAAIqbcF4CDiXYLUpwGBGBxwTBwbAQCCIlgQQqycSwqBwAIQcoAYTlaDADTw8OVBiUCzgIGApVKjgA/KLxayJEQIKgzZbrahbbAmojXDSkUd4GMAHxwQA4xBzolz6o1mvBynBAORE+OccfKgFxiXwClliyXS8qGuDQuAAdQMTEdIg2OuBEAA7jUAOZwZAQcEsADk8B70AA1l63PCVRBNv2DHA3nAp1Bp0q5ULknTyd5Bf7+IHg+aYFaWDa7VG3LHMUmjgDXOmqjUs7z4IWARjvBXiVJclKT+akrgPBkmRZf030zHkcwLItUkxSs90JaCAwYENLzDCN7WjWNKjgJ9YI/eC2AA851mico9jgF51w+IdSBZYERHgTFAATCIUnEFGlkMEFURGgER5BomAIMZQUMNI7lsxaVCWXE6S2UwoNsKvG9IwdGNtjgIiSIqOD5JgACWRZJjejOczzJAWpsH7MQwnEuIbJZAB2uBqylGV6wAZigtyq3FeYNwQmAIDXNgoAgZBNmwDshPjOZdyStjVngZoQkaFd4AgdYAANcQK5EVJs6tQuwTAQA7TYwA3N5VyS2EEV7AdUXdds1Q1EARLXZBbCUfAwqYH0guCtx9VVR1miHNYagHV0217cR2FwfAj3G10ahgGK4EAACJSjK2yqs9JVVz7FU4EAC/IDEAQIJUQMQAggkAS/JjpZUpyDCX8gTAUFwUhYJklc8bMDAP620CYJUDEdhgGBCEtRYCEdpi96ot2ljxs+8B0e82tZXEAAWQKgurIS1U6usEXVcQCrJYICqi9s4H7CB4VKrbq16TZ4CpkRRKVFVnQK/tGmvJnOt6arem1AAvNiQistcYCVJJPRYBK/FcdGnVqDsmJ+8h/ohKF0bFmoBC58UADEBeQaXsGnOAFWlkIRG+aBXXBUpMEchqroKt1oogAq8fFHsjHEUKnRCPV+pEDVI+dUKe0wJVh3al1drBK3xurFlg8x8PaZCNn4CSj2YqgEulMizZPTgIPUdD1E/sTxuamwYFNhWJvyF4AMsHW+hQ5LhcDCXFcWd6uK2LXJUB9gRwS9cUKHHhYA5dyTAMo9mb4GbkOmZYe2lVmhp+02Gq2FRHmK6MOAq69zq3VKNjMAGlh+28IA\">I changed your test file to reflect that</a>. Still I would expect that there is a manual proof using the <code>m*</code>-style tactics of the SPred proof mode; however my current attempts chokes on <code>mintro</code> not having reduced the application of <code>SPred.and</code> to the state <code>s</code>.<br>\nI will add your code as a test case, thanks!</p>",
        "id": 529816871,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753089092
    },
    {
        "content": "<p>Cool, thank you for the answers!</p>\n<blockquote>\n<p>None yet. Maybe you have something in mind? I think a use case would help; I feel like <code>PostCond.partial</code> is far less common than <code>PostCond.total</code>, and when you use the former you often want to specify a more refined failure condition, but I might be wrong.</p>\n</blockquote>\n<p>I am interested in proving security properties of cryptographic protocols that operate in adversarial environment, so functions may fail for a variety of reasons (e.g. a message may fail to parse, a signature verification may say \"invalid\" and we don't proceed further, or a decryption may fail). Therefore in that area we would rely on <code>PostCond.partial</code>, because we cannot prove characterize meaningfully when a function succeed.</p>\n<blockquote>\n<p>Sorry about the lack of documentation/reference manual content at the moment.</p>\n</blockquote>\n<p>No worries, this is expected when using cutting-edge features :)</p>",
        "id": 529890533,
        "sender_full_name": "Théophile",
        "timestamp": 1753104310
    },
    {
        "content": "<blockquote>\n<p>Therefore in that area we would rely on <code>PostCond.partial</code>, because we cannot prove characterize meaningfully when a function succeed.</p>\n</blockquote>\n<p>That makes sense. I suppose your language does not have any means to <code>catch</code> an \"exception\" then? Then yes, <code>PostCond.partial</code> is what you want.</p>",
        "id": 529892069,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753104754
    },
    {
        "content": "<p>Yes, catching exceptions doesn't seem useful in that area (other than e.g. reporting error to the user, but that outside the scope of what we prove)</p>",
        "id": 529897849,
        "sender_full_name": "Théophile",
        "timestamp": 1753106417
    },
    {
        "content": "<p>I finally looked closer at this project and it is super cool! Now that <code>iris-lean</code> is further along, I'm thinking a bit about how our projects can interoperate. I have a ton of questions that might help me understand it better (and a few pieces of feedback). If you have time to answer any of them I would appreciate it!</p>\n<p>High-level:</p>\n<ol>\n<li>I know you mentioned above that documentation is not a priority right now, but are there any existing program logics you're modeling this after that I might be able to read more about? I've read a few loosely related papers about these logics based on predicate transformers but I'm still very green.  </li>\n<li>What work needs to be done to extend the framework with a new monadic effect? I'd guess that you'd need at least a <code>WP</code> and <code>WPMonad</code> instance, but what does this workflow look like in general? </li>\n<li>Related, I see a bunch of lemmas around the development written for specific monads (for example, <code>*_run</code>, the <code>MonadLift</code>/<code>MonadFunctor</code> instances related to <code>PredTrans</code>) and I don't understand which are meant for \"object-level\" monads vs \"specification-level\" monads (those special ones you have <code>PostShape</code>s for). </li>\n</ol>\n<p>Low-level questions:</p>\n<ol start=\"4\">\n<li>What is the <code>HasFrame</code> class (resp. <code>Frame.frame</code> proof rule) meant to be used for? Do you have any examples that use it? </li>\n<li>Why is <code>PostShape</code> an inductive type? Is there any way to specify postconditions for effects other than those that are state-like (with <code>PostShape.arg</code>)  or error-like (with <code>PostShape.except</code>)? </li>\n<li>Why do <code>PredTrans</code> need to be conjunctive? I'm not surprised that they would be, I'm more just curious about where this constraint arises. </li>\n<li>If I understand correctly, the <code>*.by_wp</code> theorems are your adequacy theorems. Why only <code>Id</code> <code>StateM</code> and <code>EStateM</code>? Do you expect there to be something more general at play here? </li>\n<li>Related to the last one, I noticed that they all have <code>PostCond.total</code> postconditions. Is the logic only meant to have <code>PostCond.total</code> postconditions at the top level or do you think that other adequacy statements are provable? </li>\n</ol>\n<p>Feedback:</p>\n<ul>\n<li>The \"Barrel\" term is used a couple times, does this mean anything?</li>\n<li>The term \"partial\" is overloaded, I think here you mean <code>safe p -&gt; postcondition p</code> (right?) but people also use that to mean <code>terminating p -&gt; postcondition p</code>.</li>\n</ul>\n<p>Again thanks for anything you have time to answer :)</p>",
        "id": 529948727,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1753123715
    },
    {
        "content": "<p>I'm glad you like it :)</p>\n<blockquote>\n<p>are there any existing program logics you're modeling this after that I might be able to read more about?</p>\n</blockquote>\n<p>I... don't think there are. I used predicate transformers as the semantic foundation as that is how Hoare triples are commonly defined. I recalled traditional predicate transformers for an IMP-style language (there is plenty material on the internet, e.g., <a href=\"https://en.wikipedia.org/wiki/Predicate_transformer_semantics\">Wikipedia</a>) and connected the dots for monadic programs. The initial challenge then was coming up with finding a good translation from <em>arbitrary</em> monads into predicate transformers. I played with Dijkstra monads (which translate an algebra of monads into a corresponding continuation monad) but that turned out to be cumbersome (search the thread). I simplified the approach into the <code>WP</code> and <code>WPMonad</code> type classes and was quite happy with that. Nice and boring :)</p>\n<p>Perhaps there is a connection to Iris in that every <code>StateT σ</code> gives rise to an additional <code>σ -&gt; .</code> parameter in the assertion, and hypotheses on these state parameters work like persistent propositions in Iris (I call these \"stateful\"). I.e., you may duplicate them but once you apply the rule of consequence (for <code>c1 &gt;&gt; c2</code>) they are \"gone\" (because the state changes and the hypothesis may no longer hold). This is in contrast to <em>pure</em> hypotheses which live in the regular Lean context.</p>\n<blockquote>\n<p>What work needs to be done to extend the framework with a new monadic effect? I'd guess that you'd need at least a <code>WP</code> and <code>WPMonad</code> instance, but what does this workflow look like in general?</p>\n</blockquote>\n<p>If your effect needs a new monad, then yes, you need to instantiate <code>WP</code> and <code>WPMonad</code>. Then you also need to prove and register a specification for you new effect (i.e., some monadic action), for which you need to unfold your definition of <code>WP.wp</code>. <a href=\"https://github.com/leanprover/lean4/blob/master/src/Std/Do/Triple/SpecLemmas.lean\">SpecLemmas.lean</a> has them all for the pre-defined ones. This mechanism also works for loop invariants (e.g., <code>forIn_list</code>). </p>\n<blockquote>\n<p>Related, I see a bunch of lemmas around the development written for specific monads (for example, <code>*_run</code>, the <code>MonadLift</code>/<code>MonadFunctor</code> instances related to <code>PredTrans</code>) and I don't understand which are meant for \"object-level\" monads vs \"specification-level\" monads (those special ones you have <code>PostShape</code>s for).</p>\n</blockquote>\n<p>The only \"specification-level\" monad is <code>PredTrans ps</code> for some <code>ps : PostShape</code>. Users of the VC generator never interact with this monad (or even the fact that it is a monad) unless they are specifying their own effects.<br>\nI suppose you are referring to the <code>*_apply</code> lemmas in the <code>PredTrans</code> development? I just took a second look and deleted them. The approach I settled for no longer needs them and they are mostly confusing. Thanks for making me take that second look.<br>\nThe reason I don't need them is that it's often much preferable to stay in the \"syntactic\"/definable world where we see <code>wp[someEffect a b c]</code> rather than in the \"semantic\" world <code>somePredTrans wp[someEffectPart1] wp[someEffectPart2] ...</code> due to reasons of full abstraction/definable elements. (This is important when handling scoped effects such as <code>withReader</code>.) </p>\n<blockquote>\n<p>What is the <code>HasFrame</code> class?</p>\n</blockquote>\n<p>It is used by the <code>mframe</code> tactic. It tries to lift as many stateful hypotheses into the pure Lean context as possible. That is, a smart <code>mpure</code> that infers the pure \"frame\" of hypotheses that can survive the next effect.<br>\nThis tactic might be useful for <code>iris-lean</code> as well (although I find it unfortunately unlikely that we can share implementations).<br>\nHere's the docstring:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"ss\">`mframe</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">infers</span><span class=\"w\"> </span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">hypotheses</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">stateful</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">moved</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"bp\">.</span>\n<span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">useful</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">hypotheses</span><span class=\"w\"> </span><span class=\"s2\">\"survive\"</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">modus</span><span class=\"w\"> </span><span class=\"n\">ponens</span>\n<span class=\"o\">(</span><span class=\"ss\">`Std.Do.SPred.mp</span><span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">transitivity</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"ss\">`Std.Do.SPred.entails.trans</span><span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"bp\">.</span>\n\n<span class=\"n\">It</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">used</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">part</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"ss\">`mspec</span><span class=\"bp\">`</span><span class=\"w\"> </span><span class=\"n\">tactic</span><span class=\"bp\">.</span>\n\n<span class=\"bp\">`</span><span class=\"ss\">``lean</span>\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">SPred</span><span class=\"w\"> </span><span class=\"n\">σs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">p</span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">q</span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">s</span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">t</span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">mintro</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">mframe</span>\n<span class=\"w\">  </span><span class=\"c\">/-</span><span class=\"cm\"> `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/</span>\n<span class=\"w\">  </span><span class=\"n\">mcases</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">hP</span>\n<span class=\"w\">  </span><span class=\"n\">mexact</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"bp\">```</span>\n</code></pre></div>\n<p>Note that the stateful proof mode is entirely independent from the weakest precondition translation/Hoare triples.</p>\n<blockquote>\n<p>Why is <code>PostShape</code> an inductive type? Is there any way to specify postconditions for effects other than those that are state-like (with <code>PostShape.arg</code>) or error-like (with <code>PostShape.except</code>)?</p>\n</blockquote>\n<p>It is inductive precisely <em>because</em> I wanted a simple, closed definition! Do you have an effect in mind that cannot be modelled using this notion of postcondition? As I wrote in the OP (RFC (2)), I would be very keen to know about this use case.</p>\n<blockquote>\n<p>Why do <code>PredTrans</code> need to be conjunctive? I'm not surprised that they would be, I'm more just curious about where this constraint arises.</p>\n</blockquote>\n<p>One user wanted to separately prove a global spec <code>{P1} x {Q1}</code> and a more local spec <code>{P2} x {Q2}</code> to get <code>{P1 /\\ P2} x {Q1 /\\ Q2}</code> (cf. <code>Triple.and</code>) without repeating the proof for the global spec, and making this a native property of <code>PredTrans</code> was (sadly) the only way I could make that work.</p>\n<blockquote>\n<p>If I understand correctly, the <code>*.by_wp</code> theorems are your adequacy theorems. Why only <code>Id</code> <code>StateM</code> and <code>EStateM</code>? Do you expect there to be something more general at play here?</p>\n</blockquote>\n<p>Yeah, this is just an oversight. I should add the other theorems as well :) Thanks for the nudge.</p>\n<blockquote>\n<p>Related to the last one, I noticed that they all have <code>PostCond.total</code> postconditions. Is the logic only meant to have <code>PostCond.total</code> postconditions at the top level or do you think that other adequacy statements are provable?</p>\n</blockquote>\n<p>I just strengthened <code>EStateM.by_wp</code> to </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">by_wp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">ε</span><span class=\"w\"> </span><span class=\"n\">σ</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"n\">prog</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">EStateM</span><span class=\"bp\">.</span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"n\">s'</span><span class=\"o\">)</span><span class=\"bp\">⟩⟩</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<blockquote>\n<p>The \"Barrel\" term is used a couple times, does this mean anything?</p>\n</blockquote>\n<p>Ah, this is PL semantics lingo relating to \"double-barrelled continuations\". Perhaps it is not as common a term that I should use it. \"Barrel\" in this context just refers to either a sucess or one of the failure \"continuations\"/assertions in a <code>PostCond</code>.</p>\n<blockquote>\n<p>The term \"partial\" is overloaded, I think here you mean safe p -&gt; postcondition p (right?) but people also use that to mean terminating p -&gt; postcondition p.</p>\n</blockquote>\n<p>Yeah, I actually don't like \"partial\" very much because it is often conflates divergence of a program with throwing an exception. The former is a meta property of the program but the latter is a recoverable object property of the program. But in the programs we consider, divergence does not play any role, so partiality refers to whether or not an exception has been thrown. <br>\nThen \"partial correctness\" indeed means <code>safe p -&gt; postcondition p</code> (if <code>safe p</code> means \"no exception in <code>p</code>) and is expressed via <code>PostCond.partial</code>.</p>\n<p>Do you maybe have a suggestion for better names?</p>",
        "id": 530098608,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753174657
    },
    {
        "content": "<p>Thanks for the response, you answered most of my questions very decisively! </p>\n<blockquote>\n<p>Perhaps there is a connection to Iris ... </p>\n</blockquote>\n<p>Yeah there's probably something here. That said there are also a variety of ways you might want to relate the state in a state monad (and in fact all other parts of the program state) to Iris state. At a high level, I'm trying to understand which problems that <code>Std.Do</code> is good at solving, so the weaknesses of one project can be supported by the strengths of the other. </p>\n<p>One idea which is present in quite a few Iris papers is that programs in complicated languages can have much simpler semantic models. Type systems are one example, <code>Std.Do</code>-style monadic programs are another. So if I can use Iris to prove that my horrifying deeply embedded program refines a simpler <code>Std.Do</code> model, your logic may be able to take over.  </p>\n<blockquote>\n<p>The only \"specification-level\" monad is... <br>\nI suppose you are referring to the <code>*_apply</code> lemmas in the <code>PredTrans</code> development?</p>\n</blockquote>\n<p>Sure, I was confused about those, but (with apologies for the #XY) in general I was trying to figure out which lemmas meant to be applied to specifications, versus applied to objects. For example: you laid out the steps I would need to take to support code that uses a new monad. In that case do I also need to add a new <code>*.by_wp</code> theorem? Or are the <code>*.by_wp</code> theorems \"specification-level\" in the sense that they correspond to the cases of <code>PostShape</code> and therefore don't need to be extended to support new effects? </p>\n<p>Don't worry about it if this question doesn't have a clear answer. I know the object/specification line is blurry in this world. </p>\n<blockquote>\n<p>The reason I don't need them is that it's often much preferable to stay in the \"syntactic\"/definable world</p>\n</blockquote>\n<p>By this do you mean \"definable using the syntax of <code>do</code> notation\" or something else? I kind of hope that the former isn't the case. In SampCert (where we had shallowly embedded monadic programs) we pretty frequently used terms that couldn't be written using <code>do</code> in intermediate stages of our proofs.  </p>\n<blockquote>\n<p>Do you have an effect in mind that cannot be modelled using this notion of postcondition?</p>\n</blockquote>\n<p>None come to mind. It is definitely good to know where this decision came from. You don't need to convince an Iris user that <code>State</code> itself express a lot. What still confuses me though is why you need this type to be closed for extension... maybe I missed this in your code but do you have an example of where having this be closed is useful? </p>\n<blockquote>\n<p>Ah, this is PL semantics lingo relating to \"double-barrelled continuations\".</p>\n</blockquote>\n<p>Just a gap in my PL jargon then, no need to change it :) </p>\n<blockquote>\n<p>Do you maybe have a suggestion for better names?</p>\n</blockquote>\n<p>For partiality, I just think a comment is fine. The term is used inconsistently so trying to pick a universally understood one is a lost cause haha.</p>",
        "id": 530159069,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1753194402
    },
    {
        "content": "<blockquote>\n<p>relate the state in a state monad (and in fact all other parts of the program state) to Iris state.</p>\n</blockquote>\n<p>So a stack of <code>StateT σ1 (StateT σ2 (... StateT σn Id Nat))</code> leads to assertion <code>p : σ1 -&gt; ... -&gt; σn -&gt; Prop</code>. In a Separation Logic you could encode such an assertion as <code>l1 |-&gt; s1 * l2 |-&gt; s2  * ... * ln |-&gt; sn * [p s1 s2 ... sn]</code>. That is, every StateT corresponds to a \"static\" address <code>li</code> which is by birth alias-free with any of the other StateTs. <br>\nWhat SL can do and the StateT encoding can't is \"dynamic\" memory allocation; that is, implement <code>ST.mkRef</code>. The equivalent StateT operation would need to change the type and generally require some sort of polymorphic recursion/lenses in the object program. Of course you could allocate all your dynamic ref cells from a heap stored in one particular StateT layer, but then you will lack the aliasing guarantees that SL provides you (unless you implement an SL <em>just for that single StateT layer</em>.).</p>\n<p>So: if you have an Iris proof for some program in <code>ST</code> (which I doubt is a well-formed statement given that Iris needs to deeply embed its object language and give it an OpSem) which does not itself allocate, you could probably translate your proof obligation into <code>Std.Do</code> and blast through the proof with <code>mvcgen</code> and <code>grind</code>.</p>\n<blockquote>\n<p>In that case do I also need to add a new <code>*.by_wp</code> theorem? Or are the <code>*.by_wp</code> theorems \"specification-level\" in the sense that they correspond to the cases of <code>PostShape</code> and therefore don't need to be extended to support new effects?</p>\n</blockquote>\n<p>Good question. I don't know :) You probably need to define such a theorem for every new <code>WP</code> instance. These lemmas are mostly useful if (1) you have some pure proof obligation such as <code>isPrime n = true</code> and (2) <code>isPrime</code> is internally implemented using <code>M.run prog</code> (for example <code>M=Id</code>). Then the <code>by_wp</code> lemma is convenient to expose the monadic <code>prog</code> and start the proof in terms of <code>wp[prog] Q</code>. <a href=\"https://live.lean-lang.org/#project=lean-nightly&amp;codez=JYWwDg9gTgLgBAZRgEwHQBUCGBjGxuoAiEAUCRGAKYB2iK5VtSaxZylAZnB8AEYD6oMABs4ACloAuOADlMMAJRxpASWSz5ygLxxkpOHGBdaOgAxwYACxpwolGAFcotUyQPD7cEA/iZtcV3dPb3hefwBGN25oOH5DWgBtcMlqAF1dfQM4D18Acn9MKIM/SR1eIrgw0rhMfIBqSqi7R2dGkkxeXjsAN24+fgBnKmxlDXhAJMIxkgAfALgtAD4Ambhw+aXI2eo6gCZ1voEhyhHaBp5D4fFt8IUyK0poShAD/hgoYBFKUcBgykAcYnQoA5KIBcYkAIZQvISiWjfQDLhLZ9r8oPMXkcTmD/LwAJ5RBzUDgQYTqc6CcDCKLIAZCKIgYDUN4QWJRIxwSyjExze60SngOAJSzpSjCAaUKLcsBwCDUYSY3mWAA0tkoyAc2EoKhglFS1NRcAAtLrEMNUGAnCKDCAdQgjfioCpqPwoJhqABzL5iOFiQAX5JgFbxAJfkCoAHgMlIs4L8/DpiTrg6goGA7BxUB4XVY4IByIkqyOjlzEsfjieTNGdaYaN2BSgA/AMNWAothMMK4DXKOKwxShABueL0gbdml0qAM/jdsX8TDCMkGMcT0QJOQwVADBwCSWUcfIZD8Ndakj3R7PYnYaB2XBwADe1AAvqMxMTIXBqAo47js/0dVIytiDK7qJRHcIwAAF5fKy0h3v0D5Pi+7KBlEmBgCIMpqKgWL8AA7uKljwYh0ovG8HweEAA\">Here's an example from the kitchen sink test file</a>. Different <code>M</code>s need different <code>by_wp</code> lemmas.</p>\n<blockquote>\n<p>In SampCert (where we had shallowly embedded monadic programs) we pretty frequently used terms that couldn't be written using <code>do</code> in intermediate stages of our proofs.</p>\n</blockquote>\n<p>I meant \"definable in the computational monad <code>m α</code>\". I suppose these terms in SampCert you are referring to are still definable as a computation in <code>m α</code>? By contrast, the semantic domain <code>PredTrans</code> of <code>WP.wp</code> is far larger than the image of <code>WP.wp</code>. Many properties can only be shown considering the image of <code>WP.wp</code> (the \"definable elements\" of <code>PredTrans</code>), a classic gotcha of denotational semantics. Hence it is best to keep <code>WP.wp</code> \"as far out as possible\"; pushing it inwards by unfolding loses information. But I suppose this is not super important for users of <code>Std.Do</code> :)</p>\n<blockquote>\n<p>What still confuses me though is why you need this type to be closed for extension... maybe I missed this in your code but do you have an example of where having this be closed is useful?</p>\n</blockquote>\n<p>One reason I like it closed is that I can define <a href=\"https://github.com/leanprover/lean4/blob/9328271dd0e3710fcc7224db4eddaa79d2b9c8fc/src/Std/Do/PostCond.lean#L54\"><code>PredShape.args</code></a> as a closed definition. Maybe that could live in a type class that an abstract <code>PredShape</code> would need to implement... And similarly we would need a method for <a href=\"https://github.com/leanprover/lean4/blob/9328271dd0e3710fcc7224db4eddaa79d2b9c8fc/src/Std/Do/PostCond.lean#L81\"><code>FailConds</code></a> and all its properties.<br>\nDoable, but it is unclear why you would want to do that when keeping it closed is the simpler and more direct solution :)</p>",
        "id": 530319556,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1753269510
    },
    {
        "content": "<blockquote>\n<p>which I doubt is a well-formed statement given that Iris needs to deeply embed its object language and give it an OpSem</p>\n</blockquote>\n<p>One of the ideas I'm exploring right now is that an iris-lean program logic could be used to relate a model of a programming language that does have an operational semantics (eg. Rust a la RustBelt or C a la RefinedC) to an <code>ST</code> program. In this case, <code>StateT</code> state doesn't have to correspond just to physical state, just the stateful part of your program that you're trying to model. In this setup, <code>iris-lean</code> becomes a great way to construct models of your program and <code>Std.Do</code> becomes a great way to reason about them. Could be interesting, but I'm still thinking about it! </p>\n<blockquote>\n<p>I meant \"definable in the computational monad <code>m α</code>\".</p>\n</blockquote>\n<p>Great, that's what I was hoping you meant. Thanks for the explanations :)</p>",
        "id": 530346143,
        "sender_full_name": "Markus de Medeiros",
        "timestamp": 1753277731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"721721\">@Markus de Medeiros</span> <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> The experimental Lean backend for the Hax tool for verifying Rust programs already uses Std.Do. E.g. <a href=\"https://github.com/cryspen/hax/pull/1590\">https://github.com/cryspen/hax/pull/1590</a></p>",
        "id": 532475542,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1754157721
    },
    {
        "content": "<p>Nice! hax-lib/proof-libs/lean/Lib.lean looks what I had in mind to support Aeneas.</p>",
        "id": 532721575,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754311961
    },
    {
        "content": "<p>Thanks! Indeed we're very interested in your work <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> , as we're buildind a Lean backend (still very early) for <a href=\"https://hax.cryspen.com/\">Hax</a>. So far, we are very happy with the design, and <code>mvcgen</code> works quite well for our use case. </p>\n<p>I have a couple of questions : </p>\n<ol>\n<li>When defining hoare triples, is it possible to have the precondition in the context for the definition of the post-condition ? For instance, this is ill-formed :</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">spec</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">test_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">):</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">ofOption</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">?</span><span class=\"w\"> </span><span class=\"n\">arrayOutOfBounds</span><span class=\"w\"> </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Indeed, the hypothesis <code>i &lt; a.size</code> is not accessible in the post condition, making <code>a[i]</code> ill formed. It can be solved by turning <code>i &lt; a.size</code> into an extra argument of the theorem, but it feels less natural than keeping it in the hoare triple </p>\n<ol start=\"2\">\n<li>We define Hoare triples for our arithmetic operations with overflows, which look like this (where <code>+?</code> is our custom add): </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">spec</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxAdd_spec_bv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">saddOverflow</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHaxAdd</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>However, we also need rewriting rules (because <code>+?</code> can also appear in postconditions, once the job of <code>mvcgen</code> is finished), like: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxAdd_spec_bv_rw</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">   </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">saddOverflow</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">   </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHaxAdd</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Is there a way to use the Hoare triples as rewriting rules : use <code>HaxAdd_spec_bv</code> instead of <code>HaxAdd_spec_bv_rw</code> in proofs ?</p>",
        "id": 532724511,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754312931
    },
    {
        "content": "<ol start=\"3\">\n<li>Are there ways to define several attributes besides <code>spec</code>, so that <code>mvcgen</code> could be configured to use different sets of specifications ? Typically, we have bitvector based specifications <strong>and</strong> nat/int based specifications depending on the uses cases : </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Bitvec-based specification for rust multiplication on usize -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">spec_bv</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_bv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">usize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">umulOverflow</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"sd\">/-- Nat-based specification for rust multiplication on usize -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">spec_nat</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">usize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>It would be very useful to be able to do <code>mvcgen with spec_bv</code> or <code>mvcgen with spec_nat</code> and get the right preconditions</p>",
        "id": 532889965,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754391421
    },
    {
        "content": "<blockquote>\n<p>So far, we are very happy with the design, and <code>mvcgen</code> works quite well for our use case.</p>\n</blockquote>\n<p>Thanks, that's very nice to hear :)</p>\n<blockquote>\n<p>It can be solved by turning <code>i &lt; a.size</code> into an extra argument of the theorem, but it feels less natural than keeping it in the hoare triple</p>\n</blockquote>\n<p>Moving it into the regular Lean context is exactly what I would do. It is desirable to move as many facts as possible into the pure Lean context so that they survive applications of the rule of consequence (i.e., <code>SPred.entails.trans</code>). The <code>mframe</code> tactic tries to help and automate such moves, and it is automatically applied by <code>mspec</code> (and <code>mvcgen</code>) to do these moves for you, but it doesn't hurt to define specs in a way that has \"maximum information content\".</p>\n<blockquote>\n<p>Is there a way to use the Hoare triples as rewriting rules : use <code>HaxAdd_spec_bv</code> instead of <code>HaxAdd_spec_bv_rw</code> in proofs ?</p>\n</blockquote>\n<p>Sorry, I don't completely understand what you want to do. Per the previous answer, I would write <code>HasAdd_spec_bv</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">spec</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxAdd_spec_bv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">isize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">saddOverflow</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instHaxAdd</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Why would <code>x +? y</code> appear in postconditions? It's part of the program syntax so it should only occur <del>in the postcondition</del> in <code>wp[.]</code> or in Hoare triples <code>{P} . {Q}</code>? Unless you mean inside a <code>wp</code> application?</p>\n<blockquote>\n<p>Are there ways to define several attributes besides <code>spec</code>?</p>\n</blockquote>\n<p>Hmm. I don't have plans for this kind of feature... However, would it work for you to use <code>scoped [attribute spec]</code> and then <code>open</code> the respective namespace?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"sd\">/-- Bitvec-based specification for rust multiplication on usize -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_bv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">usize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">¬</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">BitVec</span><span class=\"bp\">.</span><span class=\"n\">umulOverflow</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toBitVec</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">BV</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_bv</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">BV</span>\n\n<span class=\"sd\">/-- Nat-based specification for rust multiplication on usize -/</span>\n<span class=\"kd\">@[</span><span class=\"n\">spec_nat</span><span class=\"kd\">]</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_nat</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">usize</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"n\">toNat</span><span class=\"w\"> </span><span class=\"bp\">&lt;</span><span class=\"w\"> </span><span class=\"n\">USize</span><span class=\"bp\">.</span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"bp\">⌝</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*?</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n\n<span class=\"kn\">namespace</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"kn\">attribute</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"kn\">scoped</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">HaxMul_spec_nat</span>\n\n<span class=\"kn\">end</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n\n<span class=\"bp\">...</span>\n<span class=\"w\">  </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">BV</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 532893568,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754392666
    },
    {
        "content": "<p>Thank you for the answers!</p>\n<ul>\n<li>for 1. Indeed, moving every pure fact out of the precondition made <code>mvcgen</code> happier, and solves the issue</li>\n<li>For 3.  scoped attributes do the trick, allowing for a nice <code>open SpecBV in mvcgen</code> or <code>open SpecNat in mvcgen</code></li>\n</ul>\n<p>Regarding 2. As we export pre and post-conditions from the rust code, we can have hoare triples that look like this (where the barrett function computes the modulus of 3329) : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">%?</span><span class=\"w\"> </span><span class=\"mi\">3329</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">barrett_spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\">  </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\">  </span><span class=\"mi\">0</span><span class=\"n\">x40000</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\">  </span><span class=\"bp\">__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Indeed, the rust written post-condition <code>__ensures</code> will also mention panicking arithmetic <code>%?</code>. Therefore, once all the panic freedom side conditions have be proved, and there is only the post-condition remaining, I would like to do rewrites on <code>%?</code> that are basically the same as the hoare triple.</p>",
        "id": 533269731,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754564644
    },
    {
        "content": "<p>Ah, sounds like you actually want a relational/binary hoare logic to prove that <code>barret_reduce value</code> is bisimilar to <code>value %? 3329</code>. That's tricky and not currently a use case that is actively supported by <code>Std.Do</code>.</p>\n<p>In your particular example you can first run <code>mvcgen</code> on <code>barret_reduce value</code> and then will have some proof obligation in which <code>__ensures value result</code> occurs. You would run <code>mvcgen</code> on that once more. <br>\nThat said, this approach is not particularly compositional and is likely unpleasant to work with.</p>\n<p>Regarding your original question (2), I imagine you can define a lemma that derives <code>HaxAdd_spec_bv_rw</code> from <code>HaxAdd_spec_bv</code>. This could be helpful (this is assuming nightly; leave out <code>.down</code> on the RC):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">by_wp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"n\">x</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">⌝</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">⌝⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hspec</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">instWP</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hspec</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"n\">hspec</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">PredTrans</span><span class=\"bp\">.</span><span class=\"n\">const</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">to_rw</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"n\">x</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">⌝</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hspec</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">by_wp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hspec</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">to_rw'</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(⦃</span><span class=\"n\">P</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">⌝</span><span class=\"o\">⦄)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">hspec</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n<span class=\"w\">    </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"bp\">.</span><span class=\"n\">by_wp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"k\">at</span><span class=\"w\"> </span><span class=\"bp\">*</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hspec</span><span class=\"w\"> </span><span class=\"n\">hp</span>\n</code></pre></div>",
        "id": 533280168,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754568686
    },
    {
        "content": "<p>Thank your for the rewriting lemmas!</p>\n<p>In this specific example (barrett reduction), I might want a proof of bisimilarity, but in a lot of cases we're only interested in panic-freedom that seems to fit in the <code>Std.Do</code> use-cases. Interestingly, the different (while, I believe, <em>equivalent</em>) ways of writing the same specification are handled differently by <code>mvcgen</code>. Considering that <code>__requires</code> and <code>__ensures</code> return a <code>Result Bool</code>, we have   : </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">barrett_spec1</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">barrett_spec2</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">__</span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦄</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">barrett_spec3</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">wp</span><span class=\"bp\">⟦__</span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"bp\">⟨</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊢ₛ</span>\n<span class=\"w\">      </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"n\">barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"bp\">⟧</span>\n<span class=\"w\">        </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">wp</span><span class=\"bp\">⟦__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">)),</span>\n<span class=\"w\">    </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"c1\">-- if the precondition panics, nothing to prove</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">barrett_spec4</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">i32</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"n\">wp</span><span class=\"bp\">⟦__</span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"bp\">⟨</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">⊢ₛ</span>\n<span class=\"w\">    </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">barrett_reduce</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"bp\">;</span>\n<span class=\"w\">           </span><span class=\"bp\">__</span><span class=\"n\">ensures</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"w\"> </span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">),</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"w\"> </span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"c1\">-- if the precondition panics, nothing to prove</span>\n<span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The first one <strong>1</strong> (that I originally wrote) requires rewriting lemmas to prove <code>__ensures .. = pure true</code>, and tenious splitting on the hypothesis <code>__requires .. = pure true</code>. The <strong>2</strong> is much better for <code>mvcgen</code>, as it also steps through <code>__ensures</code>, but still requires manual splitting on  the hypothesis <code>__requires .. = pure true</code>.  The third one <strong>3</strong> can be fully handled by mvcgen, although I need to run it twice (first on the precondition, then use <code>apply SPred.pure_intro ; intros</code>, then re-run it). The fourth one <strong>4</strong> is equivalent to the third one I think, but maybe more readable ? (debatable). Do you have an opinion on the style of specifications and their potential limitations (from a proof point of view) ?  </p>\n<p>Thank you for your help!</p>",
        "id": 533310758,
        "sender_full_name": "Clément Blaudeau",
        "timestamp": 1754578645
    },
    {
        "content": "<p>Is it expected that <code>simp_all</code> doesn't simplify away the <code>wp</code> occurrences in this example?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">matchFn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">23</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">8</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">matchFn_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"o\">⦃</span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span><span class=\"o\">⦄</span>\n<span class=\"w\">    </span><span class=\"n\">matchFn</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">    </span><span class=\"o\">⦃</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"bp\">⌝⟩</span><span class=\"w\"> </span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">matchFn</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 533376323,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754609275
    },
    {
        "content": "<p>(Sorry if this is more or less the same issue that <span class=\"user-mention\" data-user-id=\"746143\">@Clément Blaudeau</span> was asking about <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> )</p>",
        "id": 533376723,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754609591
    },
    {
        "content": "<p>Generally, I also struggle to find an easy way to go between an simple implication and the Hoare triple for total functions, which is relevant at points where monadic code and pure code touch, e.g. by <code>Id.run</code> inside a pure function.</p>",
        "id": 533381367,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1754613678
    },
    {
        "content": "<blockquote>\n<p>Do you have an opinion on the style of specifications and their potential limitations (from a proof point of view) ?</p>\n</blockquote>\n<p>I feel like I'm lacking context here, but I think I would first try and convert the pre and postconditions from a \"program\" involving <code>Result Bool</code> into something without it by running a metaprogram that does <code>mvcgen</code>/<code>simp_all</code> on</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦__</span><span class=\"n\">requires</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"bp\">⌝</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This should yield the desired <code>Prop</code> that you can put in the precondition.</p>\n<p>Alternatively, you could provide a tactic that your users should run <em>before</em> the actual <code>mvcgen</code> invokation in <code>barret_spec</code> that rewrites the pre and postconditions using (the inverse of) <code>Result.to_rw</code> and <code>mvcgen</code>.</p>",
        "id": 533411347,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754638149
    },
    {
        "content": "<blockquote>\n<p>Is it expected that <code>simp_all</code> doesn't simplify away the <code>wp</code> occurrences in this example?</p>\n</blockquote>\n<p>It kind of is because there is no monadic computation that it could apply the spec to. If you insert the <code>pure (x, y)</code> that is implicit by defeq, you'll get</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"n\">x</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">23</span>\n<span class=\"n\">y</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">8</span>\n<span class=\"bp\">⊢</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"bp\">✝</span><span class=\"w\"> </span><span class=\"bp\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n</code></pre></div>\n<p>and can proceed however you want.</p>",
        "id": 533411620,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754638273
    },
    {
        "content": "<blockquote>\n<p>Generally, I also struggle to find an easy way to go between an simple implication and the Hoare triple for total functions, which is relevant at points where monadic code and pure code touch, e.g. by <code>Id.run</code> inside a pure function.</p>\n</blockquote>\n<p>Does <code>Id.by_wp</code> help?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">by_wp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">⊢ₛ</span><span class=\"w\"> </span><span class=\"n\">wp</span><span class=\"bp\">⟦</span><span class=\"n\">prog</span><span class=\"bp\">⟧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PostCond</span><span class=\"bp\">.</span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">▸</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">True</span><span class=\"bp\">.</span><span class=\"n\">intro</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You use it with <code>generalize</code> like in Bhavik's example (and a few others) to \"focus\" on/punch a hole into the part of the target <code>P</code> (i.e. a function application) that is defined by <code>Id.run</code> and then you can use <code>mvcgen</code> on its <code>do</code> block to show the target <code>P</code>.</p>",
        "id": 533412076,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754638506
    },
    {
        "content": "<p>While adding some grind lemmas to eliminate the idiosyncratic <code>Std.Range.toList range = xs ++ y :: ys</code> assumptions that arise through the current encoding of loop invariants using the new <code>Std.List.Zipper</code>, I got carried away trying out a different encoding for loop invariants.</p>\n<p>In <a href=\"https://github.com/leanprover/lean4/pull/9766\">lean4#9766</a>, I switched to using a <code>Fin (xs.length + 1)</code> to encode the iteration state of the loop. All in all I like that, because it makes specification of loop invariants simpler (below, <code>xs</code> used to be a <code>Zipper</code>; now it's just the list the loop iterates over):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"bp\">-</span><span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">suff</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">suff</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"bp\">⌝</span><span class=\"o\">)</span>\n<span class=\"bp\">+</span><span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">⇓</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"bp\">⟩</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"bp\">.</span><span class=\"n\">drop</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"mi\">25</span><span class=\"bp\">⌝</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Unfortunately, some of the proofs get more complicated due to type dependencies; a hyp <code>h : i &lt; [1:5].toList.length</code> in the local context will not be simplified to <code>h : i &lt; 4</code> if <code>h</code> is used in an array bounds check.</p>\n<p>Does anyone have an opinion here? I tend to prefer the <code>Fin</code>-based encoding because it means one fewer concept (zippers) to learn for users.</p>",
        "id": 533450787,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1754654616
    },
    {
        "content": "<p>I rejected the <code>Fin (xs.length + 1)</code> idea and parked it at <a href=\"https://github.com/leanprover/lean4/commits/sg/parked-fin-specs/\">https://github.com/leanprover/lean4/commits/sg/parked-fin-specs/</a>.</p>",
        "id": 534027211,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755020182
    },
    {
        "content": "<p>Here's where I'm drafting a reference manual entry/tutorial: <a href=\"https://hackmd.io/@sg-fro/BJRlurP_xg\">https://hackmd.io/@sg-fro/BJRlurP_xg</a></p>",
        "id": 534027251,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755020204
    },
    {
        "content": "<p>Earlier in the thread you wrote</p>\n<blockquote>\n<p>Moving it into the regular Lean context is exactly what I would do. It is desirable to move as many facts as possible into the pure Lean context so that they survive applications of the rule of consequence (i.e., <code>SPred.entails.trans</code>).</p>\n</blockquote>\n<p>and I think something along these lines would be a welcome addition to the entry, since I had otherwise assumed the exact opposite would be true</p>",
        "id": 534027744,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1755020450
    },
    {
        "content": "<p>Wrapping functions to be verified in <code>Id</code> since it requires a monad is kinda ugly (but makes sense)</p>",
        "id": 534174853,
        "sender_full_name": "Alok Singh",
        "timestamp": 1755071057
    },
    {
        "content": "<p>That's not specific to this framework, that pattern was around for perhaps a couple of years before this!</p>",
        "id": 534222459,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1755089077
    },
    {
        "content": "<p>TIL</p>",
        "id": 534305931,
        "sender_full_name": "Alok Singh",
        "timestamp": 1755119945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/534027744\">said</a>:</p>\n<blockquote>\n<p>and I think something along these lines would be a welcome addition to the entry, since I had otherwise assumed the exact opposite would be true</p>\n</blockquote>\n<p>added a digressing subsection. Not good writing style but should do the job.</p>\n<p>The <a href=\"https://hackmd.io/@sg-fro/BJRlurP_xg\">linked tutorial</a> should be \"complete enough\" now. As always, I'm open for feedback! Though I'll be away for a month now, so I can't really incorporate feedback until after that.</p>",
        "id": 534522506,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755190062
    },
    {
        "content": "<p>Is there a trick required to make <code>mvcgen</code> with loops over <code>Std.PRange</code>?</p>\n<p>Here's an MWE that has me puzzled:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Tactic</span><span class=\"bp\">.</span><span class=\"n\">Do</span>\n\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Std</span><span class=\"bp\">.</span><span class=\"n\">Do</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">out</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">mut</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mf\">0.</span><span class=\"bp\">..</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">    </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">  </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">out</span>\n\n<span class=\"sd\">/-- This works as expected: -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">foo_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">l</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">of_wp_run_eq</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⇓⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- This fails in `inv1`: -/</span>\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bar_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">of_wp_run_eq</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Invalid match expression: The type of pattern variable 'xs' contains metavariables:</span>\n<span class=\"w\">    </span><span class=\"c1\">-- (0...n).toList.Cursor</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⇓⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc4</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 534793169,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1755393322
    },
    {
        "content": "<p>It seems that it fails to synthesize the instance for <code>Std.PRange.HasFiniteRanges Std.PRange.BoundShape.open Nat</code> which is one of the requirements of the spec lemma for <code>PRange</code>s. Not sure why that is; <code>#synth Std.PRange.HasFiniteRanges Std.PRange.BoundShape.open Nat</code> succeeds. Need to investigate.</p>\n<p>Edit: You can work around it by inferring the instance <code>vc1</code> before specifying the invariant <code>inv1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">bar_eq</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">  </span><span class=\"n\">generalize</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"bp\">.</span><span class=\"n\">of_wp_run_eq</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">  </span><span class=\"n\">mvcgen</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inv1</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"bp\">⇓⟨</span><span class=\"n\">xs</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">⌜</span><span class=\"n\">True</span><span class=\"bp\">⌝</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc2</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc3</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">vc4</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 534824857,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1755438525
    },
    {
        "content": "<p>Is there plan to support <code>loop</code> or <code>while</code> loop in this framework? This might be tricky, since <code>loop</code> is now a <code>partial def</code>, and even <code>partial_fixpoint</code> is said not to be planned.</p>",
        "id": 543112641,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759607377
    },
    {
        "content": "<p>Supporting <code>repeat</code> is tricky because as it is you can't do anything with it (as you said because of <code>partial</code>). If we want to change that we have to face a problem: We want it to still work for <em>all</em> monads (because it did before) but we also want to guarantee that it actually does something reasonable on infinite loop (and not always something completely random through <code>Classical.choice</code>). For example, an infinite loop in <code>Option</code> should be <code>none</code>. But then there are monads like <code>ExceptT Bool Option</code>. Without any more information than the monad instance, you can't distinguish between <code>none</code>, <code>throw false</code> and <code>throw true</code> but we want to ensure an infinite loop is <code>none</code>. Thus, we need more information, e.g. an additional type class. But then <code>repeat</code> would behave differently before and after defining an instance of such type class, where it would first return any of the three exceptions on infinite loop and after defining an instance return <code>none</code> in particular. Thus programs written before vs. after that point behave differently in logic, which could be confusing.</p>",
        "id": 543174057,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759682527
    },
    {
        "content": "<p>Yeah let's not get into termination hell. I think we can do a lot with constrained looping primitives (recursors).</p>",
        "id": 543183182,
        "sender_full_name": "(deleted)",
        "timestamp": 1759688147
    },
    {
        "content": "<p>If you want while, or arbitrary recursion, it's possible to use an inductive predicate</p>",
        "id": 543183209,
        "sender_full_name": "(deleted)",
        "timestamp": 1759688167
    },
    {
        "content": "<p>Would it be so bad if the <code>loop</code> and <code>while</code> keywords detect when they have a monad with suitable structure and have different, <code>partial_fixpoint</code>-like logical content that allows partial correctness proofs using <code>mvcgen</code>? All existing users likely only care about the compiled behavior, and that wouldn't change, would it?</p>",
        "id": 543184251,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759689331
    },
    {
        "content": "<p>No it's a can of worms</p>",
        "id": 543184891,
        "sender_full_name": "(deleted)",
        "timestamp": 1759690007
    },
    {
        "content": "<p>Let's say there's a program that prints hello world forever</p>",
        "id": 543184918,
        "sender_full_name": "(deleted)",
        "timestamp": 1759690030
    },
    {
        "content": "<p>How is the program represented</p>",
        "id": 543184925,
        "sender_full_name": "(deleted)",
        "timestamp": 1759690039
    },
    {
        "content": "<p>Things are nice and dandy if there are no side effects</p>",
        "id": 543184953,
        "sender_full_name": "(deleted)",
        "timestamp": 1759690074
    },
    {
        "content": "<p>Already now, with <code>partial</code>,  the logical content of such a program is unspecified. Are you saying users currently rely on that somehow?</p>",
        "id": 543187282,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1759692364
    },
    {
        "content": "<p>My idea would've been:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">MonadLoop</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">loop_of_exists</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">,</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">→</span>\n<span class=\"w\">    </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">·.</span><span class=\"n\">casesOn</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">))</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">priority</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">low</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">MonadLoop</span><span class=\"bp\">.</span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MonadLoop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">epsilon</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"n\">loop_of_exists</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Classical</span><span class=\"bp\">.</span><span class=\"n\">epsilon_spec</span><span class=\"w\"> </span><span class=\"n\">h</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">MonadLoop</span><span class=\"bp\">.</span><span class=\"n\">fixByOrder</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CCPO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">MonoBind</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">fixByOrder</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"n\">partial_fixpoint</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">CCPO</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">Order</span><span class=\"bp\">.</span><span class=\"n\">MonoBind</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">MonadLoop</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">loop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">MonadLoop</span><span class=\"bp\">.</span><span class=\"n\">fixByOrder</span>\n<span class=\"w\">  </span><span class=\"n\">loop_of_exists</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadLoop</span><span class=\"bp\">.</span><span class=\"n\">fixByOrder</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">congr</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">funext</span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"bp\">&lt;;&gt;</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>\n<p>So yeah, basically <code>partial_fixpoint</code></p>",
        "id": 543187315,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759692392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"511228\">Huỳnh Trần Khanh</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/543184925\">schrieb</a>:</p>\n<blockquote>\n<p>How is the program represented</p>\n</blockquote>\n<p>Do we care? There are already plans to make <code>IO</code> opaque, so might as well also make that aspect of it opaque with suitable specification.</p>",
        "id": 543187409,
        "sender_full_name": "Robin Arnez",
        "timestamp": 1759692456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"873547\">Robin Arnez</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/543174057\">said</a>:</p>\n<blockquote>\n<p>Supporting <code>repeat</code> is tricky because as it is you can't do anything with it (as you said because of <code>partial</code>). If we want to change that we have to face a problem: We want it to still work for <em>all</em> monads (because it did before) but we also want to guarantee that it actually does something reasonable on infinite loop (and not always something completely random through <code>Classical.choice</code>). For example, an infinite loop in <code>Option</code> should be <code>none</code>. But then there are monads like <code>ExceptT Bool Option</code>. Without any more information than the monad instance, you can't distinguish between <code>none</code>, <code>throw false</code> and <code>throw true</code> but we want to ensure an infinite loop is <code>none</code>. Thus, we need more information, e.g. an additional type class. But then <code>repeat</code> would behave differently before and after defining an instance of such type class, where it would first return any of the three exceptions on infinite loop and after defining an instance return <code>none</code> in particular. Thus programs written before vs. after that point behave differently in logic, which could be confusing.</p>\n</blockquote>\n<p>Thanks to point it out. This is indeed tricky, and even <code>partial_fixpoint</code> uses <code>none</code> or <code>Classical.choice</code> as the value of a non-terminated function.</p>",
        "id": 543197339,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759703681
    },
    {
        "content": "<p>I'm thinking that to prove a Hoare triple of a loop, one can require a termination measure to be specified (which is typical in e.g. Dafny). This will work with <code>partial_fixpoint</code>. This is a total Hoare triple, and I don't know if it is possible to even define a partial Hoare triple when we work with any monad.</p>",
        "id": 543198404,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759705044
    },
    {
        "content": "<blockquote>\n<p>Is there plan to support <code>loop</code> or <code>while</code> loop in this framework?</p>\n</blockquote>\n<p>No, no plans yet. I think we'd first need to support generating definition bodies for <code>partial def</code>s in the first place.</p>\n<blockquote>\n<p>I'm thinking that to prove a Hoare triple of a loop, one can require a termination measure to be specified (which is typical in e.g. Dafny).</p>\n</blockquote>\n<p>Indeed this would be nice, and I think it's what Joachim suggests above. But I don't think it's possible without producing definition bodies taking some sort of termination proof as argument. See <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Extrinsic.20termination.20proofs.20for.20well-founded.20recursion/with/524144154\">#lean4 &gt; Extrinsic termination proofs for well-founded recursion</a>.</p>",
        "id": 543280381,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1759748447
    },
    {
        "content": "<blockquote>\n<p>Dijkstra monads forever: termination-sensitive specifications for interaction trees<br>\n<a href=\"https://dl.acm.org/doi/10.1145/3434307\">https://dl.acm.org/doi/10.1145/3434307</a></p>\n</blockquote>\n<p>Combines Dijkstra monad with ITrees for non-termination. <span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> Have you compared this with your implementation?</p>",
        "id": 543295902,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1759752648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/543280381\">said</a>:</p>\n<blockquote>\n<p>Indeed this would be nice, and I think it's what Joachim suggests above. But I don't think it's possible without producing definition bodies taking some sort of termination proof as argument. See <a class=\"stream-topic\" data-stream-id=\"270676\" href=\"/#narrow/channel/270676-lean4/topic/Extrinsic.20termination.20proofs.20for.20well-founded.20recursion/with/524144154\">#lean4 &gt; Extrinsic termination proofs for well-founded recursion</a>.</p>\n</blockquote>\n<p>That discussion looks nice! Though, instead of finding a general solution of partial functions, we can alternatively customize the instance of <code>ForIn Loop</code>.</p>",
        "id": 543337263,
        "sender_full_name": "Dexin Zhang",
        "timestamp": 1759762247
    },
    {
        "content": "<blockquote>\n<p>Combines Dijkstra monad with ITrees for non-termination. @Sebastian Graf Have you compared this with your implementation?</p>\n</blockquote>\n<p>Yes. They use ITress as a semantic domain for a denotational semantics of a first-order imperative language <code>IMP</code>. We need to define an expansion of <code>while</code> from Lean's native <code>do</code> notation. It would be very confusing and not at all performant to involve an ITree-based monad in that expansion (and I have no idea how something like that could solve our problem). This has nothing to do with Dijkstra monads/<code>Std.Do</code>; it's a fundamental limitation of how Lean's <code>while</code> is implemented in terms of the <code>ForIn Loop</code> instance.</p>\n<blockquote>\n<p>Though, instead of finding a general solution of partial functions, we can alternatively customize the instance of <code>ForIn Loop</code>.</p>\n</blockquote>\n<p>Just yesterday I brainstormed how to implement a <code>while ... decreasing &lt;measure mentioning let muts&gt; do ...</code> primitive that takes a different expansion path than <code>while ... do ...</code> that would allow for reasoning about such loops. Coming up with the right kind of well-founded relation/accessibility predicate is challenging.<br>\nIt might be promising to build on the <code>Iterator</code> framework, because its <code>Finite</code> predicate solves exactly this problem.</p>",
        "id": 543462302,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1759822550
    }
]