[
    {
        "content": "<p>Fellow Lean users,</p>\n<p>As announced in the <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493913623\">Lean FRO meeting at Lean Together 2025</a>, I'm working on behalf of the Lean FRO on a Floyd/Hoare-style program logic framework to verify \"arbitrary\" monadic code written in Lean. <br>\nThis thread is meant to collect requirements from you! </p>\n<h3>Scope: \"Is this work relevant to my use case?\"</h3>\n<p>TLDR; this work could be relevant to you if you want to verify code written using Lean's <code>do</code>-notation.</p>\n<p>Let me clarify what \"program logic for monadic code\" means by giving a sketch of the definition of Hoare Triple I have in mind: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>(Find <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=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\">here the exact definition</a> I'm currently working with, but the above is close enough to give you an idea.)<br>\nThe intention is that any user may provide a definition of <code>M</code> and <code>triple</code> (plus structural rules) and then verify programs in <code>M</code> building on an extensive program logic with good automation and UX.</p>\n<p>In addition to scalable extrinsic proofs, the vision is to allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework.</p>\n<p>Note that although <code>M α</code> is \"semantics of a program in Lean\", you should be able to use this framework for any language with a denotational semantics into a monad.</p>\n<p>This should include any strongly normalizing object language such as System F, but exclude untyped lambda calculus, System F with recursive types or mutable references (finding monadic semantic domains for the latter is an <a href=\"https://arxiv.org/abs/2210.02169\">active research problem</a>).</p>\n<h3>Request for feedback</h3>\n<p>I am interested in gathering any kind of feedback (please keep focus on semantics rather than syntax that is likely to change <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>), or people I should reach out to that are <em>not yet</em> in the following list:</p>\n<p>Jeremy Avigad, Mario Carneiro, Wojciech Nawrocki, John Tristan, Jonathan Protzenko</p>\n<p>However, I'm specifically interested in feedback to the following items which I encourage you refer to in your answer:</p>\n<ol>\n<li>What is your use case? Can you point me to reasonably self-contained example code?</li>\n<li>We need to figure out what \"arbitrary\" monadic code means. For example, my prototype would currently support any kind of transformer stack that can be represented as <code>StateT</code>/<code>ExceptT</code> (plus <code>ReaderT</code>/<code>WriterT</code> and equivalents through <code>StateT</code>) over <code>Id</code>/<code>IO</code>.  (Behavior of runtime <code>IO</code> functions will be axiomatised.) <strong>Is this sufficient for your use case?</strong> I'm asking because this plan does not currently include a Separation Logic to reason about <code>IO.Ref</code> or <code>ST.Ref</code>, and I'm yet unsure how much of a breaking change it would be to add this capability after the fact.</li>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>.    Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n<li>My focus so far is on unary program logic. I have heard at least one voice who want to work in a relational program logic (relating multiple program runs with different preconditions) for cryptographic proofs à la <a href=\"https://github.com/SSProve/ssprove\">SSProve</a>. <strong>Does your use case require a relational program logic?</strong></li>\n<li>Any Related Work I should look at?  I am aware of F*, Dafny, Verus, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Classes/SatisfiesM.html#SatisfiesM\">the <code>SatisfiesM</code> experiment from Batteries</a>, the Rocq frameworks above and the literature on Dijkstra monads.</li>\n</ol>\n<p>Thanks!</p>",
        "id": 499713950,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739532684
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">said</a>:</p>\n<blockquote>\n<ol>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>. Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n</ol>\n</blockquote>\n<p>I assume you are aware of <a href=\"https://github.com/leanprover-community/iris-lean\">https://github.com/leanprover-community/iris-lean</a> ? It is starting to gain momentum with some of the people working on Iris, so while it's currently not really ready for use it may be in a better state once your work is getting closer to completion. Ideally these two frameworks will be able to work together seamlessly, and we should coordinate as needed to make sure this is the case</p>",
        "id": 499733706,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739537836
    },
    {
        "content": "<p>I would love to support that effort in some form. I could imagine the following definition for <code>triple</code> in terms of <a href=\"https://github.com/leanprover-community/iris-lean/blob/f1274361f9aee39717db8c7c0a611deddaf6ba9a/src/Iris/Instances/Classical/Instance.lean#L15\"><code>HeapProp</code></a> (could probably be generalised to any <code>BI</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HeapProp</span><span class=\"w\"> </span><span class=\"n\">VAL</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HeapProp</span><span class=\"w\"> </span><span class=\"n\">VAL</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">    </span><span class=\"bp\">□</span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"bp\">-⋆</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OBSERVE</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This is the interpretation suggested on p141 in <a href=\"https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf\">the Iris lecture notes</a>.<br>\nBut what is <code>M</code>? What is <code>OBSERVE</code>? What is <code>VAL</code>?</p>\n<p>Provided that a user can answer these questions for their domain, I have no doubts that they will be able to use the framework I have prototyped.</p>\n<p>I am however doubtful whether this will be useful to verify code using <code>IO.Ref</code>s.<br>\nFor example, even if we take <code>M := IO</code> and postulate <code>OBSERVE</code> as well as the structural rules of the logic, it is still quite difficult to find a <code>VAL</code> that lives in <code>Type 0</code>. <br>\nI have played around with using <code>VAL := Σ α, α</code> (because we want to allocate <code>IO.Ref</code>s for any kind of <code>α : Type</code>), but that lives in <code>Type 1</code>. A potential shortcoming of my prototype is that this universe bump requires several <code>ULift</code>s in pure instantiations where we do not even need separation logic. Frankly, this is unacceptable.</p>\n<p>I tried the alternative of indexing all computations over a heap context <code>Γ : Nat -&gt; Type</code> but stopped when I realized that I would need to sacrifice the functional dependency <code>m -&gt; stack</code> in doing so, because <code>Γ</code> occurs in the instantiation of <code>stack</code>. That turned out to be a no-go as well, because it greatly regresses type inference for all other instances.</p>\n<p>Long story short: I would be more than happy to anticipate support for future Separation Logics, however that support must not come at  a loss of convenience for other instances of the framework.</p>",
        "id": 499767219,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739546231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499713950\">said</a>:</p>\n<blockquote>\n<p>Fellow Lean users,</p>\n<p>As announced in the <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493913623\">Lean FRO meeting at Lean Together 2025</a>, I'm working on behalf of the Lean FRO on a Floyd/Hoare-style program logic framework to verify \"arbitrary\" monadic code written in Lean. <br>\nThis thread is meant to collect requirements from you! </p>\n<h3>Scope: \"Is this work relevant to my use case?\"</h3>\n<p>TLDR; this work could be relevant to you if you want to verify code written using Lean's <code>do</code>-notation.</p>\n<p>Let me clarify what \"program logic for monadic code\" means by giving a sketch of the definition of Hoare Triple I have in mind: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"kn\">where</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">triple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>(Find <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=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\">here the exact definition</a> I'm currently working with, but the above is close enough to give you an idea.)<br>\nThe intention is that any user may provide a definition of <code>M</code> and <code>triple</code> (plus structural rules) and then verify programs in <code>M</code> building on an extensive program logic with good automation and UX.</p>\n<p>In addition to scalable extrinsic proofs, the vision is to allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework.</p>\n<p>Note that although <code>M α</code> is \"semantics of a program in Lean\", you should be able to use this framework for any language with a denotational semantics into a monad.</p>\n<p>This should include any strongly normalizing object language such as System F, but exclude untyped lambda calculus, System F with recursive types or mutable references (finding monadic semantic domains for the latter is an <a href=\"https://arxiv.org/abs/2210.02169\">active research problem</a>).</p>\n<h3>Request for feedback</h3>\n<p>I am interested in gathering any kind of feedback (please keep focus on semantics rather than syntax that is likely to change <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>), or people I should reach out to that are <em>not yet</em> in the following list:</p>\n<p>Jeremy Avigad, Mario Carneiro, Wojciech Nawrocki, John Tristan, Jonathan Protzenko</p>\n<p>However, I'm specifically interested in feedback to the following items which I encourage you refer to in your answer:</p>\n<ol>\n<li>What is your use case?</li>\n<li>We need to figure out what \"arbitrary\" monadic code means. For example, my prototype would currently support any kind of transformer stack that can be represented as <code>StateT</code>/<code>ExceptT</code> (plus <code>ReaderT</code>/<code>WriterT</code> and equivalents through <code>StateT</code>) over <code>Id</code>/<code>IO</code>.  (Behavior of runtime <code>IO</code> functions will be axiomatised.) <strong>Is this sufficient for your use case?</strong> I'm asking because this plan does not currently include a Separation Logic to reason about <code>IO.Ref</code> or <code>ST.Ref</code>, and I'm yet unsure how much of a breaking change it would be to add this capability after the fact.</li>\n<li>The logic will include tactics on par with established Rocq frameworks such as <a href=\"https://www.chargueraud.org/softs/cfml/\">CFML</a> (of Separation Logic Foundations fame) or <a href=\"https://iris-project.org/\">Iris</a>.    Good integration with the upcoming <code>grind</code> tactic is a given. <strong>Any other frameworks I should take a look at?</strong></li>\n<li>My focus so far is on unary program logic. I have heard at least one voice who want to work in a relational program logic (relating multiple program runs with different preconditions) for cryptographic proofs à la <a href=\"https://github.com/SSProve/ssprove\">SSProve</a>. <strong>Does your use case require a relational program logic?</strong></li>\n<li>Any Related Work I should look at?  I am aware of F*, Dafny, Verus, <a href=\"https://leanprover-community.github.io/mathlib4_docs/Batteries/Classes/SatisfiesM.html#SatisfiesM\">the <code>SatisfiesM</code> experiment from Batteries</a>, the Rocq frameworks above and the literature on Dijkstra monads.</li>\n</ol>\n<p>Thanks!</p>\n</blockquote>\n<p>I only know Iris and have a passing experience with Satisfies and Dafny. The thing that annoyed me in Satisfies is how difficult it is to extract the guarantees from inside the satisfies monad and relate it to a specific input variable in a proof for a function outside the monadic context. I also have a question, which is that we currently use the Id monad for proofs. Is it a good idea to add support for a monad with a heap structure for use with separation logics?</p>",
        "id": 499770803,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1739547219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> Are you aware of the Dijkstra monad approach. I know there are other groups trying to implement it in Lean.<br>\n<a href=\"https://arxiv.org/abs/1903.01237\">https://arxiv.org/abs/1903.01237</a></p>\n<p>We've used it successfully for probabilistic relational Hoare logic in Coq: E.g. <a href=\"https://github.com/SSProve/ssprove\">https://github.com/SSProve/ssprove</a></p>",
        "id": 499774064,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1739548131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499770803\">said</a>:</p>\n<blockquote>\n<p>I only know Iris and have a passing experience with Satisfies and Dafny. The thing that annoyed me in Satisfies is how difficult it is to extract the guarantees from inside the satisfies monad and relate it to a specific input variable in a proof for a function outside the monadic context.</p>\n</blockquote>\n<p>What is appealing about definitions such as <code>SatisfiesM</code>is their applicability across different monads. Unfortunately we were unable to prove basic properties such as conjunction (<code>SatisfiesM x p -&gt; SatisfiesM x q -&gt; SatisfiesM x (p \\and q)</code>) with it. Then we tinkered with (the weaker)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">SatisfiesM</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">g</span>\n</code></pre></div>\n<p>but had trouble defining infinite conjunction (i.e., the logic's <code>forall</code>) in terms of it. That was when I gave up on this approach and had a look at encodings of <code>triple</code> based on effect observations/Dijkstra monads (see my next post).</p>\n<p><span class=\"user-mention silent\" data-user-id=\"466334\">Shreyas Srinivas</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499770803\">said</a>:</p>\n<blockquote>\n<p>I also have a question, which is that we currently use the Id monad for proofs. Is it a good idea to add support for a monad with a heap structure for use with separation logics?</p>\n</blockquote>\n<p>I'm not completely sure I understand the question. If all programs that you want to prove correct can be expressed in <code>Id</code> (or any number of <code>StateT</code> on top of that), I don't think you need separation logic. You need separation logic only if your programs have dynamic memory allocation, because you need a way to say, e.g., \"the <code>ST.Ref</code> <code>a</code> returned by <code>ST.mkRef</code> is distinct from any <code>ST.Ref</code> <code>b</code> returned by <code>ST.mkRef</code> in the future\" and to then preserve any property of <code>a</code> after <code>b</code> has been allocated. Without dynamic memory allocation, you can express this property statically in the type system as a stack of <code>StateT</code>s; the frame rule is an appropriate <code>liftM</code>.</p>",
        "id": 499787164,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739552241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499774064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> Are you aware of the Dijkstra monad approach. I know there are other groups trying to implement it in Lean.<br>\n<a href=\"https://arxiv.org/abs/1903.01237\">https://arxiv.org/abs/1903.01237</a></p>\n<p>We've used it successfully for probabilistic relational Hoare logic in Coq: E.g. <a href=\"https://github.com/SSProve/ssprove\">https://github.com/SSProve/ssprove</a></p>\n</blockquote>\n<p>Yes, I am. In fact, until this week I had based my prototype framework around effect <code>Observation</code>s defined by</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">class</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">outParam</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"kn\">extends</span><span class=\"w\"> </span><span class=\"n\">MonadOrdered</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"n\">pure_pure</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">Pure</span><span class=\"bp\">.</span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">a</span>\n<span class=\"w\">  </span><span class=\"n\">bind_bind</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>You could define <code>def triple x P Q := P ≤ x.observe Q</code> in terms of this type class, and that would work well for most instances (except separation logic, where you want persistent separating implication as alluded to in my previous post instead of entailment).</p>\n<p>Again, what is important for the planned framework is that it is maximally convenient for the \"<code>StateT</code>/<code>ExceptT</code> on top of <code>Id</code>\" use case. <code>Observation</code>/Dijkstra monads allow for a polymorphic monad stack, which is nice.<br>\nHowever, when I tried to actually prove stuff about monad-polymorphic functions such as <code>forIn</code> or <code>foldlM</code>, I noticed that it is incredibly difficult to do so. Here is an example for <code>forIn</code>, allowing the user to supply a loop invariant. (I have successfully applied this lemma in my experiments, so it is useful.) Mind my difficulty expressing pre and post conditions such as <code>hpre</code> and <code>hstep</code>in this framework:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">forIn_list</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">Preorder</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">obs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">tl</span>\n<span class=\"w\">    </span><span class=\"bp\">∨</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\">  </span><span class=\"bp\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[])</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"w\"> </span><span class=\"n\">MonadOrdered</span><span class=\"w\"> </span><span class=\"k\">in</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Intuition: inv encapsulates the effects of looping over a prefix of xs (and gets passed the suffix)</span>\n<span class=\"w\">    </span><span class=\"c1\">-- The induction hypothesis is:</span>\n<span class=\"w\">    </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">suffix</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">suffices</span><span class=\"w\"> </span><span class=\"n\">hind</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">      </span><span class=\"c1\">-- This is because the predicate transformer is stronger (≤) than the invariant,</span>\n<span class=\"w\">      </span><span class=\"c1\">-- and the longer the suffix passed to `prog`, the more we rely on predicate transformer.</span>\n<span class=\"w\">      </span><span class=\"c1\">-- Conversely, the shorter the suffix, the more we rely on the invariant summarizing the effects of looping over a prefix.</span>\n<span class=\"w\">      </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">inferInstance</span>\n<span class=\"w\">      </span><span class=\"k\">calc</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">pure_bind</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c1\">-- only [List.forIn_nil, obs.pure_pure, bind_pure]</span>\n<span class=\"w\">        </span><span class=\"c1\">-- For the after case (xs=[]), we have a lower bound because `forIn [] b` reduces to `pure b`</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"c1\">-- For the initial case (full xs), we have an upper bound via hpre</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">obs</span><span class=\"bp\">.</span><span class=\"n\">observe</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">hind</span>\n<span class=\"w\">        </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"c1\">-- Now prove hind : prog xs ≤ prog [] by induction</span>\n<span class=\"w\">    </span><span class=\"n\">clear</span><span class=\"w\"> </span><span class=\"n\">hpre</span><span class=\"w\"> </span><span class=\"c1\">-- not needed any longer and would need to be generalized</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp_all</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">nil_append</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inl</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"n\">h</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonadOrdered</span><span class=\"bp\">.</span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bind_map_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">inr</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">prog</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_nil</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Observation</span><span class=\"bp\">.</span><span class=\"n\">bind_bind</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"n\">bind_assoc</span><span class=\"o\">]</span>\n<span class=\"w\">        </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LE</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">MonadOrdered</span><span class=\"bp\">.</span><span class=\"n\">bind_mono</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">rfl</span><span class=\"o\">))</span>\n<span class=\"w\">        </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">bind_map_left</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">le_refl</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">prog</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Note</p>\n<ul>\n<li><code>pure init ≤ inv xs</code> expresses that <code>init</code> satisfies the precondition <code>inv xs</code>. Although I came up with this after long and hard thinking, I have no real intutition for what <code>inv xs</code> means. Its domain <code>w β</code> is <em>huge</em>, potentially encompassing all kinds of predicate transformers. </li>\n<li>In <code>hstep</code>, I want to express that the result of the loop iteration <code>f hd b</code> satisfies <code>inv [] b'</code> when it is <code>.done b'</code>, and <code>inv xs b'</code> when it is <code>.yield b'</code>. This is incredibly difficult to state and requires a disjunction. The disjunction means <code>hstep</code> is going to be hard to automate for the user of the lemma.</li>\n<li>While I could have required <code>∀{α}, CompleteLattice (w α)</code> instead and formulated <code>hstep</code> as <code>(inv (hd :: tl) &gt;&gt;= fun b =&gt; obs.observe (f hd b)) ≤ (.yield &lt;$&gt; inv tl ⊔ .done &lt;$&gt; inv [])</code> instead, this would not helped much with the automation problem.</li>\n</ul>\n<p>So I found myself wondering whether we could find a way to expose the means to formulate proper pre and postconditions. In doing so I came up with the framework I propose and realized that we do not need <code>Observation</code> at all. Here's the equivalent lemma in the framework I propose:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">Triple</span><span class=\"bp\">.</span><span class=\"n\">forIn_list</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">MonadTriple</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">LawfulMonadTriple</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"o\">]</span>\n<span class=\"w\">  </span><span class=\"o\">{</span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ForInStep</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">PreCond</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">,</span>\n<span class=\"w\">      </span><span class=\"o\">⦃</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">⦄</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">yield</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">done</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">⦄)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"o\">⦃</span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">forIn</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">⦃</span><span class=\"bp\">⇓</span><span class=\"n\">b'</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">inv</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">b'</span><span class=\"o\">⦄</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span>\n<span class=\"w\">    </span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">generalizing</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_pure</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">    </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">ih</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">forIn_cons</span><span class=\"o\">]</span>\n<span class=\"w\">      </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_bind</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">hx</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">hstep</span><span class=\"w\"> </span><span class=\"n\">hd</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"n\">init</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">herror</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">      </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">hf</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"n\">intro</span><span class=\"w\"> </span><span class=\"n\">b</span>\n<span class=\"w\">        </span><span class=\"n\">split</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">LawfulMonadTriple</span><span class=\"bp\">.</span><span class=\"n\">triple_pure</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">        </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">exact</span><span class=\"w\"> </span><span class=\"n\">ih</span>\n</code></pre></div>\n<p>It is <em>so much simpler</em>. Maybe I'm doing something wrong or missing a trick in my encoding of effect observations. If that is indeed the case, I would like to see how to improve on <code>Observation.forIn_list</code>.</p>",
        "id": 499787873,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739552425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> I haven't tried thinking about the details of your proposed approach, but it looks well thought-out. The issues we ran into in the past were really quite basic:</p>\n<ol>\n<li><code>do</code> notation does not provide a way to state and prove loop invariants. It seems that adding this is a foundational component of your strategy.</li>\n<li>With <code>SatisfiesM</code> specifically, we can prove <code>p arg a</code> where <code>arg</code> is the input, and <code>a : α</code> is the value produced by <code>M α</code>, but there is no way to reason about other cases, e.g. failure in <code>Except</code>: we may only show that if the result is <code>.ok v</code> then <code>p arg v</code>, but not that if the result is <code>.err e</code> then <code>q arg e</code>. Perhaps building <code>except</code> into your <code>TransStack</code> accounts for this?</li>\n</ol>\n<blockquote>\n<p>allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework</p>\n</blockquote>\n<p>I am also curious about this statement. My current model of verified programming in DTT is that certain intrinsically-verified programs cannot be expressed extrinsically. Here is the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">tizio</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- imagined syntax</span>\n<span class=\"w\">    </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>In this program, the executable code includes an array-bound proof term derived from proofs about earlier parts of the program. I don't immediately see how this could be expressed extrinisically (i.e., write the code first and the prove it correct as a separate theorem), and I suspect that it cannot.</p>",
        "id": 499934353,
        "sender_full_name": "𝚠𝚘𝚓𝚌𝚒𝚎𝚌𝚑 𝚗𝚊𝚠𝚛𝚘𝚌𝚔𝚒",
        "timestamp": 1739641553
    },
    {
        "content": "<p>Hypothetically speaking it should be possibel to generate a function <code>tizio_aux</code> that contains the old body of <code>tizio</code> but also a proof argument that is abstracted over   the necessary hypotheses and plugs these hypothesis in at the appropriate array spots, then redefine <code>tizio</code> in terms of <code>tizio_aux &lt;your_external_proof_term&gt;</code> right? I'm not saying that this is convenient but at least a technical possibility and potentially automatable.</p>",
        "id": 499938836,
        "sender_full_name": "Henrik Böving",
        "timestamp": 1739643377
    },
    {
        "content": "<p>Me and <span class=\"user-mention\" data-user-id=\"246591\">@Quang Dao</span>  would have a definite use case for this in verifying cryptographic code (see <a href=\"https://github.com/dtumad/VCV-io\">here</a>). Having a standardized program logic would be very useful to simplify proofs that currently require ad-hoc reasoning.</p>\n<p>Specifically to your questions, in our use case we've been writing algorithms using a relatively simple monad stack, the main definition being a type to represent computations with oracles, which we use for uniform selection, random oracles, security game oracles, etc. More explicitly our main stack is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"kn\">protected</span><span class=\"w\"> </span><span class=\"n\">pure</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">roll</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"c1\">-- Map from indexing set to domain/range type of that oracle</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span>\n\n<span class=\"c1\">-- Functor to represent queries with a given output type</span>\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">domain</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">range</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Most definitions are written in terms of this monad</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">ι</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OptionT</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMonad</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Operational semantics are essentially just the universal properties of <code>OptionT</code>/<code>FreeMonad</code>, letting us lift a mapping from <code>OracleQuery</code> to a new monad <code>m</code> to one from <code>OracleComp</code> to <code>m</code>. The monads you listed seem to cover all our use cases of this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">structure</span><span class=\"w\"> </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleSpec</span><span class=\"w\"> </span><span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleQuery</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">simulateQ</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Monad</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Alternative</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">]</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">OptionT</span><span class=\"bp\">.</span><span class=\"n\">mapM'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">FreeMonad</span><span class=\"bp\">.</span><span class=\"n\">mapM'</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"bp\">.</span><span class=\"n\">impl</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Example responding to repeated queries with a cache using StateT</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">cachingOracle</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">DecidableEq</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">QueryImpl</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">StateT</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">QueryCache</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"n\">impl</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"n\">u</span>\n<span class=\"w\">    </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Option</span><span class=\"bp\">.</span><span class=\"n\">none</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">QueryCache</span><span class=\"bp\">.</span><span class=\"n\">queryFresh</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">t</span>\n</code></pre></div>\n<p>Denotational semantics are just the case of mapping this into the <code>PMF</code> monad (actually <code>OptionT PMF</code> to represent a spmf):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">evalDist</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">spec</span><span class=\"bp\">.</span><span class=\"n\">FiniteRange</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\">    </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">OptionT</span><span class=\"w\"> </span><span class=\"n\">PMF</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"n\">simulateQ</span><span class=\"w\"> </span><span class=\"bp\">⟨</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">query</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">OptionT</span><span class=\"bp\">.</span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">PMF</span><span class=\"bp\">.</span><span class=\"n\">uniformOfFintype</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"w\"> </span><span class=\"n\">oa</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">probOutput</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">oa</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">OracleComp</span><span class=\"w\"> </span><span class=\"n\">spec</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"w\"> </span><span class=\"o\">:=</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">evalDist</span><span class=\"w\"> </span><span class=\"n\">oa</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">some</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I do think a relational program logic would be nice for our case, although the unary case would also be helpful.</p>",
        "id": 499942814,
        "sender_full_name": "Devon Tuma",
        "timestamp": 1739646858
    },
    {
        "content": "<p>Hi, this sounds quite interesting. I am currently not working with Lean, but I am quite interested in using it for Iris-based verification in the future.<br>\n We recently presented a modular method for building program logics at POPL: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3704847\">https://dl.acm.org/doi/pdf/10.1145/3704847</a><br>\nOur approach is based on the free monad (or more concretely its implementation in Rocq in the form of interaction trees) and it allows one to modularly combine different effects in a program and reuse proofs. In particular, I think this approach provides a higher degree of modularity and reuse than an Dijkstra-monad-based approach.<br>\nOur target was to modularly build program logics for Iris and I would expect that one wants to use a similar approach if Iris gets ported to Lean. But I have not thought about general monadic programs, so maybe the tradeoffs are a bit different there.<br>\nMaybe some ideas from that paper could also be useful for what you have in mind. Let me know if you have any questions about this paper. I would be happy to talk more about this.</p>",
        "id": 500104446,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1739778261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"128280\">Wojciech Nawrocki</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499934353\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> I haven't tried thinking about the details of your proposed approach, but it looks well thought-out. The issues we ran into in the past were really quite basic:</p>\n<ol>\n<li><code>do</code> notation does not provide a way to state and prove loop invariants. It seems that adding this is a foundational component of your strategy.</li>\n</ol>\n</blockquote>\n<p>Thanks! Indeed. Stating and proving loop invariants is just \"the specification lemma\" for <code>forIn</code> that I called <code>Triple.forIn_list</code> above.</p>\n<blockquote>\n<ol start=\"2\">\n<li>With <code>SatisfiesM</code> specifically, we can prove <code>p arg a</code> where <code>arg</code> is the input, and <code>a : α</code> is the value produced by <code>M α</code>, but there is no way to reason about other cases, e.g. failure in <code>Except</code>: we may only show that if the result is <code>.ok v</code> then <code>p arg v</code>, but not that if the result is <code>.err e</code> then <code>q arg e</code>. Perhaps building <code>except</code> into your <code>TransStack</code> accounts for this?</li>\n</ol>\n</blockquote>\n<p>Yes; the <a href=\"https://live.lean-lang.org/#project=mathlib-stable&amp;codez=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\"><code>PostCond</code> type</a> contains a failure \"continuation\" for every <code>ExceptT</code> in the stack. That said, this is not the only viable design. I think that if the one-specification-monad-to-rule-them-all <code>SatisfiesM</code> would have worked out, we could encode the same information syntactically rather than semantically via the semantics of <code>tryCatch</code>.<br>\nSo something like <code>SatisfiesM (tryCatch (.ok &lt;$&gt; e) (.error \\o pure)) (fun | .ok a =&gt; p a | .error e =&gt; q e)</code> would work (<code>tryCatch</code> is used to \"interpret\" <code>ExceptT</code> here).  </p>\n<blockquote>\n<blockquote>\n<p>allow convenient <strong>intrinsic</strong> F*/Dafny/Verus-style proofs embedded into <code>do</code> blocks by elaboration into the extrinsic framework</p>\n</blockquote>\n<p>I am also curious about this statement. My current model of verified programming in DTT is that certain intrinsically-verified programs cannot be expressed extrinsically. Here is the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">tizio</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"mi\">0</span><span class=\"o\">:</span><span class=\"n\">n</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">invariant</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"> </span><span class=\"c1\">-- imagined syntax</span>\n<span class=\"w\">    </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">..</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span><span class=\"bp\">'</span><span class=\"o\">(</span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>In this program, the executable code includes an array-bound proof term derived from proofs about earlier parts of the program. I don't immediately see how this could be expressed extrinisically (i.e., write the code first and the prove it correct as a separate theorem), and I suspect that it cannot.</p>\n</blockquote>\n<p>By \"intrinsic\" above I was referring to taking a function that would type-check all on its own, and then augmenting its definition with <code>requires</code>, <code>ensures</code>, <code>assert</code> and <code>invariant</code> syntax to specify a contract intrinsically. I would hope that the ensuing verification conditions (predicate entailments) would be discharged by e.g. <code>grind</code> for maximal convenience.<br>\nThis would be equivalent to implementing a post-processing step that extracts <code>requires</code>, <code>ensures</code>, <code>assert</code>s etc. and turns them into an extrinsic specification that can be proven entirely by a fixed set of tactics.</p>\n<p>In your example, the function wouldn't type-check without the array-bounds proof, so that would not fall within the \"intrinsic specification\" use case.<br>\nOn a related note, <code>while True</code> and <code>partial def</code> is unlikely to be supported. Perhaps the definitions provided by the <code>partial_fixpoint</code> work can be utilized, but that is yet hard to anticipate.</p>",
        "id": 500126921,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739784296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319772\">Devon Tuma</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499942814\">said</a>:</p>\n<blockquote>\n<p>Me and <span class=\"user-mention silent\" data-user-id=\"246591\">Quang Dao</span>  would have a definite use case for this in verifying cryptographic code (see <a href=\"https://github.com/dtumad/VCV-io\">here</a>). Having a standardized program logic would be very useful to simplify proofs that currently require ad-hoc reasoning.</p>\n<p>Specifically to your questions, in our use case we've been writing algorithms using a relatively simple monad stack, the main definition being a type to represent computations with oracles, which we use for uniform selection, random oracles, security game oracles, etc.</p>\n</blockquote>\n<p>Indeed, that should work nicely. Can you give an example of a relational property you would like to see specified? That is, how would <code>triple</code> need to be generalized for your relational use case? Would something like this help? (NB: <code>$states → Prop</code> is like a set of <code>tupleOf $states</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reltriple</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">states</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Prop</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"bp\">...</span>\n</code></pre></div>\n<p>Example for a pre and postcondition modelling non-interference on <code>StateT {secret : Bool, public : Nat} Id</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">secret</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">true</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">secret</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">public</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">α₁</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">α₂</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">σ₁</span><span class=\"bp\">.</span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">σ₂</span><span class=\"bp\">.</span><span class=\"n\">public</span>\n</code></pre></div>\n<p>(The interpretation of these predicates in <code>reltriple</code> must be monotonic.)</p>\n<p>The problem with the relational case is that the design space is so large.</p>\n<ul>\n<li>I think the definition <code>reltriple</code> above characterises many 2-properties (of the same program), but some relational properties want to relate <em>two different programs</em> with each other, and the above does not allow for that.</li>\n<li>There is also the question of whether one wants to relate a code path that throws a particular exception <code>ε</code> with a successful execution returning an <code>α</code>. This affects the encoding of <code>PostCond</code>.</li>\n</ul>\n<p>I think we might want to hold back on this feature until we have more information on what kind of relational properties people want to express.</p>",
        "id": 500132682,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739785679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"574718\">Michael Sammler</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500104446\">said</a>:</p>\n<blockquote>\n<p>Hi, this sounds quite interesting. I am currently not working with Lean, but I am quite interested in using it for Iris-based verification in the future.<br>\n We recently presented a modular method for building program logics at POPL: <a href=\"https://dl.acm.org/doi/pdf/10.1145/3704847\">https://dl.acm.org/doi/pdf/10.1145/3704847</a><br>\nOur approach is based on the free monad (or more concretely its implementation in Rocq in the form of interaction trees) and it allows one to modularly combine different effects in a program and reuse proofs. In particular, I think this approach provides a higher degree of modularity and reuse than an Dijkstra-monad-based approach.</p>\n</blockquote>\n<p>Great work! That looks like a neat approach if you want to reason about your own bespoke object language.<br>\nThough a small nit: Judging from the non-structural recursion in the application case in Fig. 9 I think I would have referred to the approach as \"coinductive big-step\" rather than \"denotational\".<br>\nOn the other hand, this makes me realize that my use \"denotational\" in the OP could perhaps be weakened to \"coinductive big-step\". That said, the program logic will only be useful to reason about calls to the <em>interpreter</em>, and not so much for reasoning about expressions in the object language; that would require bespoke specification lemmas and perhaps an entire tactic stack on top. At this point, I'm unsure whether the program logic is so useful at all for this use case...</p>\n<p>Just this weekend I had a look at the <a href=\"https://lthms.github.io/FreeSpec/coq/FreeSpec.Core.Impure.html#impure\">FreeSpec library</a> which is based on free monads, but they don't really apply it to a language with an interesting semantics...</p>\n<p>Regarding Iris: the goal of the planned framework is to provide a program logic for reasoning about programs written <em>in Lean as shallowly-embedded object language</em>. It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean. <br>\nThe program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>",
        "id": 500148363,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739789360
    },
    {
        "content": "<p>Thanks for your thoughts on this!</p>\n<blockquote>\n<p>Though a small nit: Judging from the non-structural recursion in the application case in Fig. 9 I think I would have referred to the approach as \"coinductive big-step\" rather than \"denotational\".</p>\n</blockquote>\n<p>I guess it depends on the view point and we also had some discussion about whether to use \"denotational\" or some other term when writing the paper. We landed on \"denotational\" since I would argue that one can view InteractionTrees as a semantic domain that we denote our expressions into, but one can argue about it. (In fact, I would see the non-structural recursion you mention as an argument for calling the approach denotational since we denote recursion into a recursion combinator of the semantic domain instead of doing the fixpoint ourselves, but I guess this is a matter of perspective.)</p>\n<blockquote>\n<p>That said, the program logic will only be useful to reason about calls to the <em>interpreter</em>, and not so much for reasoning about expressions in the object language; that would require bespoke specification lemmas and perhaps an entire tactic stack on top.</p>\n</blockquote>\n<p>I should clarify: The Program Logics a la Carte paper has two parts that can be separated: First, it provides a program logics for effectful programs (in the form of interaction trees) that provides nice modular reasoning principles. Second, it shows how use can use this program logic to build programs logics for object-level languages for it. For your purposes, only the first part is really relevant and I think you can ignore all parts about the object level languages. (This might be interesting to look at in the future, but probably not in the initial step.)</p>\n<blockquote>\n<p>Just this weekend I had a look at the <a href=\"https://lthms.github.io/FreeSpec/coq/FreeSpec.Core.Impure.html#impure\">FreeSpec library</a> which is based on free monads, but they don't really apply it to a language with an interesting semantics...</p>\n</blockquote>\n<p>At least from my perspective, <a href=\"https://github.com/DeepSpec/InteractionTrees/tree/master\">interaction trees</a> have superseeded the FreeSpec library as the canonical implementation of free monads in Rocq, so I would look at them instead. There have been quite a few interesting semantics formalized using interaction trees at this point (see e.g. the paper).</p>\n<blockquote>\n<p>The program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n</blockquote>\n<p>Just to make sure that we are one the same page: The Program Logics a la Carte paper proposes to replace this program logic part of Iris that is geared towards operational semantics of deeply-embedded languages with the denotational approach to interaction trees. I think the denotational way has significant advantages (in particular wrt. modularity) and if Iris gets ported to Lean, it might make sense to port the denotation approach to build a program logic instead of the old operational semantics based one.</p>\n<blockquote>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>\n</blockquote>\n<p>This is actually something something that surprised me when working on that paper, but the approach we use there and which is not too different from what you are proposing, scales to a surprisingly large number of effects. In the paper, we support the following effects among others: state, non-determinism, undefined behavior, aborting, concurrency, I/O with trace properties, non-termination. However, some of these effects rely on the expressiveness of Iris (e.g. non-termination relies on step-indexing), but maybe it is possible to achieve a similar large set of effects for your approach. </p>\n<blockquote>\n<p>It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean.</p>\n</blockquote>\n<p>This makes a lot of sense and I fully agree with this goal. To be clear, I don't want to argue that it makes sense to directly use the approach from the paper, instead I just want to share my perspective as someone who has worked on similar problems in the past and hope that this is useful for finding a solution that works well for Lean.</p>",
        "id": 500156586,
        "sender_full_name": "Michael Sammler",
        "timestamp": 1739791361
    },
    {
        "content": "<p>Thanks again for your reply! I will definitely have a closer look at the first part of your paper then.<br>\nIt is pretty likely that interaction trees are out of scope as an out-of-the-box instance of <code>MonadTriple</code> because there currently is no formalisation of interaction trees in Lean's standard library. However, I would hope that your paper will guide me to a framework which could be instantiated for a user-written interaction tree library.</p>",
        "id": 500162133,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739792808
    },
    {
        "content": "<p>Hi, this would be really useful for the <a href=\"https://github.com/AeneasVerif/aeneas\">Aeneas project</a> that I'm working on (in collaboration with Jonathan Protzenko and others) where we do extrinsic proofs about pure models generated from Rust code and which live in an error monad:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">inductive</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Result</span><span class=\"w\"> </span><span class=\"n\">α</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">div</span><span class=\"w\"> </span><span class=\"c1\">-- for partial_fixpoint</span>\n</code></pre></div>\n<p>We had to put a fair amount of work into writing a <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/backends/lean/Aeneas/Progress/Progress.lean\"><code>progress</code></a> tactic to do proofs in a Hoare-logic style and which is a bit equivalent to CFML's <code>xapp</code>, though in our case we are not concerned about framing separation logic specifications but rather about automatically discharging preconditions.</p>\n<p>For now, because we only work with one monad and do not specify failing or divergent executions (we prove total correctness theorems) we write our theorems in a very specific shape (<code>progress</code> is mostly syntax driven - I would like something more general of course). For instance, this is the theorem to reason about addition about U32 machine integers and that <code>progress</code> knows how to manipulate (it automatically looks it up whenever seeing a call to <code>+</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">progress</span><span class=\"kd\">]</span><span class=\"w\"> </span><span class=\"c1\">-- saves the theorem in the relevant database</span>\n<span class=\"kd\">theorem</span><span class=\"w\"> </span><span class=\"n\">U32.add_spec</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U32</span><span class=\"o\">}</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">hmax</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">≤</span><span class=\"w\"> </span><span class=\"n\">U32.max</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"c1\">-- precondition</span>\n<span class=\"w\">  </span><span class=\"c1\">-- there is generally a list of preconditions, and which live in different theories (i.e., require different solvers)</span>\n<span class=\"w\">  </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"c1\">-- there are usually several existentially quantified variables</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"bp\">↑</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Int</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"bp\">↑</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"c1\">-- post-condition</span>\n<span class=\"w\">  </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"kd\">by</span><span class=\"w\"> </span><span class=\"bp\">....</span>\n</code></pre></div>\n<p>This is a specific class of proofs, but quite informative of what we need in practice, I believe, and I have a few examples of proofs that you can have a look at. For instance, there is the <a href=\"https://github.com/AeneasVerif/aeneas/blob/29d05d86d410d469a6979409777e869a390efbfc/tests/lean/Tutorial/Solutions.lean#L414\">tutorial</a> which showcases proofs about list-manipulating functions and a (minimal) big num library. We also have proofs about an <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/tests/lean/Avl/Properties.lean\">AVL tree</a> and a <a href=\"https://github.com/AeneasVerif/aeneas/blob/main/tests/lean/Hashmap/Properties.lean\">hashmap</a> (the latter one is quite old and needs deep cleaning). I'm currently working on the verification of a Rust implementation of the ML-KEM post-quantum cryptographic primitive (not public yet).</p>\n<p>I believe there are quite a few things that need improvement and that would benefit from a more systematic approach.</p>\n<ol>\n<li>\n<p>For now, we only work with an error monad but in the future we will have to work with code which lives in more expressive monads to reason about some form of aliasing, I/O, or concurrency. An extremely useful feature would be a way of seamlessly switching between monads, for instance by having a way of lifting theorems (from, say, an error monad to a state error monad). Also, I mentioned that we currently only prove total correctness theorems, but users of the framework may also want to prove partial correctness theorems. It would be nice to have a way of easily switching between partial correctness and total correctness proofs, in particular by factoring theorems out. For instance, it should be possible to write a correctness theorem about <code>+</code> which specifies both the <code>ok</code> and <code>fail</code> cases, and use it in both partial and total correctness proofs, in the latter case by using the specification of <code>fail</code> as a precondition that has to be disproved.</p>\n</li>\n<li>\n<p>It is currently not extremely convenient to reason about sub-expressions; the problem of loops has been mentioned above, but I also need a way of easily reasoning about expressions like this (today <code>progress</code> is good at reasoning about <em>function calls</em>):</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">i1</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<ol start=\"3\">\n<li>(those are maybe more of technical details at this stage, but I think it's important to mention them to inform about the proof experience) so far, most of the work has been put into writing the <code>progress</code> tactic so that the proofs are smooth, in particular when it comes to discharging pre-conditions. This tactic uses several simple, yet extremely useful tactics (<code>simp</code>, a tactic which looks a bit like <code>assumption</code> but which uses more clever heuristics to instantiate meta-variables, and a solver based on <code>omega</code>) - I can share a document about this if you are interested. Those tactics are currently hardcoded, but in the future we want them to be customizable: one non-obvious problem here is how to quickly figure out which solver should be applied on which precondition (we can't just try them one after the other as they tend to be expensive). It can also happen that we want to switch between different flavours of \"spec\" theorems depending on the program we verify. For instance I mentioned the problem of partial vs total correctness above. Another example is that in most situations today we want to use the <code>+</code> theorem I showed above which specifies addition in terms of <code>Int</code>, but when reasoning about a function performing bitwise operations we want to systematically lookup theorems which specify arithmetic operations in terms of bitvector operations, etc.</li>\n</ol>",
        "id": 500163298,
        "sender_full_name": "Son Ho",
        "timestamp": 1739793135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"371938\">Son Ho</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500163298\">said</a>:</p>\n<blockquote>\n<p>do not specify failing or divergent executions (we prove total correctness theorems) we</p>\n</blockquote>\n<p>You man “partial correctness”, right?</p>",
        "id": 500180060,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739797283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500180060\">said</a>:</p>\n<blockquote>\n<p>You man “partial correctness”, right?</p>\n</blockquote>\n<p>I was slightly imprecise. I believe a partial correctness theorem would go like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>In our case we prove panic freedom which means our theorems are total correctness theorems I think:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">exists</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">/\\</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n</code></pre></div>\n<p>But because here <code>fail</code> actually models a <code>panic</code> in Rust, and as it is possible to recover from panic in some situations, we may want to prove theorems of the following shape:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">forall</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">ok</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">post</span><span class=\"w\"> </span><span class=\"n\">y</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"bp\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- something like this probably?</span>\n</code></pre></div>",
        "id": 500183173,
        "sender_full_name": "Son Ho",
        "timestamp": 1739798032
    },
    {
        "content": "<p>Ah, yes, that looks like total correctess to me. I misread the prose then.</p>",
        "id": 500200854,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1739802067
    },
    {
        "content": "<p>Thanks, Son Ho, your pointer to Aeneas' <code>progress</code> tactic and its examples will be incredibly valuable. I think I'm already starting to encounter similar challenges in the examples I'm looking at (without a tactic such as <code>progress</code>). The <code>Result</code> type seems entirely reasonable to instantiate <code>triple</code> for.</p>\n<blockquote>\n<p>more expressive monads to reason about some form of aliasing, I/O, or concurrency</p>\n</blockquote>\n<p>As alluded to in <a class=\"message-link\" href=\"/#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/499767219\">#Program verification &gt; Monadic program logic: Request for feedback @ 💬</a>, I have played around with an encoding of separation logic, but realized that you would need to somehow restrict the kinds of computations that end up in the heap to a closed universe, so that its entries can have <code>Type 0</code> rather than <code>Type 1</code> for the general <code>Σ α, α</code>. For this reason, I do not yet have plans to include a monad transformer adding a separation logic-based heap out of the box, but since the syntax of predicates is the same as for <code>StateT</code>, we could nurture such a transformer in a separate library first. I do not yet know how to model concurrency in this framework appropriately.</p>\n<blockquote>\n<p>This tactic uses several simple, yet extremely useful tactics [...]. I can share a document about this if you are interested.</p>\n</blockquote>\n<p>I would be very interested in that. It is something that I have been wondering as well, but put on my backlog because it is impossible to solve without seeing concrete instances, which I hopefully will see soon.</p>",
        "id": 500214056,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1739805018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500214056\">said</a>:</p>\n<blockquote>\n<p>I would be very interested in that.</p>\n</blockquote>\n<p>I wrote this down in my <a href=\"https://www.sonho.fr/papers/thesis-manuscript.pdf\">PhD dissertation</a>, chapter 14.3.3 \"Hoare-Logic Style Proofs and the progress Tactic\". I will be very happy to provide additional feedback if you have questions.</p>",
        "id": 500217205,
        "sender_full_name": "Son Ho",
        "timestamp": 1739805724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500214056\">said</a>:</p>\n<blockquote>\n<p>but since the syntax of predicates is the same as for <code>StateT</code>, we could nurture such a transformer in a separate library first</p>\n</blockquote>\n<p>Yes, at this stage I'm also not sure what's the best way to proceed and what I will <em>actually</em> need either. But I intend to study the problem of verifying stateful code (i.e., code which I can't model only with an error monad) later this year: this should provide interesting insights about how to combine these kinds of reasonings.</p>",
        "id": 500220718,
        "sender_full_name": "Son Ho",
        "timestamp": 1739806507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130195\">Sebastian Graf</span> <a href=\"#narrow/channel/236449-Program-verification/topic/Monadic.20program.20logic.3A.20Request.20for.20feedback/near/500148363\">said</a>:</p>\n<blockquote>\n<p>Regarding Iris: the goal of the planned framework is to provide a program logic for reasoning about programs written <em>in Lean as shallowly-embedded object language</em>. It is not currently a goal to be forward compatible with every future project, especially not if it is not about verifying programs written in Lean. <br>\nThe program logic of Iris (in contrast to just its logic of bunched implications implemented in <code>iris-lean</code>) in particular is geared towards operational semantics of \"deeply-embedded\" languages.</p>\n<p>I think the main limiting factor when it comes to reusing the planned framework for custom, non-standard monads is that the shape of pre and postconditions must be encodable in a fixed language that is currently targeted towards stacks of <code>StateT s</code> and <code>ExceptT ε</code>. I'm not sure if this is expressive enough for general free monads or interaction trees.</p>\n</blockquote>\n<p>My inclination regarding this is that you should take care to separate the <em>syntax</em> of do notation programs with invariants from the <em>interpretation</em> of those programs and specifications wrt lean shallow embedding. I agree that lean shallow embedded programs should be the main focus, but it should be possible to leverage some parts of the frontend to do similar things even if the specification language is something fancy. </p>\n<p>This is more or less what I mean by \"working together with iris-lean\": it should be possible for iris-lean to present an interface that feels native to the greatest extent possible. I don't want to tie your hands too much here, but please don't do like <code>do</code> did and make a completely non-extensible system (and leave it unmaintained for a long time). I'm sure you weren't really thinking of doing so anyway, but I want to stress that extensibility and pluggability of the architecture is very much a use case that matters to me.</p>",
        "id": 500289419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1739834884
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> I just found this thread. I am literally right now trying to verify some code that uses do notation and running into the issue that I don't have for loop pre- and post-conditions! (In particular, it makes working with mutable arrays where I want to prove facts about their size at the end of the loop quite tricky.)</p>",
        "id": 507043386,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742493809
    },
    {
        "content": "<p>In general I am very interested in this work.</p>",
        "id": 507043689,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742493893
    },
    {
        "content": "<p>You could give my prototype a try; here's an example for proving a loop-based fibonacci function correct: <a href=\"https://github.com/sgraf812/mpl/blob/682c1f7ef8dfee8f1b565338c5a8f3c80d6442f1/Tests/Toy.lean#L284\">https://github.com/sgraf812/mpl/blob/682c1f7ef8dfee8f1b565338c5a8f3c80d6442f1/Tests/Toy.lean#L284</a>.<br>\nDislaimer: Not \"ready for production\" yet.</p>\n<p>What kind of code are we talking about? What kind of mutable arrays in particular? Is it the local kind of mutability, i.e. just <code>let mut arr : Array Blah := ...</code>?</p>",
        "id": 507045922,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1742494670
    },
    {
        "content": "<p>Yes, it's nothing particularly fancy. Though it uses vectors rather than arrays which makes the types more of a headache.</p>",
        "id": 507538742,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1742714357
    },
    {
        "content": "<p>I think the dust on the semantic foundations and the general UX vision for manual proofs has settled.<br>\nIt's time to elicit a bit of guinea pig feedback! You can depend on <code>mpl</code> by adding the following <code>requires</code> to your lakefile.toml:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"o\">[[</span><span class=\"n\">require</span><span class=\"o\">]]</span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"mpl\"</span>\n<span class=\"n\">git</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"https://github.com/sgraf812/mpl\"</span>\n<span class=\"n\">rev</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"s2\">\"pre-release\"</span>\n</code></pre></div>\n<p>Alternatively, you can just clone the repository and play with the files in <code>Test/</code>, such as <code>Test/Toy.lean</code>.</p>\n<p><strong>Bear in mind that this not an official release! This library is not ready for production use. Please do not emphatically share this request. The automation is still hacky and underdeveloped and subject to change.</strong> </p>\n<p>I would be very happy for you to <code>import MPL</code>, give it a go and let me know about the general proof mode UX (examples in <code>Test/Toy.lean</code>). I am specifically interested in your opinion on</p>\n<ol>\n<li>The semantic foundations. Hoare triples are encoded based on a notion of predicate transformers that is parameterized by a <code>PostShape</code> parameter. Batteries are included for the typical transformer primitives (<code>StateT</code>, <code>ExceptT</code>, <code>Id</code>, a better-behaved <code>Idd</code>, <code>IO</code>). Would you say this is enough for your use case? </li>\n<li>The Iris-like proof mode for manipulating stateful hypotheses in a pointfree way, one that does not require repeated introduction of state variables. (Check out <code>Test/ProofMode.lean</code> for a comprehensive set of small examples.)</li>\n<li>The prototypical syntax in the README.md that extends <code>def</code>-elaboration with support for intrinsic verification features (<code>requires</code>, <code>ensures</code>, <code>invariant</code>). It bears repeating: You will find the proof automation lacking once you type in more complicated examples; this is mostly about the general look and feel for now. You have to <code>import MPL.Experimental</code> to opt into that feature. </li>\n</ol>\n<p>Next up on my agenda is writing an actual verification condition generator that replaces the <code>simp</code>-based <code>mwp</code> tactic and grow that in parallel with small to medium-sized verification projects. We were thinking about a congruence closure algorithm; any other ideas?</p>",
        "id": 514391777,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1745591052
    },
    {
        "content": "<p><a href=\"https://github.com/sgraf812/mpl\">https://github.com/sgraf812/mpl</a></p>",
        "id": 514683754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1745787372
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130195\">@Sebastian Graf</span> this looks nice. I have yet to get a full overview. Are you planning a write-up?<br>\nThe automatic proofs of equivalence between imperative and functional code are nice.<br>\nWe added them in the Rocq backend for Hax some time ago (for the state monad):<br>\n<a href=\"https://eprint.iacr.org/2023/185\">https://eprint.iacr.org/2023/185</a></p>",
        "id": 515557624,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1746124111
    }
]