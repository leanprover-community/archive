[
    {
        "content": "<p>I mean this in the kindest, gentlest way possible. Dependent types are new. </p>\n<p>it would be really nice if there was some syntax to say, X is the type I'm targeting. Y is the process I believe will satisfy that type, and finally Z is the proof Y satisfies X.  I'm super new, and probably in the wrong channel.  and I'm happy to move somewhere else.</p>\n<p>I understand and have deep sympathy for encoding 3 different things in a linear text file. Perhaps I'm just venting.</p>\n<p>Sigma offers pairs, and I'm free to choose, do I want to encode the proof Or the type or the proof? I don't know. I'm new. Do you bundle up arguments and proofs, or do you put the arguments up front, and then the proofs trailing at the end? I don't know. I'm new and dumb.</p>\n<p>But I feel like there is space for &lt;type, process, proof&gt;. Perhaps I'm missing something fundamental. But I feel like these 3 together sort of make the language. No complaints. I'm getting there. sigma helps, but pairs don't really capture the space. Perhaps I just need to be smarter. </p>\n<p>&lt;type, process, proof&gt; seems to capture all of the difficulties I've encountered. might make it easier for other folks.</p>",
        "id": 536356094,
        "sender_full_name": "Jason Foutz",
        "timestamp": 1756277004
    },
    {
        "content": "<p>Types in dependent type theory are specifications. If you produce a program of a particular type, it necessarily has the specification. So, <code>Y : X</code> is all that is needed in principle. If there are additional properties of Y that X does not reflect, then additional types may be constructed that involve explicit reference to Y.</p>\n<p>For instance, constructing a program <code>f</code> of type <code>(n : Nat) -&gt; Fin (n + 1)</code> already suffices to guarantee that the output is less than or equal to the input. However, if you also want to show that the output is always even, you can show <code>(n : Nat) -&gt; Even (f n).val</code>. In reality, this second type is just another program, that happens to return a proposition instead of data.</p>",
        "id": 536461502,
        "sender_full_name": "Chase Norman",
        "timestamp": 1756313458
    }
]