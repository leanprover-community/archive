[
    {
        "content": "<p>I'm writing a data structure for representing n-dimensional (rectangular) arrays using a single flat array to contain the elements and this is needing me to do some of my first non-trivial proofs.</p>\n<p>My problem is with defining the <code>GetElem</code> instance for my type. Given a proof that a multi-dimensional index is in bounds of an arrays shape (e.g. the index [5, 50, 15] is in bounds of the shape [10, 100, 20] because each index value is smaller than its corresponding dimension in the shape), I need to prove that the flattening of the multi-dimensional index into a single integer is in the bounds of the size of the flat array. I think I should be able to do it with <code>induction</code> but I can't figure out how/it's not giving me the hypotheses I thought it would.</p>\n<p>Thanks in advance!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Mathlib.Data.Vector</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Nat</span>\n<span class=\"kd\">def</span> <span class=\"n\">product</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">List</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span> <span class=\"n\">l.foldr</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"mi\">1</span>\n<span class=\"kd\">end</span> <span class=\"n\">Nat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">RankNArray</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">RankNArray</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"n\">where</span>\n  <span class=\"n\">data</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">α</span>\n  <span class=\"n\">shape</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span>\n  <span class=\"n\">property</span> <span class=\"o\">:</span> <span class=\"n\">data.size</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.product</span> <span class=\"n\">shape.val</span>\n\n<span class=\"c1\">-- flattenIndex [s₀, .. , sₙ] [i₀, .. , iₙ] = (s₁ * .. * sₙ) * i₀ + .. + sₙ * i_(n-1) + iₙ</span>\n<span class=\"kd\">def</span> <span class=\"n\">flattenIndex</span> <span class=\"o\">(</span><span class=\"n\">shape</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">strides</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">List.scanr</span> <span class=\"o\">(</span><span class=\"bp\">·</span> <span class=\"bp\">*</span> <span class=\"bp\">·</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"n\">shape.val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">tail</span>\n  <span class=\"k\">let</span> <span class=\"n\">flatIndex</span> <span class=\"o\">:=</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">acc</span> <span class=\"bp\">=&gt;</span>\n    <span class=\"n\">acc</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">strides.zip</span> <span class=\"n\">idx.val</span><span class=\"o\">)</span>\n  <span class=\"n\">flatIndex</span>\n\n<span class=\"c1\">-- A multi-dimensional index is in the bounds of a shape if each of the indices</span>\n<span class=\"c1\">-- is less than its respective dimension.</span>\n<span class=\"kd\">def</span> <span class=\"n\">inBounds</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">xs.shape.toList.zip</span> <span class=\"n\">idx.toList</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">flattenIndex_inBounds</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"n\">flattenIndex</span> <span class=\"n\">xs.shape</span> <span class=\"n\">idx</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.product</span> <span class=\"n\">xs.shape.val</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">inBounds</span> <span class=\"n\">where</span>\n  <span class=\"n\">getElem</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span>\n    <span class=\"k\">let</span> <span class=\"n\">flatIdx</span> <span class=\"o\">:=</span> <span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">idx.val</span>\n    <span class=\"c1\">-- Can't do this without a proof of (flattenIndex_inBounds xs idx):</span>\n    <span class=\"c1\">-- xs.data[flatIdx]</span>\n    <span class=\"gr\">sorry</span>\n    <span class=\"c1\">-- Try and establish (flattenIndex_inBounds xs idx) by proving a theorem</span>\n    <span class=\"c1\">-- below</span>\n\n<span class=\"c1\">-- If a multi-dimensional index is in the bounds of a shape, the flattening of</span>\n<span class=\"c1\">-- the index is in the bounds of the flattened shape</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">inBounds_implies_flattenIndex_inBounds</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">inBounds</span> <span class=\"n\">xs</span> <span class=\"n\">idx</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">flattenIndex_inBounds</span> <span class=\"n\">xs</span> <span class=\"n\">idx</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"n\">induction</span> <span class=\"n\">xs.shape.val</span>\n    <span class=\"c1\">-- where are the hypotheses, e.g. xs.shape.val = nil?</span>\n    <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">RankNArray</span>\n</code></pre></div>",
        "id": 404133796,
        "sender_full_name": "Aiken Cairncross",
        "timestamp": 1700935239
    },
    {
        "content": "<p>Hmm, yeah…where <em>are</em> the hypotheses? I think we might be a bit too eager to clear them.</p>",
        "id": 404149849,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1700942200
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- If a multi-dimensional index is in the bounds of a shape, the flattening of</span>\n<span class=\"c1\">-- the index is in the bounds of the flattened shape</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">inBounds_implies_flattenIndex_inBounds</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">shape</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">ℕ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">shape.toList.zip</span> <span class=\"n\">idx.toList</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">all</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n    <span class=\"n\">flattenIndex</span> <span class=\"n\">shape</span> <span class=\"n\">idx</span> <span class=\"bp\">&lt;</span> <span class=\"n\">Nat.product</span> <span class=\"n\">shape.val</span>\n  <span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">shape</span><span class=\"o\">,</span> <span class=\"n\">hshape</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">idx</span><span class=\"o\">,</span> <span class=\"n\">hidx</span><span class=\"o\">⟩</span> <span class=\"bp\">=&gt;</span> <span class=\"kd\">by</span>\n    <span class=\"k\">have</span> <span class=\"n\">H1</span> <span class=\"n\">shape</span> <span class=\"o\">:</span>\n        <span class=\"o\">(</span><span class=\"n\">List.foldr</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">↦</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x.1</span><span class=\"o\">,</span> <span class=\"n\">x.1</span> <span class=\"o\">::</span> <span class=\"n\">x.2</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">[])</span> <span class=\"n\">shape</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">Nat.product</span> <span class=\"n\">shape</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">Nat.product</span><span class=\"bp\">;</span> <span class=\"n\">induction</span> <span class=\"n\">shape</span> <span class=\"bp\">&lt;;&gt;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">Vector.toList_mk</span><span class=\"o\">,</span> <span class=\"n\">List.all_eq_true</span><span class=\"o\">,</span> <span class=\"n\">decide_eq_true_eq</span><span class=\"o\">,</span> <span class=\"n\">Prod.forall</span><span class=\"o\">,</span> <span class=\"n\">flattenIndex</span><span class=\"o\">,</span>\n      <span class=\"n\">List.scanr</span><span class=\"o\">,</span> <span class=\"n\">List.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">Nat.product</span><span class=\"o\">]</span>\n    <span class=\"n\">subst</span> <span class=\"n\">n</span>\n    <span class=\"n\">induction</span> <span class=\"n\">shape</span> <span class=\"n\">generalizing</span> <span class=\"n\">idx</span> <span class=\"k\">with</span> <span class=\"n\">simp</span> <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">a</span> <span class=\"n\">shape</span> <span class=\"n\">IH</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">cases</span> <span class=\"n\">idx</span> <span class=\"k\">with</span> <span class=\"n\">injection</span> <span class=\"n\">hidx</span> <span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"n\">b</span> <span class=\"n\">idx</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">simp</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">IH</span> <span class=\"n\">idx</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"k\">fun</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h'</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inr</span> <span class=\"n\">h'</span><span class=\"o\">)</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">add_lt_add_right</span> <span class=\"n\">IH</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span> <span class=\"bp\">?</span><span class=\"n\">_</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">H1</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">Nat.product</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">Nat.mul_succ</span><span class=\"o\">]</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩)</span>\n    <span class=\"n\">exact</span> <span class=\"n\">Nat.mul_le_mul_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">Nat.succ_le_of_lt</span> <span class=\"n\">this</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">GetElem</span> <span class=\"o\">(</span><span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"n\">inBounds</span> <span class=\"n\">where</span>\n    <span class=\"n\">getElem</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">RankNArray</span> <span class=\"n\">α</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">idx</span> <span class=\"o\">:</span> <span class=\"n\">Vector</span> <span class=\"n\">Nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ok</span> <span class=\"o\">:=</span>\n  <span class=\"n\">xs.data</span><span class=\"o\">[</span><span class=\"n\">flattenIndex</span> <span class=\"n\">xs.shape</span> <span class=\"n\">idx</span><span class=\"o\">]</span><span class=\"bp\">'</span>\n    <span class=\"o\">(</span><span class=\"n\">xs.property</span> <span class=\"bp\">▸</span> <span class=\"n\">inBounds_implies_flattenIndex_inBounds</span> <span class=\"n\">xs.shape</span> <span class=\"n\">idx</span> <span class=\"n\">ok</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 404205073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1700979453
    },
    {
        "content": "<p>Wow, I'll have a good study of that!</p>",
        "id": 404229255,
        "sender_full_name": "Aiken Cairncross",
        "timestamp": 1700991902
    },
    {
        "content": "<blockquote>\n<p>Hmm, yeah…where are the hypotheses? I think we might be a bit too eager to clear them.</p>\n</blockquote>\n<p>I'm still interested in the answer to this though!</p>",
        "id": 404279082,
        "sender_full_name": "Aiken Cairncross",
        "timestamp": 1701022104
    },
    {
        "content": "<p>doing <code>induction xs.shape.val</code> will only generalize <code>xs.shape.val</code> where it appears in the goal state, so all other facts about <code>xs</code> are lost (the variable <code>xs</code> is still around but it has no relation to the newly introduced variable being inducted over)</p>",
        "id": 404279685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701022770
    },
    {
        "content": "<p>That's why my proof works by pattern matching <code>xs</code> instead (or rather, calling a lemma with <code>xs.shape</code>, which itself pattern matches as <code>⟨shape, hshape⟩</code>). Note that the <code>induction shape</code> line does manage to change the type of <code>hshape</code> to match</p>",
        "id": 404279773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701022848
    },
    {
        "content": "<p>However, regarding:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>    <span class=\"c1\">-- where are the hypotheses, e.g. xs.shape.val = nil?</span>\n</code></pre></div>\n<p>You normally don't want to have something like <code>xs.shape.val = nil</code> in the context after <code>induction</code>, because the only way to get that in the context is to put <code>xs.shape.val = x</code> as part of the induction hypothesis, and this will make the induction hypothesis useless (you will have <code>IH : xs.shape.val = a -&gt; P a</code> and <code>h : xs.shape.val = a :: b</code> in the context, so the hypothesis is not applicable because it has a false assumption), which is why only <code>cases</code> does this (with the syntax <code>cases e : xs.shape.val</code> to introduce <code>e : xs.shape.val = nil</code> in the subgoal), not <code>induction</code>.</p>",
        "id": 404280134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1701023200
    },
    {
        "content": "<p>Shouldn’t these equations be there if we’re <code>generalizing xs</code>, at least, though?</p>",
        "id": 404287571,
        "sender_full_name": "Thomas Murrills",
        "timestamp": 1701030566
    }
]