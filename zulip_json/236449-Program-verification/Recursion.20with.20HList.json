[
    {
        "content": "<p>Hey! I'm trying to model a simple type with Lean and I'm stuck proving termination. I'm using the following definition of HList: </p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tp</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">denote</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">result</span>\n</code></pre></div>\n<p>for representation of Types. <code>Tp.denote</code> does not converge and I'm not even sure what measure to use for <code>termination_by</code> – everything I try gives me a free-variable-out-of-nowhere in the <code>decreasing_by</code> goal. FWIW it seems like <code>HList</code> is a red herring, a similar definition with a simple <code>List.map</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">toList</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tp</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"bp\">.</span><span class=\"n\">join</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">toList</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>fails similarly. What am I missing? Is there any way to get these kinds of definitions to work?</p>",
        "id": 467768785,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1725526387
    },
    {
        "content": "<p>I don't understand your definition of <code>Tp.fn</code>. Is it's argument supposed to be a function of type <code>List Tp → Tp</code>? Because in that case you would have to write <code>| fn : (List Tp → Tp) → Tp</code>. But that won't compile due to positivity constraints on inductive types.</p>",
        "id": 467793058,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1725530888
    },
    {
        "content": "<p>No, <code>fn</code> is the non-dependent arrow type, not a pi type. The expected result of <code>denote $ .fn [.nat, .bool] .nat</code> is (isomorphic to) <code>Nat × Bool -&gt; Nat</code>.</p>",
        "id": 467794084,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1725531194
    },
    {
        "content": "<p>Hmm, I'm also confused by the proof goal and error message:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nil</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">[]</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">cons</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"o\">{</span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">},</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">β</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\">            </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"w\">           </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">result</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\">    </span><span class=\"c1\">-- ^^^^^^</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to prove termination, possible solutions:</span>\n<span class=\"cm\">  - Use `have`-expressions to prove the remaining goals</span>\n<span class=\"cm\">  - Use `termination_by` to specify a different well-founded relation</span>\n<span class=\"cm\">  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal</span>\n<span class=\"cm\">args: List Tp</span>\n<span class=\"cm\">result a✝: Tp</span>\n<span class=\"cm\">⊢ sizeOf a✝ &lt; 1 + sizeOf args + sizeOf result</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">denote'</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\">            </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"w\">           </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HList</span><span class=\"w\"> </span><span class=\"n\">denote'</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">denote'</span><span class=\"w\"> </span><span class=\"n\">result</span>\n<span class=\"w\">  </span><span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">structural</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span>\n<span class=\"c\">/-</span>\n<span class=\"cm\">failed to infer structural recursion:</span>\n<span class=\"cm\">Cannot use parameter #1:</span>\n<span class=\"cm\">  unexpected occurrence of recursive application</span>\n<span class=\"cm\">    denote'</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 467795532,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1725531535
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span></p>",
        "id": 467796147,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1725531708
    },
    {
        "content": "<p><code>HList</code> is a higher order function, recursion through higher-order functions rarely works, because the termination checker cannot know that <code>HList </code>is applying its arguments only to elements of the list.</p>\n<p>For well-founded recursion, using <code>args.attach</code> might help.</p>\n<p>For structural recursion, if <code>HList</code> was a function, and not an inductive, you could try to use a mutual definition of <code>TP.denote'</code> and <code>TP.denoteList'</code> that essentially inlines <code>HList</code>.</p>",
        "id": 467816816,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1725534417
    },
    {
        "content": "<p>Well-founded recursion will not work here well if you want to use <code>Tp.denote</code> in types, as well-founded definitoins don't reduce well.</p>",
        "id": 467816994,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1725534440
    },
    {
        "content": "<p>Here is how I’d approach this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Tp</span>\n\n<span class=\"kn\">mutual</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"w\">            </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Nat</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"w\">           </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Bool</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">denoteArgs</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">result</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">structural</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">denoteArgs</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Unit</span>\n<span class=\"w\">  </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">denoteArgs</span><span class=\"w\"> </span><span class=\"n\">args</span>\n<span class=\"n\">termination_by</span><span class=\"w\"> </span><span class=\"n\">structural</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">ts</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"bp\">.</span><span class=\"n\">bool</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">denote</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Nat</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Bool</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 467819537,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1725534790
    },
    {
        "content": "<p>Thank you so much! The biggest issue with HList as a def is that my terms have HList-typed fields and they don't compile with defined HLists. So I guess I'll have to juggle two different reps?  Unless you have some idea if this can be made to compile (<code>app</code> is the issue, works fine with the inductive HList):</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kd\">@[</span><span class=\"n\">reducible</span><span class=\"kd\">]</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">HList'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">emb</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"n\">α</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">PUnit</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">::</span><span class=\"w\"> </span><span class=\"n\">ts</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">emb</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"bp\">×</span><span class=\"w\"> </span><span class=\"n\">HList'</span><span class=\"w\"> </span><span class=\"n\">emb</span><span class=\"w\"> </span><span class=\"n\">ts</span>\n\n<span class=\"kn\">inductive</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tp</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"kn\">where</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">lam</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">HList'</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"n\">paramTps</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"n\">outTp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">paramTps</span><span class=\"w\"> </span><span class=\"n\">outTp</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Tp</span><span class=\"bp\">.</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"n\">outTp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">HList'</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"n\">outTp</span>\n</code></pre></div>\n<p>Also specifically thank you both for pointing out <code>terminating_by structural</code> – I've been on Lean 4.10, bumping 4.11 made many more definitions compile :D</p>",
        "id": 467874668,
        "sender_full_name": "Marcin Kostrzewa",
        "timestamp": 1725545889
    },
    {
        "content": "<p>Yes, for <code>Term</code> I think <code>inductive HList</code> is your only option. Lean does not support nested inductives through <code>def</code>s</p>",
        "id": 467876936,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1725546293
    }
]