[
    {
        "content": "<p>I don't know anything about  how computer algebra systems actually work, but here are some random thoughts:</p>\n<p>In SageMath I can do something like</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">var</span><span class=\"p\">(</span><span class=\"s1\">'x'</span><span class=\"p\">)</span>\n<span class=\"n\">expr</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">)</span> <span class=\"c1\"># 3*x + 2*log(e^x)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"o\">.</span><span class=\"n\">simplify</span><span class=\"p\">())</span> <span class=\"c1\"># 5*x</span>\n</code></pre></div>\n<p>What would such a thing look like in Lean?</p>\n<p>My understanding is that in Sage and SymPy (and maybe other CAS languages, not sure about Mathematica) they construct a special type of symbolic expressions and then implement operator overloading on them to allow multiplying expressions. Then functions like <code>exp</code> take in symbolic expressions and spit out symbolic expressions. In Lean, functions like <code>exp</code> take in actual real numbers and spit out actual real numbers, which is very different.</p>\n<p>We could of course use the Sage/SymPy approach of having a new custom type of expressions, but I think it's possible to do better. There's already an <code>Expr</code> type in Lean, so we could just use that as our type of expressions. This has the following advantages:</p>\n<ol>\n<li>Expressions of type <code>Q(Int)</code> actually correspond to object-level integers, whereas to my knowledge symbolic expressions about integers in Sage don't really have anything to do with sage integers.</li>\n<li>When we define a function like <code>Real.exp : Real -&gt; Real</code>, then we don't have to define another function <code>exp : Expr -&gt; Expr</code>.</li>\n<li>If we had a simplifier of type <code>Expr -&gt; Expr</code> or <code>Expr -&gt; M Expr</code> for some monad <code>M</code>, then we could use the same simplifier as a tactic for normal theorem proving.</li>\n<li>If we want some assurance of correctness, we don't actually have to formally verify the correctness of the simplifier (which would require formally defining the semantics of expressions), since we can instead just make the simplifier proof-producing, like a tactic.</li>\n</ol>\n<p>Let's suppose we already have access to some powerful simplifier of type <code>Expr -&gt; Expr</code> or <code>Expr -&gt; M Expr</code>, which maybe produces proofs of correctness as well (so let's say we aren't worried about what algorithms to use right now). How would we invoke that in Lean?</p>\n<p>The most direct equivalent of the Sage code, where we use <code>Expr</code> instead of a custom expression type, would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"c1\">-- pretend this has a more interesting definition</span>\n\n<span class=\"c1\">-- Realistically, a simplifier would probably need some way to know that `x` is a Real number</span>\n<span class=\"c1\">-- which we don't provide right now.</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">FVarId</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"n\">x</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Ideally I would just write `def expr := q(3 * $x + 2 * log (exp $x))` but this gave me an error</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"c1\">-- 3 * x + 2 * Real.log (rexp x)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- result of simplification</span>\n</code></pre></div>\n<p>But maybe there are some better ways to do this? Like, maybe we can reflect definitions from the object level to the meta level somehow?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"c1\">-- pretend this has a more interesting definition</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">reflect</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Name</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c1\">-- some function which converts a declaration name to its actual expression</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reflect</span><span class=\"w\"> </span><span class=\"ss\">`e</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">reflect</span><span class=\"w\"> </span><span class=\"ss\">`e</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Or, we could make no attempt to reflect the definition of <code>e</code> at all and just create an expression at the time of invoking the simplifier:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Real</span><span class=\"w\"> </span><span class=\"n\">Qq</span><span class=\"w\"> </span><span class=\"n\">Lean</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"c1\">-- pretend this has a more interesting definition</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">x_expr</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"o\">(</span><span class=\"n\">ℝ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"bp\">.</span><span class=\"n\">fvar</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">FVarId</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"w\"> </span><span class=\"ss\">`x</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x_expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c1\">-- e x</span>\n<span class=\"w\">  </span><span class=\"c1\">-- Ideally I would like to have just written `q(e $x_expr)`, but this gave me an error.</span>\n<span class=\"bp\">#</span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">PrettyPrinter</span><span class=\"bp\">.</span><span class=\"n\">ppExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mysimplifier</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">↦</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"bp\">$</span><span class=\"n\">x</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">x_expr</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"c1\">-- result of simplification</span>\n</code></pre></div>\n<p>In any case, this seems like a difficult problem to solve. Does anyone have any thoughts on how this should be done?</p>",
        "id": 540620989,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758414078
    },
    {
        "content": "<p>TIL about the Expr type. Thank you!</p>",
        "id": 540657622,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1758460934
    },
    {
        "content": "<p>In my opinion, the common and the most important part of all three cases is the <code>mysimplifier</code> function. And all three ways to use it seems to be valid, at first glance.</p>",
        "id": 540659585,
        "sender_full_name": "Ilmārs Cīrulis",
        "timestamp": 1758462987
    },
    {
        "content": "<p>For the sake of this question, I am assuming that we already have a mysimplifier function, and I'm wondering what the most ergonomic way to invoke it would be.</p>\n<p>I guess my question is maybe a little bit more general: In the long run, if we wanted Lean to become a viable alternative to Sage, Matlab, Mathematica, Maple, Python, etc. (assuming sufficient labor was available), what would an average user's session look like in the best case scenario, and how do we best take advantage of Lean's unique features (e.g. dependent types, powerful metaprogramming, and extensible UI)?</p>\n<p>This is of course a hypothetical question, because we don't have the labor to match Mathematica. But I think it's still an important question.</p>",
        "id": 540698224,
        "sender_full_name": "Niels Voss",
        "timestamp": 1758505694
    },
    {
        "content": "<p>A lot depends on what theorems you will want to prove. There is a huge amount of related work on coupling CAS and proof assistants.</p>",
        "id": 541307039,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1758740129
    },
    {
        "content": "<p>There is also work (by yours truly) on defining what 'simplification' means.</p>",
        "id": 541307130,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1758740169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326322\">Jacques Carette</span> <a href=\"#narrow/channel/482893-Computer-algebra/topic/What.20would.20interactive.20use.20of.20a.20simplifier.20look.20like.3F/near/541307130\">said</a>:</p>\n<blockquote>\n<p>There is also work (by yours truly) on defining what 'simplification' means.</p>\n</blockquote>\n<p>that sounds interesting, do you mind pointing us to said work?</p>",
        "id": 541395534,
        "sender_full_name": "Andrés Goens",
        "timestamp": 1758788076
    },
    {
        "content": "<p>(Ignoring the example implementation) are you looking for something in this direction?</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"n\">Mathlib</span>\n<span class=\"kn\">open</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"w\"> </span><span class=\"n\">Meta</span><span class=\"w\"> </span><span class=\"n\">Elab</span><span class=\"w\"> </span><span class=\"n\">Term</span><span class=\"w\"> </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">Real</span>\n\n<span class=\"kn\">noncomputable</span><span class=\"w\"> </span><span class=\"kn\">section</span>\n\n<span class=\"kn\">elab</span><span class=\"w\"> </span><span class=\"s2\">\"#apply \"</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"n\">ident</span><span class=\"w\"> </span><span class=\"s2\">\" to \"</span><span class=\"w\"> </span><span class=\"n\">tgt</span><span class=\"o\">:</span><span class=\"n\">term</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"bp\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">liftTermElabM</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">tgt</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">none</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">Lean</span><span class=\"bp\">.</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Expr</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">unsafe</span><span class=\"w\"> </span><span class=\"n\">evalExpr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkArrow</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">mkAppM</span><span class=\"w\"> </span><span class=\"ss\">``TermElabM</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">[</span><span class=\"n\">expr</span><span class=\"o\">]))</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">tgt</span>\n<span class=\"w\">  </span><span class=\"n\">logInfo</span><span class=\"w\"> </span><span class=\"n\">result</span>\n\n<span class=\"c1\">-- Example:</span>\n\n<span class=\"kn\">variable</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"bp\">*</span><span class=\"w\"> </span><span class=\"n\">log</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- \"Simplifiers\":</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">nothing</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"n\">pure</span>\n\n<span class=\"bp\">#</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">nothing</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"c1\">-- e</span>\n\n<span class=\"kn\">def</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TermElabM</span><span class=\"w\"> </span><span class=\"n\">Expr</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">do</span>\n<span class=\"w\">  </span><span class=\"n\">elabTerm</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"bp\">←</span><span class=\"w\"> </span><span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">mkConst</span><span class=\"w\"> </span><span class=\"ss\">``Real</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"n\">apply</span><span class=\"w\"> </span><span class=\"n\">zero</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"c1\">-- 0</span>\n</code></pre></div>",
        "id": 541402731,
        "sender_full_name": "Marcus Rossel",
        "timestamp": 1758790065
    },
    {
        "content": "<p><a href=\"https://www.cas.mcmaster.ca/~carette/publications/simplification.pdf\">Understanding Expression Simplification</a> published at ISSAC 2004.</p>\n<p>Quick take-home:</p>\n<ul>\n<li>simplification is \"denotationally equivalent yet representationally shorter\"</li>\n<li>the only stable notion of representation length is Kolmogorov complexity (which is uncomputable but easily approximable)</li>\n<li>\n<p>consequences:</p>\n<ol>\n<li>minor differences in length may be an illusion of 'simpler' due to encoding</li>\n<li>definitional extensions are a crucial component of 'simpler'.</li>\n</ol>\n</li>\n</ul>",
        "id": 541679695,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1758896427
    }
]