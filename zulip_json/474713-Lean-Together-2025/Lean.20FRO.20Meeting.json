[
    {
        "content": "<p>A thread for discussion about the Lean FRO talk.</p>",
        "id": 493635239,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736875867
    },
    {
        "content": "<p>180k Loogle queries per day!! <span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> (since Leo just attributed the graph to you) do you have stats on the number of unique queriers?</p>",
        "id": 493639204,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1736877404
    },
    {
        "content": "<p>Quoting from the zoom chat: \"...So about 1000 per day\"</p>",
        "id": 493639931,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1736877672
    },
    {
        "content": "<p>Number of website uses vs <code>#loogle</code> in-editor uses I think might also be an interesting number if you have it to share.</p>",
        "id": 493640122,
        "sender_full_name": "Julian Berman",
        "timestamp": 1736877729
    },
    {
        "content": "<p>Regarding the issue that Mathlib build parallelism may be slower on a per declaration vs. per file level basis: wouldn't per file generally be slower than per declaration (especially in files with many transitive imports) due to the start-up time loading the environment?</p>",
        "id": 493640685,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736877952
    },
    {
        "content": "<p><code>partial_fixpoint</code> <span aria-label=\"mind blown\" class=\"emoji emoji-1f92f\" role=\"img\" title=\"mind blown\">:mind_blown:</span></p>",
        "id": 493640953,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1736878052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493639931\">said</a>:</p>\n<blockquote>\n<p>Quoting from the zoom chat: \"...So about 1000 per day\"</p>\n</blockquote>\n<p>Yes, I made a stupid time calculation mistake and overestimated it by 150×. Sorry.</p>",
        "id": 493642276,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736878552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321696\">Julian Berman</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493640122\">said</a>:</p>\n<blockquote>\n<p>Number of website uses vs <code>#loogle</code> in-editor uses I think might also be an interesting number if you have it to share.</p>\n</blockquote>\n<p>We don’t have good numbers on website users, I fear, (yet).</p>",
        "id": 493642415,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736878593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"470149\">@Joachim Breitner</span> can you post here the code (or the slides) to see <code>partial_fixpoint</code> in action?</p>",
        "id": 493642573,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1736878671
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code from the demo</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>variable (f : α → Option α)\n\ndef whileSome (x : α) : α :=\n  match f x with\n  | none =&gt; x\n  | some x&#39; =&gt; whileSome x&#39;\npartial_fixpoint\n\n/-- info: 10 -/\n#guard_msgs in\n#eval whileSome (fun x =&gt; do guard (x &lt; 10); pure (x+1)) 1\n\ntheorem whileSome_none : whileSome (fun _ =&gt; none) x = x := by\n  simp [whileSome]\n\nsection\n\nexample : whileSome (fun x =&gt; do guard (x &lt; 10); pure (x+1)) 1 = 10 := by\n  -- simp [whileSome]\n  repeat (rw [whileSome]; simp [guard, failure])\n  done\n\nsection\n\n--example : whileSome (fun x =&gt; pure x) 1 = ??\n\nsection\n\n/-- Soundness is not in danger -/\ndef findNat (f : Nat → Option α) (i : Nat) : α :=\n  match f i with\n  | none =&gt; findNat f (i+1)\n  | some x&#39; =&gt; x&#39;\npartial_fixpoint\n\nsection\n\n/-- Within Option monad, we can prove partial correctness -/\n\ndef whileSome&#39; (x : α) : Option α :=\n  match f x with\n  | none =&gt; x\n  | some x&#39; =&gt; whileSome&#39; x&#39;\npartial_fixpoint\n\ntheorem whileSome&#39;_correct : whileSome&#39; f x = some r → f r = none := by\n  apply whileSome&#39;.partial_correctness\n  intros whileSome ih x r hyp\n  split at hyp\n  · simp_all\n  · apply ih _ _ hyp\n\nsection\n\n\n/-! Essentially any monadic function works -- useful for program verification -/\n\ndef ack : (n m : Nat) → Option Nat\n  | 0,   y   =&gt; some (y+1)\n  | x+1, 0   =&gt; ack x 1\n  | x+1, y+1 =&gt; do ack x (← ack (x+1) y)\npartial_fixpoint\n\n/-! Even nested recursion-/\n\nstructure Tree where cs : List Tree\n\ndef Tree.rev (t : Tree) : Option Tree := do\n  Tree.mk (← t.cs.reverse.mapM (Tree.rev ·))\npartial_fixpoint\n\ndef Tree.rev&#39; (t : Tree) : Option Tree := do\n  let mut cs := []\n  for c in t.cs do\n    cs := (← c.rev&#39;) :: cs\n  return Tree.mk cs\npartial_fixpoint\n</code></pre></div>\n</div></div>",
        "id": 493642664,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736878696
    },
    {
        "content": "<p>And feel free to play around with <a href=\"https://github.com/leanprover/lean4/pull/6355\">https://github.com/leanprover/lean4/pull/6355</a> (put <code>leanprover/lean4-pr-releases:pr-release-6355</code> into the toolchain)</p>",
        "id": 493642746,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736878736
    },
    {
        "content": "<p>i can't wait to read the reference manual entry on this!</p>",
        "id": 493643086,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736878865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"684366\">Edward van de Meent</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493643086\">said</a>:</p>\n<blockquote>\n<p>i can't wait to read the reference manual entry on this!</p>\n</blockquote>\n<p>Nice, a volunteer to review my reference manual PR once it's there! ;-)</p>",
        "id": 493643225,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736878923
    },
    {
        "content": "<p>feel free to ping me for that!</p>",
        "id": 493643297,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736878952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Lean.20FRO.20Meeting/near/493640685\">said</a>:</p>\n<blockquote>\n<p>Regarding the issue that Mathlib build parallelism may be slower on a per declaration vs. per file level basis: wouldn't per file generally be slower than per declaration (especially in files with many transitive imports) due to the start-up time loading the environment?</p>\n</blockquote>\n<p>I'm not sure I get you, the start-up overhead will be included in either case. The gist is that when you already have more independent files than CPU core at most points of the build, there is nothing to further speed up through more parallelization.</p>",
        "id": 493650640,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1736881729
    },
    {
        "content": "<p>The transition to the talk that followed was not definitive so didn't get a chance to clap in chat channel.<br>\n<span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span></p>",
        "id": 493650731,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1736881765
    },
    {
        "content": "<p><span aria-label=\"video camera\" class=\"emoji emoji-1f4f9\" role=\"img\" title=\"video camera\">:video_camera:</span> Video recording: <a href=\"https://youtu.be/QcLBbzQiTYY\">https://youtu.be/QcLBbzQiTYY</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"QcLBbzQiTYY\" href=\"https://youtu.be/QcLBbzQiTYY\"><img src=\"https://uploads.zulipusercontent.net/4b38ddc03ff0b5458a66edc2a505ed0483251712/68747470733a2f2f692e7974696d672e636f6d2f76692f51634c42627a51695459592f64656661756c742e6a7067\"></a></div>",
        "id": 493685828,
        "sender_full_name": "Pietro Monticone",
        "timestamp": 1736895854
    },
    {
        "content": "<p>I have another small question about the <code>partial_fixpoint</code> feature... <span class=\"user-mention silent\" data-user-id=\"470149\">Joachim Breitner</span> mentioned that a condition for using this is that \"all the recursive calls are in tail position\". What does that mean?</p>",
        "id": 493801974,
        "sender_full_name": "Edward van de Meent",
        "timestamp": 1736928039
    },
    {
        "content": "<p>That's for the non-monadic, more general case. A tail position is the RHS of the function, and for every match or if in tail position, their branches are tail positions, and the body of a let in tail position is in tail position.</p>\n<p>Not tail positions are in particular the discriminants of matches, the conditions of ifs, and in general function arguments.</p>",
        "id": 493803965,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736928847
    },
    {
        "content": "<p>In other words: a tail recursive function either returns a value, or calls itself with different arguments.</p>",
        "id": 493804078,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1736928899
    },
    {
        "content": "<p>In the talk, Leonardo de Moura mentioned that a planned feature for Lean in 2025 is <a href=\"https://youtu.be/QcLBbzQiTYY?t=1572\">\"support for monadic code reasoning\"</a>. I'm curious about how that support would look like. Are there any ideas already being considered?</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"QcLBbzQiTYY\" href=\"https://youtu.be/QcLBbzQiTYY?t=1572\"><img src=\"https://uploads.zulipusercontent.net/4b38ddc03ff0b5458a66edc2a505ed0483251712/68747470733a2f2f692e7974696d672e636f6d2f76692f51634c42627a51695459592f64656661756c742e6a7067\"></a></div>",
        "id": 493913623,
        "sender_full_name": "Ayhon",
        "timestamp": 1736943817
    },
    {
        "content": "<p>Hi Ayhon, as the person implementing that support, let me share my budding plans. I'm only one week into the project, so there are still a lot of open questions.</p>\n<p>The general idea for now is to provide a tactic that generates verification conditions for a given <code>do</code>-block + some postcondition. Currently, I model \"<code>do</code>-block + some postcondition\" using the <a href=\"https://github.com/leanprover-community/batteries/blob/e8dc5fc16c625fc4fe08f42d625523275ddbbb4b/Batteries/Classes/SatisfiesM.lean#L45\"><code>SatisfiesM</code> framework from <code>Batteries</code></a>.</p>\n<p>Example: <code>def fib_impl n := Id.run do ...</code> could be a linear-time implementation of  the fibonacci function making use of local state and other functional-imperative features. Then we could specify correctness of <code>fib_impl</code> as <code>fib_impl n = fib_spec n</code>, for all <code>n</code>, and for <code>fib_spec</code> implemented by the usual recursion.<br>\nUsing the <code>SatisfiesM</code>, this is equivalent (apply <code>SatisfiesM_Id_eq</code>) to <code>SatisfiesM (fun r =&gt; r = fib_spec n) (fib_impl n)</code>, at which point we can unfold <code>fib_impl</code> and apply the tactic.<br>\nThe goal is for the tactic to yield a bunch of sub-goals, broadly falling in 3 categories:</p>\n<ol>\n<li>Loop invariants (e.g., <code>0 &lt;= i, i &lt;= n, a = fib_spec (i-1), b = fib_spec i</code>)</li>\n<li>Pure sub-goals (i.e., no <code>SatisfiesM</code>), hopefully dischargable by <code>simp</code>, <code>assumption</code> or <code>grind</code> in the future</li>\n<li>Impure sub-goals (i.e., involving <code>SatisfiesM</code>) about effectful functions from the base monad being used (in case of <code>Id</code> there really should be none)</li>\n</ol>\n<p>The goal is to target what Lean's <code>do</code> notation expands to, including local state, local control flow (early return, <code>break</code>, <code>continue</code>), and reasoning about <code>try</code>/<code>catch</code> for law-abiding implementations.</p>\n<p>As I work towards a basic prototype, one of the most important questions becomes: <strong>What are the requirements?</strong><br>\nYou can help me to collect requirements by handing me short, self-contained programs that are painful for you to verify at the moment.</p>",
        "id": 493943761,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1736952328
    },
    {
        "content": "<p>Missed the talk, will have to catch up soon. We'll likely have properties on monadic functions coming out of the Sail-&gt;Lean project at some point as well, so this is really good news!</p>",
        "id": 493955937,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1736955516
    },
    {
        "content": "<p>Sebastian, did you talk to the people who thought about this in CMU? I think this includes at least Jeremy Avigad, Mario Carneiro and Wojciech Nawrocki.</p>",
        "id": 493961654,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1736957079
    },
    {
        "content": "<p>No, I haven't talked to anyone yet. Thanks for listing a few stakeholders; I'll reach out to these people before long!</p>",
        "id": 493963723,
        "sender_full_name": "Sebastian Graf",
        "timestamp": 1736957655
    },
    {
        "content": "<p>It’s a really important topic, and indeed the requirements are not clear at all. I only know those people had some rather extensive brainstorming about those requirements a couple of years ago.</p>",
        "id": 493965723,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1736958223
    },
    {
        "content": "<p>An example is the greedy algorithm for constructing graph spanners.  My implementation is based on <a href=\"https://www.cs.princeton.edu/~hy2/teaching/fall22-cos521/notes/spanner.pdf\">this lecture note</a>.</p>\n<p>I show you a minimal instance of unweighted graphs <a href=\"https://live.lean-lang.org/#codez=JYWwDg9gTgLgBAWQIYwBYBtgCMBQOJgCmAdnAMqhjqEDiUSYqc+RpAYsMQM6EwslwAwuiRcuwAMZJ0eACaEAZnA7EK4anQZMAFKQBccQKiEASjh6AvOUob6jONpVxixvAQFkYsuYuWc1VWltUADoASS4yMCRiYkIoAHklAG9iPUM4AF97AAk4GjNfVWtArSdTexg08oMABSgCM0tssIiAVywAcyC8uEByIjhmwQgYwgkYQlk+uDhAACI4VrgANwLHYgAaAeDZYC54BeXAEyI4eAAqPK2dvaW8YmGJCHBWmCQsajh5JRV/Gy1g4laQABRWQdQhcOApAqGDLafIGL7FTR2ZxQxpwADENGCE1BKh48G8SgAgrJZMDQRD9NDtAgVpwnHBAEmEhQZzLqBFM2jghAKZAAniAAEz2VamYzw+mkZmrJlwdlgNEKVqkbTAOAAKzppBRgDLCRBwNWawAURPYeZYuKq1urjC4cLdiPdHs9XjyPu9LpSzNTaRLtbKZWz6mBOTyDPyhSLJTaDOkLPZviVGMEFPUQAAlQjoRDGC67ewARVaEBgwQgT25OYAjAWiyWy/BCDnBYS4F1CBM+ZForEoJS0plYVqE0imCjtPB++LCsPuvpLKFZMEoMr3hAcNNqPAQOWFAB9XK+1ksqVyoOKlfaXdwXemPUKaQ8ddwBTQbkG0hYnGEPG8YIwCAADIerIa7TNMwBKNogonPAAC0lamAAPO6eZ7rkPJoAIaFoiSZIgjy2GEE+M6/CmDwZlmaF4NQIAgEgcD3FAUCjDAsRiIkdDtrInZRCMvYpP2MJwtOiKzsY45enAph6E+m4DGibYdl2fE9Hw0xzPsWpOBszTbHmmlHNBMDwWiWB8nAXDQFA5k4EAA\">here</a>.  </p>\n<p>I hope it is relevant to your question.</p>",
        "id": 494105144,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1737021398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"759386\">@Sorrachai Yingchareonthawornchai</span> : we can implement this without monadic verification</p>",
        "id": 494112165,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1737023613
    },
    {
        "content": "<p>Especially if we only want to verify the correctness and not complexity.</p>",
        "id": 494112427,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1737023693
    },
    {
        "content": "<p>The idea is to express the loop as a (tail?) recursive procedure and use standard induction and cases tactics.</p>",
        "id": 494112818,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1737023818
    },
    {
        "content": "<p>That's nice to know. Is there a way to prove the time complexity of the algorithm?</p>",
        "id": 494113896,
        "sender_full_name": "Sorrachai Yingchareonthawornchai",
        "timestamp": 1737024144
    },
    {
        "content": "<p>So the idea that many of us converged on in separate ways is to model all computational models as query models. Let’s discuss in DM</p>",
        "id": 494114195,
        "sender_full_name": "Shreyas Srinivas",
        "timestamp": 1737024244
    },
    {
        "content": "<p>Mathlib doesn't contain any time complexity results, and for now at least we think that the design space for setting up such proofs is so large, and relatively unexplored in Lean, that we'd prefer this happened outside Mathlib.</p>",
        "id": 494114263,
        "sender_full_name": "Kim Morrison",
        "timestamp": 1737024271
    }
]