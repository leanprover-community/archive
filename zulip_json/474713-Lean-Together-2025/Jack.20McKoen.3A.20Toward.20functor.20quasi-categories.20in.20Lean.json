[
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span>! Thanks for your talk. I'm currently half-way through watching it. On p24 you mention subcomplexes, and you show a formalization of <code>Subpresheaf</code>. But there is also a reasonably large API for subobjects in mathlib already. (All monomorphism modulo equiv.) Do you think it would be useful/possible to reuse that API?</p>",
        "id": 494287202,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737092482
    },
    {
        "content": "<p>I think Jack is using <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=CategoryTheory.Subpresheaf#doc\">docs#CategoryTheory.Subpresheaf</a></p>",
        "id": 494366556,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737122217
    },
    {
        "content": "<p>I'd also be curious to hear about the relative merits of Subpresheaves and more general subobjects.</p>\n<p>Relatedly, what is the rationale for the name: <code>[Set](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Defs.html#Set) (F.obj U)</code>. I had assumed this was a typo in the slides and it should have said \"Subset\" until I looked up the definition just now...</p>",
        "id": 494399787,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737132416
    },
    {
        "content": "<p>Do you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> ?</p>",
        "id": 494400065,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737132527
    },
    {
        "content": "<p>My main comment for <span class=\"user-mention\" data-user-id=\"488744\">@Jack McKoen</span> and the peanut gallery is that he is really underselling the importance of this project. We need this result and some extensions (a few relative forms of the theorem he has nearly proven involving an isofibration between quasi-categories) to construct the motivating examples of an ∞-cosmos: the ∞-cosmos of quasi-categories. Only then will the general synthetic theory of ∞-categories we are developing have concrete implications for Mathlib.</p>",
        "id": 494400130,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737132554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Jack.20McKoen.3A.20Toward.20functor.20quasi-categories.20in.20Lean/near/494400065\">said</a>:</p>\n<blockquote>\n<p>Do you mean <a href=\"https://leanprover-community.github.io/mathlib4_docs/find/?pattern=Set#doc\">docs#Set</a> ?</p>\n</blockquote>\n<p>Yes, how should I be thinking of sets? I had been thinking that types in mathlib were either sets (or propositions), eg., 0-types or -1-types in the language of HoTT. So why are we using the name \"set\" for their subsets?</p>",
        "id": 494400409,
        "sender_full_name": "Emily Riehl",
        "timestamp": 1737132657
    },
    {
        "content": "<p>This is how the type theory lingo goes as far as I'm aware. Set-theoretic sets becomes types, and subset of <code>X</code> become <code>Set X</code>.</p>",
        "id": 494401052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1737132850
    },
    {
        "content": "<p>In this case, using the <code>Subpresheaf</code> API seems much more convenient for computations, as compared to <code>Subobject</code> (equivalences classes of monomorphisms). Imagine doing computations with \"subsets\" of a set <code>X</code> using only the notion of monomorphism in the category of sets, pullbacks, etc, when we can use the more convenient <code>Set</code> API.<br>\nI am currently working on usual \"anodyne extensions\", whereas Jack works on \"inner anodyne extensions\". The latter are probably slightly more difficult to handle as it seems he has to deal with subcomplexes of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Δ</mi><mn>2</mn></msup><mo>×</mo><msup><mi mathvariant=\"normal\">Δ</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\Delta^2 \\times \\Delta^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> which may have more intricate combinatorics as compared to the subcomplexes of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"normal\">Δ</mi><mn>1</mn></msup><mo>×</mo><msup><mi mathvariant=\"normal\">Δ</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\Delta^1 \\times \\Delta^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\"><span class=\"mord\">Δ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> which I have to deal with.</p>",
        "id": 494403091,
        "sender_full_name": "Joël Riou",
        "timestamp": 1737133565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/channel/474713-Lean-Together-2025/topic/Jack.20McKoen.3A.20Toward.20functor.20quasi-categories.20in.20Lean/near/494401052\">said</a>:</p>\n<blockquote>\n<p>This is how the type theory lingo goes as far as I'm aware. Set-theoretic sets becomes types, and subset of <code>X</code> become <code>Set X</code>.</p>\n</blockquote>\n<p>The fact that Agda likes to use <code>Set</code> to mean <code>Type</code> could be some source of confusion.</p>",
        "id": 494403637,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737133771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246635\">Emily Riehl</span> <a href=\"#narrow/stream/474713-Lean-Together-2025/topic/Jack.20McKoen.3A.20Toward.20functor.20quasi-categories.20in.20Lean/near/494399787\">said</a>:</p>\n<blockquote>\n<p>Relatedly, what is the rationale for the name: <code>[Set](https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Defs.html#Set) (F.obj U)</code>. I had assumed this was a typo in the slides and it should have said \"Subset\" until I looked up the definition just now...</p>\n</blockquote>\n<p>I think one reason is that you can think of <code>S : Set Nat</code> as a <em>set</em> of natural numbers.<br>\nOf course \"subset\" is a good mental model. But since <code>Nat</code> is not itself a set, it breaks down somewhere...</p>",
        "id": 494406961,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1737134980
    },
    {
        "content": "<p>I guess a natural name could be <code>SetOf X</code> so <code>S : SetOf Nat</code> is a set of nats.</p>",
        "id": 494408117,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737135389
    },
    {
        "content": "<p>But I don't think <code>Set</code> is ever going to change in Lean, and I think most Leansters are used to it by now.</p>",
        "id": 494408265,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737135457
    },
    {
        "content": "<p>In terms of HoTT, IIRC, contractible types are the (-2)-types, props are the (-1)-types and sets are the 0-types. So Lean's <code>Prop</code> should correspond to the type of HoTT's <code>(-1)</code>-types, Lean's <code>Type</code> should correspond to the type of HoTT's <code>0</code>-types (and of course we don't have a built-in notion of an <code>n</code>-type for positive <code>n</code>). In Lean, <code>Set X</code> is defined as <code>X -&gt; Prop</code>, i.e. we identify a subset of <code>X</code> with the predicate that defines it.</p>",
        "id": 494409102,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1737135787
    },
    {
        "content": "<p>I goofed up the intro to this one, the video with fixed intro is here <a href=\"https://youtu.be/PHL4Ma3znmE?si=VCdzQ6cIzuqSHtMN\">https://youtu.be/PHL4Ma3znmE?si=VCdzQ6cIzuqSHtMN</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"PHL4Ma3znmE\" href=\"https://youtu.be/PHL4Ma3znmE?si=VCdzQ6cIzuqSHtMN\"><img src=\"https://uploads.zulipusercontent.net/4f7595229fa8dac8164002a00635385acca02169/68747470733a2f2f692e7974696d672e636f6d2f76692f50484c344d61337a6e6d452f64656661756c742e6a7067\"></a></div>",
        "id": 494501142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1737193235
    },
    {
        "content": "<p>Late response but I largely agree with Joël on using the <code>Subpresheaf</code> API. Thanks for your comments <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"246635\">@Emily Riehl</span>!</p>",
        "id": 494715370,
        "sender_full_name": "Jack McKoen",
        "timestamp": 1737347302
    }
]